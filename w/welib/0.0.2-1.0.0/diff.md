# Comparing `tmp/welib-0.0.2.tar.gz` & `tmp/welib-1.0.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "welib-0.0.2.tar", last modified: Tue Jul  5 18:24:04 2022, max compression
+gzip compressed data, was "welib-1.0.0.tar", last modified: Fri Jun 16 18:17:28 2023, max compression
```

## Comparing `welib-0.0.2.tar` & `welib-1.0.0.tar`

### file list

```diff
@@ -1,1034 +1,1138 @@
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.843043 welib-0.0.2/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.316678 welib-0.0.2/.github/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.377364 welib-0.0.2/.github/workflows/
--rw-rw-rw-   0        0        0     1313 2022-07-05 18:17:30.000000 welib-0.0.2/.github/workflows/tests.yml
--rw-rw-rw-   0        0        0      200 2022-07-05 06:56:16.000000 welib-0.0.2/.gitignore
--rw-rw-rw-   0        0        0      273 2021-07-21 16:10:07.000000 welib-0.0.2/.travis.yml
--rw-rw-rw-   0        0        0     1058 2019-04-01 15:48:57.000000 welib-0.0.2/LICENSE.TXT
--rw-rw-rw-   0        0        0      526 2022-07-05 18:17:30.000000 welib-0.0.2/Makefile
--rw-rw-rw-   0        0        0     1348 2022-07-05 18:24:04.842048 welib-0.0.2/PKG-INFO
--rw-rw-rw-   0        0        0    20940 2022-07-05 18:17:30.000000 welib-0.0.2/README.md
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.322365 welib-0.0.2/data/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.382365 welib-0.0.2/data/Hawc2/
--rw-rw-rw-   0        0        0     4104 2020-07-20 16:25:13.000000 welib-0.0.2/data/Hawc2/BD.dat
--rw-rw-rw-   0        0        0     1103 2019-08-28 18:14:30.000000 welib-0.0.2/data/Hawc2/Blade_Planform_Hawc2.csv
--rw-rw-rw-   0        0        0     5023 2019-12-16 19:17:01.000000 welib-0.0.2/data/Hawc2/Blade_Structural_Hawc2.csv
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.398365 welib-0.0.2/data/Monopile/
--rw-rw-rw-   0        0        0       85 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/.gitignore
--rw-rw-rw-   0        0        0     6097 2021-05-15 16:50:36.000000 welib-0.0.2/data/Monopile/ED_Blade_Light.dat
--rw-rw-rw-   0        0        0     3762 2021-05-15 16:50:36.000000 welib-0.0.2/data/Monopile/ED_Tower100_Light.dat
--rw-rw-rw-   0        0        0    15159 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/MT100_ED.dat
--rw-rw-rw-   0        0        0    19568 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/MT100_HD_RegularWave.dat
--rw-rw-rw-   0        0        0    19568 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/MT100_HD_Still.dat
--rw-rw-rw-   0        0        0   611624 2021-05-15 16:50:36.000000 welib-0.0.2/data/Monopile/MT100_LoadsMotions.csv
--rw-rw-rw-   0        0        0     8440 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/MT100_SD.dat
--rw-rw-rw-   0        0        0     6318 2021-07-21 16:10:07.000000 welib-0.0.2/data/Monopile/Main_MT100_RegularWave.fst
--rw-rw-rw-   0        0        0      983 2021-05-15 16:50:36.000000 welib-0.0.2/data/Monopile/README.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.405706 welib-0.0.2/data/NREL5MW/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.421180 welib-0.0.2/data/NREL5MW/5MW_Baseline/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.441180 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/
--rw-rw-rw-   0        0        0     7026 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat
--rw-rw-rw-   0        0        0     8396 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1_coords.txt
--rw-rw-rw-   0        0        0     7095 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2.dat
--rw-rw-rw-   0        0        0     8400 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2_coords.txt
--rw-rw-rw-   0        0        0    12679 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17.dat
--rw-rw-rw-   0        0        0     7865 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17_coords.txt
--rw-rw-rw-   0        0        0    12601 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17.dat
--rw-rw-rw-   0        0        0     8060 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17_coords.txt
--rw-rw-rw-   0        0        0    12720 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17.dat
--rw-rw-rw-   0        0        0     8066 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17_coords.txt
--rw-rw-rw-   0        0        0    12406 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17.dat
--rw-rw-rw-   0        0        0     8066 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17_coords.txt
--rw-rw-rw-   0        0        0    12445 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17.dat
--rw-rw-rw-   0        0        0     8066 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17_coords.txt
--rw-rw-rw-   0        0        0    12098 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17.dat
--rw-rw-rw-   0        0        0     8272 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17_coords.txt
--rw-rw-rw-   0        0        0     5576 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_IW.dat
--rw-rw-rw-   0        0        0     5511 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_IW_Step.dat
--rw-rw-rw-   0        0        0    12219 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_SvD.dat
--rw-rw-rw-   0        0        0    12143 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_SvD_Simple.dat
--rw-rw-rw-   0        0        0     2654 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_AeroDyn_blade.dat
--rw-rw-rw-   0        0        0     6958 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn.dat
--rw-rw-rw-   0        0        0    58500 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn_Blade.dat
--rw-rw-rw-   0        0        0     6727 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Blade.dat
--rw-rw-rw-   0        0        0    27002 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_OC4Jacket_SubDyn.dat
--rw-rw-rw-   0        0        0     3552 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Offshore_ElastoDyn_Tower.dat
--rw-rw-rw-   0        0        0     3523 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Onshore_ElastoDyn_Tower.dat
--rw-rw-rw-   0        0        0      279 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/5MW_Baseline/README.rst
--rw-rw-rw-   0        0        0     7497 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/Main_Onshore.fst
--rw-rw-rw-   0        0        0     7497 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/Main_Onshore_DriveTrainTorsion.fst
--rw-rw-rw-   0        0        0    16535 2020-12-12 06:12:44.000000 welib-0.0.2/data/NREL5MW/NREL5MW_Blade_FEM_Modes.csv
--rw-rw-rw-   0        0        0     3945 2021-07-21 16:10:07.000000 welib-0.0.2/data/NREL5MW/NREL5MW_Oper.csv
--rw-rw-rw-   0        0        0     1518 2020-12-12 02:33:18.000000 welib-0.0.2/data/NREL5MW/NREL5MW_Tower_Onshore_FEM_Modes.csv
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.443180 welib-0.0.2/data/NREL5MW/dt_torsion/
--rw-rw-rw-   0        0        0    22531 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/dt_torsion/NREL5MW_ED_DT.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.447180 welib-0.0.2/data/NREL5MW/hawc2/
--rw-rw-rw-   0        0        0      771 2021-07-21 16:10:07.000000 welib-0.0.2/data/NREL5MW/hawc2/Blade_Planform_Hawc2.csv
--rw-rw-rw-   0        0        0    10353 2021-07-21 16:10:07.000000 welib-0.0.2/data/NREL5MW/hawc2/Blade_Structural_Hawc2.csv
--rw-rw-rw-   0        0        0      225 2021-07-21 16:10:07.000000 welib-0.0.2/data/NREL5MW/hawc2/README.md
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.452180 welib-0.0.2/data/NREL5MW/offshore/
--rw-rw-rw-   0        0        0    21239 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/offshore/NREL5MW_ED_Offshore.dat
--rw-rw-rw-   0        0        0    21385 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/offshore/NREL5MW_ED_Offshore_Legacy.dat
--rw-rw-rw-   0        0        0    17931 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/offshore/NREL5MW_HD.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.456180 welib-0.0.2/data/NREL5MW/onshore/
--rw-rw-rw-   0        0        0     9503 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/onshore/NREL5MW_AD.dat
--rw-rw-rw-   0        0        0    22402 2022-07-05 18:17:30.000000 welib-0.0.2/data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.468180 welib-0.0.2/data/Spar/
--rw-rw-rw-   0        0        0     7892 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Main_Spar_ED.fst
--rw-rw-rw-   0        0        0     7892 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Main_Spar_ED_HydroExample.fst
--rw-rw-rw-   0        0        0     8666 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Main_Spar_ED_HydroExample.outb
--rw-rw-rw-   0        0        0     7887 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Main_Spar_SD.fst
--rw-rw-rw-   0        0        0    14956 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Spar_ED_ForED.dat
--rw-rw-rw-   0        0        0    20029 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Spar_ED_ForSD.dat
--rw-rw-rw-   0        0        0    20300 2022-07-05 18:17:30.000000 welib-0.0.2/data/Spar/Spar_HD.dat
--rw-rw-rw-   0        0        0    12616 2020-11-03 18:44:19.000000 welib-0.0.2/data/Spar/Spar_SD.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.484126 welib-0.0.2/data/SubDyn/
--rw-rw-rw-   0        0        0       16 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/.gitignore
--rw-rw-rw-   0        0        0    23650 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/Jacket.dat
--rw-rw-rw-   0        0        0     2703 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/Jacket.dvr
--rw-rw-rw-   0        0        0    28981 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/JacketTwr.dat
--rw-rw-rw-   0        0        0     2709 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/JacketTwr.dvr
--rw-rw-rw-   0        0        0    16742 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/SD_Cable_5Joints.dat
--rw-rw-rw-   0        0        0     2672 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/SD_Cable_5Joints.dvr
--rw-rw-rw-   0        0        0    15749 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/Twr.dat
--rw-rw-rw-   0        0        0     2697 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/Twr.dvr
--rw-rw-rw-   0        0        0    10573 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/TwrSmall.dat
--rw-rw-rw-   0        0        0     2707 2022-07-05 18:17:30.000000 welib-0.0.2/data/SubDyn/TwrSmall.dvr
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.485122 welib-0.0.2/data/Waves/
--rw-rw-rw-   0        0        0    23069 2020-10-22 00:24:04.000000 welib-0.0.2/data/Waves/RegularWave.Elev
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.491122 welib-0.0.2/data/example_files/
--rw-rw-rw-   0        0        0    17178 2020-08-03 21:20:16.000000 welib-0.0.2/data/example_files/FASTSum_Pendulum.SD.sum.yaml
--rw-rw-rw-   0        0        0    16593 2020-10-13 04:40:35.000000 welib-0.0.2/data/example_files/FASTSum_PendulumNoCB.SD.sum.yaml
--rw-rw-rw-   0        0        0   234919 2021-07-21 16:10:07.000000 welib-0.0.2/data/example_files/fastout_allnodes.outb
--rw-rw-rw-   0        0        0      192 2021-07-21 16:10:07.000000 welib-0.0.2/requirements.txt
--rw-rw-rw-   0        0        0       42 2022-07-05 18:24:04.843043 welib-0.0.2/setup.cfg
--rw-rw-rw-   0        0        0     2011 2022-07-05 18:23:09.000000 welib-0.0.2/setup.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.494126 welib-0.0.2/welib/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.512999 welib-0.0.2/welib/BEM/
--rw-rw-rw-   0        0        0    31753 2019-06-08 18:46:14.000000 welib-0.0.2/welib/BEM/_OTHER.py
--rw-rw-rw-   0        0        0     9800 2018-10-15 22:46:51.000000 welib-0.0.2/welib/BEM/_TODO.py
--rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-0.0.2/welib/BEM/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.523999 welib-0.0.2/welib/BEM/examples/
--rw-rw-rw-   0        0        0     1635 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_AxialInduction.py
--rw-rw-rw-   0        0        0     2007 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_BEM_1.py
--rw-rw-rw-   0        0        0     3260 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_BEM_2.py
--rw-rw-rw-   0        0        0     3029 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_BEM_CPLambdaPitch.py
--rw-rw-rw-   0        0        0     2044 2021-07-21 16:10:07.000000 welib-0.0.2/welib/BEM/examples/Example_IdealRotor.py
--rw-rw-rw-   0        0        0     1031 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_UnsteadyBEM_1_ConstantRPM.py
--rw-rw-rw-   0        0        0     3292 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/examples/Example_UnsteadyBEM_2_PrescribedMotion.py
--rw-rw-rw-   0        0        0        0 2020-12-14 02:13:06.000000 welib-0.0.2/welib/BEM/examples/README.md
--rw-rw-rw-   0        0        0     6748 2021-07-21 16:10:07.000000 welib-0.0.2/welib/BEM/highthrust.py
--rw-rw-rw-   0        0        0     3860 2021-07-21 16:10:07.000000 welib-0.0.2/welib/BEM/idealrotors.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.549065 welib-0.0.2/welib/BEM/matlab/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.563067 welib-0.0.2/welib/BEM/matlab/Simulations/
--rw-rw-rw-   0        0        0     4846 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/MainBEMCompAllTipLossAEP.m
--rw-rw-rw-   0        0        0     7456 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_CompAllTipLoss.m
--rw-rw-rw-   0        0        0      412 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_FindPitch.m
--rw-rw-rw-   0        0        0      818 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_PowerCurve.m
--rw-rw-rw-   0        0        0     1811 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_PrescribedGamma.m
--rw-rw-rw-   0        0        0     1735 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_SetSim.m
--rw-rw-rw-   0        0        0      686 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_SimpleRun.m
--rw-rw-rw-   0        0        0     1844 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/Test_SimulationRef.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.583063 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/
--rw-rw-rw-   0        0        0     3398 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcode.m
--rw-rw-rw-   0        0        0     1231 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeB49.m
--rw-rw-rw-   0        0        0      964 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeLeishman.m
--rw-rw-rw-   0        0        0     1364 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu.m
--rw-rw-rw-   0        0        0      687 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu2.m
--rw-rw-rw-   0        0        0      895 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD.m
--rw-rw-rw-   0        0        0     1059 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD2.m
--rw-rw-rw-   0        0        0     1560 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD3.m
--rw-rw-rw-   0        0        0     1916 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainFindPitch.m
--rw-rw-rw-   0        0        0     2896 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/OptiminumParam.m
--rw-rw-rw-   0        0        0     1902 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/Test2BEMCodeForoneLambda.m
--rw-rw-rw-   0        0        0     1032 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/Simulations/fPlotCodeCompBEM.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.564063 welib-0.0.2/welib/BEM/matlab/SimulationsAeroelasticit/
--rw-rw-rw-   0        0        0     2064 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/SimulationsAeroelasticit/MainPb3_2_WT3Dof_Pitch.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.566063 welib-0.0.2/welib/BEM/matlab/SimulationsUnsteadyBEM/
--rw-rw-rw-   0        0        0     6226 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/SimulationsUnsteadyBEM/Main_PitchStep.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.595064 welib-0.0.2/welib/BEM/matlab/bkp/
--rw-rw-rw-   0        0        0    10975 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyNew.m
--rw-rw-rw-   0        0        0     6893 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyRiso.m
--rw-rw-rw-   0        0        0    10934 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyTipLoss.m
--rw-rw-rw-   0        0        0    11569 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyTipLossStandAlone1.m
--rw-rw-rw-   0        0        0    11001 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_BACKUP.m
--rw-rw-rw-   0        0        0    11618 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_mostRecentBackup.m
--rw-rw-rw-   0        0        0     9663 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_try.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.610063 welib-0.0.2/welib/BEM/matlab/bkp/tmp/
--rw-rw-rw-   0        0        0     1805 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/AeroFun.m
--rw-rw-rw-   0        0        0     1340 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/LiftDataFun.m
--rw-rw-rw-   0        0        0     1875 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/PowerCurve.m
--rw-rw-rw-   0        0        0     3788 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/ReadHawc2.m
--rw-rw-rw-   0        0        0     1246 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test2BEMcodeForOneLambda.m
--rw-rw-rw-   0        0        0     3369 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test3OptimumLambda.m
--rw-rw-rw-   0        0        0     3671 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test3OptimumLambdaClCd.m
--rw-rw-rw-   0        0        0    14543 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEM.m
--rw-rw-rw-   0        0        0      277 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMCTFind.m
--rw-rw-rw-   0        0        0     3404 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMSimulation.m
--rw-rw-rw-   0        0        0     1132 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMpseudo_steady.m
--rw-rw-rw-   0        0        0    14440 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMsteady.m
--rw-rw-rw-   0        0        0     9987 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMsteadyTipLoss.m
--rw-rw-rw-   0        0        0    18473 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMsteadyTipLossStandAlone.m
--rw-rw-rw-   0        0        0     2515 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fBEMunsteady.m
--rw-rw-rw-   0        0        0     3799 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fCorrectionHighThrust.m
--rw-rw-rw-   0        0        0     3508 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fInductionCoefficients.m
--rw-rw-rw-   0        0        0     2221 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fInductionsBEM_Propeller.m
--rw-rw-rw-   0        0        0      316 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fInitBEMAlgo.m
--rw-rw-rw-   0        0        0     4341 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fRunBEM.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.624487 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/
--rw-rw-rw-   0        0        0      789 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/Runge.m
--rw-rw-rw-   0        0        0     2406 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/RungeCore.m
--rw-rw-rw-   0        0        0      631 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/RungeGoOn.m
--rw-rw-rw-   0        0        0      236 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/fStep.m
--rw-rw-rw-   0        0        0      231 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/getDampingMatrix.m
--rw-rw-rw-   0        0        0     2368 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/getMassMatrix.m
--rw-rw-rw-   0        0        0      352 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/getMatrices.m
--rw-rw-rw-   0        0        0      275 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/getStiffnessMatrix.m
--rw-rw-rw-   0        0        0      803 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_aeroelastic/solveAcceleration.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.632486 welib-0.0.2/welib/BEM/matlab/f_optimal/
--rw-rw-rw-   0        0        0      293 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_optimal/fFitChord.m
--rw-rw-rw-   0        0        0      220 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_optimal/fFitTwist.m
--rw-rw-rw-   0        0        0     1529 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_optimal/getOptimizedParameters.m
--rw-rw-rw-   0        0        0      684 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_optimal/getOptimizedParametersClCd.m
--rw-rw-rw-   0        0        0       79 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/f_optimal/getRelationAX.m
--rw-rw-rw-   0        0        0     1964 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fakeBEM.m
--rw-rw-rw-   0        0        0     1751 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/fakeBEMClCd.m
--rw-rw-rw-   0        0        0      371 2015-11-24 09:24:59.000000 welib-0.0.2/welib/BEM/matlab/getTransfoMatrices.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.701992 welib-0.0.2/welib/BEM/matlab/tools/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.713996 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/
--rw-rw-rw-   0        0        0     1808 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/AeroFun.m
--rw-rw-rw-   0        0        0     1340 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/LiftDataFun.m
--rw-rw-rw-   0        0        0     2380 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/MainFindPitch.m
--rw-rw-rw-   0        0        0     5362 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/ReadHtcFileAll.m
--rw-rw-rw-   0        0        0     5387 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/SuperDebug.m
--rw-rw-rw-   0        0        0     4722 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/fFindPitch.m
--rw-rw-rw-   0        0        0     2687 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/fPower.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.719995 welib-0.0.2/welib/BEM/matlab/tools/__tests__/
--rw-rw-rw-   0        0        0     1509 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/__tests__/testAeroCoeff.m
--rw-rw-rw-   0        0        0     1070 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/__tests__/testCompareIntegration.m
--rw-rw-rw-   0        0        0      399 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/__tests__/testIntegration.m
--rw-rw-rw-   0        0        0      608 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/__tests__/testRead.m
--rw-rw-rw-   0        0        0     4426 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fAeroCoeff.m
--rw-rw-rw-   0        0        0     3714 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fAeroCoeffWrap.m
--rw-rw-rw-   0        0        0      106 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fApplySimOnWT.m
--rw-rw-rw-   0        0        0     5023 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fExportWTPerf.m
--rw-rw-rw-   0        0        0     1625 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fFindSimFolder.m
--rw-rw-rw-   0        0        0     6079 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitAlgo.m
--rw-rw-rw-   0        0        0     3001 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitFlex.m
--rw-rw-rw-   0        0        0     2716 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitHawc.m
--rw-rw-rw-   0        0        0     2030 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitSim.m
--rw-rw-rw-   0        0        0     1337 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitVLAlgo_old.m
--rw-rw-rw-   0        0        0    13773 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitWT.m
--rw-rw-rw-   0        0        0     2976 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitWTDefault.m
--rw-rw-rw-   0        0        0      303 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitWTPerf.m
--rw-rw-rw-   0        0        0      738 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fInitXblade.m
--rw-rw-rw-   0        0        0     1743 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadBlade.m
--rw-rw-rw-   0        0        0     3960 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadCFD_AL.m
--rw-rw-rw-   0        0        0     2801 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadCodes.m
--rw-rw-rw-   0        0        0     7630 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadHawc2.m
--rw-rw-rw-   0        0        0      415 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadMeas.m
--rw-rw-rw-   0        0        0     1177 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadShen.m
--rw-rw-rw-   0        0        0     5531 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fLoadVC.m
--rw-rw-rw-   0        0        0     1404 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadAeFile.m
--rw-rw-rw-   0        0        0     1370 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadBtcFile.m
--rw-rw-rw-   0        0        0      612 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadBtcFileAll.m
--rw-rw-rw-   0        0        0     3789 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadHawc2.m
--rw-rw-rw-   0        0        0     3621 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadHtcFile.m
--rw-rw-rw-   0        0        0      261 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadHtcFileAll.m
--rw-rw-rw-   0        0        0     1768 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadPcFile.m
--rw-rw-rw-   0        0        0     2331 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadPcFileExtended.m
--rw-rw-rw-   0        0        0      683 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadSpec.m
--rw-rw-rw-   0        0        0     3457 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadWTPerf.m
--rw-rw-rw-   0        0        0     1452 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fReadXbladeParamFile.m
--rw-rw-rw-   0        0        0     4041 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fSetRotorGrid.m
--rw-rw-rw-   0        0        0      612 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fSetRun.m
--rw-rw-rw-   0        0        0     1534 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fSetSim.m
--rw-rw-rw-   0        0        0      155 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTAEP.m
--rw-rw-rw-   0        0        0     2871 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTFindPitch.m
--rw-rw-rw-   0        0        0     2300 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTGetRefRPM.m
--rw-rw-rw-   0        0        0     1828 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTParametricCP.m
--rw-rw-rw-   0        0        0     1509 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTPowerCurve.m
--rw-rw-rw-   0        0        0     8004 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTSimRef.m
--rw-rw-rw-   0        0        0     6157 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fWTSimulation.m
--rw-rw-rw-   0        0        0      711 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fhawc2_create_output.m
--rw-rw-rw-   0        0        0      810 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fhawc2_signal.m
--rw-rw-rw-   0        0        0     3239 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/fplotCodesComparison.m
--rw-rw-rw-   0        0        0      140 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/getThrustFromBlade.m
--rw-rw-rw-   0        0        0      340 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/getTorqueFromBlade.m
--rw-rw-rw-   0        0        0       68 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/istrue.m
--rw-rw-rw-   0        0        0       83 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/totrue.m
--rw-rw-rw-   0        0        0    11678 2015-11-24 09:24:20.000000 welib-0.0.2/welib/BEM/matlab/tools/wind_rose.m
--rw-rw-rw-   0        0        0    15554 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/steadyBEM.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.724531 welib-0.0.2/welib/BEM/tests/
--rw-rw-rw-   0        0        0        0 2019-01-20 23:17:10.000000 welib-0.0.2/welib/BEM/tests/__init__.py
--rw-rw-rw-   0        0        0     1196 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/tests/test_BEM.py
--rw-rw-rw-   0        0        0     7986 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/tests/test_BEM_unsteady.py
--rw-rw-rw-   0        0        0     1183 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/tests/test_run_Examples.py
--rw-rw-rw-   0        0        0    51898 2022-07-05 18:17:30.000000 welib-0.0.2/welib/BEM/unsteadyBEM.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.731526 welib-0.0.2/welib/CFD/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/CFD/__init__.py
--rw-rw-rw-   0        0        0    10774 2021-07-10 18:18:14.000000 welib-0.0.2/welib/CFD/_vorticity-rz - Copy.py
--rw-rw-rw-   0        0        0    10774 2021-07-10 18:18:14.000000 welib-0.0.2/welib/CFD/_vorticity-rz.py
--rw-rw-rw-   0        0        0    11311 2021-07-14 04:53:04.000000 welib-0.0.2/welib/CFD/_vorticity-rz_lesswalls.py
--rw-rw-rw-   0        0        0    10901 2022-07-05 18:17:30.000000 welib-0.0.2/welib/CFD/axisym_streamf.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.734526 welib-0.0.2/welib/CFD/tests/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/CFD/tests/__init__.py
--rw-rw-rw-   0        0        0     9090 2022-07-05 18:17:30.000000 welib-0.0.2/welib/CFD/tests/test_axisym_streamf.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.757530 welib-0.0.2/welib/FEM/
--rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-0.0.2/welib/FEM/__init__.py
--rw-rw-rw-   0        0        0     4105 2020-09-02 04:46:05.000000 welib-0.0.2/welib/FEM/beam2d.py
--rw-rw-rw-   0        0        0     2867 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/cable.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.759527 welib-0.0.2/welib/FEM/derivations/
--rw-rw-rw-   0        0        0     1801 2020-12-14 01:37:27.000000 welib-0.0.2/welib/FEM/derivations/GuyanReduction.py
--rw-rw-rw-   0        0        0    12331 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/direct_elimination.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.772527 welib-0.0.2/welib/FEM/examples/
--rw-rw-rw-   0        0        0     5229 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/Beam_CraigBamptonReduction_Monopile.py
--rw-rw-rw-   0        0        0     4381 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/Beam_FlexibleProperties_Tower.py
--rw-rw-rw-   0        0        0     4612 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_Monopile.py
--rw-rw-rw-   0        0        0     6636 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_Tower.py
--rw-rw-rw-   0        0        0     5695 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py
--rw-rw-rw-   0        0        0     2512 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/Graph_CreateSimpleGraph.py
--rw-rw-rw-   0        0        0      678 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/examples/README.md
--rw-rw-rw-   0        0        0     1673 2020-12-14 02:38:55.000000 welib-0.0.2/welib/FEM/examples/frame2d_element.py
--rw-rw-rw-   0        0        0    40826 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/fem_beam.py
--rw-rw-rw-   0        0        0      307 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/fem_core.py
--rw-rw-rw-   0        0        0    12767 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/fem_elements.py
--rw-rw-rw-   0        0        0    30786 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/fem_model.py
--rw-rw-rw-   0        0        0     3976 2020-11-06 03:25:04.000000 welib-0.0.2/welib/FEM/fem_sympy.py
--rw-rw-rw-   0        0        0     6106 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/frame2d.py
--rw-rw-rw-   0        0        0    10323 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/frame3d.py
--rw-rw-rw-   0        0        0    31076 2020-11-07 02:11:46.000000 welib-0.0.2/welib/FEM/frame3dlin.py
--rw-rw-rw-   0        0        0    40062 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/graph.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.800526 welib-0.0.2/welib/FEM/matlab/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.815527 welib-0.0.2/welib/FEM/matlab/examples/
--rw-rw-rw-   0        0        0     3486 2020-03-05 22:59:31.000000 welib-0.0.2/welib/FEM/matlab/examples/Main_CraigBampton_2D.m
--rw-rw-rw-   0        0        0     4204 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/examples/Main_CraigBampton_3D.m
--rw-rw-rw-   0        0        0    10227 2020-04-13 01:55:18.000000 welib-0.0.2/welib/FEM/matlab/examples/Main_TowerTopExcitation.m
--rw-rw-rw-   0        0        0     7918 2020-04-10 21:53:37.000000 welib-0.0.2/welib/FEM/matlab/examples/RefDisp.csv
--rw-rw-rw-   0        0        0     4172 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/examples/ThinBeam3D.m
--rw-rw-rw-   0        0        0     4679 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/examples/ThinRotatingBeam_FEM.m
--rw-rw-rw-   0        0        0      221 2020-04-10 22:00:52.000000 welib-0.0.2/welib/FEM/matlab/examples/fTowerTopExcitation.m
--rw-rw-rw-   0        0        0      709 2020-08-21 05:50:54.000000 welib-0.0.2/welib/FEM/matlab/examples/fTowerTopMDKR.m
--rw-rw-rw-   0        0        0      444 2020-04-10 21:59:24.000000 welib-0.0.2/welib/FEM/matlab/examples/fTowerTopYDot.m
--rw-rw-rw-   0        0        0     4585 2020-04-10 21:36:06.000000 welib-0.0.2/welib/FEM/matlab/fBeamMatrices2D_2DOF.m
--rw-rw-rw-   0        0        0     3821 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fBeamMatrices3D_Frame6DOF.m
--rw-rw-rw-   0        0        0      375 2018-05-10 22:41:13.000000 welib-0.0.2/welib/FEM/matlab/fBuildGlobalMatrix.m
--rw-rw-rw-   0        0        0     1759 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamFEM2D.m
--rw-rw-rw-   0        0        0     6651 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamFEM3D_Frame.m
--rw-rw-rw-   0        0        0     3736 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamModes2D_2DOF.m
--rw-rw-rw-   0        0        0     5081 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRayleighRitz.m
--rw-rw-rw-   0        0        0     5333 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRayleighRitzHermitian.m
--rw-rw-rw-   0        0        0     5350 2021-07-21 16:10:07.000000 welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRotating.m
--rw-rw-rw-   0        0        0     2744 2020-08-21 05:50:35.000000 welib-0.0.2/welib/FEM/matlab/fCraigBamptonReduce.m
--rw-rw-rw-   0        0        0      449 2020-03-05 21:58:00.000000 welib-0.0.2/welib/FEM/matlab/fElementDOFIndex.m
--rw-rw-rw-   0        0        0      432 2020-03-05 21:59:02.000000 welib-0.0.2/welib/FEM/matlab/fElementKNormalForce2D_2DOF.m
--rw-rw-rw-   0        0        0     1511 2020-04-10 21:55:15.000000 welib-0.0.2/welib/FEM/matlab/fElementMatricesBeam2D_2DOF.m
--rw-rw-rw-   0        0        0     2455 2020-04-10 21:35:37.000000 welib-0.0.2/welib/FEM/matlab/fElementMatricesFrame2D_3DOF.m
--rw-rw-rw-   0        0        0     8898 2020-04-01 15:57:14.000000 welib-0.0.2/welib/FEM/matlab/fElementMatricesFrame3D_6DOF.m
--rw-rw-rw-   0        0        0     2080 2020-03-05 21:57:38.000000 welib-0.0.2/welib/FEM/matlab/fGuyanReduce.m
--rw-rw-rw-   0        0        0     5563 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/reduction.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.827527 welib-0.0.2/welib/FEM/tests/
--rw-rw-rw-   0        0        0    21881 2020-11-04 02:52:54.000000 welib-0.0.2/welib/FEM/tests/_FEMBeam2SID.py
--rw-rw-rw-   0        0        0        0 2020-10-08 18:54:47.000000 welib-0.0.2/welib/FEM/tests/__init__.py
--rw-rw-rw-   0        0        0     8219 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/tests/test_beam_linear_element.py
--rw-rw-rw-   0        0        0     4206 2020-11-07 04:08:35.000000 welib-0.0.2/welib/FEM/tests/test_frame3d.py
--rw-rw-rw-   0        0        0     2797 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/tests/test_reduction.py
--rw-rw-rw-   0        0        0     1189 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/tests/test_run_Examples.py
--rw-rw-rw-   0        0        0     1142 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/tests/test_utils.py
--rw-rw-rw-   0        0        0     7854 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/timoshenko.py
--rw-rw-rw-   0        0        0     9333 2022-07-05 18:17:30.000000 welib-0.0.2/welib/FEM/utils.py
--rw-rw-rw-   0        0        0       39 2020-10-08 19:09:22.000000 welib-0.0.2/welib/Makefile
--rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-0.0.2/welib/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.835530 welib-0.0.2/welib/airfoils/
--rw-rw-rw-   0        0        0    17973 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/DynamicStall.py
--rw-rw-rw-   0        0        0       44 2020-09-15 16:23:12.000000 welib-0.0.2/welib/airfoils/Makefile
--rw-rw-rw-   0        0        0    65627 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/Polar.py
--rw-rw-rw-   0        0        0       51 2019-04-05 21:28:09.000000 welib-0.0.2/welib/airfoils/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.843526 welib-0.0.2/welib/airfoils/data/
--rw-rw-rw-   0        0        0     6778 2019-03-01 06:49:58.000000 welib-0.0.2/welib/airfoils/data/63-235.csv
--rw-rw-rw-   0        0        0      116 2019-03-01 06:49:53.000000 welib-0.0.2/welib/airfoils/data/Cylinder.csv
--rw-rw-rw-   0        0        0      194 2019-02-28 22:31:43.000000 welib-0.0.2/welib/airfoils/data/Cylinder.dat
--rw-rw-rw-   0        0        0     6099 2019-03-19 02:56:59.000000 welib-0.0.2/welib/airfoils/data/DU21_A17.csv
--rw-rw-rw-   0        0        0     4451 2019-02-28 22:08:34.000000 welib-0.0.2/welib/airfoils/data/FFA-W3-241-Re12M.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.857527 welib-0.0.2/welib/airfoils/examples/
--rw-rw-rw-   0        0        0        0 2020-12-14 02:35:02.000000 welib-0.0.2/welib/airfoils/examples/README.md
--rw-rw-rw-   0        0        0      985 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/correction3D.py
--rw-rw-rw-   0        0        0     4066 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/createADPolarFile.py
--rw-rw-rw-   0        0        0     5888 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh.py
--rw-rw-rw-   0        0        0     5329 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh_riso_1792.py
--rw-rw-rw-   0        0        0     4349 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh_step_change.py
--rw-rw-rw-   0        0        0     2840 2022-07-05 02:08:00.000000 welib-0.0.2/welib/airfoils/examples/dynamic_stall_oye.py
--rw-rw-rw-   0        0        0      607 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/examples/wagner.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.911527 welib-0.0.2/welib/airfoils/matlab/
--rw-rw-rw-   0        0        0    19866 2014-05-07 14:35:43.000000 welib-0.0.2/welib/airfoils/matlab/KarmanTrefftzGeometry
--rw-rw-rw-   0        0        0     4965 2014-05-07 14:32:35.000000 welib-0.0.2/welib/airfoils/matlab/KarmanTrefftzGeometry.f90
--rw-rw-rw-   0        0        0     6182 2019-02-28 20:32:02.000000 welib-0.0.2/welib/airfoils/matlab/MainProfileCoordinatesExamples.m
--rw-rw-rw-   0        0        0      173 2014-05-07 14:35:41.000000 welib-0.0.2/welib/airfoils/matlab/Makefile
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.915531 welib-0.0.2/welib/airfoils/matlab/__tests__/
--rw-rw-rw-   0        0        0     2034 2019-03-18 17:29:05.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/MainForcedOscillations.m
--rw-rw-rw-   0        0        0     1302 2019-03-16 23:41:03.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/MainPolars.m
--rw-rw-rw-   0        0        0     1479 2019-03-16 23:41:44.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/MainPolarsFullySep.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.920530 welib-0.0.2/welib/airfoils/matlab/__tests__/data/
--rw-rw-rw-   0        0        0    26888 2013-06-03 11:13:04.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/data/DTU_10MW_RWT_pc.dat
--rw-rw-rw-   0        0        0     4410 2014-04-09 08:06:30.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/data/FFA-W3-241-Re12e6.dat
--rw-rw-rw-   0        0        0     2224 2010-02-01 13:52:50.000000 welib-0.0.2/welib/airfoils/matlab/__tests__/data/tjaere11_ds.dat
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.934527 welib-0.0.2/welib/airfoils/matlab/data/
--rw-rw-rw-   0        0        0     8944 2014-04-21 14:10:12.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3211.dat
--rw-rw-rw-   0        0        0     1904 2012-10-29 11:52:29.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3241.dat
--rw-rw-rw-   0        0        0     1539 2012-10-29 11:52:29.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3301.dat
--rw-rw-rw-   0        0        0     1540 2012-10-29 11:52:29.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3360.dat
--rw-rw-rw-   0        0        0     2980 2014-04-21 14:10:22.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3400fb.dat
--rw-rw-rw-   0        0        0     3318 2014-04-21 14:10:29.000000 welib-0.0.2/welib/airfoils/matlab/data/ffaw3480.dat
--rw-rw-rw-   0        0        0     2200 2014-01-12 00:17:40.000000 welib-0.0.2/welib/airfoils/matlab/data/geom-cylinder.dat
--rw-rw-rw-   0        0        0     1904 2012-10-29 11:52:29.000000 welib-0.0.2/welib/airfoils/matlab/data/geom-ffaw3241.dat
--rw-rw-rw-   0        0        0     7581 2014-05-07 14:35:44.000000 welib-0.0.2/welib/airfoils/matlab/data/geom-karman-trefftz_-0.1_0.0_5.dat
--rw-rw-rw-   0        0        0      203 2014-04-09 08:23:36.000000 welib-0.0.2/welib/airfoils/matlab/fAirfoilExtendPolarViterna.m
--rw-rw-rw-   0        0        0      876 2014-04-09 08:37:28.000000 welib-0.0.2/welib/airfoils/matlab/fAlpha0.m
--rw-rw-rw-   0        0        0      224 2019-03-18 02:00:04.000000 welib-0.0.2/welib/airfoils/matlab/fAlphaSlope.m
--rw-rw-rw-   0        0        0      424 2011-05-19 20:11:24.000000 welib-0.0.2/welib/airfoils/matlab/fCdFromCf.m
--rw-rw-rw-   0        0        0      425 2011-05-20 20:11:31.000000 welib-0.0.2/welib/airfoils/matlab/fCdFromCp.m
--rw-rw-rw-   0        0        0      425 2011-05-20 20:11:13.000000 welib-0.0.2/welib/airfoils/matlab/fClFromCf.m
--rw-rw-rw-   0        0        0      427 2011-05-20 20:11:38.000000 welib-0.0.2/welib/airfoils/matlab/fClFromCp.m
--rw-rw-rw-   0        0        0      527 2019-03-18 17:27:38.000000 welib-0.0.2/welib/airfoils/matlab/fDynaStallOye.m
--rw-rw-rw-   0        0        0     1401 2014-04-09 11:31:09.000000 welib-0.0.2/welib/airfoils/matlab/fInitPolar.m
--rw-rw-rw-   0        0        0     1738 2011-05-20 20:48:27.000000 welib-0.0.2/welib/airfoils/matlab/fLoadFromPressure.m
--rw-rw-rw-   0        0        0      850 2011-05-20 20:25:34.000000 welib-0.0.2/welib/airfoils/matlab/fLoadFromTau.m
--rw-rw-rw-   0        0        0      926 2011-09-10 03:59:16.000000 welib-0.0.2/welib/airfoils/matlab/fPlotAirfoilForces.m
--rw-rw-rw-   0        0        0      507 2012-08-08 12:23:08.000000 welib-0.0.2/welib/airfoils/matlab/fPlotAirfoilScene.m
--rw-rw-rw-   0        0        0      378 2011-05-20 20:45:16.000000 welib-0.0.2/welib/airfoils/matlab/fPlotAirfoilShear.m
--rw-rw-rw-   0        0        0     9038 2011-09-12 21:48:04.000000 welib-0.0.2/welib/airfoils/matlab/fPolarExtendViterna.m
--rw-rw-rw-   0        0        0     2330 2014-04-09 08:52:47.000000 welib-0.0.2/welib/airfoils/matlab/fPolarFullySeparated.m
--rw-rw-rw-   0        0        0      490 2019-03-16 22:39:16.000000 welib-0.0.2/welib/airfoils/matlab/fPolarInviscid.m
--rw-rw-rw-   0        0        0     1432 2011-05-20 21:14:55.000000 welib-0.0.2/welib/airfoils/matlab/fPressureIntegration.m
--rw-rw-rw-   0        0        0     4386 2012-11-07 13:36:12.000000 welib-0.0.2/welib/airfoils/matlab/fProfileCoordinates.m
--rw-rw-rw-   0        0        0     3017 2012-11-15 12:29:42.000000 welib-0.0.2/welib/airfoils/matlab/fProfileKarmanTrefftz.m
--rw-rw-rw-   0        0        0     7729 2014-05-07 13:53:39.000000 welib-0.0.2/welib/airfoils/matlab/fProfileStandardize.m
--rw-rw-rw-   0        0        0     5323 2012-11-15 12:01:24.000000 welib-0.0.2/welib/airfoils/matlab/fProfileVanDeVooren.m
--rw-rw-rw-   0        0        0     4363 2008-12-24 15:57:46.000000 welib-0.0.2/welib/airfoils/matlab/naca4gen.m
--rw-rw-rw-   0        0        0     4620 2009-03-10 14:10:18.000000 welib-0.0.2/welib/airfoils/matlab/naca5gen.m
--rw-rw-rw-   0        0        0      620 2012-11-05 14:32:54.000000 welib-0.0.2/welib/airfoils/matlab/struct2str.m
--rw-rw-rw-   0        0        0      645 2012-11-05 15:03:02.000000 welib-0.0.2/welib/airfoils/matlab/textlegend.m
--rw-rw-rw-   0        0        0      287 2009-02-13 15:24:42.000000 welib-0.0.2/welib/airfoils/matlab/tst_naca4gen.m
--rw-rw-rw-   0        0        0      359 2009-03-10 14:09:18.000000 welib-0.0.2/welib/airfoils/matlab/tst_naca5gen.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.943527 welib-0.0.2/welib/airfoils/tests/
--rw-rw-rw-   0        0        0        0 2019-02-16 23:50:56.000000 welib-0.0.2/welib/airfoils/tests/__init__.py
--rw-rw-rw-   0        0        0     6290 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/tests/test_dynamic_stall.py
--rw-rw-rw-   0        0        0     1726 2019-06-14 02:53:54.000000 welib-0.0.2/welib/airfoils/tests/test_polar_interp.py
--rw-rw-rw-   0        0        0      756 2019-06-16 01:02:37.000000 welib-0.0.2/welib/airfoils/tests/test_polar_manip.py
--rw-rw-rw-   0        0        0    10104 2021-07-21 16:10:07.000000 welib-0.0.2/welib/airfoils/tests/test_polar_params.py
--rw-rw-rw-   0        0        0     1138 2022-07-05 18:17:30.000000 welib-0.0.2/welib/airfoils/tests/test_run_Examples.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.945527 welib-0.0.2/welib/beams/
--rw-rw-rw-   0        0        0        0 2020-10-22 04:09:55.000000 welib-0.0.2/welib/beams/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.951527 welib-0.0.2/welib/beams/examples/
--rw-rw-rw-   0        0        0     1369 2022-07-05 18:17:30.000000 welib-0.0.2/welib/beams/examples/Ex1_BeamModes.py
--rw-rw-rw-   0        0        0     2141 2022-07-05 18:17:30.000000 welib-0.0.2/welib/beams/examples/Ex2_BeamModesAllBC.py
--rw-rw-rw-   0        0        0      804 2022-06-25 00:53:30.000000 welib-0.0.2/welib/beams/examples/___TestBeamDynUniform.py
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/beams/examples/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.957530 welib-0.0.2/welib/beams/matlab/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.960526 welib-0.0.2/welib/beams/matlab/examples/
--rw-rw-rw-   0        0        0     1215 2019-07-20 21:04:21.000000 welib-0.0.2/welib/beams/matlab/examples/Main_Modes.m
--rw-rw-rw-   0        0        0     3803 2019-07-20 21:05:23.000000 welib-0.0.2/welib/beams/matlab/examples/Main_Modes_For_FAST.m
--rw-rw-rw-   0        0        0    18787 2018-06-30 11:16:10.000000 welib-0.0.2/welib/beams/matlab/fInputParser.m
--rw-rw-rw-   0        0        0     6125 2019-07-20 21:56:52.000000 welib-0.0.2/welib/beams/matlab/fUniformBeamTheory.m
--rw-rw-rw-   0        0        0     2958 2019-07-20 21:56:55.000000 welib-0.0.2/welib/beams/matlab/fUniformBeamTheoryLongi.m
--rw-rw-rw-   0        0        0     3136 2019-07-20 22:21:00.000000 welib-0.0.2/welib/beams/matlab/fUniformBeamTheoryTorsion.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.963532 welib-0.0.2/welib/beams/tests/
--rw-rw-rw-   0        0        0        0 2020-10-22 04:10:07.000000 welib-0.0.2/welib/beams/tests/__init__.py
--rw-rw-rw-   0        0        0     3133 2022-06-25 00:01:42.000000 welib-0.0.2/welib/beams/tests/test_theory.py
--rw-rw-rw-   0        0        0    10931 2022-07-05 18:17:30.000000 welib-0.0.2/welib/beams/theory.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.969527 welib-0.0.2/welib/ctrl/
--rw-rw-rw-   0        0        0      681 2021-07-01 19:37:08.000000 welib-0.0.2/welib/ctrl/_BodePlot.py
--rw-rw-rw-   0        0        0        0 2020-10-09 00:08:07.000000 welib-0.0.2/welib/ctrl/__init__.py
--rw-rw-rw-   0        0        0     6657 2021-06-30 23:33:01.000000 welib-0.0.2/welib/ctrl/_secord-matlab.py
--rw-rw-rw-   0        0        0     2038 2020-11-16 04:59:10.000000 welib-0.0.2/welib/ctrl/_secord_transfer.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.972527 welib-0.0.2/welib/dyninflow/
--rw-rw-rw-   0        0        0    19894 2022-07-05 18:17:30.000000 welib-0.0.2/welib/dyninflow/DynamicInflow.py
--rw-rw-rw-   0        0        0        0 2021-02-01 06:21:39.000000 welib-0.0.2/welib/dyninflow/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.975531 welib-0.0.2/welib/dyninflow/examples/
--rw-rw-rw-   0        0        0     2131 2022-07-05 18:17:30.000000 welib-0.0.2/welib/dyninflow/examples/Ex1_StepUp.py
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/dyninflow/examples/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.017526 welib-0.0.2/welib/fast/
--rw-rw-rw-   0        0        0     9186 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/FASTLin.py
--rw-rw-rw-   0        0        0      335 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/README.md
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/__init__.py
--rw-rw-rw-   0        0        0    50498 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/beamdyn.py
--rw-rw-rw-   0        0        0    24945 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/campbell.py
--rw-rw-rw-   0        0        0    23706 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/case_gen.py
--rw-rw-rw-   0        0        0    39316 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/elastodyn.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.042482 welib-0.0.2/welib/fast/examples/
--rw-rw-rw-   0        0        0       32 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/examples/.gitignore
--rw-rw-rw-   0        0        0     1966 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_CPLambdaPitch.py
--rw-rw-rw-   0        0        0     2556 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_ExcelFile.py
--rw-rw-rw-   0        0        0     3283 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_ExtractInertia.py
--rw-rw-rw-   0        0        0     2228 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_Hawc2ToBeamDyn.py
--rw-rw-rw-   0        0        0     7057 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_HydroDyn_PrescribedMotion.py
--rw-rw-rw-   0        0        0     4319 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_Parametric.py
--rw-rw-rw-   0        0        0      755 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_PointMesh.py
--rw-rw-rw-   0        0        0     6396 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_PowerCurve_Parametric.py
--rw-rw-rw-   0        0        0     2880 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_RadialInterp.py
--rw-rw-rw-   0        0        0     2386 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_RadialPostPro.py
--rw-rw-rw-   0        0        0     1174 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/examples/Example_Remap.py
--rw-rw-rw-   0        0        0     3480 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/examples/Example_SubDyn_Modes.py
--rw-rw-rw-   0        0        0    11500 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/examples/ParametricExcel.xlsx
--rw-rw-rw-   0        0        0      912 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/examples/README.md
--rw-rw-rw-   0        0        0    20095 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/extract.py
--rw-rw-rw-   0        0        0     8570 2022-02-21 23:41:08.000000 welib-0.0.2/welib/fast/fast_mesh - Copy.py
--rw-rw-rw-   0        0        0     8414 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/fast_mesh.py
--rw-rw-rw-   0        0        0    19738 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/fastfarm.py
--rw-rw-rw-   0        0        0      226 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/fastlib.py
--rw-rw-rw-   0        0        0    11972 2020-03-31 01:43:57.000000 welib-0.0.2/welib/fast/fastlib_legacy.py
--rw-rw-rw-   0        0        0    25379 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/hydrodyn.py
--rw-rw-rw-   0        0        0     9314 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/hydrodyn_driver.py
--rw-rw-rw-   0        0        0   101479 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/hydrodyn_morison.py
--rw-rw-rw-   0        0        0     1803 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/hydrodyn_waves.py
--rw-rw-rw-   0        0        0    29342 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/linearization.py
--rw-rw-rw-   0        0        0     9249 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/linmodel.py
--rw-rw-rw-   0        0        0     2526 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/olaf.py
--rw-rw-rw-   0        0        0    64279 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/postpro.py
--rw-rw-rw-   0        0        0     7083 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/runner.py
--rw-rw-rw-   0        0        0    38150 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/subdyn.py
--rw-rw-rw-   0        0        0     6004 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/subdyn_sum.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.050481 welib-0.0.2/welib/fast/tests/
--rw-rw-rw-   0        0        0        2 2021-07-21 16:10:07.000000 welib-0.0.2/welib/fast/tests/__init__.py
--rw-rw-rw-   0        0        0    17118 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/tests/test_elastodyn.py
--rw-rw-rw-   0        0        0     2800 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/tests/test_hydrodyn.py
--rw-rw-rw-   0        0        0     1336 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/tests/test_mesh.py
--rw-rw-rw-   0        0        0     1138 2022-07-05 18:17:30.000000 welib-0.0.2/welib/fast/tests/test_run_Examples.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.062481 welib-0.0.2/welib/hydro/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/__init__.py
--rw-rw-rw-   0        0        0    35232 2020-09-24 14:44:08.000000 welib-0.0.2/welib/hydro/_spectral.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.074480 welib-0.0.2/welib/hydro/examples/
--rw-rw-rw-   0        0        0     4309 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/examples/Ex1_WaveKinematics.py
--rw-rw-rw-   0        0        0     1366 2022-07-05 18:17:30.000000 welib-0.0.2/welib/hydro/examples/Ex2_Jonswap_spectrum.py
--rw-rw-rw-   0        0        0     2311 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/examples/Ex3_WaveTimeSeries.py
--rw-rw-rw-   0        0        0     6407 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/examples/Ex4_WaveLoads.py
--rw-rw-rw-   0        0        0      517 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/examples/README.md
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/examples/__init__.py
--rw-rw-rw-   0        0        0     1516 2022-07-05 18:17:30.000000 welib-0.0.2/welib/hydro/hydrostat.py
--rw-rw-rw-   0        0        0     2468 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/morison.py
--rw-rw-rw-   0        0        0     2108 2022-07-05 18:17:30.000000 welib-0.0.2/welib/hydro/spectra.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.082481 welib-0.0.2/welib/hydro/tests/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/tests/__init__.py
--rw-rw-rw-   0        0        0     1057 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/tests/test_morison.py
--rw-rw-rw-   0        0        0     1142 2022-07-05 18:17:30.000000 welib-0.0.2/welib/hydro/tests/test_run_Examples.py
--rw-rw-rw-   0        0        0      770 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/tests/test_spectra.py
--rw-rw-rw-   0        0        0     3856 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/tests/test_wavekin.py
--rw-rw-rw-   0        0        0     3358 2022-07-05 18:17:30.000000 welib-0.0.2/welib/hydro/tools.py
--rw-rw-rw-   0        0        0     5534 2021-07-21 16:10:07.000000 welib-0.0.2/welib/hydro/wavekin.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.096481 welib-0.0.2/welib/kalman/
--rw-rw-rw-   0        0        0    15404 2021-07-21 16:10:07.000000 welib-0.0.2/welib/kalman/TN.py
--rw-rw-rw-   0        0        0    19131 2020-10-22 01:57:32.000000 welib-0.0.2/welib/kalman/TNLin - Copy.py
--rw-rw-rw-   0        0        0    18916 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/TNLin.py
--rw-rw-rw-   0        0        0        0 2020-10-22 04:12:55.000000 welib-0.0.2/welib/kalman/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.098481 welib-0.0.2/welib/kalman/examples/
--rw-rw-rw-   0        0        0     5875 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/Mech_1DOF.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.105481 welib-0.0.2/welib/kalman/examples/onshore_OFLin/
--rw-rw-rw-   0        0        0     3571 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/onshore_OFLin/001_Linearization_GenerateCase.py
--rw-rw-rw-   0        0        0     3822 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/onshore_OFLin/002_Create_FASTLin.py
--rw-rw-rw-   0        0        0     4313 2020-10-22 01:41:55.000000 welib-0.0.2/welib/kalman/examples/onshore_OFLin/301_Kalman_2DOF_5States.py
--rw-rw-rw-   0        0        0     3563 2020-02-26 20:42:29.000000 welib-0.0.2/welib/kalman/examples/onshore_OFLin/kalman_models.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.112482 welib-0.0.2/welib/kalman/examples/onshore_YAMS/
--rw-rw-rw-   0        0        0     2116 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/onshore_YAMS/000_CPLambdaPitch.py
--rw-rw-rw-   0        0        0     2137 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/onshore_YAMS/100_WSEstimation.py
--rw-rw-rw-   0        0        0     3328 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/examples/onshore_YAMS/300_Kalman_2DOF_7States.py
--rw-rw-rw-   0        0        0      338 2019-12-02 05:24:30.000000 welib-0.0.2/welib/kalman/filters.py
--rw-rw-rw-   0        0        0     8166 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/kalman.py
--rw-rw-rw-   0        0        0    15105 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/kalmanfilter.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.121481 welib-0.0.2/welib/kalman/tests/
--rw-rw-rw-   0        0        0        0 2020-10-22 04:12:55.000000 welib-0.0.2/welib/kalman/tests/__init__.py
--rw-rw-rw-   0        0        0     5050 2020-10-22 04:12:45.000000 welib-0.0.2/welib/kalman/tests/test_kalman.py
--rw-rw-rw-   0        0        0     1138 2022-07-05 18:17:30.000000 welib-0.0.2/welib/kalman/tests/test_run_Examples.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.138481 welib-0.0.2/welib/mesh/
--rw-rw-rw-   0        0        0        0 2019-08-03 03:03:46.000000 welib-0.0.2/welib/mesh/__init__.py
--rw-rw-rw-   0        0        0      250 2019-08-03 04:16:19.000000 welib-0.0.2/welib/mesh/fCoordRectilinearGrid.py
--rw-rw-rw-   0        0        0      200 2019-08-03 04:16:19.000000 welib-0.0.2/welib/mesh/fCoordRegularGrid.py
--rw-rw-rw-   0        0        0      352 2019-08-03 04:16:20.000000 welib-0.0.2/welib/mesh/fMeshProgressive.py
--rw-rw-rw-   0        0        0      503 2019-08-03 04:16:20.000000 welib-0.0.2/welib/mesh/fMeshProgressiveExtent.py
--rw-rw-rw-   0        0        0     1090 2019-08-03 04:16:18.000000 welib-0.0.2/welib/mesh/fbinary_search.py
--rw-rw-rw-   0        0        0     2571 2021-05-16 21:35:10.000000 welib-0.0.2/welib/mesh/gradient.py
--rw-rw-rw-   0        0        0     9635 2020-10-09 00:28:37.000000 welib-0.0.2/welib/mesh/mesh.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.142481 welib-0.0.2/welib/mesh/tests/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/mesh/tests/__init__.py
--rw-rw-rw-   0        0        0     3861 2021-07-21 16:10:07.000000 welib-0.0.2/welib/mesh/tests/test_vectoranalysis.py
--rw-rw-rw-   0        0        0     3065 2021-07-21 16:10:07.000000 welib-0.0.2/welib/mesh/vectoranalysis.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.147486 welib-0.0.2/welib/moor/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/moor/__init__.py
--rw-rw-rw-   0        0        0    44142 2022-07-05 18:17:30.000000 welib-0.0.2/welib/moor/mappp.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.343365 welib-0.0.2/welib/ode/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.157481 welib-0.0.2/welib/ode/matlab/
--rw-rw-rw-   0        0        0     4011 2020-04-10 21:38:36.000000 welib-0.0.2/welib/ode/matlab/fodeKrenk.m
--rw-rw-rw-   0        0        0     8012 2020-04-10 21:38:26.000000 welib-0.0.2/welib/ode/matlab/fodeNewmark.m
--rw-rw-rw-   0        0        0     6544 2020-04-10 21:38:18.000000 welib-0.0.2/welib/ode/matlab/fodeNewmarkNonLinear.m
--rw-rw-rw-   0        0        0     3410 2018-07-21 12:03:59.000000 welib-0.0.2/welib/ode/matlab/fodeProgressBar.m
--rw-rw-rw-   0        0        0     5785 2020-04-10 21:38:10.000000 welib-0.0.2/welib/ode/matlab/fodeRK4.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.166480 welib-0.0.2/welib/plot/
--rw-rw-rw-   0        0        0     2294 2021-06-06 00:03:57.000000 welib-0.0.2/welib/plot/_PlotTorus.py
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.171480 welib-0.0.2/welib/plot/examples/
--rw-rw-rw-   0        0        0     3878 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/examples/JSON3D_01_CreateSimpleFile.py
--rw-rw-rw-   0        0        0     7300 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/examples/Plot_3D_blades.py
--rw-rw-rw-   0        0        0     1146 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/examples/Plot_3D_surfaces.py
--rw-rw-rw-   0        0        0    10303 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/json3d.py
--rw-rw-rw-   0        0        0     2464 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/surface3d.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.174481 welib-0.0.2/welib/plot/tests/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/tests/__init__.py
--rw-rw-rw-   0        0        0     1183 2022-07-05 18:17:30.000000 welib-0.0.2/welib/plot/tests/test_run_Examples.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.177484 welib-0.0.2/welib/standards/
--rw-rw-rw-   0        0        0     7401 2022-07-05 18:17:30.000000 welib-0.0.2/welib/standards/IEC.py
--rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-0.0.2/welib/standards/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.182486 welib-0.0.2/welib/standards/examples/
--rw-rw-rw-   0        0        0     1074 2022-02-08 22:29:24.000000 welib-0.0.2/welib/standards/examples/Ex1_TurbulenceClasses.py
--rw-rw-rw-   0        0        0     1540 2022-07-05 18:17:30.000000 welib-0.0.2/welib/standards/examples/Ex2_EOG.py
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/standards/examples/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.202485 welib-0.0.2/welib/system/
--rw-rw-rw-   0        0        0       39 2020-10-08 19:09:22.000000 welib-0.0.2/welib/system/Makefile
--rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-0.0.2/welib/system/__init__.py
--rw-rw-rw-   0        0        0       31 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/eva.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.217480 welib-0.0.2/welib/system/examples/
--rw-rw-rw-   0        0        0     7271 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/Example_DriveTrainTorsion.py
--rw-rw-rw-   0        0        0     4405 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/Example_DriveTrainTorsion_Wrap.py
--rw-rw-rw-   0        0        0     5633 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/FirstOrderSystem_Scalar.py
--rw-rw-rw-   0        0        0     2397 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/MassSpringDamper_Duhamel.py
--rw-rw-rw-   0        0        0     1288 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/MassSpringDamper_ForcedVibrations.py
--rw-rw-rw-   0        0        0     2070 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/MassSpringDamper_StateSpace_FreqDomain.py
--rw-rw-rw-   0        0        0     7255 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/SecondOrderSystem_Scalar.py
--rw-rw-rw-   0        0        0     1346 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples/StepResponse.py
--rw-rw-rw-   0        0        0     1644 2020-12-15 20:39:09.000000 welib-0.0.2/welib/system/examples/pendulum.py
--rw-rw-rw-   0        0        0    10823 2022-07-05 02:08:00.000000 welib-0.0.2/welib/system/examples/pendulum_3d.py
--rw-rw-rw-   0        0        0     3939 2020-12-15 17:31:09.000000 welib-0.0.2/welib/system/examples/pendulum_on_prescribed_cart.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.227484 welib-0.0.2/welib/system/examples_stab/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/__init__.py
--rw-rw-rw-   0        0        0     4426 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/exA1.py
--rw-rw-rw-   0        0        0     5489 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/exA2.py
--rw-rw-rw-   0        0        0     5748 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/exB1.py
--rw-rw-rw-   0        0        0    38958 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/model15DOFs.py
--rw-rw-rw-   0        0        0     1594 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/model5DOFs.py
--rw-rw-rw-   0        0        0    34595 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/examples_stab/test_model.py
--rw-rw-rw-   0        0        0     5636 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/firstorder.py
--rw-rw-rw-   0        0        0     5801 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/linearization.py
--rw-rw-rw-   0        0        0      201 2021-07-21 16:10:07.000000 welib-0.0.2/welib/system/lti.py
--rw-rw-rw-   0        0        0     5060 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/mbc.py
--rw-rw-rw-   0        0        0    23651 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/mech_system.py
--rw-rw-rw-   0        0        0     7738 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/secondorder.py
--rw-rw-rw-   0        0        0     5698 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/singledof.py
--rw-rw-rw-   0        0        0     1724 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/statespace.py
--rw-rw-rw-   0        0        0    15024 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/statespacelinear.py
--rw-rw-rw-   0        0        0     8663 2020-10-09 01:19:59.000000 welib-0.0.2/welib/system/system.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.237481 welib-0.0.2/welib/system/tests/
--rw-rw-rw-   0        0        0        0 2020-10-08 18:54:47.000000 welib-0.0.2/welib/system/tests/__init__.py
--rw-rw-rw-   0        0        0     2831 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/tests/test_eva.py
--rw-rw-rw-   0        0        0     3159 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/tests/test_linearization.py
--rw-rw-rw-   0        0        0     6797 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/tests/test_mbc.py
--rw-rw-rw-   0        0        0     1138 2022-07-05 18:17:30.000000 welib-0.0.2/welib/system/tests/test_run_Examples.py
--rw-rw-rw-   0        0        0     5159 2020-10-22 04:06:26.000000 welib-0.0.2/welib/system/tests/test_singledof.py
--rw-rw-rw-   0        0        0     2963 2022-07-05 02:08:00.000000 welib-0.0.2/welib/system/tests/test_system.py
--rw-rw-rw-   0        0        0        2 2020-10-08 17:46:25.000000 welib-0.0.2/welib/system/tools.py
--rw-rw-rw-   0        0        0      216 2020-11-17 18:34:23.000000 welib-0.0.2/welib/system/transferfunction.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.240481 welib-0.0.2/welib/time/
--rw-rw-rw-   0        0        0     2665 2015-10-14 14:57:24.000000 welib-0.0.2/welib/time/TimeManager.m
--rw-rw-rw-   0        0        0      250 2015-10-14 14:57:24.000000 welib-0.0.2/welib/time/fInitTime.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.286485 welib-0.0.2/welib/tools/
--rw-rw-rw-   0        0        0     1184 2020-10-22 00:31:55.000000 welib-0.0.2/welib/tools/README.md
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.291486 welib-0.0.2/welib/tools/SpectralAnalysis/
--rw-rw-rw-   0        0        0      745 2015-10-14 14:57:58.000000 welib-0.0.2/welib/tools/SpectralAnalysis/fLogSmooth.m
--rw-rw-rw-   0        0        0      822 2015-10-14 14:57:58.000000 welib-0.0.2/welib/tools/SpectralAnalysis/fSpectrum.m
--rw-rw-rw-   0        0        0      753 2015-10-14 14:57:58.000000 welib-0.0.2/welib/tools/SpectralAnalysis/fSpectrumAngular.m
--rw-rw-rw-   0        0        0      118 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/__init__.py
--rw-rw-rw-   0        0        0     8340 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/bithashlib.py
--rw-rw-rw-   0        0        0     2603 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/clean_exceptions.py
--rw-rw-rw-   0        0        0    17072 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/colors.py
--rw-rw-rw-   0        0        0     3327 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/compare.py
--rw-rw-rw-   0        0        0    57872 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/curve_fitting.py
--rw-rw-rw-   0        0        0     9529 2021-07-21 16:10:07.000000 welib-0.0.2/welib/tools/curves.py
--rw-rw-rw-   0        0        0     7592 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/damping.py
--rw-rw-rw-   0        0        0     9035 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/eva.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.297484 welib-0.0.2/welib/tools/examples/
--rw-rw-rw-   0        0        0     6052 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/examples/ExampleCoherence.py
--rw-rw-rw-   0        0        0     1253 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/examples/ExampleCorrelation.py
--rw-rw-rw-   0        0        0     1859 2021-07-21 16:10:07.000000 welib-0.0.2/welib/tools/examples/Example_FFT.py
--rw-rw-rw-   0        0        0    11434 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/examples/VortexCylinderPressure.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.306928 welib-0.0.2/welib/tools/external/
--rw-rw-rw-   0        0        0       95 2019-04-22 23:57:33.000000 welib-0.0.2/welib/tools/external/Makefile
--rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-0.0.2/welib/tools/external/__init__.py
--rw-rw-rw-   0        0        0     1917 2019-04-26 01:54:12.000000 welib-0.0.2/welib/tools/external/_lic_demo.py
--rw-rw-rw-   0        0        0   356558 2019-10-07 04:50:13.000000 welib-0.0.2/welib/tools/external/lic_internal.c
--rw-rw-rw-   0        0        0     2381 2019-10-07 04:49:33.000000 welib-0.0.2/welib/tools/external/lic_internal.pyx
--rw-rw-rw-   0        0        0      282 2019-04-23 00:03:15.000000 welib-0.0.2/welib/tools/external/setup.py
--rw-rw-rw-   0        0        0    32000 2021-07-21 16:10:07.000000 welib-0.0.2/welib/tools/fatigue.py
--rw-rw-rw-   0        0        0    10500 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/fields.py
--rw-rw-rw-   0        0        0    18114 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/figure.py
--rw-rw-rw-   0        0        0     8007 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/functions.py
--rw-rw-rw-   0        0        0    30804 2020-10-22 01:06:47.000000 welib-0.0.2/welib/tools/galib.py
--rw-rw-rw-   0        0        0      690 2020-03-07 23:35:32.000000 welib-0.0.2/welib/tools/latex.py
--rw-rw-rw-   0        0        0     5192 2020-10-22 00:47:41.000000 welib-0.0.2/welib/tools/lic.py
--rw-rw-rw-   0        0        0     1008 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/pandalib.py
--rw-rw-rw-   0        0        0     2077 2019-03-14 01:45:29.000000 welib-0.0.2/welib/tools/pycmd.py
--rw-rw-rw-   0        0        0     2813 2021-07-21 16:10:07.000000 welib-0.0.2/welib/tools/repo.py
--rw-rw-rw-   0        0        0       63 2019-03-20 00:16:37.000000 welib-0.0.2/welib/tools/requirements.txt
--rw-rw-rw-   0        0        0    23915 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/signal_analysis.py
--rw-rw-rw-   0        0        0    38209 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/spectral.py
--rw-rw-rw-   0        0        0     9393 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/stats.py
--rw-rw-rw-   0        0        0     3533 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/strings.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.318932 welib-0.0.2/welib/tools/tests/
--rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-0.0.2/welib/tools/tests/__init__.py
--rw-rw-rw-   0        0        0      132 2020-10-22 00:48:28.000000 welib-0.0.2/welib/tools/tests/test_colors.py
--rw-rw-rw-   0        0        0    17602 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/tests/test_curve_fitting.py
--rw-rw-rw-   0        0        0      132 2020-10-22 00:51:44.000000 welib-0.0.2/welib/tools/tests/test_curves.py
--rw-rw-rw-   0        0        0      134 2020-10-22 00:52:24.000000 welib-0.0.2/welib/tools/tests/test_fatigue.py
--rw-rw-rw-   0        0        0     3189 2020-10-22 01:28:16.000000 welib-0.0.2/welib/tools/tests/test_functions.py
--rw-rw-rw-   0        0        0    10672 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/tests/test_signal.py
--rw-rw-rw-   0        0        0      135 2020-10-22 00:53:25.000000 welib-0.0.2/welib/tools/tests/test_spectral.py
--rw-rw-rw-   0        0        0     1581 2020-10-22 00:50:14.000000 welib-0.0.2/welib/tools/tests/test_vectoranalyses.py
--rw-rw-rw-   0        0        0     2167 2022-07-05 18:17:30.000000 welib-0.0.2/welib/tools/tictoc.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.321941 welib-0.0.2/welib/vortilib/
--rw-rw-rw-   0        0        0       59 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/.gitignore
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.354017 welib-0.0.2/welib/vortilib/elements/
--rw-rw-rw-   0        0        0     1822 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/InviscidVortexPatch.py
--rw-rw-rw-   0        0        0     1013 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/LambOseen.py
--rw-rw-rw-   0        0        0     9016 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/SourceEllipsoid.py
--rw-rw-rw-   0        0        0     7599 2022-07-05 02:08:00.000000 welib-0.0.2/welib/vortilib/elements/VortexAxisymmetric.py
--rw-rw-rw-   0        0        0    22995 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/VortexCylinder.py
--rw-rw-rw-   0        0        0    31573 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexCylinderSkewed.py
--rw-rw-rw-   0        0        0    23237 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexDoublet.py
--rw-rw-rw-   0        0        0    14563 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexHelix.py
--rw-rw-rw-   0        0        0     5193 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexLine.py
--rw-rw-rw-   0        0        0     2840 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexParticle.py
--rw-rw-rw-   0        0        0     3243 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexPatch2DGaussian.py
--rw-rw-rw-   0        0        0     4398 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexPoint.py
--rw-rw-rw-   0        0        0    12904 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/VortexRing.py
--rw-rw-rw-   0        0        0     5278 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexSegment.py
--rw-rw-rw-   0        0        0       23 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/VortexSurfaceFlowField.py
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/__init__.py
--rw-rw-rw-   0        0        0     8311 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/elliptic.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.371018 welib-0.0.2/welib/vortilib/elements/examples/
--rw-rw-rw-   0        0        0     1853 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/EllipticalCoordinates.py
--rw-rw-rw-   0        0        0    12484 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/examples/InducedVelocities.py
--rw-rw-rw-   0        0        0     4637 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/InviscidVortexPatch.py
--rw-rw-rw-   0        0        0     7513 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/LambOseenFenics.py
--rw-rw-rw-   0        0        0      803 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/SourceEllipsoid_Deriv.py
--rw-rw-rw-   0        0        0     1832 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/SourceEllipsoid_Plots.py
--rw-rw-rw-   0        0        0     2699 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexHelix.py
--rw-rw-rw-   0        0        0     1663 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexParticle_Regularization.py
--rw-rw-rw-   0        0        0     4501 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexPoint2DDistribution.py
--rw-rw-rw-   0        0        0     4576 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexSegment_CrossField.py
--rw-rw-rw-   0        0        0     2121 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexSegment_Regularization.py
--rw-rw-rw-   0        0        0     6153 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/elements/examples/VortexSurfaceFlowField.py
--rw-rw-rw-   0        0        0      294 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fOmega_VortexBrick2D.py
--rw-rw-rw-   0        0        0      371 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fOmega_VortexBrick3D.py
--rw-rw-rw-   0        0        0     5110 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fUi_VortexSegment11_smooth.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.393452 welib-0.0.2/welib/vortilib/elements/fortran/
--rw-rw-rw-   0        0        0     4454 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/EllipticIntegrals.f90
--rw-rw-rw-   0        0        0     1719 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/MathConstants.f90
--rw-rw-rw-   0        0        0    13969 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/Part.f90
--rw-rw-rw-   0        0        0     6429 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/PrecisionMod.f90
--rw-rw-rw-   0        0        0    18057 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/Sgmt.f90
--rw-rw-rw-   0        0        0     5648 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/SurfaceMap.f90
--rw-rw-rw-   0        0        0    12206 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIBlobs.f90
--rw-rw-rw-   0        0        0     4312 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIHillsVortex.f90
--rw-rw-rw-   0        0        0    35015 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIPanels.f90
--rw-rw-rw-   0        0        0     8457 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIPointSource.f90
--rw-rw-rw-   0        0        0    29156 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UISegments.f90
--rw-rw-rw-   0        0        0     7883 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIVortexCylinders.f90
--rw-rw-rw-   0        0        0     5422 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIVortexPoint2D.f90
--rw-rw-rw-   0        0        0     2256 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIVortexPoint2DPerdiodic.f90
--rw-rw-rw-   0        0        0    12487 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/fortran/UIVortexRings.f90
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.397452 welib-0.0.2/welib/vortilib/elements/tests/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/tests/__init__.py
--rw-rw-rw-   0        0        0      600 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/elements/tests/test_elements.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.404451 welib-0.0.2/welib/vortilib/particles/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.405455 welib-0.0.2/welib/vortilib/particles/examples/
--rw-rw-rw-   0        0        0     4827 2022-07-05 18:17:30.000000 welib-0.0.2/welib/vortilib/particles/examples/MainVC2D_TestProj.py
--rw-rw-rw-   0        0        0     6507 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/initialization.py
--rw-rw-rw-   0        0        0     2356 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/particles.py
--rw-rw-rw-   0        0        0    24121 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/projection.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.408451 welib-0.0.2/welib/vortilib/particles/tests/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/tests/__init__.py
--rw-rw-rw-   0        0        0      180 2021-07-21 16:10:07.000000 welib-0.0.2/welib/vortilib/particles/tests/test_particles.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.506952 welib-0.0.2/welib/weio/
--rw-rw-rw-   0        0        0      142 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/.gitignore
--rw-rw-rw-   0        0        0     4245 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/_NEWFILE_TEMPLATE.py
--rw-rw-rw-   0        0        0    10609 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/__init__.py
--rw-rw-rw-   0        0        0    15004 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/bladed_out_file.py
--rw-rw-rw-   0        0        0     5492 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/bmodes_out_file.py
--rw-rw-rw-   0        0        0     3163 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/cactus_element_file.py
--rw-rw-rw-   0        0        0    18742 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/cactus_file.py
--rw-rw-rw-   0        0        0    12179 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/csv_file.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.509952 welib-0.0.2/welib/weio/examples/
--rw-rw-rw-   0        0        0      954 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/examples/ModifyAeroDynBladeFile.py
--rw-rw-rw-   0        0        0     3300 2021-01-14 03:26:47.000000 welib-0.0.2/welib/weio/excel_file.py
--rw-rw-rw-   0        0        0    18378 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_input_deck.py
--rw-rw-rw-   0        0        0    59538 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_input_file.py
--rw-rw-rw-   0        0        0    13781 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_input_file_graph.py
--rw-rw-rw-   0        0        0    14216 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_linearization_file.py
--rw-rw-rw-   0        0        0    20450 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_output_file.py
--rw-rw-rw-   0        0        0    10224 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_summary_file.py
--rw-rw-rw-   0        0        0     3028 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/fast_wind_file.py
--rw-rw-rw-   0        0        0     6587 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/file.py
--rw-rw-rw-   0        0        0      903 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/file_formats.py
--rw-rw-rw-   0        0        0     6682 2020-10-19 19:32:24.000000 welib-0.0.2/welib/weio/flex_blade_file.py
--rw-rw-rw-   0        0        0     8015 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/flex_doc_file.py
--rw-rw-rw-   0        0        0     8771 2020-08-15 20:03:30.000000 welib-0.0.2/welib/weio/flex_out_file.py
--rw-rw-rw-   0        0        0     5995 2020-08-15 20:03:33.000000 welib-0.0.2/welib/weio/flex_profile_file.py
--rw-rw-rw-   0        0        0     3943 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/flex_wavekin_file.py
--rw-rw-rw-   0        0        0     2173 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/hawc2_ae_file.py
--rw-rw-rw-   0        0        0     7574 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/hawc2_dat_file.py
--rw-rw-rw-   0        0        0     4254 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/hawc2_htc_file.py
--rw-rw-rw-   0        0        0     2328 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/hawc2_pc_file.py
--rw-rw-rw-   0        0        0     2421 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/hawc2_st_file.py
--rw-rw-rw-   0        0        0     1004 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/hawcstab2_cmb_file.py
--rw-rw-rw-   0        0        0     2588 2020-08-15 20:03:44.000000 welib-0.0.2/welib/weio/hawcstab2_ind_file.py
--rw-rw-rw-   0        0        0     2075 2020-08-15 20:03:47.000000 welib-0.0.2/welib/weio/hawcstab2_pwr_file.py
--rw-rw-rw-   0        0        0    11093 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/mannbox_file.py
--rw-rw-rw-   0        0        0     2947 2020-10-26 01:12:25.000000 welib-0.0.2/welib/weio/mini_yaml.py
--rw-rw-rw-   0        0        0     1312 2020-08-15 20:03:56.000000 welib-0.0.2/welib/weio/netcdf_file.py
--rw-rw-rw-   0        0        0     1068 2022-07-05 02:08:00.000000 welib-0.0.2/welib/weio/parquet_file.py
--rw-rw-rw-   0        0        0     8016 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/raawmat_file.py
--rw-rw-rw-   0        0        0     8718 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/rosco_performance_file.py
--rw-rw-rw-   0        0        0     2146 2020-08-15 20:03:59.000000 welib-0.0.2/welib/weio/tdms_file.py
--rw-rw-rw-   0        0        0     7632 2020-10-30 02:42:03.000000 welib-0.0.2/welib/weio/tecplot_file.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.515952 welib-0.0.2/welib/weio/tools/
--rw-rw-rw-   0        0        0        0 2020-10-26 00:18:14.000000 welib-0.0.2/welib/weio/tools/__init__.py
--rw-rw-rw-   0        0        0    26745 2022-02-04 00:16:37.000000 welib-0.0.2/welib/weio/tools/graph.py
--rw-rw-rw-   0        0        0    28855 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/turbsim_file.py
--rw-rw-rw-   0        0        0     3932 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/turbsim_ts_file.py
--rw-rw-rw-   0        0        0      311 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/user.py
--rw-rw-rw-   0        0        0    46628 2020-10-30 02:59:52.000000 welib-0.0.2/welib/weio/vtk_file.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.517953 welib-0.0.2/welib/weio/wetb/
--rw-rw-rw-   0        0        0        0 2018-10-29 21:38:59.000000 welib-0.0.2/welib/weio/wetb/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.539953 welib-0.0.2/welib/weio/wetb/hawc2/
--rw-rw-rw-   0        0        0    14725 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/wetb/hawc2/Hawc2io.py
--rw-rw-rw-   0        0        0      553 2018-10-29 21:38:59.000000 welib-0.0.2/welib/weio/wetb/hawc2/__init__.py
--rw-rw-rw-   0        0        0     5247 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/wetb/hawc2/ae_file.py
--rw-rw-rw-   0        0        0    17929 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/wetb/hawc2/htc_contents.py
--rw-rw-rw-   0        0        0     6281 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/wetb/hawc2/htc_extensions.py
--rw-rw-rw-   0        0        0    24682 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/wetb/hawc2/htc_file.py
--rw-rw-rw-   0        0        0     2477 2022-07-05 18:17:30.000000 welib-0.0.2/welib/weio/wetb/hawc2/htc_file_set.py
--rw-rw-rw-   0        0        0     5826 2021-07-21 16:10:07.000000 welib-0.0.2/welib/weio/wetb/hawc2/pc_file.py
--rw-rw-rw-   0        0        0    12147 2022-07-05 02:08:00.000000 welib-0.0.2/welib/weio/wetb/hawc2/st_file.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.544952 welib-0.0.2/welib/wind/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/__init__.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.547952 welib-0.0.2/welib/wind/examples/
--rw-rw-rw-   0        0        0     2084 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/examples/WindGenerationAtPoint.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.568959 welib-0.0.2/welib/wind/matlab/
--rw-rw-rw-   0        0        0      295 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/fInitWind.m
--rw-rw-rw-   0        0        0      281 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/fReadMannBinary.m
--rw-rw-rw-   0        0        0      166 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/fSetWind.m
--rw-rw-rw-   0        0        0     2565 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/fStocWind.m
--rw-rw-rw-   0        0        0      433 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/fUi_Wind.m
--rw-rw-rw-   0        0        0     1031 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy01.m
--rw-rw-rw-   0        0        0     1012 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy02.m
--rw-rw-rw-   0        0        0     1625 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy03.m
--rw-rw-rw-   0        0        0      299 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/wind_Load.m
--rw-rw-rw-   0        0        0       47 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/matlab/wind_SetDefault.m
--rw-rw-rw-   0        0        0      635 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/spectra.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.572963 welib-0.0.2/welib/wind/tests/
--rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/tests/__init__.py
--rw-rw-rw-   0        0        0     1138 2022-07-05 18:17:30.000000 welib-0.0.2/welib/wind/tests/test_run_Examples.py
--rw-rw-rw-   0        0        0     5261 2021-07-21 16:10:07.000000 welib-0.0.2/welib/wind/windsim.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.596964 welib-0.0.2/welib/windwave/
--rw-rw-rw-   0        0        0     6364 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/Main_Calls.m
--rw-rw-rw-   0        0        0     2154 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/Main_Elast.m
--rw-rw-rw-   0        0        0     5952 2021-07-21 16:10:07.000000 welib-0.0.2/welib/windwave/Main_WindWaves.m
--rw-rw-rw-   0        0        0     4092 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fHydroCalcFinal.m
--rw-rw-rw-   0        0        0      839 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fJonswap.m
--rw-rw-rw-   0        0        0      590 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fPlotCompare.m
--rw-rw-rw-   0        0        0      423 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fPlotSimple.m
--rw-rw-rw-   0        0        0     2055 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fSpectrum.m
--rw-rw-rw-   0        0        0      665 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fSpectrumAvg.m
--rw-rw-rw-   0        0        0      791 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fSpectrumCalc.m
--rw-rw-rw-   0        0        0     2565 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fStocWind.m
--rw-rw-rw-   0        0        0     2942 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fWaveKin.m
--rw-rw-rw-   0        0        0      524 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fWindCalc.m
--rw-rw-rw-   0        0        0      588 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fgetDispersion.m
--rw-rw-rw-   0        0        0     1180 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/fqPrime.m
--rw-rw-rw-   0        0        0      210 2018-10-17 22:56:26.000000 welib-0.0.2/welib/windwave/include_globals.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.599959 welib-0.0.2/welib/ws_estimator/
--rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-0.0.2/welib/ws_estimator/__init__.py
--rw-rw-rw-   0        0        0    12180 2022-07-05 18:17:30.000000 welib-0.0.2/welib/ws_estimator/tabulated.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.603959 welib-0.0.2/welib/wt_theory/
--rw-rw-rw-   0        0        0     1043 2011-02-22 19:24:39.000000 welib-0.0.2/welib/wt_theory/AxialInduction-CT.m
--rw-rw-rw-   0        0        0       91 2019-11-10 03:20:07.000000 welib-0.0.2/welib/wt_theory/AxialInduction.py
--rw-rw-rw-   0        0        0     2190 2016-11-29 21:23:27.000000 welib-0.0.2/welib/wt_theory/AxialInductionCT.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.606959 welib-0.0.2/welib/wt_theory/OptimalCirculation/
--rw-rw-rw-   0        0        0       34 2013-04-09 18:22:16.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/.gitignore
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.357365 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.619959 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/
--rw-rw-rw-   0        0        0     1087 2010-12-08 14:06:51.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Dates.m
--rw-rw-rw-   0        0        0     3428 2010-12-09 08:56:46.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m
--rw-rw-rw-   0        0        0      468 2010-12-08 14:05:33.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Lists.m
--rw-rw-rw-   0        0        0      126 2010-12-08 14:28:01.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Maths.m
--rw-rw-rw-   0        0        0     2101 2010-11-30 10:56:33.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Plots.m
--rw-rw-rw-   0        0        0      525 2010-11-25 07:15:04.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SQL.m
--rw-rw-rw-   0        0        0     1927 2010-12-13 15:23:57.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m
--rw-rw-rw-   0        0        0     1156 2010-12-13 16:56:42.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Stats.m
--rw-rw-rw-   0        0        0      419 2012-08-25 10:47:22.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/VERSIONS
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.624959 welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/
--rw-rw-rw-   0        0        0     6622 2012-06-29 08:51:04.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/MainGoldsteinPlots.m
--rw-rw-rw-   0        0        0     6080 2015-05-04 15:06:48.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m
--rw-rw-rw-   0        0        0     2594 2012-02-03 16:32:17.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/PrandtlTheory.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.627959 welib-0.0.2/welib/wt_theory/OptimalCirculation/__tests__/
--rw-rw-rw-   0        0        0     1496 2012-06-26 15:32:57.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/__tests__/testCompareGoldstein.m
--rw-rw-rw-   0        0        0     1146 2012-06-26 15:26:40.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/__tests__/testGoldstein.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.630959 welib-0.0.2/welib/wt_theory/OptimalCirculation/v-1/
--rw-rw-rw-   0        0        0      201 2011-07-19 13:08:49.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v-1/fBetzCirculation.m
--rw-rw-rw-   0        0        0     4064 2011-07-29 00:39:09.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.648712 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/
--rw-rw-rw-   0        0        0      427 2012-04-27 09:18:46.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fCirculationBetz.m
--rw-rw-rw-   0        0        0      227 2012-04-27 09:21:15.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fCirculationGoldstein.m
--rw-rw-rw-   0        0        0      307 2012-04-27 09:20:25.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fCirculationPrandtl.m
--rw-rw-rw-   0        0        0   259603 2014-07-03 11:37:10.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor.mexa64
--rw-rw-rw-   0        0        0     3977 2012-06-26 14:39:00.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m
--rw-rw-rw-   0        0        0     5184 2012-06-26 14:38:46.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m
--rw-rw-rw-   0        0        0     1594 2013-12-10 12:39:39.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFarWakeParams.m
--rw-rw-rw-   0        0        0     4536 2012-03-23 10:43:31.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinOkulovF.m
--rw-rw-rw-   0        0        0     2450 2012-06-05 11:49:26.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fTiberyWrench.m
--rw-rw-rw-   0        0        0      254 2012-04-27 09:21:27.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fTipLossGoldsteinOkulov.m
--rw-rw-rw-   0        0        0      157 2012-04-27 08:39:44.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fTipLossPrandtl.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.664713 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/
--rw-rw-rw-   0        0        0      427 2012-04-27 09:18:46.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationBetz.m
--rw-rw-rw-   0        0        0      227 2012-04-27 09:21:15.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationGoldstein.m
--rw-rw-rw-   0        0        0      307 2012-04-27 09:20:25.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationPrandtl.m
--rw-rw-rw-   0        0        0     3977 2012-06-26 14:39:00.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor.m
--rw-rw-rw-   0        0        0     5184 2012-06-26 14:38:46.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m
--rw-rw-rw-   0        0        0     1418 2012-06-26 15:43:23.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m
--rw-rw-rw-   0        0        0     4536 2012-03-23 10:43:31.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m
--rw-rw-rw-   0        0        0     2450 2012-06-05 11:49:26.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fTiberyWrench.m
--rw-rw-rw-   0        0        0      254 2012-04-27 09:21:27.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fTipLossGoldsteinOkulov.m
--rw-rw-rw-   0        0        0      157 2012-04-27 08:39:44.000000 welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fTipLossPrandtl.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.670710 welib-0.0.2/welib/wt_theory/OptimalTurbine/
--rw-rw-rw-   0        0        0       19 2013-04-09 18:19:55.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/.gitignore
--rw-rw-rw-   0        0        0     5014 2016-11-20 21:30:45.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m
--rw-rw-rw-   0        0        0     3893 2016-11-20 22:29:29.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m
--rw-rw-rw-   0        0        0     2896 2011-08-01 23:58:12.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/OptiminumParam.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.682711 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/
--rw-rw-rw-   0        0        0     2199 2010-10-27 23:34:42.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Exercise4bnew.m
--rw-rw-rw-   0        0        0      757 2010-10-27 15:18:42.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test1OptiminumParam.m
--rw-rw-rw-   0        0        0     1902 2012-04-24 08:50:46.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m
--rw-rw-rw-   0        0        0     3369 2010-11-24 22:28:50.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test3OptimumLambda.m
--rw-rw-rw-   0        0        0     3671 2010-11-24 23:03:08.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test3OptimumLambdaClCd.m
--rw-rw-rw-   0        0        0     1080 2010-10-28 00:14:32.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test5PowerCurve.m
--rw-rw-rw-   0        0        0     8117 2010-10-25 06:24:04.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/old/fBEM_backup.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.701774 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/
--rw-rw-rw-   0        0        0     4069 2010-10-24 23:28:56.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/BEMfunction.m
--rw-rw-rw-   0        0        0     1345 2009-10-08 14:01:49.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/Exercise1.m
--rw-rw-rw-   0        0        0     1361 2009-10-08 15:03:02.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/Exercise2new.m
--rw-rw-rw-   0        0        0     3217 2010-10-23 15:41:14.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/Exercise3new.m
--rw-rw-rw-   0        0        0     1634 2010-10-24 18:35:19.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/GlauertSolutions.m
--rw-rw-rw-   0        0        0     1970 2010-10-24 13:33:38.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/fakeBEM.m
--rw-rw-rw-   0        0        0      602 2009-10-08 09:18:59.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/getOptimizedParameters.m
--rw-rw-rw-   0        0        0       79 2009-10-04 08:57:16.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/getRelationAX.m
--rw-rw-rw-   0        0        0      140 2010-10-24 14:37:32.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/getThrustFromBlade.m
--rw-rw-rw-   0        0        0      325 2010-10-24 14:35:10.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/getTorqueFromBlade.m
--rw-rw-rw-   0        0        0      813 2010-10-24 14:25:38.000000 welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/loading.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.716774 welib-0.0.2/welib/wt_theory/Theodorsen/
--rw-rw-rw-   0        0        0       19 2013-04-09 18:18:34.000000 welib-0.0.2/welib/wt_theory/Theodorsen/.gitignore
--rw-rw-rw-   0        0        0     9690 2015-03-31 11:20:04.000000 welib-0.0.2/welib/wt_theory/Theodorsen/TheodorsenTheory.m
--rw-rw-rw-   0        0        0     6379 2012-08-25 11:08:36.000000 welib-0.0.2/welib/wt_theory/Theodorsen/TheodorsenTheory_Expansion_DevPhase0.m
--rw-rw-rw-   0        0        0     6303 2012-08-25 11:11:49.000000 welib-0.0.2/welib/wt_theory/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m
--rw-rw-rw-   0        0        0      197 2012-08-25 10:41:38.000000 welib-0.0.2/welib/wt_theory/Theodorsen/VERSIONS
--rw-rw-rw-   0        0        0      681 2012-06-22 11:42:06.000000 welib-0.0.2/welib/wt_theory/Theodorsen/WaldWakeRotorMapping.m
--rw-rw-rw-   0        0        0     1336 2012-08-25 10:31:13.000000 welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenAtOperatingPoint.m
--rw-rw-rw-   0        0        0     2281 2012-08-21 08:45:05.000000 welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenExpansion.m
--rw-rw-rw-   0        0        0     1879 2012-08-25 10:32:35.000000 welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenExpansionWrap.m
--rw-rw-rw-   0        0        0     3536 2012-08-25 11:41:18.000000 welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenFarWakeParams.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.719774 welib-0.0.2/welib/wt_theory/VortexCylinder/
--rw-rw-rw-   0        0        0       34 2013-04-09 18:24:54.000000 welib-0.0.2/welib/wt_theory/VortexCylinder/.gitignore
--rw-rw-rw-   0        0        0     3333 2013-04-09 18:24:34.000000 welib-0.0.2/welib/wt_theory/VortexCylinder/VortexCylinder.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.728776 welib-0.0.2/welib/wt_theory/WakeExpansion/
--rw-rw-rw-   0        0        0       19 2013-04-09 18:19:17.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/.gitignore
--rw-rw-rw-   0        0        0     5254 2015-03-31 11:32:56.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_CodesAndTheory.m
--rw-rw-rw-   0        0        0     1920 2012-08-25 11:39:27.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_ForEwan.m
--rw-rw-rw-   0        0        0     1457 2012-08-25 11:33:41.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_TheoryOnly.m
--rw-rw-rw-   0        0        0      576 2012-05-22 09:43:20.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionFranksen.m
--rw-rw-rw-   0        0        0      541 2012-05-22 15:03:12.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionRathmann.m
--rw-rw-rw-   0        0        0     1166 2012-08-25 10:39:54.000000 welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionVortexRings.m
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.769775 welib-0.0.2/welib/yams/
--rw-rw-rw-   0        0        0       33 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/.gitignore
--rw-rw-rw-   0        0        0     7294 2019-07-20 04:43:49.000000 welib-0.0.2/welib/yams/DEBUG.py
--rw-rw-rw-   0        0        0    14354 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/FNSB_FAST.py
--rw-rw-rw-   0        0        0      792 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/README.md
--rw-rw-rw-   0        0        0    19961 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/TNSB.py
--rw-rw-rw-   0        0        0    12923 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/TNSB_FAST.py
--rw-rw-rw-   0        0        0       47 2020-12-20 02:57:34.000000 welib-0.0.2/welib/yams/__init__.py
--rw-rw-rw-   0        0        0    31210 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/bodies.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.771773 welib-0.0.2/welib/yams/examples/
--rw-rw-rw-   0        0        0     1581 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples/Tower_MassMatrix_ShapeFunctions.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.772778 welib-0.0.2/welib/yams/examples_numeric_recursive/
--rw-rw-rw-   0        0        0     4593 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_numeric_recursive/Tower_SubBeams.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.783774 welib-0.0.2/welib/yams/examples_symbolic_kane/
--rw-rw-rw-   0        0        0       13 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/.gitignore
--rw-rw-rw-   0        0        0     1213 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/L1_Top.py
--rw-rw-rw-   0        0        0     7421 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/L3_BladeModels.py
--rw-rw-rw-   0        0        0    10685 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/L3_FXTXRNA_Simulation.py
--rw-rw-rw-   0        0        0     7883 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.py
--rw-rw-rw-   0        0        0     6861 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/L3_OneRigidBody_SparHydro.py
--rw-rw-rw-   0        0        0     1665 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_kane/README.md
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.785774 welib-0.0.2/welib/yams/examples_symbolic_recursive/
--rw-rw-rw-   0        0        0     9738 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/examples_symbolic_recursive/T1NRNA_yams_rec.py
--rw-rw-rw-   0        0        0    52937 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/flexibility.py
--rw-rw-rw-   0        0        0     1433 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/kinematics.py
--rw-rw-rw-   0        0        0      607 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/kinetics.py
--rw-rw-rw-   0        0        0      792 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/kinetics_sympy.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.799774 welib-0.0.2/welib/yams/models/
--rw-rw-rw-   0        0        0    30407 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/FTNSB_sympy.py
--rw-rw-rw-   0        0        0     3672 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/FTNSB_sympy_symbols.py
--rw-rw-rw-   0        0        0     8126 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/OneRigidBody_sympy.py
--rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-0.0.2/welib/yams/models/__init__.py
--rw-rw-rw-   0        0        0     3809 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/generator.py
--rw-rw-rw-   0        0        0     7055 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/generator_oneRigidBody.py
--rw-rw-rw-   0        0        0     8416 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/packman.py
--rw-rw-rw-   0        0        0    16338 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/simulator.py
--rw-rw-rw-   0        0        0     2694 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/models/utils.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.365364 welib-0.0.2/welib/yams/papers/
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.803774 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/
--rw-rw-rw-   0        0        0        7 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/.gitignore
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.807774 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/
--rw-rw-rw-   0        0        0     6971 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.fst
--rw-rw-rw-   0        0        0     2932 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.outb
--rw-rw-rw-   0        0        0    11519 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Spar_ED_ForED.dat
--rw-rw-rw-   0        0        0     4746 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1_yams_model.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.811774 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/
--rw-rw-rw-   0        0        0     6957 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.fst
--rw-rw-rw-   0        0        0     4748 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.outb
--rw-rw-rw-   0        0        0    11568 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Spar_ED_ForED.dat
--rw-rw-rw-   0        0        0     4869 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_yams_model.py
--rw-rw-rw-   0        0        0    16591 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/rotations.py
--rw-rw-rw-   0        0        0    30878 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/sid.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.824044 welib-0.0.2/welib/yams/tests/
--rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-0.0.2/welib/yams/tests/__init__.py
--rw-rw-rw-   0        0        0     3517 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests/test_bodies.py
--rw-rw-rw-   0        0        0    24439 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests/test_flexibility.py
--rw-rw-rw-   0        0        0     5298 2020-12-30 22:56:18.000000 welib-0.0.2/welib/yams/tests/test_rotations.py
--rw-rw-rw-   0        0        0     3732 2021-07-21 16:10:07.000000 welib-0.0.2/welib/yams/tests/test_sectionloads.py
--rw-rw-rw-   0        0        0     8410 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests/test_sid.py
--rw-rw-rw-   0        0        0     1701 2020-12-20 03:46:48.000000 welib-0.0.2/welib/yams/tests/test_utils.py
--rw-rw-rw-   0        0        0    11828 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests/test_windturbine.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.830044 welib-0.0.2/welib/yams/tests_numeric_recursive/
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_numeric_recursive/__init__.py
--rw-rw-rw-   0        0        0    12742 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_numeric_recursive/test_TNSB_FAST.py
--rw-rw-rw-   0        0        0     7540 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_numeric_recursive/test_TNSB_article.py
--rw-rw-rw-   0        0        0     2363 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_numeric_recursive/test_yams.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:04.841044 welib-0.0.2/welib/yams/tests_symbolic_kane/
--rw-rw-rw-   0        0        0    13976 2022-04-13 16:07:18.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/_F2T1RNA.py
--rw-rw-rw-   0        0        0        0 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/__init__.py
--rw-rw-rw-   0        0        0     1186 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T0N2S1.py
--rw-rw-rw-   0        0        0     3008 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T1RNA.py
--rw-rw-rw-   0        0        0     1160 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/test_run_Examples.py
--rw-rw-rw-   0        0        0     7174 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/test_yams_sympy_rigid.py
--rw-rw-rw-   0        0        0     5144 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/tests_symbolic_kane/test_yams_sympy_tools.py
--rw-rw-rw-   0        0        0     8027 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/utils.py
--rw-rw-rw-   0        0        0    28386 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/windturbine.py
--rw-rw-rw-   0        0        0    32657 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/yams.py
--rw-rw-rw-   0        0        0    57188 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/yams_kane.py
--rw-rw-rw-   0        0        0    65468 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/yams_sympy.py
--rw-rw-rw-   0        0        0    47046 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/yams_sympy_model.py
--rw-rw-rw-   0        0        0    22507 2022-07-05 18:17:30.000000 welib-0.0.2/welib/yams/yams_sympy_tools.py
-drwxrwxrwx   0        0        0        0 2022-07-05 18:24:03.502122 welib-0.0.2/welib.egg-info/
--rw-rw-rw-   0        0        0     1348 2022-07-05 18:24:02.000000 welib-0.0.2/welib.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    35169 2022-07-05 18:24:03.000000 welib-0.0.2/welib.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2022-07-05 18:24:02.000000 welib-0.0.2/welib.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        2 2022-07-05 18:24:02.000000 welib-0.0.2/welib.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0      135 2022-07-05 18:24:02.000000 welib-0.0.2/welib.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2022-07-05 18:24:02.000000 welib-0.0.2/welib.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.905329 welib-1.0.0/
+-rw-rw-rw-   0        0        0       40 2023-06-15 23:48:51.000000 welib-1.0.0/.gitattributes
+-rw-rw-rw-   0        0        0      209 2023-06-15 23:48:51.000000 welib-1.0.0/.gitconfig
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.346242 welib-1.0.0/.github/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.393115 welib-1.0.0/.github/workflows/
+-rw-rw-rw-   0        0        0     1310 2023-06-15 23:48:51.000000 welib-1.0.0/.github/workflows/tests.yml
+-rw-rw-rw-   0        0        0      223 2023-06-16 00:12:32.000000 welib-1.0.0/.gitignore
+-rw-rw-rw-   0        0        0      273 2021-07-21 16:10:07.000000 welib-1.0.0/.travis.yml
+-rw-rw-rw-   0        0        0     1058 2019-04-01 15:48:57.000000 welib-1.0.0/LICENSE.TXT
+-rw-rw-rw-   0        0        0      526 2022-12-06 21:47:38.000000 welib-1.0.0/Makefile
+-rw-rw-rw-   0        0        0     1348 2023-06-16 18:17:28.905329 welib-1.0.0/PKG-INFO
+-rw-rw-rw-   0        0        0    28580 2023-06-16 00:08:11.000000 welib-1.0.0/README.md
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.346242 welib-1.0.0/data/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.408736 welib-1.0.0/data/Hawc2/
+-rw-rw-rw-   0        0        0     4104 2020-07-20 16:25:13.000000 welib-1.0.0/data/Hawc2/BD.dat
+-rw-rw-rw-   0        0        0     1103 2019-08-28 18:14:30.000000 welib-1.0.0/data/Hawc2/Blade_Planform_Hawc2.csv
+-rw-rw-rw-   0        0        0     5023 2019-12-16 19:17:01.000000 welib-1.0.0/data/Hawc2/Blade_Structural_Hawc2.csv
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.424364 welib-1.0.0/data/Monopile/
+-rw-rw-rw-   0        0        0       85 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/.gitignore
+-rw-rw-rw-   0        0        0     6097 2021-05-15 16:50:36.000000 welib-1.0.0/data/Monopile/ED_Blade_Light.dat
+-rw-rw-rw-   0        0        0     3762 2021-05-15 16:50:36.000000 welib-1.0.0/data/Monopile/ED_Tower100_Light.dat
+-rw-rw-rw-   0        0        0    15159 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/MT100_ED.dat
+-rw-rw-rw-   0        0        0    19568 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/MT100_HD_RegularWave.dat
+-rw-rw-rw-   0        0        0    19568 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/MT100_HD_Still.dat
+-rw-rw-rw-   0        0        0   611624 2021-05-15 16:50:36.000000 welib-1.0.0/data/Monopile/MT100_LoadsMotions.csv
+-rw-rw-rw-   0        0        0     8440 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/MT100_SD.dat
+-rw-rw-rw-   0        0        0     6318 2021-07-21 16:10:07.000000 welib-1.0.0/data/Monopile/Main_MT100_RegularWave.fst
+-rw-rw-rw-   0        0        0      983 2021-05-15 16:50:36.000000 welib-1.0.0/data/Monopile/README.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.439986 welib-1.0.0/data/NREL5MW/
+-rw-rw-rw-   0        0        0       16 2023-06-15 23:48:51.000000 welib-1.0.0/data/NREL5MW/.gitignore
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.462124 welib-1.0.0/data/NREL5MW/5MW_Baseline/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.477742 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/
+-rw-rw-rw-   0        0        0     7026 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat
+-rw-rw-rw-   0        0        0     8396 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1_coords.txt
+-rw-rw-rw-   0        0        0     7095 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2.dat
+-rw-rw-rw-   0        0        0     8400 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2_coords.txt
+-rw-rw-rw-   0        0        0    12679 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17.dat
+-rw-rw-rw-   0        0        0     7865 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17_coords.txt
+-rw-rw-rw-   0        0        0    12601 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17.dat
+-rw-rw-rw-   0        0        0     8060 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17_coords.txt
+-rw-rw-rw-   0        0        0    12720 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17.dat
+-rw-rw-rw-   0        0        0     8066 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17_coords.txt
+-rw-rw-rw-   0        0        0    12406 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17.dat
+-rw-rw-rw-   0        0        0     8066 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17_coords.txt
+-rw-rw-rw-   0        0        0    12445 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17.dat
+-rw-rw-rw-   0        0        0     8066 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17_coords.txt
+-rw-rw-rw-   0        0        0    12098 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17.dat
+-rw-rw-rw-   0        0        0     8272 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17_coords.txt
+-rw-rw-rw-   0        0        0     7430 2023-06-15 23:48:51.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_IW.dat
+-rw-rw-rw-   0        0        0     7288 2023-06-15 23:48:51.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_IW_Step.dat
+-rw-rw-rw-   0        0        0    12219 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_SvD.dat
+-rw-rw-rw-   0        0        0    12143 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_SvD_Simple.dat
+-rw-rw-rw-   0        0        0     2654 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_AeroDyn_blade.dat
+-rw-rw-rw-   0        0        0     6958 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn.dat
+-rw-rw-rw-   0        0        0    58500 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn_Blade.dat
+-rw-rw-rw-   0        0        0     6727 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Blade.dat
+-rw-rw-rw-   0        0        0    27002 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_OC4Jacket_SubDyn.dat
+-rw-rw-rw-   0        0        0     3552 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Offshore_ElastoDyn_Tower.dat
+-rw-rw-rw-   0        0        0     3523 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Onshore_ElastoDyn_Tower.dat
+-rw-rw-rw-   0        0        0      279 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/5MW_Baseline/README.rst
+-rw-rw-rw-   0        0        0     7497 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/Main_Onshore.fst
+-rw-rw-rw-   0        0        0     7497 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/Main_Onshore_DriveTrainTorsion.fst
+-rw-rw-rw-   0        0        0    16535 2020-12-12 06:12:44.000000 welib-1.0.0/data/NREL5MW/NREL5MW_Blade_FEM_Modes.csv
+-rw-rw-rw-   0        0        0   160250 2023-06-15 23:48:51.000000 welib-1.0.0/data/NREL5MW/NREL5MW_CPCTCQ.txt
+-rw-rw-rw-   0        0        0     3945 2021-07-21 16:10:07.000000 welib-1.0.0/data/NREL5MW/NREL5MW_Oper.csv
+-rw-rw-rw-   0        0        0     1518 2020-12-12 02:33:18.000000 welib-1.0.0/data/NREL5MW/NREL5MW_Tower_Onshore_FEM_Modes.csv
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.477742 welib-1.0.0/data/NREL5MW/dt_torsion/
+-rw-rw-rw-   0        0        0    22531 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/dt_torsion/NREL5MW_ED_DT.dat
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.493369 welib-1.0.0/data/NREL5MW/hawc2/
+-rw-rw-rw-   0        0        0      771 2021-07-21 16:10:07.000000 welib-1.0.0/data/NREL5MW/hawc2/Blade_Planform_Hawc2.csv
+-rw-rw-rw-   0        0        0    10353 2021-07-21 16:10:07.000000 welib-1.0.0/data/NREL5MW/hawc2/Blade_Structural_Hawc2.csv
+-rw-rw-rw-   0        0        0      225 2021-07-21 16:10:07.000000 welib-1.0.0/data/NREL5MW/hawc2/README.md
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.493369 welib-1.0.0/data/NREL5MW/offshore/
+-rw-rw-rw-   0        0        0    21239 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/offshore/NREL5MW_ED_Offshore.dat
+-rw-rw-rw-   0        0        0    21385 2022-12-06 21:47:38.000000 welib-1.0.0/data/NREL5MW/offshore/NREL5MW_ED_Offshore_Legacy.dat
+-rw-rw-rw-   0        0        0    17931 2022-12-06 21:34:09.000000 welib-1.0.0/data/NREL5MW/offshore/NREL5MW_HD.dat
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.493369 welib-1.0.0/data/NREL5MW/onshore/
+-rw-rw-rw-   0        0        0    11054 2023-06-15 23:48:51.000000 welib-1.0.0/data/NREL5MW/onshore/NREL5MW_AD.dat
+-rw-rw-rw-   0        0        0    22402 2023-06-15 19:30:06.000000 welib-1.0.0/data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.524613 welib-1.0.0/data/Spar/
+-rw-rw-rw-   0        0        0     1487 2023-06-15 23:48:51.000000 welib-1.0.0/data/Spar/MAP.dat
+-rw-rw-rw-   0        0        0     7892 2022-12-06 21:47:38.000000 welib-1.0.0/data/Spar/Main_Spar_ED.fst
+-rw-rw-rw-   0        0        0     7892 2022-12-06 21:47:38.000000 welib-1.0.0/data/Spar/Main_Spar_ED_HydroExample.fst
+-rw-rw-rw-   0        0        0     8666 2022-12-13 18:54:13.000000 welib-1.0.0/data/Spar/Main_Spar_ED_HydroExample.outb
+-rw-rw-rw-   0        0        0     7362 2023-06-15 23:48:51.000000 welib-1.0.0/data/Spar/Main_Spar_ED_MAP.fst
+-rw-rw-rw-   0        0        0     7887 2022-12-06 21:47:38.000000 welib-1.0.0/data/Spar/Main_Spar_SD.fst
+-rw-rw-rw-   0        0        0    15500 2023-06-15 23:48:51.000000 welib-1.0.0/data/Spar/Spar_ED_ForED.dat
+-rw-rw-rw-   0        0        0    20029 2022-12-06 21:47:38.000000 welib-1.0.0/data/Spar/Spar_ED_ForSD.dat
+-rw-rw-rw-   0        0        0    20300 2023-06-15 23:48:51.000000 welib-1.0.0/data/Spar/Spar_HD.dat
+-rw-rw-rw-   0        0        0    20245 2023-06-15 23:48:51.000000 welib-1.0.0/data/Spar/Spar_HD_Dummy.dat
+-rw-rw-rw-   0        0        0    12616 2020-11-03 18:44:19.000000 welib-1.0.0/data/Spar/Spar_SD.dat
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.540236 welib-1.0.0/data/SubDyn/
+-rw-rw-rw-   0        0        0       16 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/.gitignore
+-rw-rw-rw-   0        0        0    23650 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/Jacket.dat
+-rw-rw-rw-   0        0        0     2703 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/Jacket.dvr
+-rw-rw-rw-   0        0        0    28981 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/JacketTwr.dat
+-rw-rw-rw-   0        0        0     2709 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/JacketTwr.dvr
+-rw-rw-rw-   0        0        0    16742 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/SD_Cable_5Joints.dat
+-rw-rw-rw-   0        0        0     2672 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/SD_Cable_5Joints.dvr
+-rw-rw-rw-   0        0        0    15749 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/Twr.dat
+-rw-rw-rw-   0        0        0     2697 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/Twr.dvr
+-rw-rw-rw-   0        0        0    10573 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/TwrSmall.dat
+-rw-rw-rw-   0        0        0     2707 2022-12-06 21:47:38.000000 welib-1.0.0/data/SubDyn/TwrSmall.dvr
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.540236 welib-1.0.0/data/Waves/
+-rw-rw-rw-   0        0        0    23069 2020-10-22 00:24:04.000000 welib-1.0.0/data/Waves/RegularWave.Elev
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.546750 welib-1.0.0/data/example_files/
+-rw-rw-rw-   0        0        0    17178 2020-08-03 21:20:16.000000 welib-1.0.0/data/example_files/FASTSum_Pendulum.SD.sum.yaml
+-rw-rw-rw-   0        0        0    16593 2020-10-13 04:40:35.000000 welib-1.0.0/data/example_files/FASTSum_PendulumNoCB.SD.sum.yaml
+-rw-rw-rw-   0        0        0   234919 2021-07-21 16:10:07.000000 welib-1.0.0/data/example_files/fastout_allnodes.outb
+-rw-rw-rw-   0        0        0      638 2023-06-15 23:48:51.000000 welib-1.0.0/developper_notes.md
+-rw-rw-rw-   0        0        0      184 2023-06-15 23:48:51.000000 welib-1.0.0/requirements.txt
+-rw-rw-rw-   0        0        0       42 2023-06-16 18:17:28.905329 welib-1.0.0/setup.cfg
+-rw-rw-rw-   0        0        0     1991 2023-06-15 23:48:51.000000 welib-1.0.0/setup.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.546750 welib-1.0.0/welib/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.562384 welib-1.0.0/welib/BEM/
+-rw-rw-rw-   0        0        0    31753 2019-06-08 18:46:14.000000 welib-1.0.0/welib/BEM/_OTHER.py
+-rw-rw-rw-   0        0        0     9800 2018-10-15 22:46:51.000000 welib-1.0.0/welib/BEM/_TODO.py
+-rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-1.0.0/welib/BEM/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.578001 welib-1.0.0/welib/BEM/examples/
+-rw-rw-rw-   0        0        0     1635 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_AxialInduction.py
+-rw-rw-rw-   0        0        0     2015 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_BEM_1.py
+-rw-rw-rw-   0        0        0     4162 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_BEM_2.py
+-rw-rw-rw-   0        0        0     2913 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_BEM_CPLambdaPitch.py
+-rw-rw-rw-   0        0        0     2183 2023-06-16 00:08:11.000000 welib-1.0.0/welib/BEM/examples/Example_IdealRotor.py
+-rw-rw-rw-   0        0        0     1009 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_UnsteadyBEM_1_ConstantRPM.py
+-rw-rw-rw-   0        0        0     3270 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/examples/Example_UnsteadyBEM_2_PrescribedMotion.py
+-rw-rw-rw-   0        0        0        0 2020-12-14 02:13:06.000000 welib-1.0.0/welib/BEM/examples/README.md
+-rw-rw-rw-   0        0        0    19436 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/highthrust.py
+-rw-rw-rw-   0        0        0     3900 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/idealrotors.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.609246 welib-1.0.0/welib/BEM/matlab/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.624872 welib-1.0.0/welib/BEM/matlab/Simulations/
+-rw-rw-rw-   0        0        0     4846 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/MainBEMCompAllTipLossAEP.m
+-rw-rw-rw-   0        0        0     7456 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_CompAllTipLoss.m
+-rw-rw-rw-   0        0        0      412 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_FindPitch.m
+-rw-rw-rw-   0        0        0      818 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_PowerCurve.m
+-rw-rw-rw-   0        0        0     1811 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_PrescribedGamma.m
+-rw-rw-rw-   0        0        0     1735 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_SetSim.m
+-rw-rw-rw-   0        0        0      686 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_SimpleRun.m
+-rw-rw-rw-   0        0        0     1844 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/Test_SimulationRef.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.640494 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/
+-rw-rw-rw-   0        0        0     3398 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcode.m
+-rw-rw-rw-   0        0        0     1231 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeB49.m
+-rw-rw-rw-   0        0        0      964 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeLeishman.m
+-rw-rw-rw-   0        0        0     1364 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu.m
+-rw-rw-rw-   0        0        0      687 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu2.m
+-rw-rw-rw-   0        0        0      895 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD.m
+-rw-rw-rw-   0        0        0     1059 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD2.m
+-rw-rw-rw-   0        0        0     1560 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD3.m
+-rw-rw-rw-   0        0        0     1916 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainFindPitch.m
+-rw-rw-rw-   0        0        0     2896 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/OptiminumParam.m
+-rw-rw-rw-   0        0        0     1902 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/Test2BEMCodeForoneLambda.m
+-rw-rw-rw-   0        0        0     1032 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/Simulations/fPlotCodeCompBEM.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.624872 welib-1.0.0/welib/BEM/matlab/SimulationsAeroelasticit/
+-rw-rw-rw-   0        0        0     2064 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/SimulationsAeroelasticit/MainPb3_2_WT3Dof_Pitch.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.624872 welib-1.0.0/welib/BEM/matlab/SimulationsUnsteadyBEM/
+-rw-rw-rw-   0        0        0     6226 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/SimulationsUnsteadyBEM/Main_PitchStep.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.647007 welib-1.0.0/welib/BEM/matlab/bkp/
+-rw-rw-rw-   0        0        0    10975 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyNew.m
+-rw-rw-rw-   0        0        0     6893 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyRiso.m
+-rw-rw-rw-   0        0        0    10934 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyTipLoss.m
+-rw-rw-rw-   0        0        0    11569 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyTipLossStandAlone1.m
+-rw-rw-rw-   0        0        0    11001 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_BACKUP.m
+-rw-rw-rw-   0        0        0    11618 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_mostRecentBackup.m
+-rw-rw-rw-   0        0        0     9663 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_try.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.662635 welib-1.0.0/welib/BEM/matlab/bkp/tmp/
+-rw-rw-rw-   0        0        0     1805 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/AeroFun.m
+-rw-rw-rw-   0        0        0     1340 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/LiftDataFun.m
+-rw-rw-rw-   0        0        0     1875 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/PowerCurve.m
+-rw-rw-rw-   0        0        0     3788 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/ReadHawc2.m
+-rw-rw-rw-   0        0        0     1246 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test2BEMcodeForOneLambda.m
+-rw-rw-rw-   0        0        0     3369 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test3OptimumLambda.m
+-rw-rw-rw-   0        0        0     3671 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test3OptimumLambdaClCd.m
+-rw-rw-rw-   0        0        0    14543 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEM.m
+-rw-rw-rw-   0        0        0      277 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMCTFind.m
+-rw-rw-rw-   0        0        0     3404 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMSimulation.m
+-rw-rw-rw-   0        0        0     1132 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMpseudo_steady.m
+-rw-rw-rw-   0        0        0    14440 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMsteady.m
+-rw-rw-rw-   0        0        0     9987 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMsteadyTipLoss.m
+-rw-rw-rw-   0        0        0    18473 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMsteadyTipLossStandAlone.m
+-rw-rw-rw-   0        0        0     2515 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fBEMunsteady.m
+-rw-rw-rw-   0        0        0     3799 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fCorrectionHighThrust.m
+-rw-rw-rw-   0        0        0     3508 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fInductionCoefficients.m
+-rw-rw-rw-   0        0        0     2221 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fInductionsBEM_Propeller.m
+-rw-rw-rw-   0        0        0      316 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fInitBEMAlgo.m
+-rw-rw-rw-   0        0        0     4341 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fRunBEM.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.662635 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/
+-rw-rw-rw-   0        0        0      789 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/Runge.m
+-rw-rw-rw-   0        0        0     2406 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/RungeCore.m
+-rw-rw-rw-   0        0        0      631 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/RungeGoOn.m
+-rw-rw-rw-   0        0        0      236 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/fStep.m
+-rw-rw-rw-   0        0        0      231 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/getDampingMatrix.m
+-rw-rw-rw-   0        0        0     2368 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/getMassMatrix.m
+-rw-rw-rw-   0        0        0      352 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/getMatrices.m
+-rw-rw-rw-   0        0        0      275 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/getStiffnessMatrix.m
+-rw-rw-rw-   0        0        0      803 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_aeroelastic/solveAcceleration.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.678259 welib-1.0.0/welib/BEM/matlab/f_optimal/
+-rw-rw-rw-   0        0        0      293 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_optimal/fFitChord.m
+-rw-rw-rw-   0        0        0      220 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/matlab/f_optimal/fFitTwist.m
+-rw-rw-rw-   0        0        0     1529 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_optimal/getOptimizedParameters.m
+-rw-rw-rw-   0        0        0      689 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/matlab/f_optimal/getOptimizedParametersClCd.m
+-rw-rw-rw-   0        0        0       79 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/f_optimal/getRelationAX.m
+-rw-rw-rw-   0        0        0     1964 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fakeBEM.m
+-rw-rw-rw-   0        0        0     1751 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/fakeBEMClCd.m
+-rw-rw-rw-   0        0        0      371 2015-11-24 09:24:59.000000 welib-1.0.0/welib/BEM/matlab/getTransfoMatrices.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.747256 welib-1.0.0/welib/BEM/matlab/tools/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.747256 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/
+-rw-rw-rw-   0        0        0     1808 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/AeroFun.m
+-rw-rw-rw-   0        0        0     1340 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/LiftDataFun.m
+-rw-rw-rw-   0        0        0     2380 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/MainFindPitch.m
+-rw-rw-rw-   0        0        0     5362 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/ReadHtcFileAll.m
+-rw-rw-rw-   0        0        0     5387 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/SuperDebug.m
+-rw-rw-rw-   0        0        0     4722 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/fFindPitch.m
+-rw-rw-rw-   0        0        0     2687 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/fPower.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.747256 welib-1.0.0/welib/BEM/matlab/tools/__tests__/
+-rw-rw-rw-   0        0        0     1509 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/__tests__/testAeroCoeff.m
+-rw-rw-rw-   0        0        0     1070 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/__tests__/testCompareIntegration.m
+-rw-rw-rw-   0        0        0      399 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/__tests__/testIntegration.m
+-rw-rw-rw-   0        0        0      608 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/__tests__/testRead.m
+-rw-rw-rw-   0        0        0     4426 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fAeroCoeff.m
+-rw-rw-rw-   0        0        0     3714 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fAeroCoeffWrap.m
+-rw-rw-rw-   0        0        0      106 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fApplySimOnWT.m
+-rw-rw-rw-   0        0        0     5023 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fExportWTPerf.m
+-rw-rw-rw-   0        0        0     1625 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fFindSimFolder.m
+-rw-rw-rw-   0        0        0     6079 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitAlgo.m
+-rw-rw-rw-   0        0        0     3001 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitFlex.m
+-rw-rw-rw-   0        0        0     2716 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitHawc.m
+-rw-rw-rw-   0        0        0     2030 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitSim.m
+-rw-rw-rw-   0        0        0     1337 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitVLAlgo_old.m
+-rw-rw-rw-   0        0        0    13773 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitWT.m
+-rw-rw-rw-   0        0        0     2976 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitWTDefault.m
+-rw-rw-rw-   0        0        0      303 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitWTPerf.m
+-rw-rw-rw-   0        0        0      738 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fInitXblade.m
+-rw-rw-rw-   0        0        0     1743 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadBlade.m
+-rw-rw-rw-   0        0        0     3960 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadCFD_AL.m
+-rw-rw-rw-   0        0        0     2801 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadCodes.m
+-rw-rw-rw-   0        0        0     7630 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadHawc2.m
+-rw-rw-rw-   0        0        0      415 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadMeas.m
+-rw-rw-rw-   0        0        0     1177 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadShen.m
+-rw-rw-rw-   0        0        0     5531 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fLoadVC.m
+-rw-rw-rw-   0        0        0     1404 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadAeFile.m
+-rw-rw-rw-   0        0        0     1370 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadBtcFile.m
+-rw-rw-rw-   0        0        0      612 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadBtcFileAll.m
+-rw-rw-rw-   0        0        0     3789 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadHawc2.m
+-rw-rw-rw-   0        0        0     3621 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadHtcFile.m
+-rw-rw-rw-   0        0        0      261 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadHtcFileAll.m
+-rw-rw-rw-   0        0        0     1768 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadPcFile.m
+-rw-rw-rw-   0        0        0     2331 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadPcFileExtended.m
+-rw-rw-rw-   0        0        0      683 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadSpec.m
+-rw-rw-rw-   0        0        0     3457 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadWTPerf.m
+-rw-rw-rw-   0        0        0     1452 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fReadXbladeParamFile.m
+-rw-rw-rw-   0        0        0     4041 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fSetRotorGrid.m
+-rw-rw-rw-   0        0        0      612 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fSetRun.m
+-rw-rw-rw-   0        0        0     1534 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fSetSim.m
+-rw-rw-rw-   0        0        0      155 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTAEP.m
+-rw-rw-rw-   0        0        0     2871 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTFindPitch.m
+-rw-rw-rw-   0        0        0     2300 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTGetRefRPM.m
+-rw-rw-rw-   0        0        0     1828 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTParametricCP.m
+-rw-rw-rw-   0        0        0     1509 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTPowerCurve.m
+-rw-rw-rw-   0        0        0     8004 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTSimRef.m
+-rw-rw-rw-   0        0        0     6157 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fWTSimulation.m
+-rw-rw-rw-   0        0        0      711 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fhawc2_create_output.m
+-rw-rw-rw-   0        0        0      810 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fhawc2_signal.m
+-rw-rw-rw-   0        0        0     3239 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/fplotCodesComparison.m
+-rw-rw-rw-   0        0        0      140 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/getThrustFromBlade.m
+-rw-rw-rw-   0        0        0      340 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/getTorqueFromBlade.m
+-rw-rw-rw-   0        0        0       68 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/istrue.m
+-rw-rw-rw-   0        0        0       83 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/totrue.m
+-rw-rw-rw-   0        0        0    11678 2015-11-24 09:24:20.000000 welib-1.0.0/welib/BEM/matlab/tools/wind_rose.m
+-rw-rw-rw-   0        0        0    37367 2023-06-16 00:08:11.000000 welib-1.0.0/welib/BEM/steadyBEM.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.762889 welib-1.0.0/welib/BEM/tests/
+-rw-rw-rw-   0        0        0        0 2019-01-20 23:17:10.000000 welib-1.0.0/welib/BEM/tests/__init__.py
+-rw-rw-rw-   0        0        0     1214 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/tests/test_BEM.py
+-rw-rw-rw-   0        0        0     8313 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/tests/test_BEM_unsteady.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0    63324 2023-06-15 23:48:51.000000 welib-1.0.0/welib/BEM/unsteadyBEM.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.762889 welib-1.0.0/welib/CFD/
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:34:09.000000 welib-1.0.0/welib/CFD/__init__.py
+-rw-rw-rw-   0        0        0    10774 2021-07-10 18:18:14.000000 welib-1.0.0/welib/CFD/_vorticity-rz - Copy.py
+-rw-rw-rw-   0        0        0    10774 2021-07-10 18:18:14.000000 welib-1.0.0/welib/CFD/_vorticity-rz.py
+-rw-rw-rw-   0        0        0    11311 2021-07-14 04:53:04.000000 welib-1.0.0/welib/CFD/_vorticity-rz_lesswalls.py
+-rw-rw-rw-   0        0        0    10901 2022-12-06 21:34:09.000000 welib-1.0.0/welib/CFD/axisym_streamf.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.778511 welib-1.0.0/welib/CFD/tests/
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:34:09.000000 welib-1.0.0/welib/CFD/tests/__init__.py
+-rw-rw-rw-   0        0        0     9090 2022-12-06 21:34:09.000000 welib-1.0.0/welib/CFD/tests/test_axisym_streamf.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.794129 welib-1.0.0/welib/FEM/
+-rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-1.0.0/welib/FEM/__init__.py
+-rw-rw-rw-   0        0        0     4102 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/beam2d.py
+-rw-rw-rw-   0        0        0     2867 2022-12-06 21:44:57.000000 welib-1.0.0/welib/FEM/cable.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.809755 welib-1.0.0/welib/FEM/derivations/
+-rw-rw-rw-   0        0        0     1800 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/derivations/GuyanReduction.py
+-rw-rw-rw-   0        0        0     5883 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/derivations/frame2D_sympy.ipynb
+-rw-rw-rw-   0        0        0     6625 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/derivations/frame3D_sympy.ipynb
+-rw-rw-rw-   0        0        0    12282 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/direct_elimination.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.809755 welib-1.0.0/welib/FEM/examples/
+-rw-rw-rw-   0        0        0     5256 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/examples/Beam_CraigBampton_Monopile.py
+-rw-rw-rw-   0        0        0     4381 2022-12-06 21:47:38.000000 welib-1.0.0/welib/FEM/examples/Beam_FlexibleProperties_Tower.py
+-rw-rw-rw-   0        0        0     6991 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/examples/Beam_ModeShapes_Tower.py
+-rw-rw-rw-   0        0        0     5718 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py
+-rw-rw-rw-   0        0        0     2512 2022-12-06 21:47:38.000000 welib-1.0.0/welib/FEM/examples/Graph_CreateSimpleGraph.py
+-rw-rw-rw-   0        0        0      678 2022-12-06 21:47:38.000000 welib-1.0.0/welib/FEM/examples/README.md
+-rw-rw-rw-   0        0        0     1673 2020-12-14 02:38:55.000000 welib-1.0.0/welib/FEM/examples/frame2d_element.py
+-rw-rw-rw-   0        0        0    38573 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/fem_beam.py
+-rw-rw-rw-   0        0        0      307 2022-12-06 21:44:57.000000 welib-1.0.0/welib/FEM/fem_core.py
+-rw-rw-rw-   0        0        0    25295 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/fem_elements.py
+-rw-rw-rw-   0        0        0    60497 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/fem_model.py
+-rw-rw-rw-   0        0        0     3976 2020-11-06 03:25:04.000000 welib-1.0.0/welib/FEM/fem_sympy.py
+-rw-rw-rw-   0        0        0     6177 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/frame2d.py
+-rw-rw-rw-   0        0        0    11744 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/frame3d.py
+-rw-rw-rw-   0        0        0    31076 2020-11-07 02:11:46.000000 welib-1.0.0/welib/FEM/frame3dlin.py
+-rw-rw-rw-   0        0        0    42431 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/graph.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.841000 welib-1.0.0/welib/FEM/matlab/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.847513 welib-1.0.0/welib/FEM/matlab/examples/
+-rw-rw-rw-   0        0        0     3486 2020-03-05 22:59:31.000000 welib-1.0.0/welib/FEM/matlab/examples/Main_CraigBampton_2D.m
+-rw-rw-rw-   0        0        0     4204 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/examples/Main_CraigBampton_3D.m
+-rw-rw-rw-   0        0        0    10227 2020-04-13 01:55:18.000000 welib-1.0.0/welib/FEM/matlab/examples/Main_TowerTopExcitation.m
+-rw-rw-rw-   0        0        0     7918 2020-04-10 21:53:37.000000 welib-1.0.0/welib/FEM/matlab/examples/RefDisp.csv
+-rw-rw-rw-   0        0        0     4172 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/examples/ThinBeam3D.m
+-rw-rw-rw-   0        0        0     4679 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/examples/ThinRotatingBeam_FEM.m
+-rw-rw-rw-   0        0        0      221 2020-04-10 22:00:52.000000 welib-1.0.0/welib/FEM/matlab/examples/fTowerTopExcitation.m
+-rw-rw-rw-   0        0        0      709 2020-08-21 05:50:54.000000 welib-1.0.0/welib/FEM/matlab/examples/fTowerTopMDKR.m
+-rw-rw-rw-   0        0        0      444 2020-04-10 21:59:24.000000 welib-1.0.0/welib/FEM/matlab/examples/fTowerTopYDot.m
+-rw-rw-rw-   0        0        0     4585 2020-04-10 21:36:06.000000 welib-1.0.0/welib/FEM/matlab/fBeamMatrices2D_2DOF.m
+-rw-rw-rw-   0        0        0     3821 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fBeamMatrices3D_Frame6DOF.m
+-rw-rw-rw-   0        0        0      375 2018-05-10 22:41:13.000000 welib-1.0.0/welib/FEM/matlab/fBuildGlobalMatrix.m
+-rw-rw-rw-   0        0        0     1759 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamFEM2D.m
+-rw-rw-rw-   0        0        0     6651 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamFEM3D_Frame.m
+-rw-rw-rw-   0        0        0     3736 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamModes2D_2DOF.m
+-rw-rw-rw-   0        0        0     5081 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRayleighRitz.m
+-rw-rw-rw-   0        0        0     5333 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRayleighRitzHermitian.m
+-rw-rw-rw-   0        0        0     5350 2021-07-21 16:10:07.000000 welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRotating.m
+-rw-rw-rw-   0        0        0     2744 2020-08-21 05:50:35.000000 welib-1.0.0/welib/FEM/matlab/fCraigBamptonReduce.m
+-rw-rw-rw-   0        0        0      449 2020-03-05 21:58:00.000000 welib-1.0.0/welib/FEM/matlab/fElementDOFIndex.m
+-rw-rw-rw-   0        0        0      432 2020-03-05 21:59:02.000000 welib-1.0.0/welib/FEM/matlab/fElementKNormalForce2D_2DOF.m
+-rw-rw-rw-   0        0        0     1511 2020-04-10 21:55:15.000000 welib-1.0.0/welib/FEM/matlab/fElementMatricesBeam2D_2DOF.m
+-rw-rw-rw-   0        0        0     2455 2020-04-10 21:35:37.000000 welib-1.0.0/welib/FEM/matlab/fElementMatricesFrame2D_3DOF.m
+-rw-rw-rw-   0        0        0     8898 2020-04-01 15:57:14.000000 welib-1.0.0/welib/FEM/matlab/fElementMatricesFrame3D_6DOF.m
+-rw-rw-rw-   0        0        0     2080 2020-03-05 21:57:38.000000 welib-1.0.0/welib/FEM/matlab/fGuyanReduce.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.847513 welib-1.0.0/welib/FEM/models/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/models/__init__.py
+-rw-rw-rw-   0        0        0     5336 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/models/uniform_beam.py
+-rw-rw-rw-   0        0        0     5563 2022-12-06 21:47:38.000000 welib-1.0.0/welib/FEM/reduction.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.863141 welib-1.0.0/welib/FEM/tests/
+-rw-rw-rw-   0        0        0    21881 2020-11-04 02:52:54.000000 welib-1.0.0/welib/FEM/tests/_FEMBeam2SID.py
+-rw-rw-rw-   0        0        0        0 2020-10-08 18:54:47.000000 welib-1.0.0/welib/FEM/tests/__init__.py
+-rw-rw-rw-   0        0        0     8219 2022-12-06 21:34:09.000000 welib-1.0.0/welib/FEM/tests/test_beam_linear_element.py
+-rw-rw-rw-   0        0        0       88 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/tests/test_fem_elements.py
+-rw-rw-rw-   0        0        0     6430 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/tests/test_frame3d.py
+-rw-rw-rw-   0        0        0     2797 2022-12-06 21:44:57.000000 welib-1.0.0/welib/FEM/tests/test_reduction.py
+-rw-rw-rw-   0        0        0     1187 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0     2554 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/tests/test_timoshenko.py
+-rw-rw-rw-   0        0        0     1142 2022-12-06 21:47:38.000000 welib-1.0.0/welib/FEM/tests/test_utils.py
+-rw-rw-rw-   0        0        0     9428 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/timoshenko.py
+-rw-rw-rw-   0        0        0    14058 2023-06-15 23:48:51.000000 welib-1.0.0/welib/FEM/utils.py
+-rw-rw-rw-   0        0        0       39 2020-10-08 19:09:22.000000 welib-1.0.0/welib/Makefile
+-rw-rw-rw-   0        0        0        0 2023-04-12 21:42:39.000000 welib-1.0.0/welib/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.878768 welib-1.0.0/welib/airfoils/
+-rw-rw-rw-   0        0        0    19391 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/DynamicStall.py
+-rw-rw-rw-   0        0        0       44 2020-09-15 16:23:12.000000 welib-1.0.0/welib/airfoils/Makefile
+-rw-rw-rw-   0        0        0    81082 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/Polar.py
+-rw-rw-rw-   0        0        0    56720 2022-07-11 22:52:49.000000 welib-1.0.0/welib/airfoils/_Polar_Wisdem.py
+-rw-rw-rw-   0        0        0       51 2019-04-05 21:28:09.000000 welib-1.0.0/welib/airfoils/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.894390 welib-1.0.0/welib/airfoils/data/
+-rw-rw-rw-   0        0        0     6778 2019-03-01 06:49:58.000000 welib-1.0.0/welib/airfoils/data/63-235.csv
+-rw-rw-rw-   0        0        0      116 2019-03-01 06:49:53.000000 welib-1.0.0/welib/airfoils/data/Cylinder.csv
+-rw-rw-rw-   0        0        0      194 2019-02-28 22:31:43.000000 welib-1.0.0/welib/airfoils/data/Cylinder.dat
+-rw-rw-rw-   0        0        0     6099 2019-03-19 02:56:59.000000 welib-1.0.0/welib/airfoils/data/DU21_A17.csv
+-rw-rw-rw-   0        0        0     4451 2019-02-28 22:08:34.000000 welib-1.0.0/welib/airfoils/data/FFA-W3-241-Re12M.dat
+-rw-rw-rw-   0        0        0     3171 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/data/tjaere11_ds.csv
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.910012 welib-1.0.0/welib/airfoils/examples/
+-rw-rw-rw-   0        0        0        0 2020-12-14 02:35:02.000000 welib-1.0.0/welib/airfoils/examples/README.md
+-rw-rw-rw-   0        0        0     1671 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/examples/correction3D.py
+-rw-rw-rw-   0        0        0     4275 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/examples/createADPolarFile.py
+-rw-rw-rw-   0        0        0     5885 2023-06-16 00:10:39.000000 welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh.py
+-rw-rw-rw-   0        0        0     5317 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh_riso_1792.py
+-rw-rw-rw-   0        0        0     4335 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh_step_change.py
+-rw-rw-rw-   0        0        0     2839 2023-06-16 00:08:11.000000 welib-1.0.0/welib/airfoils/examples/dynamic_stall_oye.py
+-rw-rw-rw-   0        0        0     1003 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/examples/wagner.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.947763 welib-1.0.0/welib/airfoils/matlab/
+-rw-rw-rw-   0        0        0    19866 2014-05-07 14:35:43.000000 welib-1.0.0/welib/airfoils/matlab/KarmanTrefftzGeometry
+-rw-rw-rw-   0        0        0     4965 2014-05-07 14:32:35.000000 welib-1.0.0/welib/airfoils/matlab/KarmanTrefftzGeometry.f90
+-rw-rw-rw-   0        0        0     6182 2019-02-28 20:32:02.000000 welib-1.0.0/welib/airfoils/matlab/MainProfileCoordinatesExamples.m
+-rw-rw-rw-   0        0        0      173 2014-05-07 14:35:41.000000 welib-1.0.0/welib/airfoils/matlab/Makefile
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.947763 welib-1.0.0/welib/airfoils/matlab/__tests__/
+-rw-rw-rw-   0        0        0     2034 2019-03-18 17:29:05.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/MainForcedOscillations.m
+-rw-rw-rw-   0        0        0     1302 2019-03-16 23:41:03.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/MainPolars.m
+-rw-rw-rw-   0        0        0     1479 2019-03-16 23:41:44.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/MainPolarsFullySep.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.963395 welib-1.0.0/welib/airfoils/matlab/__tests__/data/
+-rw-rw-rw-   0        0        0    26888 2013-06-03 11:13:04.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/data/DTU_10MW_RWT_pc.dat
+-rw-rw-rw-   0        0        0     4410 2014-04-09 08:06:30.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/data/FFA-W3-241-Re12e6.dat
+-rw-rw-rw-   0        0        0     2224 2010-02-01 13:52:50.000000 welib-1.0.0/welib/airfoils/matlab/__tests__/data/tjaere11_ds.dat
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.963395 welib-1.0.0/welib/airfoils/matlab/data/
+-rw-rw-rw-   0        0        0     8944 2014-04-21 14:10:12.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3211.dat
+-rw-rw-rw-   0        0        0     1904 2012-10-29 11:52:29.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3241.dat
+-rw-rw-rw-   0        0        0     1539 2012-10-29 11:52:29.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3301.dat
+-rw-rw-rw-   0        0        0     1540 2012-10-29 11:52:29.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3360.dat
+-rw-rw-rw-   0        0        0     2980 2014-04-21 14:10:22.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3400fb.dat
+-rw-rw-rw-   0        0        0     3318 2014-04-21 14:10:29.000000 welib-1.0.0/welib/airfoils/matlab/data/ffaw3480.dat
+-rw-rw-rw-   0        0        0     2200 2014-01-12 00:17:40.000000 welib-1.0.0/welib/airfoils/matlab/data/geom-cylinder.dat
+-rw-rw-rw-   0        0        0     1904 2012-10-29 11:52:29.000000 welib-1.0.0/welib/airfoils/matlab/data/geom-ffaw3241.dat
+-rw-rw-rw-   0        0        0     7581 2014-05-07 14:35:44.000000 welib-1.0.0/welib/airfoils/matlab/data/geom-karman-trefftz_-0.1_0.0_5.dat
+-rw-rw-rw-   0        0        0      203 2014-04-09 08:23:36.000000 welib-1.0.0/welib/airfoils/matlab/fAirfoilExtendPolarViterna.m
+-rw-rw-rw-   0        0        0      876 2014-04-09 08:37:28.000000 welib-1.0.0/welib/airfoils/matlab/fAlpha0.m
+-rw-rw-rw-   0        0        0      224 2019-03-18 02:00:04.000000 welib-1.0.0/welib/airfoils/matlab/fAlphaSlope.m
+-rw-rw-rw-   0        0        0      424 2011-05-19 20:11:24.000000 welib-1.0.0/welib/airfoils/matlab/fCdFromCf.m
+-rw-rw-rw-   0        0        0      425 2011-05-20 20:11:31.000000 welib-1.0.0/welib/airfoils/matlab/fCdFromCp.m
+-rw-rw-rw-   0        0        0      425 2011-05-20 20:11:13.000000 welib-1.0.0/welib/airfoils/matlab/fClFromCf.m
+-rw-rw-rw-   0        0        0      427 2011-05-20 20:11:38.000000 welib-1.0.0/welib/airfoils/matlab/fClFromCp.m
+-rw-rw-rw-   0        0        0      527 2019-03-18 17:27:38.000000 welib-1.0.0/welib/airfoils/matlab/fDynaStallOye.m
+-rw-rw-rw-   0        0        0     1401 2014-04-09 11:31:09.000000 welib-1.0.0/welib/airfoils/matlab/fInitPolar.m
+-rw-rw-rw-   0        0        0     1738 2011-05-20 20:48:27.000000 welib-1.0.0/welib/airfoils/matlab/fLoadFromPressure.m
+-rw-rw-rw-   0        0        0      850 2011-05-20 20:25:34.000000 welib-1.0.0/welib/airfoils/matlab/fLoadFromTau.m
+-rw-rw-rw-   0        0        0      926 2011-09-10 03:59:16.000000 welib-1.0.0/welib/airfoils/matlab/fPlotAirfoilForces.m
+-rw-rw-rw-   0        0        0      507 2012-08-08 12:23:08.000000 welib-1.0.0/welib/airfoils/matlab/fPlotAirfoilScene.m
+-rw-rw-rw-   0        0        0      378 2011-05-20 20:45:16.000000 welib-1.0.0/welib/airfoils/matlab/fPlotAirfoilShear.m
+-rw-rw-rw-   0        0        0     9038 2011-09-12 21:48:04.000000 welib-1.0.0/welib/airfoils/matlab/fPolarExtendViterna.m
+-rw-rw-rw-   0        0        0     2330 2014-04-09 08:52:47.000000 welib-1.0.0/welib/airfoils/matlab/fPolarFullySeparated.m
+-rw-rw-rw-   0        0        0      490 2019-03-16 22:39:16.000000 welib-1.0.0/welib/airfoils/matlab/fPolarInviscid.m
+-rw-rw-rw-   0        0        0     1432 2011-05-20 21:14:55.000000 welib-1.0.0/welib/airfoils/matlab/fPressureIntegration.m
+-rw-rw-rw-   0        0        0     4386 2012-11-07 13:36:12.000000 welib-1.0.0/welib/airfoils/matlab/fProfileCoordinates.m
+-rw-rw-rw-   0        0        0     3017 2012-11-15 12:29:42.000000 welib-1.0.0/welib/airfoils/matlab/fProfileKarmanTrefftz.m
+-rw-rw-rw-   0        0        0     7729 2014-05-07 13:53:39.000000 welib-1.0.0/welib/airfoils/matlab/fProfileStandardize.m
+-rw-rw-rw-   0        0        0     5323 2012-11-15 12:01:24.000000 welib-1.0.0/welib/airfoils/matlab/fProfileVanDeVooren.m
+-rw-rw-rw-   0        0        0     4363 2008-12-24 15:57:46.000000 welib-1.0.0/welib/airfoils/matlab/naca4gen.m
+-rw-rw-rw-   0        0        0     4620 2009-03-10 14:10:18.000000 welib-1.0.0/welib/airfoils/matlab/naca5gen.m
+-rw-rw-rw-   0        0        0      620 2012-11-05 14:32:54.000000 welib-1.0.0/welib/airfoils/matlab/struct2str.m
+-rw-rw-rw-   0        0        0      645 2012-11-05 15:03:02.000000 welib-1.0.0/welib/airfoils/matlab/textlegend.m
+-rw-rw-rw-   0        0        0      287 2009-02-13 15:24:42.000000 welib-1.0.0/welib/airfoils/matlab/tst_naca4gen.m
+-rw-rw-rw-   0        0        0      359 2009-03-10 14:09:18.000000 welib-1.0.0/welib/airfoils/matlab/tst_naca5gen.m
+-rw-rw-rw-   0        0        0     2797 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/naca.py
+-rw-rw-rw-   0        0        0    10579 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/polar_file.py
+-rw-rw-rw-   0        0        0    51649 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/section.py
+-rw-rw-rw-   0        0        0     6036 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/shapes.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.979018 welib-1.0.0/welib/airfoils/tests/
+-rw-rw-rw-   0        0        0        0 2019-02-16 23:50:56.000000 welib-1.0.0/welib/airfoils/tests/__init__.py
+-rw-rw-rw-   0        0        0     6284 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_dynamic_stall.py
+-rw-rw-rw-   0        0        0     1708 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_polar_interp.py
+-rw-rw-rw-   0        0        0      738 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_polar_manip.py
+-rw-rw-rw-   0        0        0    11326 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_polar_params.py
+-rw-rw-rw-   0        0        0     1460 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_polar_subfunctions.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0     5160 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/tests/test_section.py
+-rw-rw-rw-   0        0        0     4273 2023-06-15 23:48:51.000000 welib-1.0.0/welib/airfoils/wings.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.979018 welib-1.0.0/welib/beams/
+-rw-rw-rw-   0        0        0        0 2020-10-22 04:09:55.000000 welib-1.0.0/welib/beams/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.994635 welib-1.0.0/welib/beams/examples/
+-rw-rw-rw-   0        0        0     1369 2022-12-06 21:47:38.000000 welib-1.0.0/welib/beams/examples/Ex1_BeamModes.py
+-rw-rw-rw-   0        0        0     2141 2022-12-06 21:47:38.000000 welib-1.0.0/welib/beams/examples/Ex2_BeamModesAllBC.py
+-rw-rw-rw-   0        0        0      807 2022-07-19 16:07:51.000000 welib-1.0.0/welib/beams/examples/___TestBeamDynUniform.py
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/beams/examples/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.994635 welib-1.0.0/welib/beams/matlab/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.994635 welib-1.0.0/welib/beams/matlab/examples/
+-rw-rw-rw-   0        0        0     1215 2019-07-20 21:04:21.000000 welib-1.0.0/welib/beams/matlab/examples/Main_Modes.m
+-rw-rw-rw-   0        0        0     3803 2019-07-20 21:05:23.000000 welib-1.0.0/welib/beams/matlab/examples/Main_Modes_For_FAST.m
+-rw-rw-rw-   0        0        0    18787 2018-06-30 11:16:10.000000 welib-1.0.0/welib/beams/matlab/fInputParser.m
+-rw-rw-rw-   0        0        0     6125 2019-07-20 21:56:52.000000 welib-1.0.0/welib/beams/matlab/fUniformBeamTheory.m
+-rw-rw-rw-   0        0        0     2958 2019-07-20 21:56:55.000000 welib-1.0.0/welib/beams/matlab/fUniformBeamTheoryLongi.m
+-rw-rw-rw-   0        0        0     3136 2019-07-20 22:21:00.000000 welib-1.0.0/welib/beams/matlab/fUniformBeamTheoryTorsion.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.010262 welib-1.0.0/welib/beams/tests/
+-rw-rw-rw-   0        0        0        0 2020-10-22 04:10:07.000000 welib-1.0.0/welib/beams/tests/__init__.py
+-rw-rw-rw-   0        0        0     3133 2022-06-25 00:01:42.000000 welib-1.0.0/welib/beams/tests/test_theory.py
+-rw-rw-rw-   0        0        0    11732 2023-06-15 23:48:51.000000 welib-1.0.0/welib/beams/theory.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.010262 welib-1.0.0/welib/ctrl/
+-rw-rw-rw-   0        0        0      681 2021-07-01 19:37:08.000000 welib-1.0.0/welib/ctrl/_BodePlot.py
+-rw-rw-rw-   0        0        0        0 2020-10-09 00:08:07.000000 welib-1.0.0/welib/ctrl/__init__.py
+-rw-rw-rw-   0        0        0     6657 2021-06-30 23:33:01.000000 welib-1.0.0/welib/ctrl/_secord-matlab.py
+-rw-rw-rw-   0        0        0     2038 2020-11-16 04:59:10.000000 welib-1.0.0/welib/ctrl/_secord_transfer.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.010262 welib-1.0.0/welib/dyninflow/
+-rw-rw-rw-   0        0        0    19946 2023-06-15 23:48:51.000000 welib-1.0.0/welib/dyninflow/DynamicInflow.py
+-rw-rw-rw-   0        0        0        0 2021-02-01 06:21:39.000000 welib-1.0.0/welib/dyninflow/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.010262 welib-1.0.0/welib/dyninflow/examples/
+-rw-rw-rw-   0        0        0     2131 2022-12-06 21:47:38.000000 welib-1.0.0/welib/dyninflow/examples/Ex1_StepUp.py
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/dyninflow/examples/__init__.py
+-rw-rw-rw-   0        0        0      306 2023-06-15 23:48:51.000000 welib-1.0.0/welib/essentials.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.063652 welib-1.0.0/welib/fast/
+-rw-rw-rw-   0        0        0    13853 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/FASTLin.py
+-rw-rw-rw-   0        0        0      335 2022-12-06 21:44:57.000000 welib-1.0.0/welib/fast/README.md
+-rw-rw-rw-   0        0        0        0 2022-11-13 23:04:25.000000 welib-1.0.0/welib/fast/__init__.py
+-rw-rw-rw-   0        0        0      561 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/aerodyn.py
+-rw-rw-rw-   0        0        0    50426 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/beamdyn.py
+-rw-rw-rw-   0        0        0    24986 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/campbell.py
+-rw-rw-rw-   0        0        0    28044 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/case_gen.py
+-rw-rw-rw-   0        0        0   129700 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/elastodyn.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.079270 welib-1.0.0/welib/fast/examples/
+-rw-rw-rw-   0        0        0       32 2021-07-21 16:10:07.000000 welib-1.0.0/welib/fast/examples/.gitignore
+-rw-rw-rw-   0        0        0     1966 2022-12-06 21:34:09.000000 welib-1.0.0/welib/fast/examples/Example_CPLambdaPitch.py
+-rw-rw-rw-   0        0        0     2308 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/examples/Example_ElastoDynShapeFunctionFitting.py
+-rw-rw-rw-   0        0        0     2556 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/examples/Example_ExcelFile.py
+-rw-rw-rw-   0        0        0     3283 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/examples/Example_ExtractInertia.py
+-rw-rw-rw-   0        0        0     2228 2022-12-06 21:34:09.000000 welib-1.0.0/welib/fast/examples/Example_Hawc2ToBeamDyn.py
+-rw-rw-rw-   0        0        0     7057 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/examples/Example_HydroDyn_PrescribedMotion.py
+-rw-rw-rw-   0        0        0     4319 2022-12-06 21:34:09.000000 welib-1.0.0/welib/fast/examples/Example_Parametric.py
+-rw-rw-rw-   0        0        0      755 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/examples/Example_PointMesh.py
+-rw-rw-rw-   0        0        0     6396 2022-12-06 21:34:09.000000 welib-1.0.0/welib/fast/examples/Example_PowerCurve_Parametric.py
+-rw-rw-rw-   0        0        0     3182 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/examples/Example_RadialInterp.py
+-rw-rw-rw-   0        0        0     2404 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/examples/Example_RadialPostPro.py
+-rw-rw-rw-   0        0        0     1174 2021-07-21 16:10:07.000000 welib-1.0.0/welib/fast/examples/Example_Remap.py
+-rw-rw-rw-   0        0        0     3480 2022-12-06 21:59:34.000000 welib-1.0.0/welib/fast/examples/Example_SubDyn_Modes.py
+-rw-rw-rw-   0        0        0      989 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/examples/Example_TuneTowerDamping.py
+-rw-rw-rw-   0        0        0    11500 2021-07-21 16:10:07.000000 welib-1.0.0/welib/fast/examples/ParametricExcel.xlsx
+-rw-rw-rw-   0        0        0      912 2021-07-21 16:10:07.000000 welib-1.0.0/welib/fast/examples/README.md
+-rw-rw-rw-   0        0        0    31156 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/extract.py
+-rw-rw-rw-   0        0        0     8570 2022-11-13 23:04:25.000000 welib-1.0.0/welib/fast/fast_mesh - Copy.py
+-rw-rw-rw-   0        0        0    10375 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/fast_mesh.py
+-rw-rw-rw-   0        0        0    27202 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/fastfarm.py
+-rw-rw-rw-   0        0        0      226 2022-11-13 23:04:25.000000 welib-1.0.0/welib/fast/fastlib.py
+-rw-rw-rw-   0        0        0    11923 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/fastlib_legacy.py
+-rw-rw-rw-   0        0        0    29879 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/hydrodyn.py
+-rw-rw-rw-   0        0        0    11225 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/hydrodyn_driver.py
+-rw-rw-rw-   0        0        0   101478 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/hydrodyn_morison.py
+-rw-rw-rw-   0        0        0     1803 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/hydrodyn_waves.py
+-rw-rw-rw-   0        0        0    29390 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/linearization.py
+-rw-rw-rw-   0        0        0    38242 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/linmodel.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.095102 welib-1.0.0/welib/fast/modules/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/modules/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.096100 welib-1.0.0/welib/fast/modules/map/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/modules/map/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.097101 welib-1.0.0/welib/fast/modules/map/examples/
+-rw-rw-rw-   0        0        0     1503 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/modules/map/examples/MAPStiffnessMatrix.py
+-rw-rw-rw-   0        0        0     9616 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/olaf.py
+-rw-rw-rw-   0        0        0    72538 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/postpro.py
+-rw-rw-rw-   0        0        0    12113 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/runner.py
+-rw-rw-rw-   0        0        0    45305 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/subdyn.py
+-rw-rw-rw-   0        0        0     8002 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/subdyn_sum.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.099200 welib-1.0.0/welib/fast/tests/
+-rw-rw-rw-   0        0        0        2 2021-07-21 16:10:07.000000 welib-1.0.0/welib/fast/tests/__init__.py
+-rw-rw-rw-   0        0        0    21868 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/tests/test_elastodyn.py
+-rw-rw-rw-   0        0        0     2800 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/tests/test_hydrodyn.py
+-rw-rw-rw-   0        0        0     1336 2022-12-06 21:47:38.000000 welib-1.0.0/welib/fast/tests/test_mesh.py
+-rw-rw-rw-   0        0        0     1197 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/tests/test_run_Examples.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.099200 welib-1.0.0/welib/fast/tools/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/tools/__init__.py
+-rw-rw-rw-   0        0        0     8077 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/tools/lin.py
+-rw-rw-rw-   0        0        0     3440 2023-06-15 23:48:51.000000 welib-1.0.0/welib/fast/tuning.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.114823 welib-1.0.0/welib/hydro/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/__init__.py
+-rw-rw-rw-   0        0        0    35232 2020-09-24 14:44:08.000000 welib-1.0.0/welib/hydro/_spectral.py
+-rw-rw-rw-   0        0        0     1636 2023-06-15 23:48:51.000000 welib-1.0.0/welib/hydro/addedmass.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.114823 welib-1.0.0/welib/hydro/examples/
+-rw-rw-rw-   0        0        0     4309 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/examples/Ex1_WaveKinematics.py
+-rw-rw-rw-   0        0        0     1366 2022-12-06 21:47:38.000000 welib-1.0.0/welib/hydro/examples/Ex2_Jonswap_spectrum.py
+-rw-rw-rw-   0        0        0     2311 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/examples/Ex3_WaveTimeSeries.py
+-rw-rw-rw-   0        0        0     6407 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/examples/Ex4_WaveLoads.py
+-rw-rw-rw-   0        0        0      517 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/examples/README.md
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/examples/__init__.py
+-rw-rw-rw-   0        0        0     1542 2023-06-15 23:48:51.000000 welib-1.0.0/welib/hydro/hydrostat.py
+-rw-rw-rw-   0        0        0     2468 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/morison.py
+-rw-rw-rw-   0        0        0     2108 2022-12-06 21:47:38.000000 welib-1.0.0/welib/hydro/spectra.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.130450 welib-1.0.0/welib/hydro/tests/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/tests/__init__.py
+-rw-rw-rw-   0        0        0     1057 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/tests/test_morison.py
+-rw-rw-rw-   0        0        0     1199 2023-06-15 23:48:51.000000 welib-1.0.0/welib/hydro/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0      770 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/tests/test_spectra.py
+-rw-rw-rw-   0        0        0     3856 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/tests/test_wavekin.py
+-rw-rw-rw-   0        0        0     3358 2022-12-06 21:47:38.000000 welib-1.0.0/welib/hydro/tools.py
+-rw-rw-rw-   0        0        0     5534 2021-07-21 16:10:07.000000 welib-1.0.0/welib/hydro/wavekin.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.130450 welib-1.0.0/welib/kalman/
+-rw-rw-rw-   0        0        0    15403 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/TN.py
+-rw-rw-rw-   0        0        0    18878 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/TNLin.py
+-rw-rw-rw-   0        0        0        0 2020-10-22 04:12:55.000000 welib-1.0.0/welib/kalman/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.146067 welib-1.0.0/welib/kalman/examples/
+-rw-rw-rw-   0        0        0     6023 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/examples/Mech_1DOF.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.148078 welib-1.0.0/welib/kalman/examples/onshore_OFLin/
+-rw-rw-rw-   0        0        0     3571 2022-12-06 21:34:09.000000 welib-1.0.0/welib/kalman/examples/onshore_OFLin/001_Linearization_GenerateCase.py
+-rw-rw-rw-   0        0        0     3822 2022-12-06 21:34:09.000000 welib-1.0.0/welib/kalman/examples/onshore_OFLin/002_Create_FASTLin.py
+-rw-rw-rw-   0        0        0     4313 2020-10-22 01:41:55.000000 welib-1.0.0/welib/kalman/examples/onshore_OFLin/301_Kalman_2DOF_5States.py
+-rw-rw-rw-   0        0        0     3563 2020-02-26 20:42:29.000000 welib-1.0.0/welib/kalman/examples/onshore_OFLin/kalman_models.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.148078 welib-1.0.0/welib/kalman/examples/onshore_YAMS/
+-rw-rw-rw-   0        0        0     2116 2022-12-06 21:34:09.000000 welib-1.0.0/welib/kalman/examples/onshore_YAMS/000_CPLambdaPitch.py
+-rw-rw-rw-   0        0        0     2137 2022-12-06 21:34:09.000000 welib-1.0.0/welib/kalman/examples/onshore_YAMS/100_WSEstimation.py
+-rw-rw-rw-   0        0        0     3328 2022-12-06 21:34:09.000000 welib-1.0.0/welib/kalman/examples/onshore_YAMS/300_Kalman_2DOF_7States.py
+-rw-rw-rw-   0        0        0      338 2019-12-02 05:24:30.000000 welib-1.0.0/welib/kalman/filters.py
+-rw-rw-rw-   0        0        0     8199 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/kalman.py
+-rw-rw-rw-   0        0        0    18761 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/kalmanfilter.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.148078 welib-1.0.0/welib/kalman/tests/
+-rw-rw-rw-   0        0        0        0 2020-10-22 04:12:55.000000 welib-1.0.0/welib/kalman/tests/__init__.py
+-rw-rw-rw-   0        0        0     5050 2020-10-22 04:12:45.000000 welib-1.0.0/welib/kalman/tests/test_kalman.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/kalman/tests/test_run_Examples.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.163709 welib-1.0.0/welib/mesh/
+-rw-rw-rw-   0        0        0        0 2019-08-03 03:03:46.000000 welib-1.0.0/welib/mesh/__init__.py
+-rw-rw-rw-   0        0        0      250 2019-08-03 04:16:19.000000 welib-1.0.0/welib/mesh/fCoordRectilinearGrid.py
+-rw-rw-rw-   0        0        0      200 2019-08-03 04:16:19.000000 welib-1.0.0/welib/mesh/fCoordRegularGrid.py
+-rw-rw-rw-   0        0        0      352 2019-08-03 04:16:20.000000 welib-1.0.0/welib/mesh/fMeshProgressive.py
+-rw-rw-rw-   0        0        0      503 2019-08-03 04:16:20.000000 welib-1.0.0/welib/mesh/fMeshProgressiveExtent.py
+-rw-rw-rw-   0        0        0     1090 2019-08-03 04:16:18.000000 welib-1.0.0/welib/mesh/fbinary_search.py
+-rw-rw-rw-   0        0        0     2571 2021-05-16 21:35:10.000000 welib-1.0.0/welib/mesh/gradient.py
+-rw-rw-rw-   0        0        0     9635 2020-10-09 00:28:37.000000 welib-1.0.0/welib/mesh/mesh.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.163709 welib-1.0.0/welib/mesh/tests/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/mesh/tests/__init__.py
+-rw-rw-rw-   0        0        0     3861 2021-07-21 16:10:07.000000 welib-1.0.0/welib/mesh/tests/test_vectoranalysis.py
+-rw-rw-rw-   0        0        0     3065 2021-07-21 16:10:07.000000 welib-1.0.0/welib/mesh/vectoranalysis.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.163709 welib-1.0.0/welib/moor/
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:47:38.000000 welib-1.0.0/welib/moor/__init__.py
+-rw-rw-rw-   0        0        0    45379 2023-06-15 23:48:51.000000 welib-1.0.0/welib/moor/mappp.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.179328 welib-1.0.0/welib/ode/
+-rw-rw-rw-   0        0        0      454 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ode/__init__.py
+-rw-rw-rw-   0        0        0     2965 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ode/generalizedalpha.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.179328 welib-1.0.0/welib/ode/matlab/
+-rw-rw-rw-   0        0        0     4011 2020-04-10 21:38:36.000000 welib-1.0.0/welib/ode/matlab/fodeKrenk.m
+-rw-rw-rw-   0        0        0     8012 2020-04-10 21:38:26.000000 welib-1.0.0/welib/ode/matlab/fodeNewmark.m
+-rw-rw-rw-   0        0        0     6544 2020-04-10 21:38:18.000000 welib-1.0.0/welib/ode/matlab/fodeNewmarkNonLinear.m
+-rw-rw-rw-   0        0        0     3410 2018-07-21 12:03:59.000000 welib-1.0.0/welib/ode/matlab/fodeProgressBar.m
+-rw-rw-rw-   0        0        0     5785 2020-04-10 21:38:10.000000 welib-1.0.0/welib/ode/matlab/fodeRK4.m
+-rw-rw-rw-   0        0        0     1325 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ode/rk_dormand_prince.py
+-rw-rw-rw-   0        0        0     1604 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ode/rk_nystrom.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.194954 welib-1.0.0/welib/ode/tests/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ode/tests/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.194954 welib-1.0.0/welib/plot/
+-rw-rw-rw-   0        0        0     2294 2021-06-06 00:03:57.000000 welib-1.0.0/welib/plot/_PlotTorus.py
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:34:09.000000 welib-1.0.0/welib/plot/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.194954 welib-1.0.0/welib/plot/examples/
+-rw-rw-rw-   0        0        0     3878 2022-12-06 21:47:38.000000 welib-1.0.0/welib/plot/examples/JSON3D_01_CreateSimpleFile.py
+-rw-rw-rw-   0        0        0     7300 2022-12-06 21:47:38.000000 welib-1.0.0/welib/plot/examples/Plot_3D_blades.py
+-rw-rw-rw-   0        0        0     1146 2022-12-06 21:47:38.000000 welib-1.0.0/welib/plot/examples/Plot_3D_surfaces.py
+-rw-rw-rw-   0        0        0    10303 2022-12-06 21:47:38.000000 welib-1.0.0/welib/plot/json3d.py
+-rw-rw-rw-   0        0        0     2464 2022-12-06 21:34:09.000000 welib-1.0.0/welib/plot/surface3d.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.194954 welib-1.0.0/welib/plot/tests/
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:47:38.000000 welib-1.0.0/welib/plot/tests/__init__.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/plot/tests/test_run_Examples.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.210577 welib-1.0.0/welib/standards/
+-rw-rw-rw-   0        0        0     7401 2022-12-06 21:47:38.000000 welib-1.0.0/welib/standards/IEC.py
+-rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-1.0.0/welib/standards/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.210577 welib-1.0.0/welib/standards/examples/
+-rw-rw-rw-   0        0        0     1074 2022-02-08 22:29:24.000000 welib-1.0.0/welib/standards/examples/Ex1_TurbulenceClasses.py
+-rw-rw-rw-   0        0        0     1540 2022-12-06 21:47:38.000000 welib-1.0.0/welib/standards/examples/Ex2_EOG.py
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/standards/examples/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.226195 welib-1.0.0/welib/system/
+-rw-rw-rw-   0        0        0       39 2020-10-08 19:09:22.000000 welib-1.0.0/welib/system/Makefile
+-rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-1.0.0/welib/system/__init__.py
+-rw-rw-rw-   0        0        0      842 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/chaos.py
+-rw-rw-rw-   0        0        0       31 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/eva.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.248325 welib-1.0.0/welib/system/examples/
+-rw-rw-rw-   0        0        0     7271 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/examples/Example_DriveTrainTorsion.py
+-rw-rw-rw-   0        0        0     4405 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/examples/Example_DriveTrainTorsion_Wrap.py
+-rw-rw-rw-   0        0        0     5633 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/examples/FirstOrderSystem_Scalar.py
+-rw-rw-rw-   0        0        0     1709 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/examples/Lorenz.py
+-rw-rw-rw-   0        0        0     2388 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/examples/MassSpringDamper_Duhamel.py
+-rw-rw-rw-   0        0        0     1288 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/examples/MassSpringDamper_ForcedVibrations.py
+-rw-rw-rw-   0        0        0     3136 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/examples/MassSpringDamper_StateSpace_FreqDomain.py
+-rw-rw-rw-   0        0        0     7255 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/examples/SecondOrderSystem_Scalar.py
+-rw-rw-rw-   0        0        0     1356 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/examples/StepResponse.py
+-rw-rw-rw-   0        0        0     1644 2020-12-15 20:39:09.000000 welib-1.0.0/welib/system/examples/pendulum.py
+-rw-rw-rw-   0        0        0    10832 2023-06-16 00:08:11.000000 welib-1.0.0/welib/system/examples/pendulum_3d.py
+-rw-rw-rw-   0        0        0     3941 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/examples/pendulum_on_prescribed_cart.py
+-rw-rw-rw-   0        0        0     5636 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/firstorder.py
+-rw-rw-rw-   0        0        0     6931 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/linearization.py
+-rw-rw-rw-   0        0        0      201 2021-07-21 16:10:07.000000 welib-1.0.0/welib/system/lti.py
+-rw-rw-rw-   0        0        0     8191 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/mbc.py
+-rw-rw-rw-   0        0        0    32605 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/mech_system.py
+-rw-rw-rw-   0        0        0     7738 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/secondorder.py
+-rw-rw-rw-   0        0        0     5698 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/singledof.py
+-rw-rw-rw-   0        0        0    39699 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/statespace.py
+-rw-rw-rw-   0        0        0    29272 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/statespacelinear.py
+-rw-rw-rw-   0        0        0     9281 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/system.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.263957 welib-1.0.0/welib/system/tests/
+-rw-rw-rw-   0        0        0        0 2020-10-08 18:54:47.000000 welib-1.0.0/welib/system/tests/__init__.py
+-rw-rw-rw-   0        0        0     2831 2022-07-05 18:17:30.000000 welib-1.0.0/welib/system/tests/test_eva.py
+-rw-rw-rw-   0        0        0     3159 2022-12-06 21:47:38.000000 welib-1.0.0/welib/system/tests/test_linearization.py
+-rw-rw-rw-   0        0        0     9348 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/tests/test_mbc.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0     5159 2020-10-22 04:06:26.000000 welib-1.0.0/welib/system/tests/test_singledof.py
+-rw-rw-rw-   0        0        0     2959 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/tests/test_system.py
+-rw-rw-rw-   0        0        0        2 2020-10-08 17:46:25.000000 welib-1.0.0/welib/system/tools.py
+-rw-rw-rw-   0        0        0     3481 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/transferfunction.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.263957 welib-1.0.0/welib/system/wtmodels/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.279579 welib-1.0.0/welib/system/wtmodels/examples/
+-rw-rw-rw-   0        0        0     5682 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/examples/model15M_exA1.py
+-rw-rw-rw-   0        0        0     6842 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/examples/model15M_exA2.py
+-rw-rw-rw-   0        0        0     7180 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/examples/model15M_exB1.py
+-rw-rw-rw-   0        0        0     6147 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/examples/model5CS_ronnie.py
+-rw-rw-rw-   0        0        0    35968 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/model15M.py
+-rw-rw-rw-   0        0        0     6494 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/model5CS.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.279579 welib-1.0.0/welib/system/wtmodels/tests/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/tests/__init__.py
+-rw-rw-rw-   0        0        0    34702 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/tests/test_model15M.py
+-rw-rw-rw-   0        0        0     1208 2023-06-15 23:48:51.000000 welib-1.0.0/welib/system/wtmodels/tests/test_run_Examples.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.279579 welib-1.0.0/welib/time/
+-rw-rw-rw-   0        0        0     2665 2015-10-14 14:57:24.000000 welib-1.0.0/welib/time/TimeManager.m
+-rw-rw-rw-   0        0        0      250 2015-10-14 14:57:24.000000 welib-1.0.0/welib/time/fInitTime.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.326442 welib-1.0.0/welib/tools/
+-rw-rw-rw-   0        0        0     1184 2020-10-22 00:31:55.000000 welib-1.0.0/welib/tools/README.md
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.326442 welib-1.0.0/welib/tools/SpectralAnalysis/
+-rw-rw-rw-   0        0        0      745 2015-10-14 14:57:58.000000 welib-1.0.0/welib/tools/SpectralAnalysis/fLogSmooth.m
+-rw-rw-rw-   0        0        0      822 2015-10-14 14:57:58.000000 welib-1.0.0/welib/tools/SpectralAnalysis/fSpectrum.m
+-rw-rw-rw-   0        0        0      753 2015-10-14 14:57:58.000000 welib-1.0.0/welib/tools/SpectralAnalysis/fSpectrumAngular.m
+-rw-rw-rw-   0        0        0      118 2023-04-12 19:37:48.000000 welib-1.0.0/welib/tools/__init__.py
+-rw-rw-rw-   0        0        0     8340 2022-12-06 21:34:09.000000 welib-1.0.0/welib/tools/bithashlib.py
+-rw-rw-rw-   0        0        0     2603 2023-04-12 19:36:52.000000 welib-1.0.0/welib/tools/clean_exceptions.py
+-rw-rw-rw-   0        0        0    17074 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/colors.py
+-rw-rw-rw-   0        0        0     3327 2022-12-06 21:47:38.000000 welib-1.0.0/welib/tools/compare.py
+-rw-rw-rw-   0        0        0    59693 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/curve_fitting.py
+-rw-rw-rw-   0        0        0     9529 2021-07-21 16:10:07.000000 welib-1.0.0/welib/tools/curves.py
+-rw-rw-rw-   0        0        0     7543 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/damping.py
+-rw-rw-rw-   0        0        0     3290 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/dictlib.py
+-rw-rw-rw-   0        0        0    10709 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/eva.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.342069 welib-1.0.0/welib/tools/examples/
+-rw-rw-rw-   0        0        0     6052 2022-12-06 21:47:38.000000 welib-1.0.0/welib/tools/examples/ExampleCoherence.py
+-rw-rw-rw-   0        0        0     1253 2022-12-06 21:47:38.000000 welib-1.0.0/welib/tools/examples/ExampleCorrelation.py
+-rw-rw-rw-   0        0        0     1859 2021-07-21 16:10:07.000000 welib-1.0.0/welib/tools/examples/Example_FFT.py
+-rw-rw-rw-   0        0        0     1531 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/examples/Example_SVD.py
+-rw-rw-rw-   0        0        0    11434 2022-12-06 21:47:38.000000 welib-1.0.0/welib/tools/examples/VortexCylinderPressure.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.348580 welib-1.0.0/welib/tools/external/
+-rw-rw-rw-   0        0        0       95 2019-04-22 23:57:33.000000 welib-1.0.0/welib/tools/external/Makefile
+-rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-1.0.0/welib/tools/external/__init__.py
+-rw-rw-rw-   0        0        0     1917 2019-04-26 01:54:12.000000 welib-1.0.0/welib/tools/external/_lic_demo.py
+-rw-rw-rw-   0        0        0   356558 2019-10-07 04:50:13.000000 welib-1.0.0/welib/tools/external/lic_internal.c
+-rw-rw-rw-   0        0        0     2381 2019-10-07 04:49:33.000000 welib-1.0.0/welib/tools/external/lic_internal.pyx
+-rw-rw-rw-   0        0        0      282 2019-04-23 00:03:15.000000 welib-1.0.0/welib/tools/external/setup.py
+-rw-rw-rw-   0        0        0    33515 2023-06-16 00:39:13.000000 welib-1.0.0/welib/tools/fatigue.py
+-rw-rw-rw-   0        0        0    10500 2022-07-05 18:17:30.000000 welib-1.0.0/welib/tools/fields.py
+-rw-rw-rw-   0        0        0    18353 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/figure.py
+-rw-rw-rw-   0        0        0    11612 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/functions.py
+-rw-rw-rw-   0        0        0    30667 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/galib.py
+-rw-rw-rw-   0        0        0      690 2020-03-07 23:35:32.000000 welib-1.0.0/welib/tools/latex.py
+-rw-rw-rw-   0        0        0     5192 2020-10-22 00:47:41.000000 welib-1.0.0/welib/tools/lic.py
+-rw-rw-rw-   0        0        0     5192 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/pandalib.py
+-rw-rw-rw-   0        0        0     2077 2019-03-14 01:45:29.000000 welib-1.0.0/welib/tools/pycmd.py
+-rw-rw-rw-   0        0        0      620 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/regression.py
+-rw-rw-rw-   0        0        0     3381 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/repo.py
+-rw-rw-rw-   0        0        0       63 2019-03-20 00:16:37.000000 welib-1.0.0/welib/tools/requirements.txt
+-rw-rw-rw-   0        0        0    30350 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/signal_analysis.py
+-rw-rw-rw-   0        0        0    38496 2023-06-16 00:36:14.000000 welib-1.0.0/welib/tools/spectral.py
+-rw-rw-rw-   0        0        0    12946 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/stats.py
+-rw-rw-rw-   0        0        0     4970 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/strings.py
+-rw-rw-rw-   0        0        0     1525 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/svd.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.364209 welib-1.0.0/welib/tools/tests/
+-rw-rw-rw-   0        0        0        0 2018-10-22 23:21:11.000000 welib-1.0.0/welib/tools/tests/__init__.py
+-rw-rw-rw-   0        0        0      132 2020-10-22 00:48:28.000000 welib-1.0.0/welib/tools/tests/test_colors.py
+-rw-rw-rw-   0        0        0    17602 2022-07-05 18:17:30.000000 welib-1.0.0/welib/tools/tests/test_curve_fitting.py
+-rw-rw-rw-   0        0        0      132 2020-10-22 00:51:44.000000 welib-1.0.0/welib/tools/tests/test_curves.py
+-rw-rw-rw-   0        0        0     2756 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/tests/test_dictlib.py
+-rw-rw-rw-   0        0        0      134 2020-10-22 00:52:24.000000 welib-1.0.0/welib/tools/tests/test_fatigue.py
+-rw-rw-rw-   0        0        0     3189 2020-10-22 01:28:16.000000 welib-1.0.0/welib/tools/tests/test_functions.py
+-rw-rw-rw-   0        0        0    10672 2022-12-06 21:47:38.000000 welib-1.0.0/welib/tools/tests/test_signal.py
+-rw-rw-rw-   0        0        0      135 2020-10-22 00:53:25.000000 welib-1.0.0/welib/tools/tests/test_spectral.py
+-rw-rw-rw-   0        0        0     1581 2020-10-22 00:50:14.000000 welib-1.0.0/welib/tools/tests/test_vectoranalyses.py
+-rw-rw-rw-   0        0        0     2128 2023-06-15 23:48:51.000000 welib-1.0.0/welib/tools/tictoc.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.364209 welib-1.0.0/welib/vortilib/
+-rw-rw-rw-   0        0        0       59 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/.gitignore
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.395449 welib-1.0.0/welib/vortilib/elements/
+-rw-rw-rw-   0        0        0     1822 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/InviscidVortexPatch.py
+-rw-rw-rw-   0        0        0     1013 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/LambOseen.py
+-rw-rw-rw-   0        0        0     8920 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/SourceEllipsoid.py
+-rw-rw-rw-   0        0        0    10572 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/VortexAxisymmetric.py
+-rw-rw-rw-   0        0        0    22901 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexCylinder.py
+-rw-rw-rw-   0        0        0    31477 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexCylinderSkewed.py
+-rw-rw-rw-   0        0        0    23180 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexDoublet.py
+-rw-rw-rw-   0        0        0    14564 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/VortexHelix.py
+-rw-rw-rw-   0        0        0     5099 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexLine.py
+-rw-rw-rw-   0        0        0     2840 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/VortexParticle.py
+-rw-rw-rw-   0        0        0     3243 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/VortexPatch2DGaussian.py
+-rw-rw-rw-   0        0        0     4398 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/VortexPoint.py
+-rw-rw-rw-   0        0        0    12847 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexRing.py
+-rw-rw-rw-   0        0        0     5182 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/VortexSegment.py
+-rw-rw-rw-   0        0        0       23 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/VortexSurfaceFlowField.py
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/__init__.py
+-rw-rw-rw-   0        0        0     8215 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/elliptic.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.411072 welib-1.0.0/welib/vortilib/elements/examples/
+-rw-rw-rw-   0        0        0     3214 2023-06-16 00:08:11.000000 welib-1.0.0/welib/vortilib/elements/examples/EllipticalCoordinates.py
+-rw-rw-rw-   0        0        0     4416 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/InviscidVortexPatch.py
+-rw-rw-rw-   0        0        0     7474 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/examples/LambOseenFenics.py
+-rw-rw-rw-   0        0        0      827 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/SourceEllipsoid_Deriv.py
+-rw-rw-rw-   0        0        0     2115 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/examples/SourceEllipsoid_Plots.py
+-rw-rw-rw-   0        0        0     2996 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexHelix.py
+-rw-rw-rw-   0        0        0     1912 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexParticle_Regularization.py
+-rw-rw-rw-   0        0        0     5099 2023-06-15 23:48:51.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexPoint2DDistribution.py
+-rw-rw-rw-   0        0        0     4747 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexSegment_CrossField.py
+-rw-rw-rw-   0        0        0     2361 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexSegment_Regularization.py
+-rw-rw-rw-   0        0        0     3545 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/examples/VortexSurfaceFlowField.py
+-rw-rw-rw-   0        0        0      294 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fOmega_VortexBrick2D.py
+-rw-rw-rw-   0        0        0      371 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fOmega_VortexBrick3D.py
+-rw-rw-rw-   0        0        0     5110 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fUi_VortexSegment11_smooth.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.448834 welib-1.0.0/welib/vortilib/elements/fortran/
+-rw-rw-rw-   0        0        0     4454 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/EllipticIntegrals.f90
+-rw-rw-rw-   0        0        0     1719 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/MathConstants.f90
+-rw-rw-rw-   0        0        0    13969 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/Part.f90
+-rw-rw-rw-   0        0        0     6429 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/PrecisionMod.f90
+-rw-rw-rw-   0        0        0    18057 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/Sgmt.f90
+-rw-rw-rw-   0        0        0     5648 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/SurfaceMap.f90
+-rw-rw-rw-   0        0        0    12206 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIBlobs.f90
+-rw-rw-rw-   0        0        0     4312 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIHillsVortex.f90
+-rw-rw-rw-   0        0        0    35015 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIPanels.f90
+-rw-rw-rw-   0        0        0     8457 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIPointSource.f90
+-rw-rw-rw-   0        0        0    29156 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UISegments.f90
+-rw-rw-rw-   0        0        0     7883 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIVortexCylinders.f90
+-rw-rw-rw-   0        0        0     5422 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIVortexPoint2D.f90
+-rw-rw-rw-   0        0        0     2256 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIVortexPoint2DPerdiodic.f90
+-rw-rw-rw-   0        0        0    12487 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/fortran/UIVortexRings.f90
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.448834 welib-1.0.0/welib/vortilib/elements/tests/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/tests/__init__.py
+-rw-rw-rw-   0        0        0      600 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/elements/tests/test_elements.py
+-rw-rw-rw-   0        0        0     1193 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/elements/tests/test_run_Examples.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.448834 welib-1.0.0/welib/vortilib/particles/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.448834 welib-1.0.0/welib/vortilib/particles/examples/
+-rw-rw-rw-   0        0        0     4827 2022-12-06 21:47:38.000000 welib-1.0.0/welib/vortilib/particles/examples/MainVC2D_TestProj.py
+-rw-rw-rw-   0        0        0     6507 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/initialization.py
+-rw-rw-rw-   0        0        0     2356 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/particles.py
+-rw-rw-rw-   0        0        0    24121 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/projection.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.464462 welib-1.0.0/welib/vortilib/particles/tests/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/tests/__init__.py
+-rw-rw-rw-   0        0        0      180 2021-07-21 16:10:07.000000 welib-1.0.0/welib/vortilib/particles/tests/test_particles.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.564715 welib-1.0.0/welib/weio/
+-rw-rw-rw-   0        0        0      142 2022-07-05 18:17:30.000000 welib-1.0.0/welib/weio/.gitignore
+-rw-rw-rw-   0        0        0     4245 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/_NEWFILE_TEMPLATE.py
+-rw-rw-rw-   0        0        0    11133 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/__init__.py
+-rw-rw-rw-   0        0        0    15282 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/bladed_out_file.py
+-rw-rw-rw-   0        0        0     5492 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/bmodes_out_file.py
+-rw-rw-rw-   0        0        0     3163 2022-12-06 21:44:57.000000 welib-1.0.0/welib/weio/cactus_element_file.py
+-rw-rw-rw-   0        0        0    18742 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/cactus_file.py
+-rw-rw-rw-   0        0        0    11914 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/csv_file.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.564715 welib-1.0.0/welib/weio/examples/
+-rw-rw-rw-   0        0        0      954 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/examples/ModifyAeroDynBladeFile.py
+-rw-rw-rw-   0        0        0     3080 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/excel_file.py
+-rw-rw-rw-   0        0        0    20489 2023-06-16 00:28:32.000000 welib-1.0.0/welib/weio/fast_input_deck.py
+-rw-rw-rw-   0        0        0   114046 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_input_file.py
+-rw-rw-rw-   0        0        0    15266 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_input_file_graph.py
+-rw-rw-rw-   0        0        0    15675 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_linearization_file.py
+-rw-rw-rw-   0        0        0    23004 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_output_file.py
+-rw-rw-rw-   0        0        0    10413 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_summary_file.py
+-rw-rw-rw-   0        0        0     2673 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/fast_wind_file.py
+-rw-rw-rw-   0        0        0     6606 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/file.py
+-rw-rw-rw-   0        0        0      903 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/file_formats.py
+-rw-rw-rw-   0        0        0     6554 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/flex_blade_file.py
+-rw-rw-rw-   0        0        0     7922 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/flex_doc_file.py
+-rw-rw-rw-   0        0        0     9081 2023-06-16 00:34:05.000000 welib-1.0.0/welib/weio/flex_out_file.py
+-rw-rw-rw-   0        0        0     5867 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/flex_profile_file.py
+-rw-rw-rw-   0        0        0     3815 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/flex_wavekin_file.py
+-rw-rw-rw-   0        0        0     3022 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/hawc2_ae_file.py
+-rw-rw-rw-   0        0        0     7219 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/hawc2_dat_file.py
+-rw-rw-rw-   0        0        0     4875 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/hawc2_htc_file.py
+-rw-rw-rw-   0        0        0     3141 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/hawc2_pc_file.py
+-rw-rw-rw-   0        0        0     3265 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/hawc2_st_file.py
+-rw-rw-rw-   0        0        0     1004 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/hawcstab2_cmb_file.py
+-rw-rw-rw-   0        0        0     2368 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/hawcstab2_ind_file.py
+-rw-rw-rw-   0        0        0     1866 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/hawcstab2_pwr_file.py
+-rw-rw-rw-   0        0        0    12627 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/mannbox_file.py
+-rw-rw-rw-   0        0        0     6534 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/mannbox_input_file.py
+-rw-rw-rw-   0        0        0     3761 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/matlabmat_file.py
+-rw-rw-rw-   0        0        0     4808 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/mini_yaml.py
+-rw-rw-rw-   0        0        0     1022 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/netcdf_file.py
+-rw-rw-rw-   0        0        0     1162 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/parquet_file.py
+-rw-rw-rw-   0        0        0     6465 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/pickle_file.py
+-rw-rw-rw-   0        0        0     8016 2023-04-10 17:51:58.000000 welib-1.0.0/welib/weio/raawmat_file.py
+-rw-rw-rw-   0        0        0     9724 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/rosco_discon_file.py
+-rw-rw-rw-   0        0        0    17302 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/rosco_performance_file.py
+-rw-rw-rw-   0        0        0     8313 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/tdms_file.py
+-rw-rw-rw-   0        0        0     7632 2020-10-30 02:42:03.000000 welib-1.0.0/welib/weio/tecplot_file.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.564715 welib-1.0.0/welib/weio/tools/
+-rw-rw-rw-   0        0        0        0 2020-10-26 00:18:14.000000 welib-1.0.0/welib/weio/tools/__init__.py
+-rw-rw-rw-   0        0        0    27367 2023-01-05 10:50:19.000000 welib-1.0.0/welib/weio/tools/graph.py
+-rw-rw-rw-   0        0        0    42918 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/turbsim_file.py
+-rw-rw-rw-   0        0        0     3916 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/turbsim_ts_file.py
+-rw-rw-rw-   0        0        0      311 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/user.py
+-rw-rw-rw-   0        0        0    46628 2020-10-30 02:59:52.000000 welib-1.0.0/welib/weio/vtk_file.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.564715 welib-1.0.0/welib/weio/wetb/
+-rw-rw-rw-   0        0        0        0 2018-10-29 21:38:59.000000 welib-1.0.0/welib/weio/wetb/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.580333 welib-1.0.0/welib/weio/wetb/hawc2/
+-rw-rw-rw-   0        0        0    14430 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/wetb/hawc2/Hawc2io.py
+-rw-rw-rw-   0        0        0      315 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/wetb/hawc2/__init__.py
+-rw-rw-rw-   0        0        0     5927 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/wetb/hawc2/ae_file.py
+-rw-rw-rw-   0        0        0    17707 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/wetb/hawc2/htc_contents.py
+-rw-rw-rw-   0        0        0     5977 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/wetb/hawc2/htc_extensions.py
+-rw-rw-rw-   0        0        0    25949 2023-06-15 23:48:51.000000 welib-1.0.0/welib/weio/wetb/hawc2/htc_file.py
+-rw-rw-rw-   0        0        0     2477 2022-12-06 21:44:57.000000 welib-1.0.0/welib/weio/wetb/hawc2/htc_file_set.py
+-rw-rw-rw-   0        0        0     5629 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/wetb/hawc2/pc_file.py
+-rw-rw-rw-   0        0        0    13412 2022-12-06 21:47:38.000000 welib-1.0.0/welib/weio/wetb/hawc2/st_file.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.580333 welib-1.0.0/welib/wind/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.580333 welib-1.0.0/welib/wind/examples/
+-rw-rw-rw-   0        0        0     2084 2023-06-09 23:56:29.000000 welib-1.0.0/welib/wind/examples/WindGenerationAtPoint.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.595960 welib-1.0.0/welib/wind/matlab/
+-rw-rw-rw-   0        0        0      295 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/fInitWind.m
+-rw-rw-rw-   0        0        0      281 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/fReadMannBinary.m
+-rw-rw-rw-   0        0        0      166 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/fSetWind.m
+-rw-rw-rw-   0        0        0     2565 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/fStocWind.m
+-rw-rw-rw-   0        0        0      433 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/fUi_Wind.m
+-rw-rw-rw-   0        0        0     1031 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy01.m
+-rw-rw-rw-   0        0        0     1012 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy02.m
+-rw-rw-rw-   0        0        0     1625 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy03.m
+-rw-rw-rw-   0        0        0      299 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/wind_Load.m
+-rw-rw-rw-   0        0        0       47 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/matlab/wind_SetDefault.m
+-rw-rw-rw-   0        0        0      635 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/spectra.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.595960 welib-1.0.0/welib/wind/tests/
+-rw-rw-rw-   0        0        0        0 2021-07-21 16:10:07.000000 welib-1.0.0/welib/wind/tests/__init__.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wind/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0     5297 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wind/windsim.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.627205 welib-1.0.0/welib/windwave/
+-rw-rw-rw-   0        0        0     6364 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/Main_Calls.m
+-rw-rw-rw-   0        0        0     2154 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/Main_Elast.m
+-rw-rw-rw-   0        0        0     5952 2021-07-21 16:10:07.000000 welib-1.0.0/welib/windwave/Main_WindWaves.m
+-rw-rw-rw-   0        0        0     4092 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fHydroCalcFinal.m
+-rw-rw-rw-   0        0        0      839 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fJonswap.m
+-rw-rw-rw-   0        0        0      590 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fPlotCompare.m
+-rw-rw-rw-   0        0        0      423 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fPlotSimple.m
+-rw-rw-rw-   0        0        0     2055 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fSpectrum.m
+-rw-rw-rw-   0        0        0      665 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fSpectrumAvg.m
+-rw-rw-rw-   0        0        0      791 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fSpectrumCalc.m
+-rw-rw-rw-   0        0        0     2565 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fStocWind.m
+-rw-rw-rw-   0        0        0     2942 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fWaveKin.m
+-rw-rw-rw-   0        0        0      524 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fWindCalc.m
+-rw-rw-rw-   0        0        0      588 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fgetDispersion.m
+-rw-rw-rw-   0        0        0     1180 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/fqPrime.m
+-rw-rw-rw-   0        0        0      210 2018-10-17 22:56:26.000000 welib-1.0.0/welib/windwave/include_globals.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.627205 welib-1.0.0/welib/ws_estimator/
+-rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-1.0.0/welib/ws_estimator/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.627205 welib-1.0.0/welib/ws_estimator/examples/
+-rw-rw-rw-   0        0        0     4877 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ws_estimator/examples/Floating.py
+-rw-rw-rw-   0        0        0    30499 2023-06-16 00:29:10.000000 welib-1.0.0/welib/ws_estimator/tabulated.py
+-rw-rw-rw-   0        0        0    36978 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ws_estimator/tabulated_floating.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.627205 welib-1.0.0/welib/ws_estimator/tests/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ws_estimator/tests/__init__.py
+-rw-rw-rw-   0        0        0     6414 2023-06-15 23:48:51.000000 welib-1.0.0/welib/ws_estimator/tests/test_tabulated.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.642827 welib-1.0.0/welib/wt_theory/
+-rw-rw-rw-   0        0        0     1043 2011-02-22 19:24:39.000000 welib-1.0.0/welib/wt_theory/AxialInduction-CT.m
+-rw-rw-rw-   0        0        0     2190 2016-11-29 21:23:27.000000 welib-1.0.0/welib/wt_theory/AxialInductionCT.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.649340 welib-1.0.0/welib/wt_theory/examples/
+-rw-rw-rw-   0        0        0     2442 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/examples/WakeExpansion.py
+-rw-rw-rw-   0        0        0     2863 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/examples/WakeLengthInducedVelocity.py
+-rw-rw-rw-   0        0        0      186 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/highthrust.py
+-rw-rw-rw-   0        0        0    11693 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/idealrotors.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.377492 welib-1.0.0/welib/wt_theory/matlab/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.649340 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/
+-rw-rw-rw-   0        0        0       39 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/.gitignore
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.377492 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.649340 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/
+-rw-rw-rw-   0        0        0     1087 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Dates.m
+-rw-rw-rw-   0        0        0     3428 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m
+-rw-rw-rw-   0        0        0      468 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Lists.m
+-rw-rw-rw-   0        0        0      126 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Maths.m
+-rw-rw-rw-   0        0        0     2101 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Plots.m
+-rw-rw-rw-   0        0        0      525 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SQL.m
+-rw-rw-rw-   0        0        0     1927 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m
+-rw-rw-rw-   0        0        0     1156 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Stats.m
+-rw-rw-rw-   0        0        0      428 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/VERSIONS
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.664968 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/
+-rw-rw-rw-   0        0        0     6622 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/MainGoldsteinPlots.m
+-rw-rw-rw-   0        0        0     6080 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m
+-rw-rw-rw-   0        0        0     2594 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/PrandtlTheory.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.664968 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/matfig/
+-rw-rw-rw-   0        0        0    20474 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/matfig/ComparisonBetzPrandtlGoldstein.fig
+-rw-rw-rw-   0        0        0    17414 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/matfig/ComparisonBetzPrandtlGoldsteinF.fig
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.664968 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__tests__/
+-rw-rw-rw-   0        0        0     1558 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__tests__/testCompareGoldstein.m
+-rw-rw-rw-   0        0        0     1203 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__tests__/testGoldstein.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.664968 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v-1/
+-rw-rw-rw-   0        0        0      201 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v-1/fBetzCirculation.m
+-rw-rw-rw-   0        0        0     4064 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.680595 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/
+-rw-rw-rw-   0        0        0      427 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationBetz.m
+-rw-rw-rw-   0        0        0      227 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationGoldstein.m
+-rw-rw-rw-   0        0        0      307 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationPrandtl.m
+-rw-rw-rw-   0        0        0   259603 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor.mexa64
+-rw-rw-rw-   0        0        0     3977 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m
+-rw-rw-rw-   0        0        0     5184 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m
+-rw-rw-rw-   0        0        0     1651 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFarWakeParams.m
+-rw-rw-rw-   0        0        0     4536 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinOkulovF.m
+-rw-rw-rw-   0        0        0     2450 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fTiberyWrench.m
+-rw-rw-rw-   0        0        0      262 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fTipLossGoldsteinOkulov.m
+-rw-rw-rw-   0        0        0      157 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fTipLossPrandtl.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.696218 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/
+-rw-rw-rw-   0        0        0      427 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationBetz.m
+-rw-rw-rw-   0        0        0      227 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationGoldstein.m
+-rw-rw-rw-   0        0        0      307 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationPrandtl.m
+-rw-rw-rw-   0        0        0     3977 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor.m
+-rw-rw-rw-   0        0        0     5184 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m
+-rw-rw-rw-   0        0        0     1466 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m
+-rw-rw-rw-   0        0        0     4536 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m
+-rw-rw-rw-   0        0        0     2450 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTiberyWrench.m
+-rw-rw-rw-   0        0        0      262 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTipLossGoldsteinOkulov.m
+-rw-rw-rw-   0        0        0      157 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTipLossPrandtl.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.711840 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/
+-rw-rw-rw-   0        0        0       22 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/.gitignore
+-rw-rw-rw-   0        0        0     5365 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m
+-rw-rw-rw-   0        0        0     3893 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m
+-rw-rw-rw-   0        0        0     3214 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/OptiminumParam.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.711840 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/
+-rw-rw-rw-   0        0        0     2199 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Exercise4bnew.m
+-rw-rw-rw-   0        0        0      807 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test1OptiminumParam.m
+-rw-rw-rw-   0        0        0     1902 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m
+-rw-rw-rw-   0        0        0     3369 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambda.m
+-rw-rw-rw-   0        0        0     3671 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambdaClCd.m
+-rw-rw-rw-   0        0        0     1080 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test5PowerCurve.m
+-rw-rw-rw-   0        0        0     8332 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/fBEM_backup.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.727461 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/
+-rw-rw-rw-   0        0        0     4069 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/BEMfunction.m
+-rw-rw-rw-   0        0        0     1428 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise1.m
+-rw-rw-rw-   0        0        0     1361 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise2new.m
+-rw-rw-rw-   0        0        0     3217 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise3new.m
+-rw-rw-rw-   0        0        0     1666 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/GlauertSolutions.m
+-rw-rw-rw-   0        0        0     1970 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/fakeBEM.m
+-rw-rw-rw-   0        0        0      602 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/getOptimizedParameters.m
+-rw-rw-rw-   0        0        0       79 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/getRelationAX.m
+-rw-rw-rw-   0        0        0      149 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/getThrustFromBlade.m
+-rw-rw-rw-   0        0        0      341 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/getTorqueFromBlade.m
+-rw-rw-rw-   0        0        0      813 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/loading.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.749592 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/
+-rw-rw-rw-   0        0        0       22 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/.gitignore
+-rw-rw-rw-   0        0        0    10037 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/TheodorsenTheory.m
+-rw-rw-rw-   0        0        0     6644 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/TheodorsenTheory_Expansion_DevPhase0.m
+-rw-rw-rw-   0        0        0     6508 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m
+-rw-rw-rw-   0        0        0      202 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/VERSIONS
+-rw-rw-rw-   0        0        0      730 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/WaldWakeRotorMapping.m
+-rw-rw-rw-   0        0        0     1376 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenAtOperatingPoint.m
+-rw-rw-rw-   0        0        0     2341 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenExpansion.m
+-rw-rw-rw-   0        0        0     1933 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenExpansionWrap.m
+-rw-rw-rw-   0        0        0     3648 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenFarWakeParams.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.749592 welib-1.0.0/welib/wt_theory/matlab/VortexCylinder/
+-rw-rw-rw-   0        0        0       39 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/VortexCylinder/.gitignore
+-rw-rw-rw-   0        0        0     3513 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/VortexCylinder/VortexCylinder.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.749592 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/
+-rw-rw-rw-   0        0        0       22 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/.gitignore
+-rw-rw-rw-   0        0        0     5412 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_CodesAndTheory.m
+-rw-rw-rw-   0        0        0     1978 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_ForEwan.m
+-rw-rw-rw-   0        0        0     1508 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_TheoryOnly.m
+-rw-rw-rw-   0        0        0      600 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionFranksen.m
+-rw-rw-rw-   0        0        0      563 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionRathmann.m
+-rw-rw-rw-   0        0        0     1166 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionVortexRings.m
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.765217 welib-1.0.0/welib/wt_theory/tests/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/tests/__init__.py
+-rw-rw-rw-   0        0        0     1187 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0     1056 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/tests/test_wakeexpansion.py
+-rw-rw-rw-   0        0        0     4128 2023-06-15 23:48:51.000000 welib-1.0.0/welib/wt_theory/wakeexpansion.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.796469 welib-1.0.0/welib/yams/
+-rw-rw-rw-   0        0        0       33 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/.gitignore
+-rw-rw-rw-   0        0        0     7294 2019-07-20 04:43:49.000000 welib-1.0.0/welib/yams/DEBUG.py
+-rw-rw-rw-   0        0        0    16294 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/FNSB_FAST.py
+-rw-rw-rw-   0        0        0      792 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/README.md
+-rw-rw-rw-   0        0        0    20071 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/TNSB.py
+-rw-rw-rw-   0        0        0    14284 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/TNSB_FAST.py
+-rw-rw-rw-   0        0        0       47 2020-12-20 02:57:34.000000 welib-1.0.0/welib/yams/__init__.py
+-rw-rw-rw-   0        0        0    32931 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/bodies.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.796469 welib-1.0.0/welib/yams/derivations/
+-rw-rw-rw-   0        0        0     5309 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/derivations/Inertia_Rotor.ipynb
+-rw-rw-rw-   0        0        0       85 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/derivations/README.md
+-rw-rw-rw-   0        0        0     6143 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/derivations/RigidBodyDyn_SkewMatrix.ipynb
+-rw-rw-rw-   0        0        0     8945 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/derivations/RotationMatricesAndCoordinates.ipynb
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.796469 welib-1.0.0/welib/yams/examples/
+-rw-rw-rw-   0        0        0     1581 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples/Tower_MassMatrix_ShapeFunctions.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.812084 welib-1.0.0/welib/yams/examples_numeric_recursive/
+-rw-rw-rw-   0        0        0     4593 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_numeric_recursive/Tower_SubBeams.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.827711 welib-1.0.0/welib/yams/examples_symbolic_kane/
+-rw-rw-rw-   0        0        0       52 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/.gitignore
+-rw-rw-rw-   0        0        0     1213 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L1_Top.py
+-rw-rw-rw-   0        0        0     3919 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_1DOF_MassSpringDamper.ipynb
+-rw-rw-rw-   0        0        0     7645 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_1DOF_Pendulum.ipynb
+-rw-rw-rw-   0        0        0     9617 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_2DOF_DoublePendulum.ipynb
+-rw-rw-rw-   0        0        0     4404 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_2DOF_MassSpringDamper.ipynb
+-rw-rw-rw-   0        0        0     5978 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_2DOF_PendulumOnACart.ipynb
+-rw-rw-rw-   0        0        0     8291 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_3DOF_Top.ipynb
+-rw-rw-rw-   0        0        0    12574 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L2_5DOF_SimplifiedCampbell.ipynb
+-rw-rw-rw-   0        0        0     7421 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_BladeModels.py
+-rw-rw-rw-   0        0        0    10685 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_FXTXRNA_Simulation.py
+-rw-rw-rw-   0        0        0     8098 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.ipynb
+-rw-rw-rw-   0        0        0     7883 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.py
+-rw-rw-rw-   0        0        0     6861 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_OneRigidBody_SparHydro.py
+-rw-rw-rw-   0        0        0    13250 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/L3_OneRigidBody_YAMSW.ipynb
+-rw-rw-rw-   0        0        0     1665 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_kane/README.md
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.827711 welib-1.0.0/welib/yams/examples_symbolic_recursive/
+-rw-rw-rw-   0        0        0     9738 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/examples_symbolic_recursive/T1NRNA_yams_rec.py
+-rw-rw-rw-   0        0        0    58337 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/flexibility.py
+-rw-rw-rw-   0        0        0     2387 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/kinematics.py
+-rw-rw-rw-   0        0        0     6549 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/kinetics.py
+-rw-rw-rw-   0        0        0      792 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/kinetics_sympy.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.849847 welib-1.0.0/welib/yams/models/
+-rw-rw-rw-   0        0        0    30417 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/models/FTNSB_sympy.py
+-rw-rw-rw-   0        0        0     3672 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/models/FTNSB_sympy_symbols.py
+-rw-rw-rw-   0        0        0     8383 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/models/OneRigidBody_sympy.py
+-rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-1.0.0/welib/yams/models/__init__.py
+-rw-rw-rw-   0        0        0     3809 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/models/generator.py
+-rw-rw-rw-   0        0        0     7069 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/models/generator_oneRigidBody.py
+-rw-rw-rw-   0        0        0     8518 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/models/packman.py
+-rw-rw-rw-   0        0        0    20012 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/models/simulator.py
+-rw-rw-rw-   0        0        0     2694 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/models/utils.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.377492 welib-1.0.0/welib/yams/papers/
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.858456 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/
+-rw-rw-rw-   0        0        0        7 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/.gitignore
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.858456 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/
+-rw-rw-rw-   0        0        0     6971 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.fst
+-rw-rw-rw-   0        0        0     2932 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.outb
+-rw-rw-rw-   0        0        0    11519 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Spar_ED_ForED.dat
+-rw-rw-rw-   0        0        0     4746 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1_yams_model.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.858456 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/
+-rw-rw-rw-   0        0        0     6957 2023-03-16 02:11:10.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.fst
+-rw-rw-rw-   0        0        0     4748 2023-03-16 02:11:10.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.outb
+-rw-rw-rw-   0        0        0    11568 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Spar_ED_ForED.dat
+-rw-rw-rw-   0        0        0     4869 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_yams_model.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.858456 welib-1.0.0/welib/yams/partdyn/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/__init__.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.874084 welib-1.0.0/welib/yams/partdyn/examples/
+-rw-rw-rw-   0        0        0     3688 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/examples/OnePart_FreeFall.py
+-rw-rw-rw-   0        0        0     2382 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/examples/ThreePart_Gravitation.py
+-rw-rw-rw-   0        0        0     2568 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/examples/ThreeSprings.py
+-rw-rw-rw-   0        0        0     6138 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/examples/TwoPart_Orbits.py
+-rw-rw-rw-   0        0        0     2100 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/examples/TwoPart_Springs.py
+-rw-rw-rw-   0        0        0    18187 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/part.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.874084 welib-1.0.0/welib/yams/partdyn/tests/
+-rw-rw-rw-   0        0        0        0 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/tests/__init__.py
+-rw-rw-rw-   0        0        0     1195 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/partdyn/tests/test_run_Examples.py
+-rw-rw-rw-   0        0        0    17972 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/rotations.py
+-rw-rw-rw-   0        0        0    30878 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/sid.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.889712 welib-1.0.0/welib/yams/tests/
+-rw-rw-rw-   0        0        0        0 2019-07-20 20:20:08.000000 welib-1.0.0/welib/yams/tests/__init__.py
+-rw-rw-rw-   0        0        0     3517 2022-12-06 21:34:09.000000 welib-1.0.0/welib/yams/tests/test_bodies.py
+-rw-rw-rw-   0        0        0    24439 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests/test_flexibility.py
+-rw-rw-rw-   0        0        0     5298 2020-12-30 22:56:18.000000 welib-1.0.0/welib/yams/tests/test_rotations.py
+-rw-rw-rw-   0        0        0     3726 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/tests/test_sectionloads.py
+-rw-rw-rw-   0        0        0     8410 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests/test_sid.py
+-rw-rw-rw-   0        0        0     1701 2020-12-20 03:46:48.000000 welib-1.0.0/welib/yams/tests/test_utils.py
+-rw-rw-rw-   0        0        0    13997 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/tests/test_windturbine.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.905329 welib-1.0.0/welib/yams/tests_numeric_recursive/
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_numeric_recursive/__init__.py
+-rw-rw-rw-   0        0        0    12742 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_numeric_recursive/test_TNSB_FAST.py
+-rw-rw-rw-   0        0        0     7540 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_numeric_recursive/test_TNSB_article.py
+-rw-rw-rw-   0        0        0     2363 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_numeric_recursive/test_yams.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:28.905329 welib-1.0.0/welib/yams/tests_symbolic_kane/
+-rw-rw-rw-   0        0        0    13976 2022-04-13 16:07:18.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/_F2T1RNA.py
+-rw-rw-rw-   0        0        0        0 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/__init__.py
+-rw-rw-rw-   0        0        0     1186 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T0N2S1.py
+-rw-rw-rw-   0        0        0     3008 2022-12-06 21:47:38.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T1RNA.py
+-rw-rw-rw-   0        0        0     1217 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/test_run_Examples.py
+-rw-rw-rw-   0        0        0     7182 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/test_yams_sympy_rigid.py
+-rw-rw-rw-   0        0        0     6353 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/tests_symbolic_kane/test_yams_sympy_tools.py
+-rw-rw-rw-   0        0        0     9467 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/utils.py
+-rw-rw-rw-   0        0        0    55091 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/windturbine.py
+-rw-rw-rw-   0        0        0    35327 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/yams.py
+-rw-rw-rw-   0        0        0    57137 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/yams_kane.py
+-rw-rw-rw-   0        0        0    74968 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/yams_sympy.py
+-rw-rw-rw-   0        0        0    52701 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/yams_sympy_model.py
+-rw-rw-rw-   0        0        0    30197 2023-06-15 23:48:51.000000 welib-1.0.0/welib/yams/yams_sympy_tools.py
+drwxrwxrwx   0        0        0        0 2023-06-16 18:17:27.562384 welib-1.0.0/welib.egg-info/
+-rw-rw-rw-   0        0        0     1348 2023-06-16 18:17:25.000000 welib-1.0.0/welib.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    39035 2023-06-16 18:17:27.000000 welib-1.0.0/welib.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-06-16 18:17:25.000000 welib-1.0.0/welib.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        2 2022-07-05 18:24:02.000000 welib-1.0.0/welib.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0      128 2023-06-16 18:17:25.000000 welib-1.0.0/welib.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2023-06-16 18:17:25.000000 welib-1.0.0/welib.egg-info/top_level.txt
```

### Comparing `welib-0.0.2/.github/workflows/tests.yml` & `welib-1.0.0/.github/workflows/tests.yml`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,23 @@
     types: [opened, synchronize] #labeled, assigned]
 
 jobs:
   build-and-test:
     strategy:
       matrix:
         include:
-          - os: ubuntu-18.04
+          - os: ubuntu-22.04
             python-version: 3.7
             python: xvfb-run python3
             pip_arg: ""
-          - os: ubuntu-18.04
+          - os: ubuntu-22.04
             python-version: 3.8
             python: xvfb-run python3
             pip_arg: ""
-          - os: macos-10.15
+          - os: macos-11
             python-version: 3.8
             python: python3
             pip_arg: ""
           - os: windows-2019
             python-version: 3.8
             python: python
             pip_arg: --user
```

### Comparing `welib-0.0.2/LICENSE.TXT` & `welib-1.0.0/LICENSE.TXT`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/Makefile` & `welib-1.0.0/Makefile`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/PKG-INFO` & `welib-1.0.0/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: welib
-Version: 0.0.2
+Version: 1.0.0
 Summary: Wind Energy Library
 Home-page: http://github.com/ebranlard/welib/
 Author: Emmanuel Branlard
 Author-email: lastname@gmail.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
```

### Comparing `welib-0.0.2/README.md` & `welib-1.0.0/README.md`

 * *Files 22% similar despite different names*

```diff
@@ -25,24 +25,32 @@
 Additional examples can be found in the `examples` and `tests` folders of the different subpackages.
 
 Click on the links to access the corresponding scripts. 
 Click on the figures to enlarge the figures.
 
 | | | | |  |
 | :-------------------------: | :-------------------------: | :-------------------------: | :-------------------------: | :-------------------------:  |
-| [MGH dynamic stall model](/welib/airfoils/examples/dynamic_stall_mhh.py) | [Oye dynamic stall model](/welib/airfoils/examples/dynamic_stall_oye.py) | [Beam - Analytical mode shapes of a beam](/welib/beams/examples/Ex1_BeamModes.py) | [Beam - Analytical mode shapes different BC](/welib/beams/examples/Ex2_BeamModesAllBC.py) | [BEM Steady - High thrust correction](/welib/BEM/examples/Example_AxialInduction.py) |
-| ![MGH dynamic stall model](/../figs/_figs/MGHDynamicStallModel.png) | ![Oye dynamic stall model](/../figs/_figs/OyeDynamicStallModel.png) | ![Beam - Analytical mode shapes of a beam](/../figs/_figs/Beam-AnalyticalModeShapesOfABeam.png) | ![Beam - Analytical mode shapes different BC](/../figs/_figs/Beam-AnalyticalModeShapesDifferentBC.png) | ![BEM Steady - High thrust correction](/../figs/_figs/BEMSteady-HighThrustCorrection.png) |
-| [BEM Steady - Performance curve](/welib/BEM/examples/Example_BEM_2.py) | [BEM Steady - CP-lambda-pitch ](/welib/BEM/examples/Example_BEM_CPLambdaPitch.py) | [BEM Unsteady - Prescribed surge motion](/welib/BEM/examples/Example_UnsteadyBEM_2_PrescribedMotion.py) | [Dynamic Inflow (Oye) - induction step](/welib/dyninflow/examples/Ex1_StepUp.py) | [FAST - interpolate radial time series](/welib/fast/examples/Example_RadialInterp.py) |
-| ![BEM Steady - Performance curve](/../figs/_figs/BEMSteady-PerformanceCurve.png) | ![BEM Steady - CP-lambda-pitch ](/../figs/_figs/BEMSteady-CP-lambda-pitch.png) | ![BEM Unsteady - Prescribed surge motion](/../figs/_figs/BEMUnsteady-PrescribedSurgeMotion.png) | ![Dynamic Inflow (Oye) - induction step](/../figs/_figs/DynamicInflow(Oye)-InductionStep.png) | ![FAST - interpolate radial time series](/../figs/_figs/FAST-InterpolateRadialTimeSeries.png) |
-| [FAST - Average radial outputs](/welib/fast/examples/Example_RadialPostPro.py) | [FEM - mode shapes of a beam](/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py) | [Hydro - Wave kinematics](/welib/hydro/examples/Ex1_WaveKinematics.py) | [Hydro - Jonswap spectrum](/welib/hydro/examples/Ex2_Jonswap_spectrum.py) | [Hydro - wave generation](/welib/hydro/examples/Ex3_WaveTimeSeries.py) |
-| ![FAST - Average radial outputs](/../figs/_figs/FAST-AverageRadialOutputs.png) | ![FEM - mode shapes of a beam](/../figs/_figs/FEM-ModeShapesOfABeam.png) | ![Hydro - Wave kinematics](/../figs/_figs/Hydro-WaveKinematics.png) | ![Hydro - Jonswap spectrum](/../figs/_figs/Hydro-JonswapSpectrum.png) | ![Hydro - wave generation](/../figs/_figs/Hydro-WaveGeneration.png) |
-| [Hydro - Morison loads on monopile](/welib/hydro/examples/Ex4_WaveLoads.py) | [Plot - 3D blades](/welib/plot/examples/Plot_3D_blades.py) | [IEC Standards - Turbulence classes](/welib/standards/examples/Ex1_TurbulenceClasses.py) | [IEC Standards - Extreme operating gusts](/welib/standards/examples/Ex2_EOG.py) | [System - 2nd order - forced vibrations](/welib/system/examples/MassSpringDamper_ForcedVibrations.py) |
-| ![Hydro - Morison loads on monopile](/../figs/_figs/Hydro-MorisonLoadsOnMonopile.png) | ![Plot - 3D blades](/../figs/_figs/Plot-3DBlades.png) | ![IEC Standards - Turbulence classes](/../figs/_figs/IECStandards-TurbulenceClasses.png) | ![IEC Standards - Extreme operating gusts](/../figs/_figs/IECStandards-ExtremeOperatingGusts.png) | ![System - 2nd order - forced vibrations](/../figs/_figs/System-2ndOrder-ForcedVibrations.png) |
-| [3D pendulum - motion](/welib/system/examples/pendulum_3d.py) | [Signal - Correlation coefficient](/welib/tools/examples/ExampleCorrelation.py) | [Signal - FFT](/welib/tools/examples/Example_FFT.py) | [Wind - wind generation at point](/welib/wind/examples/WindGenerationAtPoint.py) |  |
-| ![3D pendulum - motion](/../figs/_figs/3DPendulum-Motion.png) | ![Signal - Correlation coefficient](/../figs/_figs/Signal-CorrelationCoefficient.png) | ![Signal - FFT](/../figs/_figs/Signal-FFT.png) | ![Wind - wind generation at point](/../figs/_figs/Wind-WindGenerationAtPoint.png) |  |
+| [Airfoils - 3D correction](/welib/airfoils/examples/correction3D.py) | [Airfoils - MGH dynamic stall model](/welib/airfoils/examples/dynamic_stall_mhh.py) | [Airfoils - Oye dynamic stall model](/welib/airfoils/examples/dynamic_stall_oye.py) | [Airfoils - Wagner function](/welib/airfoils/examples/wagner.py) | [Beam - Analytical mode shapes of a beam](/welib/beams/examples/Ex1_BeamModes.py) |
+| ![Airfoils - 3D correction](/../figs/_figs/Airfoils-3DCorrection.png) | ![Airfoils - MGH dynamic stall model](/../figs/_figs/Airfoils-MGHDynamicStallModel.png) | ![Airfoils - Oye dynamic stall model](/../figs/_figs/Airfoils-OyeDynamicStallModel.png) | ![Airfoils - Wagner function](/../figs/_figs/Airfoils-WagnerFunction.png) | ![Beam - Analytical mode shapes of a beam](/../figs/_figs/Beam-AnalyticalModeShapesOfABeam.png) |
+| [Beam - Analytical mode shapes different BC](/welib/beams/examples/Ex2_BeamModesAllBC.py) | [BEM Steady - High thrust correction](/welib/BEM/examples/Example_AxialInduction.py) | [BEM Steady - Performance curve](/welib/BEM/examples/Example_BEM_2.py) | [BEM Steady - CP-lambda-pitch ](/welib/BEM/examples/Example_BEM_CPLambdaPitch.py) | [BEM Theory - Ideal rotor planform](/welib/BEM/examples/Example_IdealRotor.py) |
+| ![Beam - Analytical mode shapes different BC](/../figs/_figs/Beam-AnalyticalModeShapesDifferentBC.png) | ![BEM Steady - High thrust correction](/../figs/_figs/BEMSteady-HighThrustCorrection.png) | ![BEM Steady - Performance curve](/../figs/_figs/BEMSteady-PerformanceCurve.png) | ![BEM Steady - CP-lambda-pitch ](/../figs/_figs/BEMSteady-CP-lambda-pitch.png) | ![BEM Theory - Ideal rotor planform](/../figs/_figs/BEMTheory-IdealRotorPlanform.png) |
+| [BEM Unsteady - Prescribed surge motion](/welib/BEM/examples/Example_UnsteadyBEM_2_PrescribedMotion.py) | [Dynamic Inflow (Oye) - induction step](/welib/dyninflow/examples/Ex1_StepUp.py) | [FAST - interpolate radial time series](/welib/fast/examples/Example_RadialInterp.py) | [FAST - Average radial outputs](/welib/fast/examples/Example_RadialPostPro.py) | [FEM - mode shapes of tower](/welib/FEM/examples/Beam_ModeShapes_Tower.py) |
+| ![BEM Unsteady - Prescribed surge motion](/../figs/_figs/BEMUnsteady-PrescribedSurgeMotion.png) | ![Dynamic Inflow (Oye) - induction step](/../figs/_figs/DynamicInflow(Oye)-InductionStep.png) | ![FAST - interpolate radial time series](/../figs/_figs/FAST-InterpolateRadialTimeSeries.png) | ![FAST - Average radial outputs](/../figs/_figs/FAST-AverageRadialOutputs.png) | ![FEM - mode shapes of tower](/../figs/_figs/FEM-ModeShapesOfTower.png) |
+| [FEM - mode shapes of a beam](/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py) | [Hydro - Wave kinematics](/welib/hydro/examples/Ex1_WaveKinematics.py) | [Hydro - Jonswap spectrum](/welib/hydro/examples/Ex2_Jonswap_spectrum.py) | [Hydro - wave generation](/welib/hydro/examples/Ex3_WaveTimeSeries.py) | [Hydro - Morison loads on monopile](/welib/hydro/examples/Ex4_WaveLoads.py) |
+| ![FEM - mode shapes of a beam](/../figs/_figs/FEM-ModeShapesOfABeam.png) | ![Hydro - Wave kinematics](/../figs/_figs/Hydro-WaveKinematics.png) | ![Hydro - Jonswap spectrum](/../figs/_figs/Hydro-JonswapSpectrum.png) | ![Hydro - wave generation](/../figs/_figs/Hydro-WaveGeneration.png) | ![Hydro - Morison loads on monopile](/../figs/_figs/Hydro-MorisonLoadsOnMonopile.png) |
+| [Plot - 3D blades](/welib/plot/examples/Plot_3D_blades.py) | [IEC Standards - Turbulence classes](/welib/standards/examples/Ex1_TurbulenceClasses.py) | [IEC Standards - Extreme operating gusts](/welib/standards/examples/Ex2_EOG.py) | [System - Lorenz attractor](/welib/system/examples/Lorenz.py) | [System - 2nd order - forced vibrations](/welib/system/examples/MassSpringDamper_ForcedVibrations.py) |
+| ![Plot - 3D blades](/../figs/_figs/Plot-3DBlades.png) | ![IEC Standards - Turbulence classes](/../figs/_figs/IECStandards-TurbulenceClasses.png) | ![IEC Standards - Extreme operating gusts](/../figs/_figs/IECStandards-ExtremeOperatingGusts.png) | ![System - Lorenz attractor](/../figs/_figs/System-LorenzAttractor.png) | ![System - 2nd order - forced vibrations](/../figs/_figs/System-2ndOrder-ForcedVibrations.png) |
+| [System -  LTI Bode plot - 2nd order mass spring damper](/welib/system/examples/MassSpringDamper_StateSpace_FreqDomain.py) | [System - 3D pendulum - motion](/welib/system/examples/pendulum_3d.py) | [System - 2nd order - Responses](/welib/system/examples/StepResponse.py) | [Signal - Correlation coefficient](/welib/tools/examples/ExampleCorrelation.py) | [Signal - FFT](/welib/tools/examples/Example_FFT.py) |
+| ![System -  LTI Bode plot - 2nd order mass spring damper](/../figs/_figs/System-LTIBodePlot-2ndOrderMassSpringDamper.png) | ![System - 3D pendulum - motion](/../figs/_figs/System-3DPendulum-Motion.png) | ![System - 2nd order - Responses](/../figs/_figs/System-2ndOrder-Responses.png) | ![Signal - Correlation coefficient](/../figs/_figs/Signal-CorrelationCoefficient.png) | ![Signal - FFT](/../figs/_figs/Signal-FFT.png) |
+| [Vortilib - Elliptical Coordinates](/welib/vortilib/elements/examples/EllipticalCoordinates.py) | [Vortilib - Inviscid Vorticity Patch](/welib/vortilib/elements/examples/InviscidVortexPatch.py) | [Vortilib - Flow about an Ellipsoid](/welib/vortilib/elements/examples/SourceEllipsoid_Plots.py) | [Vortilib - Vortex helix lifting line velocity](/welib/vortilib/elements/examples/VortexHelix.py) | [Vortilib - Vortex particle regularization](/welib/vortilib/elements/examples/VortexParticle_Regularization.py) |
+| ![Vortilib - Elliptical Coordinates](/../figs/_figs/Vortilib-EllipticalCoordinates.png) | ![Vortilib - Inviscid Vorticity Patch](/../figs/_figs/Vortilib-InviscidVorticityPatch.png) | ![Vortilib - Flow about an Ellipsoid](/../figs/_figs/Vortilib-FlowAboutAnEllipsoid.png) | ![Vortilib - Vortex helix lifting line velocity](/../figs/_figs/Vortilib-VortexHelixLiftingLineVelocity.png) | ![Vortilib - Vortex particle regularization](/../figs/_figs/Vortilib-VortexParticleRegularization.png) |
+| [Vortilib - 2D vorticity patch discretized with vortex points](/welib/vortilib/elements/examples/VortexPoint2DDistribution.py) | [Vortilib - Vortex segment regularization](/welib/vortilib/elements/examples/VortexSegment_Regularization.py) | [Vortilib - Flow about an axisymmetric vorticity surface](/welib/vortilib/elements/examples/VortexSurfaceFlowField.py) | [Wind - wind generation at point](/welib/wind/examples/WindGenerationAtPoint.py) | [WT Theory - Wake Expansion Models](/welib/wt_theory/examples/WakeExpansion.py) |
+| ![Vortilib - 2D vorticity patch discretized with vortex points](/../figs/_figs/Vortilib-2DVorticityPatchDiscretizedWithVortexPoints.png) | ![Vortilib - Vortex segment regularization](/../figs/_figs/Vortilib-VortexSegmentRegularization.png) | ![Vortilib - Flow about an axisymmetric vorticity surface](/../figs/_figs/Vortilib-FlowAboutAnAxisymmetricVorticitySurface.png) | ![Wind - wind generation at point](/../figs/_figs/Wind-WindGenerationAtPoint.png) | ![WT Theory - Wake Expansion Models](/../figs/_figs/WTTheory-WakeExpansionModels.png) |
+| [WT Theory - Induced velocity vs Wake length](/welib/wt_theory/examples/WakeLengthInducedVelocity.py) | [PartDyn - Gravitational and spring interactions](/welib/yams/partdyn/examples/ThreePart_Gravitation.py) | [PartDyn - Gravitational interaction - Moon Orbit](/welib/yams/partdyn/examples/TwoPart_Orbits.py) |  |  |
+| ![WT Theory - Induced velocity vs Wake length](/../figs/_figs/WTTheory-InducedVelocityVsWakeLength.png) | ![PartDyn - Gravitational and spring interactions](/../figs/_figs/PartDyn-GravitationalAndSpringInteractions.png) | ![PartDyn - Gravitational interaction - Moon Orbit](/../figs/_figs/PartDyn-GravitationalInteraction-MoonOrbit.png) |  |  |
 
 # Examples of application
 
 
 You can have a look at the example gallery below for direct links to examples and associated plots.
 
 - Aerodynamic applications (package `airfoils`, `BEM`):
```

### Comparing `welib-0.0.2/data/Hawc2/BD.dat` & `welib-1.0.0/data/Hawc2/BD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Hawc2/Blade_Planform_Hawc2.csv` & `welib-1.0.0/data/Hawc2/Blade_Planform_Hawc2.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Hawc2/Blade_Structural_Hawc2.csv` & `welib-1.0.0/data/Hawc2/Blade_Structural_Hawc2.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/ED_Blade_Light.dat` & `welib-1.0.0/data/Monopile/ED_Blade_Light.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/ED_Tower100_Light.dat` & `welib-1.0.0/data/Monopile/ED_Tower100_Light.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/MT100_ED.dat` & `welib-1.0.0/data/Monopile/MT100_ED.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/MT100_HD_RegularWave.dat` & `welib-1.0.0/data/Monopile/MT100_HD_RegularWave.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/MT100_HD_Still.dat` & `welib-1.0.0/data/Monopile/MT100_HD_Still.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/MT100_LoadsMotions.csv` & `welib-1.0.0/data/Monopile/MT100_LoadsMotions.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/MT100_SD.dat` & `welib-1.0.0/data/Monopile/MT100_SD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/Main_MT100_RegularWave.fst` & `welib-1.0.0/data/Monopile/Main_MT100_RegularWave.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Monopile/README.py` & `welib-1.0.0/data/Monopile/README.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/Cylinder2_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU21_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU25_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU30_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU35_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/DU40_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17_coords.txt` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/Airfoils/NACA64_A17_coords.txt`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_IW.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_IW_Step.dat`

 * *Files 18% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 ------- InflowWind v3.01.* INPUT FILE -------------------------------------------------------------------------
 12 m/s turbulent winds on 31x31 FF grid and tower for FAST CertTests #18, #19, #21, #22, #23, and #24
 ---------------------------------------------------------------------------------------------------------------
 False         Echo           - Echo input data to <RootName>.ech (flag)
-          1   WindType       - switch for wind file type (1=steady; 2=uniform; 3=binary TurbSim FF; 4=binary Bladed-style FF; 5=HAWC format; 6=User defined)
-          0   PropagationDir - Direction of wind propagation (meteoroligical rotation from aligned with X (positive rotates towards -Y) -- degrees)
-          0   VFlowAng       - 
+          2   WindType       - switch for wind file type (1=steady; 2=uniform; 3=binary TurbSim FF; 4=binary Bladed-style FF; 5=HAWC format; 6=User defined)
+          0   PropagationDir - Direction of wind propagation (meteorological rotation from aligned with X (positive rotates towards -Y) -- degrees) (not used for native Bladed format WindType=7)
+          0   VFlowAng       - Upflow angle (degrees) (not used for native Bladed format WindType=7)
           1   NWindVel       - Number of points to output the wind velocity    (0 to 9)
           0   WindVxiList    - List of coordinates in the inertial X direction (m)
           0   WindVyiList    - List of coordinates in the inertial Y direction (m)
          90   WindVziList    - List of coordinates in the inertial Z direction (m)
 ================== Parameters for Steady Wind Conditions [used only for WindType = 1] =========================
-         10   HWindSpeed     - Horizontal windspeed                            (m/s)
-         90   RefHt         - Reference height for horizontal wind speed      (m)
-        0.0   PLexp          - Power law exponent                              (-)
+          1   HWindSpeed     - Horizontal wind speed                           (m/s)
+         90   RefHt          - Reference height for horizontal wind speed      (m)
+        0.2   PLexp          - Power law exponent                              (-)
 ================== Parameters for Uniform wind file   [used only for WindType = 2] ============================
-"../Wind/WindStep.wnd"    FileName_Uni       - Filename of time series data for uniform wind field.      (-)
-         90   RefHt_Uni         - Reference height for horizontal wind speed                (m)
+"../Wind/WindStep.wnd"    Filename_Uni  - Filename of time series data for uniform wind field.      (-)
+         90   RefHt_Uni      - Reference height for horizontal wind speed                (m)
      125.88   RefLength      - Reference length for linear horizontal and vertical sheer (-)
 ================== Parameters for Binary TurbSim Full-Field files   [used only for WindType = 3] ==============
 "NaN"    FileName_BTS      - Name of the Full field wind file to use (.bts)
 ================== Parameters for Binary Bladed-style Full-Field files   [used only for WindType = 4] =========
 "NaN"    FilenameRoot   - Rootname of the full-field wind file to use (.wnd, .sum)
 False         TowerFile      - Have tower file (.twr) (flag)
 ================== Parameters for HAWC-format binary files  [Only used with WindType = 5] =====================
@@ -28,29 +28,42 @@
 "NaN"    FileName_w     - name of the file containing the w-component fluctuating wind (.bin)
          64   nx             - number of grids in the x direction (in the 3 files above) (-)
          32   ny             - number of grids in the y direction (in the 3 files above) (-)
          32   nz             - number of grids in the z direction (in the 3 files above) (-)
          16   dx             - distance (in meters) between points in the x direction    (m)
           3   dy             - distance (in meters) between points in the y direction    (m)
           3   dz             - distance (in meters) between points in the z direction    (m)
-         90   RefHt_HAWC     - reference height; the height (in meters) of the vertical center of the grid (m)
+         90   RefHt_Hawc     - reference height; the height (in meters) of the vertical center of the grid (m)
   -------------   Scaling parameters for turbulence   ---------------------------------------------------------
           1   ScaleMethod    - Turbulence scaling method   [0 = none, 1 = direct scaling, 2 = calculate scaling factor based on a desired standard deviation]
           1   SFx            - Turbulence scaling factor for the x direction (-)   [ScaleMethod=1]
           1   SFy            - Turbulence scaling factor for the y direction (-)   [ScaleMethod=1]
           1   SFz            - Turbulence scaling factor for the z direction (-)   [ScaleMethod=1]
          12   SigmaFx        - Turbulence standard deviation to calculate scaling from in x direction (m/s)    [ScaleMethod=2]
           8   SigmaFy        - Turbulence standard deviation to calculate scaling from in y direction (m/s)    [ScaleMethod=2]
           2   SigmaFz        - Turbulence standard deviation to calculate scaling from in z direction (m/s)    [ScaleMethod=2]
   -------------   Mean wind profile parameters (added to HAWC-format files)   ---------------------------------
           5   URef           - Mean u-component wind speed at the reference height (m/s)
           2   WindProfile    - Wind profile type (0=constant;1=logarithmic,2=power law)
-        0.2   PLExp_HAWC     - Power law exponent (-) (used for PL wind profile type only)
+        0.2   PLExp_Hawc     - Power law exponent (-) (used for PL wind profile type only)
        0.03   Z0             - Surface roughness length (m) (used for LG wind profile type only)
-       0      XOffset
+          0   XOffset        - Initial offset in +x direction (shift of wind box)
+================== LIDAR Parameters ===========================================================================
+          0   SensorType          - Switch for lidar configuration (0 = None, 1 = Single Point Beam(s), 2 = Continuous, 3 = Pulsed)
+          0   NumPulseGate        - Number of lidar measurement gates (used when SensorType = 3)
+         30   PulseSpacing        - Distance between range gates (m) (used when SensorType = 3)
+          0   NumBeam             - Number of lidar measurement beams (0-5)(used when SensorType = 1)
+       -200   FocalDistanceX      - Focal distance co-ordinates of the lidar beam in the x direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+          0   FocalDistanceY      - Focal distance co-ordinates of the lidar beam in the y direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+          0   FocalDistanceZ      - Focal distance co-ordinates of the lidar beam in the z direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+0.0 0.0 0.0   RotorApexOffsetPos  - Offset of the lidar from hub height (m)
+         17   URefLid             - Reference average wind speed for the lidar[m/s]
+       0.25   MeasurementInterval - Time between each measurement [s]
+      False   LidRadialVel        - TRUE => return radial component, FALSE => return 'x' direction estimate
+          1   ConsiderHubMotion   - Flag whether to consider the hub motion's impact on Lidar measurements
 ====================== OUTPUT ==================================================
 False         SumPrint     - Print summary data to <RootName>.IfW.sum (flag)
               OutList      - The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
 "Wind1VelX"               X-direction wind velocity at point WindList(1)
 "Wind1VelY"               Y-direction wind velocity at point WindList(1)
 "Wind1VelZ"               Z-direction wind velocity at point WindList(1)
 END of input file (the word "END" must appear in the first 3 columns of this last OutList line)
```

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_IW_Step.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_IW.dat`

 * *Files 18% similar despite different names*

```diff
@@ -1,54 +1,70 @@
 ------- InflowWind v3.01.* INPUT FILE -------------------------------------------------------------------------
 12 m/s turbulent winds on 31x31 FF grid and tower for FAST CertTests #18, #19, #21, #22, #23, and #24
 ---------------------------------------------------------------------------------------------------------------
 False         Echo           - Echo input data to <RootName>.ech (flag)
-          2   WindType       - switch for wind file type (1=steady; 2=uniform; 3=binary TurbSim FF; 4=binary Bladed-style FF; 5=HAWC format; 6=User defined)
-          0   PropagationDir - Direction of wind propagation (meteoroligical rotation from aligned with X (positive rotates towards -Y) -- degrees)
+          1   WindType       - switch for wind file type (1=steady; 2=uniform; 3=binary TurbSim FF; 4=binary Bladed-style FF; 5=HAWC format; 6=User defined)
+          0   PropagationDir - Direction of wind propagation (meteorological rotation from aligned with X (positive rotates towards -Y) -- degrees) (not used for native Bladed format WindType=7)
+          0   VFlowAng       - Upflow angle (degrees) (not used for native Bladed format WindType=7)
+      False   VelInterpCubic - Use cubic interpolation for velocity in time (false=linear, true=cubic) [Used with WindType=2,3,4,5,7]
           1   NWindVel       - Number of points to output the wind velocity    (0 to 9)
           0   WindVxiList    - List of coordinates in the inertial X direction (m)
           0   WindVyiList    - List of coordinates in the inertial Y direction (m)
          90   WindVziList    - List of coordinates in the inertial Z direction (m)
 ================== Parameters for Steady Wind Conditions [used only for WindType = 1] =========================
-          1   HWindSpeed     - Horizontal windspeed                            (m/s)
-         90   RefHt1         - Reference height for horizontal wind speed      (m)
-        0.2   PLexp          - Power law exponent                              (-)
+         10   HWindSpeed     - Horizontal wind speed                           (m/s)
+         90   RefHt         - Reference height for horizontal wind speed      (m)
+        0.0   PLexp          - Power law exponent                              (-)
 ================== Parameters for Uniform wind file   [used only for WindType = 2] ============================
-"../Wind/WindStep.wnd"    Filename       - Filename of time series data for uniform wind field.      (-)
-         90   RefHt2         - Reference height for horizontal wind speed                (m)
+"../Wind/WindStep.wnd"    FileName_Uni       - Filename of time series data for uniform wind field.      (-)
+         90   RefHt_Uni         - Reference height for horizontal wind speed                (m)
      125.88   RefLength      - Reference length for linear horizontal and vertical sheer (-)
 ================== Parameters for Binary TurbSim Full-Field files   [used only for WindType = 3] ==============
-"NaN"    Filename3      - Name of the Full field wind file to use (.bts)
+"NaN"    FileName_BTS      - Name of the Full field wind file to use (.bts)
 ================== Parameters for Binary Bladed-style Full-Field files   [used only for WindType = 4] =========
 "NaN"    FilenameRoot   - Rootname of the full-field wind file to use (.wnd, .sum)
 False         TowerFile      - Have tower file (.twr) (flag)
 ================== Parameters for HAWC-format binary files  [Only used with WindType = 5] =====================
 "NaN"    FileName_u     - name of the file containing the u-component fluctuating wind (.bin)
 "NaN"    FileName_v     - name of the file containing the v-component fluctuating wind (.bin)
 "NaN"    FileName_w     - name of the file containing the w-component fluctuating wind (.bin)
          64   nx             - number of grids in the x direction (in the 3 files above) (-)
          32   ny             - number of grids in the y direction (in the 3 files above) (-)
          32   nz             - number of grids in the z direction (in the 3 files above) (-)
          16   dx             - distance (in meters) between points in the x direction    (m)
           3   dy             - distance (in meters) between points in the y direction    (m)
           3   dz             - distance (in meters) between points in the z direction    (m)
-         90   RefHt5         - reference height; the height (in meters) of the vertical center of the grid (m)
+         90   RefHt_Hawc     - reference height; the height (in meters) of the vertical center of the grid (m)
   -------------   Scaling parameters for turbulence   ---------------------------------------------------------
           1   ScaleMethod    - Turbulence scaling method   [0 = none, 1 = direct scaling, 2 = calculate scaling factor based on a desired standard deviation]
           1   SFx            - Turbulence scaling factor for the x direction (-)   [ScaleMethod=1]
           1   SFy            - Turbulence scaling factor for the y direction (-)   [ScaleMethod=1]
           1   SFz            - Turbulence scaling factor for the z direction (-)   [ScaleMethod=1]
          12   SigmaFx        - Turbulence standard deviation to calculate scaling from in x direction (m/s)    [ScaleMethod=2]
           8   SigmaFy        - Turbulence standard deviation to calculate scaling from in y direction (m/s)    [ScaleMethod=2]
           2   SigmaFz        - Turbulence standard deviation to calculate scaling from in z direction (m/s)    [ScaleMethod=2]
   -------------   Mean wind profile parameters (added to HAWC-format files)   ---------------------------------
           5   URef           - Mean u-component wind speed at the reference height (m/s)
           2   WindProfile    - Wind profile type (0=constant;1=logarithmic,2=power law)
-        0.2   PLExp          - Power law exponent (-) (used for PL wind profile type only)
+        0.2   PLExp_Hawc     - Power law exponent (-) (used for PL wind profile type only)
        0.03   Z0             - Surface roughness length (m) (used for LG wind profile type only)
+          0   XOffset        - Initial offset in +x direction (shift of wind box)
+================== LIDAR Parameters ===========================================================================
+          0   SensorType          - Switch for lidar configuration (0 = None, 1 = Single Point Beam(s), 2 = Continuous, 3 = Pulsed)
+          0   NumPulseGate        - Number of lidar measurement gates (used when SensorType = 3)
+         30   PulseSpacing        - Distance between range gates (m) (used when SensorType = 3)
+          0   NumBeam             - Number of lidar measurement beams (0-5)(used when SensorType = 1)
+       -200   FocalDistanceX      - Focal distance co-ordinates of the lidar beam in the x direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+          0   FocalDistanceY      - Focal distance co-ordinates of the lidar beam in the y direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+          0   FocalDistanceZ      - Focal distance co-ordinates of the lidar beam in the z direction (relative to hub height) (only first coordinate used for SensorType 2 and 3) (m)
+0.0 0.0 0.0   RotorApexOffsetPos  - Offset of the lidar from hub height (m)
+         17   URefLid             - Reference average wind speed for the lidar[m/s]
+       0.25   MeasurementInterval - Time between each measurement [s]
+      False   LidRadialVel        - TRUE => return radial component, FALSE => return 'x' direction estimate
+          1   ConsiderHubMotion   - Flag whether to consider the hub motion's impact on Lidar measurements
 ====================== OUTPUT ==================================================
 False         SumPrint     - Print summary data to <RootName>.IfW.sum (flag)
               OutList      - The next line(s) contains a list of output parameters.  See OutListParameters.xlsx for a listing of available output channels, (-)
 "Wind1VelX"               X-direction wind velocity at point WindList(1)
 "Wind1VelY"               Y-direction wind velocity at point WindList(1)
 "Wind1VelZ"               Z-direction wind velocity at point WindList(1)
 END of input file (the word "END" must appear in the first 3 columns of this last OutList line)
```

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_SvD.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_SvD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NREL5MW_SvD_Simple.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NREL5MW_SvD_Simple.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_AeroDyn_blade.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_AeroDyn_blade.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn_Blade.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_BeamDyn_Blade.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Blade.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Blade.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_OC4Jacket_SubDyn.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_OC4Jacket_SubDyn.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Offshore_ElastoDyn_Tower.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Offshore_ElastoDyn_Tower.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Onshore_ElastoDyn_Tower.dat` & `welib-1.0.0/data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Onshore_ElastoDyn_Tower.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/Main_Onshore.fst` & `welib-1.0.0/data/NREL5MW/Main_Onshore.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/Main_Onshore_DriveTrainTorsion.fst` & `welib-1.0.0/data/NREL5MW/Main_Onshore_DriveTrainTorsion.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/NREL5MW_Blade_FEM_Modes.csv` & `welib-1.0.0/data/NREL5MW/NREL5MW_Blade_FEM_Modes.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/NREL5MW_Oper.csv` & `welib-1.0.0/data/NREL5MW/NREL5MW_Oper.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/NREL5MW_Tower_Onshore_FEM_Modes.csv` & `welib-1.0.0/data/NREL5MW/NREL5MW_Tower_Onshore_FEM_Modes.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/dt_torsion/NREL5MW_ED_DT.dat` & `welib-1.0.0/data/NREL5MW/dt_torsion/NREL5MW_ED_DT.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/hawc2/Blade_Planform_Hawc2.csv` & `welib-1.0.0/data/NREL5MW/hawc2/Blade_Planform_Hawc2.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/hawc2/Blade_Structural_Hawc2.csv` & `welib-1.0.0/data/NREL5MW/hawc2/Blade_Structural_Hawc2.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/offshore/NREL5MW_ED_Offshore.dat` & `welib-1.0.0/data/NREL5MW/offshore/NREL5MW_ED_Offshore.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/offshore/NREL5MW_ED_Offshore_Legacy.dat` & `welib-1.0.0/data/NREL5MW/offshore/NREL5MW_ED_Offshore_Legacy.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/offshore/NREL5MW_HD.dat` & `welib-1.0.0/data/NREL5MW/offshore/NREL5MW_HD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/NREL5MW/onshore/NREL5MW_AD.dat` & `welib-1.0.0/data/NREL5MW/onshore/NREL5MW_AD.dat`

 * *Files 14% similar despite different names*

```diff
@@ -1,594 +1,691 @@
 00000000: 2d2d 2d2d 2d2d 2d20 4145 524f 4459 4e20  ------- AERODYN 
-00000010: 7631 352e 3034 2e2a 2049 4e50 5554 2046  v15.04.* INPUT F
-00000020: 494c 4520 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ILE ------------
+00000010: 7631 3520 666f 7220 4f70 656e 4641 5354  v15 for OpenFAST
+00000020: 2049 4e50 5554 2046 494c 4520 2d2d 2d2d   INPUT FILE ----
 00000030: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
 00000040: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00000050: 2d2d 2d2d 0d0a 4e52 454c 2035 2e30 204d  ----..NREL 5.0 M
-00000060: 5720 6f66 6673 686f 7265 2062 6173 656c  W offshore basel
-00000070: 696e 6520 6165 726f 6479 6e61 6d69 6320  ine aerodynamic 
-00000080: 696e 7075 7420 7072 6f70 6572 7469 6573  input properties
-00000090: 2e0d 0a3d 3d3d 3d3d 3d20 2047 656e 6572  ...======  Gener
-000000a0: 616c 204f 7074 696f 6e73 2020 3d3d 3d3d  al Options  ====
-000000b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000050: 2d2d 2d2d 2d2d 2d2d 2d2d 2d0d 0a4e 5245  -----------..NRE
+00000060: 4c20 352e 3020 4d57 206f 6666 7368 6f72  L 5.0 MW offshor
+00000070: 6520 6261 7365 6c69 6e65 2061 6572 6f64  e baseline aerod
+00000080: 796e 616d 6963 2069 6e70 7574 2070 726f  ynamic input pro
+00000090: 7065 7274 6965 732e 0d0a 3d3d 3d3d 3d3d  perties...======
+000000a0: 2020 4765 6e65 7261 6c20 4f70 7469 6f6e    General Option
+000000b0: 7320 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  s  =============
 000000c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000000d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 000000e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000000f0: 3d3d 3d3d 3d3d 3d3d 0d0a 4661 6c73 6520  ========..False 
-00000100: 2020 2020 2020 2020 4563 686f 2020 2020          Echo    
-00000110: 2020 2020 2020 2020 2020 202d 2045 6368             - Ech
-00000120: 6f20 7468 6520 696e 7075 7420 746f 2022  o the input to "
-00000130: 3c72 6f6f 746e 616d 653e 2e41 442e 6563  <rootname>.AD.ec
-00000140: 6822 3f20 2028 666c 6167 290d 0a22 6465  h"?  (flag).."de
-00000150: 6661 756c 7422 2020 2020 2044 5441 6572  fault"     DTAer
-00000160: 6f20 2020 2020 2020 2020 2020 2020 2d20  o             - 
-00000170: 5469 6d65 2069 6e74 6572 7661 6c20 666f  Time interval fo
-00000180: 7220 6165 726f 6479 6e61 6d69 6320 6361  r aerodynamic ca
-00000190: 6c63 756c 6174 696f 6e73 207b 6f72 2022  lculations {or "
-000001a0: 6465 6661 756c 7422 7d20 2873 290d 0a20  default"} (s).. 
-000001b0: 2020 2020 2020 2020 2031 2020 2057 616b           1   Wak
-000001c0: 654d 6f64 2020 2020 2020 2020 2020 2020  eMod            
-000001d0: 2d20 5479 7065 206f 6620 7761 6b65 2f69  - Type of wake/i
-000001e0: 6e64 7563 7469 6f6e 206d 6f64 656c 2028  nduction model (
-000001f0: 7377 6974 6368 2920 7b30 3d6e 6f6e 652c  switch) {0=none,
-00000200: 2031 3d42 454d 547d 0d0a 2020 2020 2020   1=BEMT}..      
-00000210: 2020 2020 3120 2020 4146 4165 726f 4d6f      1   AFAeroMo
-00000220: 6420 2020 2020 2020 2020 202d 2054 7970  d          - Typ
-00000230: 6520 6f66 2062 6c61 6465 2061 6972 666f  e of blade airfo
-00000240: 696c 2061 6572 6f64 796e 616d 6963 7320  il aerodynamics 
-00000250: 6d6f 6465 6c20 2873 7769 7463 6829 207b  model (switch) {
-00000260: 313d 7374 6561 6479 206d 6f64 656c 2c20  1=steady model, 
-00000270: 323d 4265 6464 6f65 732d 4c65 6973 686d  2=Beddoes-Leishm
-00000280: 616e 2075 6e73 7465 6164 7920 6d6f 6465  an unsteady mode
-00000290: 6c7d 0d0a 2020 2020 2020 2020 2020 3020  l}..          0 
-000002a0: 2020 5477 7250 6f74 656e 7420 2020 2020    TwrPotent     
-000002b0: 2020 2020 202d 2054 7970 6520 746f 7765       - Type towe
-000002c0: 7220 696e 666c 7565 6e63 6520 6f6e 2077  r influence on w
-000002d0: 696e 6420 6261 7365 6420 6f6e 2070 6f74  ind based on pot
-000002e0: 656e 7469 616c 2066 6c6f 7720 6172 6f75  ential flow arou
-000002f0: 6e64 2074 6865 2074 6f77 6572 2028 7377  nd the tower (sw
-00000300: 6974 6368 2920 7b30 3d6e 6f6e 652c 2031  itch) {0=none, 1
-00000310: 3d62 6173 656c 696e 6520 706f 7465 6e74  =baseline potent
-00000320: 6961 6c20 666c 6f77 2c20 323d 706f 7465  ial flow, 2=pote
-00000330: 6e74 6961 6c20 666c 6f77 2077 6974 6820  ntial flow with 
-00000340: 4261 6b20 636f 7272 6563 7469 6f6e 7d0d  Bak correction}.
-00000350: 0a30 2020 2020 2020 2020 2020 2020 2054  .0             T
-00000360: 7772 5368 6164 6f77 2020 2020 2020 2020  wrShadow        
-00000370: 2020 9620 4361 6c63 756c 6174 6520 746f    . Calculate to
-00000380: 7765 7220 696e 666c 7565 6e63 6520 6f6e  wer influence on
-00000390: 2077 696e 6420 6261 7365 6420 6f6e 2064   wind based on d
-000003a0: 6f77 6e73 7472 6561 6d20 746f 7765 7220  ownstream tower 
-000003b0: 7368 6164 6f77 3f20 2866 6c61 6729 0d0a  shadow? (flag)..
-000003c0: 4661 6c73 6520 2020 2020 2020 2020 5477  False         Tw
-000003d0: 7241 6572 6f20 2020 2020 2020 2020 2020  rAero           
-000003e0: 202d 2043 616c 6375 6c61 7465 2074 6f77   - Calculate tow
-000003f0: 6572 2061 6572 6f64 796e 616d 6963 206c  er aerodynamic l
-00000400: 6f61 6473 3f20 2866 6c61 6729 0d0a 4661  oads? (flag)..Fa
-00000410: 6c73 6520 2020 2020 2020 2020 4672 6f7a  lse         Froz
-00000420: 656e 5761 6b65 2020 2020 2020 2020 202d  enWake         -
-00000430: 2041 7373 756d 6520 6672 6f7a 656e 2077   Assume frozen w
-00000440: 616b 6520 6475 7269 6e67 206c 696e 6561  ake during linea
-00000450: 7269 7a61 7469 6f6e 3f20 2866 6c61 6729  rization? (flag)
-00000460: 205b 7573 6564 206f 6e6c 7920 7768 656e   [used only when
-00000470: 2057 616b 654d 6f64 3d31 2061 6e64 2077   WakeMod=1 and w
-00000480: 6865 6e20 6c69 6e65 6172 697a 696e 675d  hen linearizing]
-00000490: 0d0a 4661 6c73 6520 2020 2020 2020 2020  ..False         
-000004a0: 4361 7669 7443 6865 636b 2020 2020 2020  CavitCheck      
-000004b0: 2020 202d 2050 6572 666f 726d 2063 6176     - Perform cav
-000004c0: 6974 6174 696f 6e20 6368 6563 6b3f 2028  itation check? (
-000004d0: 666c 6167 290d 0a46 616c 7365 2020 2020  flag)..False    
-000004e0: 2020 2020 2043 6f6d 7041 4120 2020 2020       CompAA     
-000004f0: 2020 2020 2020 2020 2d20 466c 6167 2074          - Flag t
-00000500: 6f20 636f 6d70 7574 6520 4165 726f 4163  o compute AeroAc
-00000510: 6f75 7374 6963 7320 6361 6c63 756c 6174  oustics calculat
-00000520: 696f 6e20 5b6f 6e6c 7920 7573 6564 2077  ion [only used w
-00000530: 6865 6e20 5761 6b65 4d6f 643d 3120 6f72  hen WakeMod=1 or
-00000540: 2032 5d0d 0a22 756e 7573 6564 2220 2020   2].."unused"   
-00000550: 2020 2041 415f 496e 7075 7446 696c 6520     AA_InputFile 
-00000560: 2020 2020 2020 2d20 4165 726f 6163 6f75        - Aeroacou
-00000570: 7374 6963 7320 696e 7075 7420 6669 6c65  stics input file
-00000580: 0d0a 3d3d 3d3d 3d3d 2020 456e 7669 726f  ..======  Enviro
-00000590: 6e6d 656e 7461 6c20 436f 6e64 6974 696f  nmental Conditio
-000005a0: 6e73 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ns  ============
-000005b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000005c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000005d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000005e0: 3d3d 3d3d 3d3d 3d0d 0a20 2064 6566 6175  =======..  defau
-000005f0: 6c74 2020 2041 6972 4465 6e73 2020 2020  lt   AirDens    
-00000600: 2020 2020 2020 2020 2d20 4169 7220 6465          - Air de
-00000610: 6e73 6974 7920 286b 672f 6d5e 3329 0d0a  nsity (kg/m^3)..
-00000620: 2020 6465 6661 756c 7420 2020 4b69 6e56    default   KinV
-00000630: 6973 6320 2020 2020 2020 2020 2020 202d  isc            -
-00000640: 204b 696e 656d 6174 6963 2061 6972 2076   Kinematic air v
-00000650: 6973 636f 7369 7479 2028 6d5e 322f 7329  iscosity (m^2/s)
-00000660: 0d0a 2020 6465 6661 756c 7420 2020 5370  ..  default   Sp
-00000670: 6453 6f75 6e64 2020 2020 2020 2020 2020  dSound          
-00000680: 202d 2053 7065 6564 206f 6620 736f 756e   - Speed of soun
-00000690: 6420 286d 2f73 290d 0a20 2064 6566 6175  d (m/s)..  defau
-000006a0: 6c74 2020 2050 6174 6d20 2020 2020 2020  lt   Patm       
-000006b0: 2020 2020 2020 2020 2d20 4174 6d6f 7370          - Atmosp
-000006c0: 6865 7269 6320 7072 6573 7375 7265 2028  heric pressure (
-000006d0: 5061 2920 5b75 7365 6420 6f6e 6c79 2077  Pa) [used only w
-000006e0: 6865 6e20 4361 7669 7443 6865 636b 3d54  hen CavitCheck=T
-000006f0: 7275 655d 0d0a 2020 6465 6661 756c 7420  rue]..  default 
-00000700: 2020 5076 6170 2020 2020 2020 2020 2020    Pvap          
-00000710: 2020 2020 202d 2056 6170 6f75 7220 7072       - Vapour pr
-00000720: 6573 7375 7265 206f 6620 666c 7569 6420  essure of fluid 
-00000730: 2850 6129 205b 7573 6564 206f 6e6c 7920  (Pa) [used only 
-00000740: 7768 656e 2043 6176 6974 4368 6563 6b3d  when CavitCheck=
-00000750: 5472 7565 5d20 2020 2020 2020 2020 2020  True]           
-00000760: 200d 0a3d 3d3d 3d3d 3d20 2042 6c61 6465   ..======  Blade
-00000770: 2d45 6c65 6d65 6e74 2f4d 6f6d 656e 7475  -Element/Momentu
-00000780: 6d20 5468 656f 7279 204f 7074 696f 6e73  m Theory Options
-00000790: 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d    ==============
-000007a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000007b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000007c0: 3d3d 3d3d 3d3d 3d3d 205b 7573 6564 206f  ======== [used o
-000007d0: 6e6c 7920 7768 656e 2057 616b 654d 6f64  nly when WakeMod
-000007e0: 3d31 5d0d 0a20 2020 2020 2020 2020 2032  =1]..          2
-000007f0: 2020 2053 6b65 774d 6f64 2020 2020 2020     SkewMod      
-00000800: 2020 2020 2020 2d20 5479 7065 206f 6620        - Type of 
-00000810: 736b 6577 6564 2d77 616b 6520 636f 7272  skewed-wake corr
-00000820: 6563 7469 6f6e 206d 6f64 656c 2028 7377  ection model (sw
-00000830: 6974 6368 2920 7b31 3d75 6e63 6f75 706c  itch) {1=uncoupl
-00000840: 6564 2c20 323d 5069 7474 2f50 6574 6572  ed, 2=Pitt/Peter
-00000850: 732c 2033 3d63 6f75 706c 6564 7d20 5b75  s, 3=coupled} [u
-00000860: 7365 6420 6f6e 6c79 2077 6865 6e20 5761  sed only when Wa
-00000870: 6b65 4d6f 643d 315d 0d0a 2264 6566 6175  keMod=1].."defau
-00000880: 6c74 2220 2020 2020 536b 6577 4d6f 6446  lt"     SkewModF
-00000890: 6163 746f 7220 2020 2020 202d 2043 6f6e  actor      - Con
-000008a0: 7374 616e 7420 7573 6564 2069 6e20 5069  stant used in Pi
-000008b0: 7474 2f50 6574 6572 7320 736b 6577 6564  tt/Peters skewed
-000008c0: 2077 616b 6520 6d6f 6465 6c20 7b6f 7220   wake model {or 
-000008d0: 2264 6566 6175 6c74 2220 6973 2031 352f  "default" is 15/
-000008e0: 3332 2a70 697d 2028 2d29 205b 7573 6564  32*pi} (-) [used
-000008f0: 206f 6e6c 7920 7768 656e 2053 6b65 774d   only when SkewM
-00000900: 6f64 3d32 3b20 756e 7573 6564 2077 6865  od=2; unused whe
-00000910: 6e20 5761 6b65 4d6f 643d 305d 0d0a 5472  n WakeMod=0]..Tr
-00000920: 7565 2020 2020 2020 2020 2020 5469 704c  ue          TipL
-00000930: 6f73 7320 2020 2020 2020 2020 2020 202d  oss            -
-00000940: 2055 7365 2074 6865 2050 7261 6e64 746c   Use the Prandtl
-00000950: 2074 6970 2d6c 6f73 7320 6d6f 6465 6c3f   tip-loss model?
-00000960: 2028 666c 6167 2920 5b75 7365 6420 6f6e   (flag) [used on
-00000970: 6c79 2077 6865 6e20 5761 6b65 4d6f 643d  ly when WakeMod=
-00000980: 315d 0d0a 4661 6c73 6520 2020 2020 2020  1]..False       
-00000990: 2020 4875 624c 6f73 7320 2020 2020 2020    HubLoss       
-000009a0: 2020 2020 202d 2055 7365 2074 6865 2050       - Use the P
-000009b0: 7261 6e64 746c 2068 7562 2d6c 6f73 7320  randtl hub-loss 
-000009c0: 6d6f 6465 6c3f 2028 666c 6167 2920 5b75  model? (flag) [u
-000009d0: 7365 6420 6f6e 6c79 2077 6865 6e20 5761  sed only when Wa
-000009e0: 6b65 4d6f 643d 315d 0d0a 5472 7565 2020  keMod=1]..True  
-000009f0: 2020 2020 2020 2020 5461 6e49 6e64 2020          TanInd  
-00000a00: 2020 2020 2020 2020 2020 202d 2049 6e63             - Inc
-00000a10: 6c75 6465 2074 616e 6765 6e74 6961 6c20  lude tangential 
-00000a20: 696e 6475 6374 696f 6e20 696e 2042 454d  induction in BEM
-00000a30: 5420 6361 6c63 756c 6174 696f 6e73 3f20  T calculations? 
-00000a40: 2866 6c61 6729 205b 7573 6564 206f 6e6c  (flag) [used onl
-00000a50: 7920 7768 656e 2057 616b 654d 6f64 3d31  y when WakeMod=1
-00000a60: 5d0d 0a46 616c 7365 2020 2020 2020 2020  ]..False        
-00000a70: 2041 4944 7261 6720 2020 2020 2020 2020   AIDrag         
-00000a80: 2020 2020 2d20 496e 636c 7564 6520 7468      - Include th
-00000a90: 6520 6472 6167 2074 6572 6d20 696e 2074  e drag term in t
-00000aa0: 6865 2061 7869 616c 2d69 6e64 7563 7469  he axial-inducti
-00000ab0: 6f6e 2063 616c 6375 6c61 7469 6f6e 3f20  on calculation? 
-00000ac0: 2866 6c61 6729 205b 7573 6564 206f 6e6c  (flag) [used onl
-00000ad0: 7920 7768 656e 2057 616b 654d 6f64 3d31  y when WakeMod=1
-00000ae0: 5d0d 0a46 616c 7365 2020 2020 2020 2020  ]..False        
-00000af0: 2054 4944 7261 6720 2020 2020 2020 2020   TIDrag         
-00000b00: 2020 2020 2d20 496e 636c 7564 6520 7468      - Include th
-00000b10: 6520 6472 6167 2074 6572 6d20 696e 2074  e drag term in t
-00000b20: 6865 2074 616e 6765 6e74 6961 6c2d 696e  he tangential-in
-00000b30: 6475 6374 696f 6e20 6361 6c63 756c 6174  duction calculat
-00000b40: 696f 6e3f 2028 666c 6167 2920 5b75 7365  ion? (flag) [use
-00000b50: 6420 6f6e 6c79 2077 6865 6e20 5761 6b65  d only when Wake
-00000b60: 4d6f 643d 3120 616e 6420 5461 6e49 6e64  Mod=1 and TanInd
-00000b70: 3d54 5255 455d 0d0a 2264 6566 6175 6c74  =TRUE].."default
-00000b80: 2220 2020 2020 496e 6454 6f6c 6572 2020  "     IndToler  
-00000b90: 2020 2020 2020 2020 202d 2043 6f6e 7665           - Conve
-00000ba0: 7267 656e 6365 2074 6f6c 6572 616e 6365  rgence tolerance
-00000bb0: 2066 6f72 2042 454d 5420 6e6f 6e6c 696e   for BEMT nonlin
-00000bc0: 6561 7220 736f 6c76 6520 7265 7369 6475  ear solve residu
-00000bd0: 616c 2065 7175 6174 696f 6e20 7b6f 7220  al equation {or 
-00000be0: 2264 6566 6175 6c74 227d 2028 2d29 205b  "default"} (-) [
-00000bf0: 7573 6564 206f 6e6c 7920 7768 656e 2057  used only when W
-00000c00: 616b 654d 6f64 3d31 5d0d 0a20 2020 2020  akeMod=1]..     
-00000c10: 2020 2031 3030 2020 204d 6178 4974 6572     100   MaxIter
-00000c20: 2020 2020 2020 2020 2020 2020 2d20 4d61              - Ma
-00000c30: 7869 6d75 6d20 6e75 6d62 6572 206f 6620  ximum number of 
-00000c40: 6974 6572 6174 696f 6e20 7374 6570 7320  iteration steps 
-00000c50: 282d 2920 5b75 7365 6420 6f6e 6c79 2077  (-) [used only w
-00000c60: 6865 6e20 5761 6b65 4d6f 643d 315d 0d0a  hen WakeMod=1]..
-00000c70: 3d3d 3d3d 3d3d 2020 4479 6e61 6d69 6320  ======  Dynamic 
-00000c80: 426c 6164 652d 456c 656d 656e 742f 4d6f  Blade-Element/Mo
-00000c90: 6d65 6e74 756d 2054 6865 6f72 7920 4f70  mentum Theory Op
-00000ca0: 7469 6f6e 7320 203d 3d3d 3d3d 3d3d 3d3d  tions  =========
-00000cb0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000cc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000cd0: 3d3d 3d3d 3d20 5b75 7365 6420 6f6e 6c79  ===== [used only
-00000ce0: 2077 6865 6e20 5761 6b65 4d6f 643d 325d   when WakeMod=2]
-00000cf0: 0d0a 2020 2020 2020 2020 2020 3220 2020  ..          2   
-00000d00: 4442 454d 545f 4d6f 6420 2020 2020 2020  DBEMT_Mod       
-00000d10: 2020 202d 2054 7970 6520 6f66 2064 796e     - Type of dyn
-00000d20: 616d 6963 2042 454d 5420 2844 4245 4d54  amic BEMT (DBEMT
-00000d30: 2920 6d6f 6465 6c20 7b31 3d63 6f6e 7374  ) model {1=const
-00000d40: 616e 7420 7461 7531 2c20 323d 7469 6d65  ant tau1, 2=time
-00000d50: 2d64 6570 656e 6465 6e74 2074 6175 317d  -dependent tau1}
-00000d60: 2028 2d29 205b 7573 6564 206f 6e6c 7920   (-) [used only 
-00000d70: 7768 656e 2057 616b 654d 6f64 3d32 5d0d  when WakeMod=2].
-00000d80: 0a20 2020 2020 2020 2020 2034 2020 2074  .          4   t
-00000d90: 6175 315f 636f 6e73 7420 2020 2020 2020  au1_const       
-00000da0: 2020 2d20 5469 6d65 2063 6f6e 7374 616e    - Time constan
-00000db0: 7420 666f 7220 4442 454d 5420 2873 2920  t for DBEMT (s) 
-00000dc0: 5b75 7365 6420 6f6e 6c79 2077 6865 6e20  [used only when 
-00000dd0: 5761 6b65 4d6f 643d 3220 616e 6420 4442  WakeMod=2 and DB
-00000de0: 454d 545f 4d6f 643d 315d 0d0a 3d3d 3d3d  EMT_Mod=1]..====
-00000df0: 3d3d 2020 4f4c 4146 202d 2d20 634f 6e76  ==  OLAF -- cOnv
-00000e00: 6563 7469 6e67 204c 4167 7261 6e67 6961  ecting LAgrangia
-00000e10: 6e20 4669 6c61 6d65 6e74 7320 2846 7265  n Filaments (Fre
-00000e20: 6520 566f 7274 6578 2057 616b 6529 2054  e Vortex Wake) T
-00000e30: 6865 6f72 7920 4f70 7469 6f6e 7320 203d  heory Options  =
-00000e40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000e50: 3d20 5b75 7365 6420 6f6e 6c79 2077 6865  = [used only whe
-00000e60: 6e20 5761 6b65 4d6f 643d 335d 0d0a 2275  n WakeMod=3].."u
-00000e70: 6e75 7365 6422 2020 2020 2020 4f4c 4146  nused"      OLAF
-00000e80: 496e 7075 7446 696c 654e 616d 6520 2d20  InputFileName - 
-00000e90: 496e 7075 7420 6669 6c65 2066 6f72 204f  Input file for O
-00000ea0: 4c41 4620 5b75 7365 6420 6f6e 6c79 2077  LAF [used only w
-00000eb0: 6865 6e20 5761 6b65 4d6f 643d 335d 0d0a  hen WakeMod=3]..
-00000ec0: 3d3d 3d3d 3d3d 2020 4265 6464 6f65 732d  ======  Beddoes-
-00000ed0: 4c65 6973 686d 616e 2055 6e73 7465 6164  Leishman Unstead
-00000ee0: 7920 4169 7266 6f69 6c20 4165 726f 6479  y Airfoil Aerody
-00000ef0: 6e61 6d69 6373 204f 7074 696f 6e73 2020  namics Options  
-00000f00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000f10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00000f20: 3d3d 3d3d 3d20 5b75 7365 6420 6f6e 6c79  ===== [used only
-00000f30: 2077 6865 6e20 4146 4165 726f 4d6f 643d   when AFAeroMod=
-00000f40: 325d 0d0a 2020 2020 2020 2020 2020 3320  2]..          3 
-00000f50: 2020 5541 4d6f 6420 2020 2020 2020 2020    UAMod         
-00000f60: 2020 2020 202d 2055 6e73 7465 6164 7920       - Unsteady 
-00000f70: 4165 726f 204d 6f64 656c 2053 7769 7463  Aero Model Switc
-00000f80: 6820 2873 7769 7463 6829 207b 313d 4261  h (switch) {1=Ba
-00000f90: 7365 6c69 6e65 206d 6f64 656c 2028 4f72  seline model (Or
-00000fa0: 6967 696e 616c 292c 2032 3d47 6f6e 7a61  iginal), 2=Gonza
-00000fb0: 6c65 7a92 7320 7661 7269 616e 7420 2863  lez.s variant (c
-00000fc0: 6861 6e67 6573 2069 6e20 436e 2c43 632c  hanges in Cn,Cc,
-00000fd0: 436d 292c 2033 3d4d 696e 656d 6d61 2f50  Cm), 3=Minemma/P
-00000fe0: 6965 7263 6520 7661 7269 616e 7420 2863  ierce variant (c
-00000ff0: 6861 6e67 6573 2069 6e20 4363 2061 6e64  hanges in Cc and
-00001000: 2043 6d29 7d20 5b75 7365 6420 6f6e 6c79   Cm)} [used only
-00001010: 2077 6865 6e20 4146 4165 726f 4d6f 643d   when AFAeroMod=
-00001020: 325d 0d0a 5472 7565 2020 2020 2020 2020  2]..True        
-00001030: 2020 464c 6f6f 6b75 7020 2020 2020 2020    FLookup       
-00001040: 2020 2020 202d 2046 6c61 6720 746f 2069       - Flag to i
-00001050: 6e64 6963 6174 6520 7768 6574 6865 7220  ndicate whether 
-00001060: 6120 6c6f 6f6b 7570 2066 6f72 2066 2720  a lookup for f' 
-00001070: 7769 6c6c 2062 6520 6361 6c63 756c 6174  will be calculat
-00001080: 6564 2028 5452 5545 2920 6f72 2077 6865  ed (TRUE) or whe
-00001090: 7468 6572 2062 6573 742d 6669 7420 6578  ther best-fit ex
-000010a0: 706f 6e65 6e74 6961 6c20 6571 7561 7469  ponential equati
-000010b0: 6f6e 7320 7769 6c6c 2062 6520 7573 6564  ons will be used
-000010c0: 2028 4641 4c53 4529 3b20 6966 2046 414c   (FALSE); if FAL
-000010d0: 5345 2053 312d 5334 206d 7573 7420 6265  SE S1-S4 must be
-000010e0: 2070 726f 7669 6465 6420 696e 2061 6972   provided in air
-000010f0: 666f 696c 2069 6e70 7574 2066 696c 6573  foil input files
-00001100: 2028 666c 6167 2920 5b75 7365 6420 6f6e   (flag) [used on
-00001110: 6c79 2077 6865 6e20 4146 4165 726f 4d6f  ly when AFAeroMo
-00001120: 643d 325d 0d0a 3d3d 3d3d 3d3d 2020 4169  d=2]..======  Ai
-00001130: 7266 6f69 6c20 496e 666f 726d 6174 696f  rfoil Informatio
-00001140: 6e20 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  n ==============
-00001150: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001160: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001170: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001180: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0d 0a20 2020  ===========..   
-00001190: 2020 2020 2020 2031 2020 2041 4654 6162         1   AFTab
-000011a0: 4d6f 6420 2020 2020 2020 2020 2020 2d20  Mod           - 
-000011b0: 496e 7465 7270 6f6c 6174 696f 6e20 6d65  Interpolation me
-000011c0: 7468 6f64 2066 6f72 206d 756c 7469 706c  thod for multipl
-000011d0: 6520 6169 7266 6f69 6c20 7461 626c 6573  e airfoil tables
-000011e0: 207b 313d 3144 2069 6e74 6572 706f 6c61   {1=1D interpola
-000011f0: 7469 6f6e 206f 6e20 416f 4120 2866 6972  tion on AoA (fir
-00001200: 7374 2074 6162 6c65 206f 6e6c 7929 3b20  st table only); 
-00001210: 323d 3244 2069 6e74 6572 706f 6c61 7469  2=2D interpolati
-00001220: 6f6e 206f 6e20 416f 4120 616e 6420 5265  on on AoA and Re
-00001230: 3b20 333d 3244 2069 6e74 6572 706f 6c61  ; 3=2D interpola
-00001240: 7469 6f6e 206f 6e20 416f 4120 616e 6420  tion on AoA and 
-00001250: 5573 6572 5072 6f70 7d20 282d 290d 0a20  UserProp} (-).. 
-00001260: 2020 2020 2020 2020 2031 2020 2049 6e43           1   InC
-00001270: 6f6c 5f41 6c66 6120 2020 2020 2020 2020  ol_Alfa         
-00001280: 2d20 5468 6520 636f 6c75 6d6e 2069 6e20  - The column in 
-00001290: 7468 6520 6169 7266 6f69 6c20 7461 626c  the airfoil tabl
-000012a0: 6573 2074 6861 7420 636f 6e74 6169 6e73  es that contains
-000012b0: 2074 6865 2061 6e67 6c65 206f 6620 6174   the angle of at
-000012c0: 7461 636b 2028 2d29 0d0a 2020 2020 2020  tack (-)..      
-000012d0: 2020 2020 3220 2020 496e 436f 6c5f 436c      2   InCol_Cl
-000012e0: 2020 2020 2020 2020 2020 202d 2054 6865             - The
-000012f0: 2063 6f6c 756d 6e20 696e 2074 6865 2061   column in the a
-00001300: 6972 666f 696c 2074 6162 6c65 7320 7468  irfoil tables th
-00001310: 6174 2063 6f6e 7461 696e 7320 7468 6520  at contains the 
-00001320: 6c69 6674 2063 6f65 6666 6963 6965 6e74  lift coefficient
-00001330: 2028 2d29 0d0a 2020 2020 2020 2020 2020   (-)..          
-00001340: 3320 2020 496e 436f 6c5f 4364 2020 2020  3   InCol_Cd    
-00001350: 2020 2020 2020 202d 2054 6865 2063 6f6c         - The col
-00001360: 756d 6e20 696e 2074 6865 2061 6972 666f  umn in the airfo
-00001370: 696c 2074 6162 6c65 7320 7468 6174 2063  il tables that c
-00001380: 6f6e 7461 696e 7320 7468 6520 6472 6167  ontains the drag
-00001390: 2063 6f65 6666 6963 6965 6e74 2028 2d29   coefficient (-)
-000013a0: 0d0a 2020 2020 2020 2020 2020 3420 2020  ..          4   
-000013b0: 496e 436f 6c5f 436d 2020 2020 2020 2020  InCol_Cm        
-000013c0: 2020 202d 2054 6865 2063 6f6c 756d 6e20     - The column 
-000013d0: 696e 2074 6865 2061 6972 666f 696c 2074  in the airfoil t
-000013e0: 6162 6c65 7320 7468 6174 2063 6f6e 7461  ables that conta
-000013f0: 696e 7320 7468 6520 7069 7463 6869 6e67  ins the pitching
-00001400: 2d6d 6f6d 656e 7420 636f 6566 6669 6369  -moment coeffici
-00001410: 656e 743b 2075 7365 207a 6572 6f20 6966  ent; use zero if
-00001420: 2074 6865 7265 2069 7320 6e6f 2043 6d20   there is no Cm 
-00001430: 636f 6c75 6d6e 2028 2d29 0d0a 2020 2020  column (-)..    
-00001440: 2020 2020 2020 3020 2020 496e 436f 6c5f        0   InCol_
-00001450: 4370 6d69 6e20 2020 2020 2020 202d 2054  Cpmin        - T
-00001460: 6865 2063 6f6c 756d 6e20 696e 2074 6865  he column in the
-00001470: 2061 6972 666f 696c 2074 6162 6c65 7320   airfoil tables 
-00001480: 7468 6174 2063 6f6e 7461 696e 7320 7468  that contains th
-00001490: 6520 4370 6d69 6e20 636f 6566 6669 6369  e Cpmin coeffici
-000014a0: 656e 743b 2075 7365 207a 6572 6f20 6966  ent; use zero if
-000014b0: 2074 6865 7265 2069 7320 6e6f 2043 706d   there is no Cpm
-000014c0: 696e 2063 6f6c 756d 6e20 282d 290d 0a20  in column (-).. 
-000014d0: 2020 2020 2020 2020 2038 2020 204e 756d           8   Num
-000014e0: 4146 6669 6c65 7320 2020 2020 2020 2020  AFfiles         
-000014f0: 2d20 4e75 6d62 6572 206f 6620 6169 7266  - Number of airf
-00001500: 6f69 6c20 6669 6c65 7320 7573 6564 2028  oil files used (
-00001510: 2d29 0d0a 222e 2e2f 354d 575f 4261 7365  -).."../5MW_Base
-00001520: 6c69 6e65 2f41 6972 666f 696c 732f 4379  line/Airfoils/Cy
-00001530: 6c69 6e64 6572 312e 6461 7422 2020 2020  linder1.dat"    
-00001540: 4146 4e61 6d65 7320 2020 2020 2020 2020  AFNames         
-00001550: 2020 202d 2041 6972 666f 696c 2066 696c     - Airfoil fil
-00001560: 6520 6e61 6d65 7320 284e 756d 4146 6669  e names (NumAFfi
-00001570: 6c65 7320 6c69 6e65 7329 2028 7175 6f74  les lines) (quot
-00001580: 6564 2073 7472 696e 6773 290d 0a22 2e2e  ed strings).."..
-00001590: 2f35 4d57 5f42 6173 656c 696e 652f 4169  /5MW_Baseline/Ai
-000015a0: 7266 6f69 6c73 2f43 796c 696e 6465 7232  rfoils/Cylinder2
-000015b0: 2e64 6174 220d 0a22 2e2e 2f35 4d57 5f42  .dat".."../5MW_B
-000015c0: 6173 656c 696e 652f 4169 7266 6f69 6c73  aseline/Airfoils
-000015d0: 2f44 5534 305f 4131 372e 6461 7422 0d0a  /DU40_A17.dat"..
-000015e0: 222e 2e2f 354d 575f 4261 7365 6c69 6e65  "../5MW_Baseline
-000015f0: 2f41 6972 666f 696c 732f 4455 3335 5f41  /Airfoils/DU35_A
-00001600: 3137 2e64 6174 220d 0a22 2e2e 2f35 4d57  17.dat".."../5MW
-00001610: 5f42 6173 656c 696e 652f 4169 7266 6f69  _Baseline/Airfoi
-00001620: 6c73 2f44 5533 305f 4131 372e 6461 7422  ls/DU30_A17.dat"
-00001630: 0d0a 222e 2e2f 354d 575f 4261 7365 6c69  .."../5MW_Baseli
-00001640: 6e65 2f41 6972 666f 696c 732f 4455 3235  ne/Airfoils/DU25
-00001650: 5f41 3137 2e64 6174 220d 0a22 2e2e 2f35  _A17.dat".."../5
-00001660: 4d57 5f42 6173 656c 696e 652f 4169 7266  MW_Baseline/Airf
-00001670: 6f69 6c73 2f44 5532 315f 4131 372e 6461  oils/DU21_A17.da
-00001680: 7422 0d0a 222e 2e2f 354d 575f 4261 7365  t".."../5MW_Base
-00001690: 6c69 6e65 2f41 6972 666f 696c 732f 4e41  line/Airfoils/NA
-000016a0: 4341 3634 5f41 3137 2e64 6174 220d 0a3d  CA64_A17.dat"..=
-000016b0: 3d3d 3d3d 3d20 2052 6f74 6f72 2f42 6c61  =====  Rotor/Bla
-000016c0: 6465 2050 726f 7065 7274 6965 7320 203d  de Properties  =
-000016d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000016e0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000016f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001700: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001710: 3d3d 3d3d 0d0a 5472 7565 2020 2020 2020  ====..True      
-00001720: 2020 2020 5573 6542 6c43 6d20 2020 2020      UseBlCm     
-00001730: 2020 2020 2020 202d 2049 6e63 6c75 6465         - Include
-00001740: 2061 6572 6f64 796e 616d 6963 2070 6974   aerodynamic pit
-00001750: 6368 696e 6720 6d6f 6d65 6e74 2069 6e20  ching moment in 
-00001760: 6361 6c63 756c 6174 696f 6e73 3f20 2028  calculations?  (
-00001770: 666c 6167 290d 0a22 2e2e 2f35 4d57 5f42  flag).."../5MW_B
-00001780: 6173 656c 696e 652f 4e52 454c 4f66 6673  aseline/NRELOffs
-00001790: 6872 4273 6c69 6e65 354d 575f 4165 726f  hrBsline5MW_Aero
-000017a0: 4479 6e5f 626c 6164 652e 6461 7422 2020  Dyn_blade.dat"  
-000017b0: 2020 4144 426c 4669 6c65 2831 2920 2020    ADBlFile(1)   
-000017c0: 2020 2020 202d 204e 616d 6520 6f66 2066       - Name of f
-000017d0: 696c 6520 636f 6e74 6169 6e69 6e67 2064  ile containing d
-000017e0: 6973 7472 6962 7574 6564 2061 6572 6f64  istributed aerod
-000017f0: 796e 616d 6963 2070 726f 7065 7274 6965  ynamic propertie
-00001800: 7320 666f 7220 426c 6164 6520 2331 2028  s for Blade #1 (
-00001810: 2d29 0d0a 222e 2e2f 354d 575f 4261 7365  -).."../5MW_Base
-00001820: 6c69 6e65 2f4e 5245 4c4f 6666 7368 7242  line/NRELOffshrB
-00001830: 736c 696e 6535 4d57 5f41 6572 6f44 796e  sline5MW_AeroDyn
-00001840: 5f62 6c61 6465 2e64 6174 2220 2020 2041  _blade.dat"    A
-00001850: 4442 6c46 696c 6528 3229 2020 2020 2020  DBlFile(2)      
-00001860: 2020 2d20 4e61 6d65 206f 6620 6669 6c65    - Name of file
-00001870: 2063 6f6e 7461 696e 696e 6720 6469 7374   containing dist
-00001880: 7269 6275 7465 6420 6165 726f 6479 6e61  ributed aerodyna
-00001890: 6d69 6320 7072 6f70 6572 7469 6573 2066  mic properties f
-000018a0: 6f72 2042 6c61 6465 2023 3220 282d 2920  or Blade #2 (-) 
-000018b0: 5b75 6e75 7365 6420 6966 204e 756d 426c  [unused if NumBl
-000018c0: 203c 2032 5d0d 0a22 2e2e 2f35 4d57 5f42   < 2].."../5MW_B
-000018d0: 6173 656c 696e 652f 4e52 454c 4f66 6673  aseline/NRELOffs
-000018e0: 6872 4273 6c69 6e65 354d 575f 4165 726f  hrBsline5MW_Aero
-000018f0: 4479 6e5f 626c 6164 652e 6461 7422 2020  Dyn_blade.dat"  
-00001900: 2020 4144 426c 4669 6c65 2833 2920 2020    ADBlFile(3)   
-00001910: 2020 2020 202d 204e 616d 6520 6f66 2066       - Name of f
-00001920: 696c 6520 636f 6e74 6169 6e69 6e67 2064  ile containing d
-00001930: 6973 7472 6962 7574 6564 2061 6572 6f64  istributed aerod
-00001940: 796e 616d 6963 2070 726f 7065 7274 6965  ynamic propertie
-00001950: 7320 666f 7220 426c 6164 6520 2333 2028  s for Blade #3 (
-00001960: 2d29 205b 756e 7573 6564 2069 6620 4e75  -) [unused if Nu
-00001970: 6d42 6c20 3c20 335d 0d0a 3d3d 3d3d 3d3d  mBl < 3]..======
-00001980: 2020 546f 7765 7220 496e 666c 7565 6e63    Tower Influenc
-00001990: 6520 616e 6420 4165 726f 6479 6e61 6d69  e and Aerodynami
-000019a0: 6373 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  cs =============
-000019b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000019c0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000019d0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-000019e0: 205b 7573 6564 206f 6e6c 7920 7768 656e   [used only when
-000019f0: 2054 7772 506f 7465 6e74 2f3d 302c 2054   TwrPotent/=0, T
-00001a00: 7772 5368 6164 6f77 2f3d 302c 206f 7220  wrShadow/=0, or 
-00001a10: 5477 7241 6572 6f3d 5472 7565 5d0d 0a20  TwrAero=True].. 
-00001a20: 2020 2020 2020 2020 3132 2020 204e 756d          12   Num
-00001a30: 5477 724e 6473 2020 2020 2020 2020 202d  TwrNds         -
-00001a40: 204e 756d 6265 7220 6f66 2074 6f77 6572   Number of tower
-00001a50: 206e 6f64 6573 2075 7365 6420 696e 2074   nodes used in t
-00001a60: 6865 2061 6e61 6c79 7369 7320 2028 2d29  he analysis  (-)
-00001a70: 205b 7573 6564 206f 6e6c 7920 7768 656e   [used only when
-00001a80: 2054 7772 506f 7465 6e74 2f3d 302c 2054   TwrPotent/=0, T
-00001a90: 7772 5368 6164 6f77 2f3d 302c 206f 7220  wrShadow/=0, or 
-00001aa0: 5477 7241 6572 6f3d 5472 7565 5d0d 0a54  TwrAero=True]..T
-00001ab0: 7772 456c 6576 2020 2020 2020 2020 5477  wrElev        Tw
-00001ac0: 7244 6961 6d20 2020 2020 2020 2054 7772  rDiam        Twr
-00001ad0: 4364 2020 2020 2020 2020 2020 5477 7254  Cd          TwrT
-00001ae0: 4920 2875 7365 6420 6f6e 6c79 2077 6974  I (used only wit
-00001af0: 6820 5477 7253 6861 646f 773d 3229 0d0a  h TwrShadow=2)..
-00001b00: 286d 2920 2020 2020 2020 2020 2020 2020  (m)             
-00001b10: 2028 6d29 2020 2020 2020 2020 2020 2028   (m)           (
-00001b20: 2d29 2020 2020 2020 2020 2020 2020 282d  -)            (-
-00001b30: 290d 0a30 2e30 3030 3030 3030 452b 3030  )..0.0000000E+00
-00001b40: 2020 362e 3030 3030 3030 3045 2b30 3020    6.0000000E+00 
-00001b50: 2031 2e30 3030 3030 3030 452b 3030 2020   1.0000000E+00  
-00001b60: 312e 3030 3030 3030 3045 2d30 310d 0a38  1.0000000E-01..8
-00001b70: 2e35 3236 3130 3030 452b 3030 2020 352e  .5261000E+00  5.
-00001b80: 3738 3730 3030 3045 2b30 3020 2031 2e30  7870000E+00  1.0
-00001b90: 3030 3030 3030 452b 3030 2020 312e 3030  000000E+00  1.00
-00001ba0: 3030 3030 3045 2d30 310d 0a31 2e37 3035  00000E-01..1.705
-00001bb0: 3330 3030 452b 3031 2020 352e 3537 3430  3000E+01  5.5740
-00001bc0: 3030 3045 2b30 3020 2031 2e30 3030 3030  000E+00  1.00000
-00001bd0: 3030 452b 3030 2020 312e 3030 3030 3030  00E+00  1.000000
-00001be0: 3045 2d30 310d 0a32 2e35 3537 3930 3030  0E-01..2.5579000
-00001bf0: 452b 3031 2020 352e 3336 3130 3030 3045  E+01  5.3610000E
-00001c00: 2b30 3020 2031 2e30 3030 3030 3030 452b  +00  1.0000000E+
-00001c10: 3030 2020 312e 3030 3030 3030 3045 2d30  00  1.0000000E-0
-00001c20: 310d 0a33 2e34 3130 3530 3030 452b 3031  1..3.4105000E+01
-00001c30: 2020 352e 3134 3830 3030 3045 2b30 3020    5.1480000E+00 
-00001c40: 2031 2e30 3030 3030 3030 452b 3030 2020   1.0000000E+00  
-00001c50: 312e 3030 3030 3030 3045 2d30 310d 0a34  1.0000000E-01..4
-00001c60: 2e32 3633 3330 3030 452b 3031 2020 342e  .2633000E+01  4.
-00001c70: 3933 3530 3030 3045 2b30 3020 2031 2e30  9350000E+00  1.0
-00001c80: 3030 3030 3030 452b 3030 2020 312e 3030  000000E+00  1.00
-00001c90: 3030 3030 3045 2d30 310d 0a35 2e31 3135  00000E-01..5.115
-00001ca0: 3830 3030 452b 3031 2020 342e 3732 3230  8000E+01  4.7220
-00001cb0: 3030 3045 2b30 3020 2031 2e30 3030 3030  000E+00  1.00000
-00001cc0: 3030 452b 3030 2020 312e 3030 3030 3030  00E+00  1.000000
-00001cd0: 3045 2d30 310d 0a35 2e39 3638 3530 3030  0E-01..5.9685000
-00001ce0: 452b 3031 2020 342e 3530 3930 3030 3045  E+01  4.5090000E
-00001cf0: 2b30 3020 2031 2e30 3030 3030 3030 452b  +00  1.0000000E+
-00001d00: 3030 2020 312e 3030 3030 3030 3045 2d30  00  1.0000000E-0
-00001d10: 310d 0a36 2e38 3231 3130 3030 452b 3031  1..6.8211000E+01
-00001d20: 2020 342e 3239 3630 3030 3045 2b30 3020    4.2960000E+00 
-00001d30: 2031 2e30 3030 3030 3030 452b 3030 2020   1.0000000E+00  
-00001d40: 312e 3030 3030 3030 3045 2d30 310d 0a37  1.0000000E-01..7
-00001d50: 2e36 3733 3830 3030 452b 3031 2020 342e  .6738000E+01  4.
-00001d60: 3038 3330 3030 3045 2b30 3020 2031 2e30  0830000E+00  1.0
-00001d70: 3030 3030 3030 452b 3030 2020 312e 3030  000000E+00  1.00
-00001d80: 3030 3030 3045 2d30 310d 0a38 2e35 3236  00000E-01..8.526
-00001d90: 3830 3030 452b 3031 2020 332e 3837 3030  8000E+01  3.8700
-00001da0: 3030 3045 2b30 3020 2031 2e30 3030 3030  000E+00  1.00000
-00001db0: 3030 452b 3030 2020 312e 3030 3030 3030  00E+00  1.000000
-00001dc0: 3045 2d30 310d 0a38 2e37 3630 3030 3030  0E-01..8.7600000
-00001dd0: 452b 3031 2020 332e 3837 3030 3030 3045  E+01  3.8700000E
-00001de0: 2b30 3020 2031 2e30 3030 3030 3030 452b  +00  1.0000000E+
-00001df0: 3030 2020 312e 3030 3030 3030 3045 2d30  00  1.0000000E-0
-00001e00: 310d 0a3d 3d3d 3d3d 3d20 204f 7574 7075  1..======  Outpu
-00001e10: 7473 2020 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ts  ============
+000000f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0d  ===============.
+00000100: 0a46 616c 7365 2020 2020 2020 2020 2045  .False         E
+00000110: 6368 6f20 2020 2020 2020 2020 2020 2020  cho             
+00000120: 2020 2d20 4563 686f 2074 6865 2069 6e70    - Echo the inp
+00000130: 7574 2074 6f20 223c 726f 6f74 6e61 6d65  ut to "<rootname
+00000140: 3e2e 4144 2e65 6368 223f 2020 2866 6c61  >.AD.ech"?  (fla
+00000150: 6729 0d0a 2264 6566 6175 6c74 2220 2020  g).."default"   
+00000160: 2020 4454 4165 726f 2020 2020 2020 2020    DTAero        
+00000170: 2020 2020 202d 2054 696d 6520 696e 7465       - Time inte
+00000180: 7276 616c 2066 6f72 2061 6572 6f64 796e  rval for aerodyn
+00000190: 616d 6963 2063 616c 6375 6c61 7469 6f6e  amic calculation
+000001a0: 7320 7b6f 7220 2264 6566 6175 6c74 227d  s {or "default"}
+000001b0: 2028 7329 0d0a 2020 2020 2020 2020 2020   (s)..          
+000001c0: 3120 2020 5761 6b65 4d6f 6420 2020 2020  1   WakeMod     
+000001d0: 2020 2020 2020 202d 2054 7970 6520 6f66         - Type of
+000001e0: 2077 616b 652f 696e 6475 6374 696f 6e20   wake/induction 
+000001f0: 6d6f 6465 6c20 2873 7769 7463 6829 207b  model (switch) {
+00000200: 303d 6e6f 6e65 2c20 313d 4245 4d54 2c20  0=none, 1=BEMT, 
+00000210: 323d 4442 454d 542c 2033 3d4f 4c41 467d  2=DBEMT, 3=OLAF}
+00000220: 205b 5761 6b65 4d6f 6420 6361 6e6e 6f74   [WakeMod cannot
+00000230: 2062 6520 3220 6f72 2033 2077 6865 6e20   be 2 or 3 when 
+00000240: 6c69 6e65 6172 697a 696e 675d 0d0a 2020  linearizing]..  
+00000250: 2020 2020 2020 2020 3120 2020 4146 4165          1   AFAe
+00000260: 726f 4d6f 6420 2020 2020 2020 2020 202d  roMod          -
+00000270: 2054 7970 6520 6f66 2062 6c61 6465 2061   Type of blade a
+00000280: 6972 666f 696c 2061 6572 6f64 796e 616d  irfoil aerodynam
+00000290: 6963 7320 6d6f 6465 6c20 2873 7769 7463  ics model (switc
+000002a0: 6829 207b 313d 7374 6561 6479 206d 6f64  h) {1=steady mod
+000002b0: 656c 2c20 323d 4265 6464 6f65 732d 4c65  el, 2=Beddoes-Le
+000002c0: 6973 686d 616e 2075 6e73 7465 6164 7920  ishman unsteady 
+000002d0: 6d6f 6465 6c7d 0d0a 2020 2020 2020 2020  model}..        
+000002e0: 2020 3020 2020 5477 7250 6f74 656e 7420    0   TwrPotent 
+000002f0: 2020 2020 2020 2020 202d 2054 7970 6520           - Type 
+00000300: 746f 7765 7220 696e 666c 7565 6e63 6520  tower influence 
+00000310: 6f6e 2077 696e 6420 6261 7365 6420 6f6e  on wind based on
+00000320: 2070 6f74 656e 7469 616c 2066 6c6f 7720   potential flow 
+00000330: 6172 6f75 6e64 2074 6865 2074 6f77 6572  around the tower
+00000340: 2028 7377 6974 6368 2920 7b30 3d6e 6f6e   (switch) {0=non
+00000350: 652c 2031 3d62 6173 656c 696e 6520 706f  e, 1=baseline po
+00000360: 7465 6e74 6961 6c20 666c 6f77 2c20 323d  tential flow, 2=
+00000370: 706f 7465 6e74 6961 6c20 666c 6f77 2077  potential flow w
+00000380: 6974 6820 4261 6b20 636f 7272 6563 7469  ith Bak correcti
+00000390: 6f6e 7d0d 0a20 2020 2020 2020 2020 2030  on}..          0
+000003a0: 2020 2054 7772 5368 6164 6f77 2020 2020     TwrShadow    
+000003b0: 2020 2020 2020 2d20 4361 6c63 756c 6174        - Calculat
+000003c0: 6520 746f 7765 7220 696e 666c 7565 6e63  e tower influenc
+000003d0: 6520 6f6e 2077 696e 6420 6261 7365 6420  e on wind based 
+000003e0: 6f6e 2064 6f77 6e73 7472 6561 6d20 746f  on downstream to
+000003f0: 7765 7220 7368 6164 6f77 2028 7377 6974  wer shadow (swit
+00000400: 6368 2920 7b30 3d6e 6f6e 652c 2031 3d50  ch) {0=none, 1=P
+00000410: 6f77 6c65 7320 6d6f 6465 6c2c 2032 3d45  owles model, 2=E
+00000420: 616d 6573 206d 6f64 656c 7d0d 0a46 616c  ames model}..Fal
+00000430: 7365 2020 2020 2020 2020 2054 7772 4165  se         TwrAe
+00000440: 726f 2020 2020 2020 2020 2020 2020 2d20  ro            - 
+00000450: 4361 6c63 756c 6174 6520 746f 7765 7220  Calculate tower 
+00000460: 6165 726f 6479 6e61 6d69 6320 6c6f 6164  aerodynamic load
+00000470: 733f 2028 666c 6167 290d 0a46 616c 7365  s? (flag)..False
+00000480: 2020 2020 2020 2020 2046 726f 7a65 6e57           FrozenW
+00000490: 616b 6520 2020 2020 2020 2020 2d20 4173  ake         - As
+000004a0: 7375 6d65 2066 726f 7a65 6e20 7761 6b65  sume frozen wake
+000004b0: 2064 7572 696e 6720 6c69 6e65 6172 697a   during lineariz
+000004c0: 6174 696f 6e3f 2028 666c 6167 2920 5b75  ation? (flag) [u
+000004d0: 7365 6420 6f6e 6c79 2077 6865 6e20 5761  sed only when Wa
+000004e0: 6b65 4d6f 643d 3120 616e 6420 7768 656e  keMod=1 and when
+000004f0: 206c 696e 6561 7269 7a69 6e67 5d0d 0a46   linearizing]..F
+00000500: 616c 7365 2020 2020 2020 2020 2043 6176  alse         Cav
+00000510: 6974 4368 6563 6b20 2020 2020 2020 2020  itCheck         
+00000520: 2d20 5065 7266 6f72 6d20 6361 7669 7461  - Perform cavita
+00000530: 7469 6f6e 2063 6865 636b 3f20 2866 6c61  tion check? (fla
+00000540: 6729 0d0a 4661 6c73 6520 2020 2020 2020  g)..False       
+00000550: 2020 4275 6f79 616e 6379 2020 2020 2020    Buoyancy      
+00000560: 2020 2020 202d 2049 6e63 6c75 6465 2062       - Include b
+00000570: 756f 7961 6e63 7920 6566 6665 6374 733f  uoyancy effects?
+00000580: 2028 666c 6167 290d 0a46 616c 7365 2020   (flag)..False  
+00000590: 2020 2020 2020 2043 6f6d 7041 4120 2020         CompAA   
+000005a0: 2020 2020 2020 2020 2020 2d20 466c 6167            - Flag
+000005b0: 2074 6f20 636f 6d70 7574 6520 4165 726f   to compute Aero
+000005c0: 4163 6f75 7374 6963 7320 6361 6c63 756c  Acoustics calcul
+000005d0: 6174 696f 6e20 5b75 7365 6420 6f6e 6c79  ation [used only
+000005e0: 2077 6865 6e20 5761 6b65 4d6f 6420 3d20   when WakeMod = 
+000005f0: 3120 6f72 2032 5d0d 0a22 756e 7573 6564  1 or 2].."unused
+00000600: 2220 2020 2020 2041 415f 496e 7075 7446  "      AA_InputF
+00000610: 696c 6520 2020 2020 2020 2d20 4165 726f  ile       - Aero
+00000620: 4163 6f75 7374 6963 7320 696e 7075 7420  Acoustics input 
+00000630: 6669 6c65 205b 7573 6564 206f 6e6c 7920  file [used only 
+00000640: 7768 656e 2043 6f6d 7041 413d 7472 7565  when CompAA=true
+00000650: 5d0d 0a3d 3d3d 3d3d 3d20 2045 6e76 6972  ]..======  Envir
+00000660: 6f6e 6d65 6e74 616c 2043 6f6e 6469 7469  onmental Conditi
+00000670: 6f6e 7320 203d 3d3d 3d3d 3d3d 3d3d 3d3d  ons  ===========
+00000680: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000690: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000006a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000006b0: 3d3d 3d3d 3d3d 3d3d 0d0a 2264 6566 6175  ========.."defau
+000006c0: 6c74 2220 2020 2020 4169 7244 656e 7320  lt"     AirDens 
+000006d0: 2020 2020 2020 2020 2020 202d 2041 6972             - Air
+000006e0: 2064 656e 7369 7479 2028 6b67 2f6d 5e33   density (kg/m^3
+000006f0: 290d 0a22 6465 6661 756c 7422 2020 2020  ).."default"    
+00000700: 204b 696e 5669 7363 2020 2020 2020 2020   KinVisc        
+00000710: 2020 2020 2d20 4b69 6e65 6d61 7469 6320      - Kinematic 
+00000720: 7669 7363 6f73 6974 7920 6f66 2077 6f72  viscosity of wor
+00000730: 6b69 6e67 2066 6c75 6964 2028 6d5e 322f  king fluid (m^2/
+00000740: 7329 0d0a 2264 6566 6175 6c74 2220 2020  s).."default"   
+00000750: 2020 5370 6453 6f75 6e64 2020 2020 2020    SpdSound      
+00000760: 2020 2020 202d 2053 7065 6564 206f 6620       - Speed of 
+00000770: 736f 756e 6420 696e 2077 6f72 6b69 6e67  sound in working
+00000780: 2066 6c75 6964 2028 6d2f 7329 0d0a 2264   fluid (m/s).."d
+00000790: 6566 6175 6c74 2220 2020 2020 5061 746d  efault"     Patm
+000007a0: 2020 2020 2020 2020 2020 2020 2020 202d                 -
+000007b0: 2041 746d 6f73 7068 6572 6963 2070 7265   Atmospheric pre
+000007c0: 7373 7572 6520 2850 6129 205b 7573 6564  ssure (Pa) [used
+000007d0: 206f 6e6c 7920 7768 656e 2043 6176 6974   only when Cavit
+000007e0: 4368 6563 6b3d 5472 7565 5d0d 0a22 6465  Check=True].."de
+000007f0: 6661 756c 7422 2020 2020 2050 7661 7020  fault"     Pvap 
+00000800: 2020 2020 2020 2020 2020 2020 2020 2d20                - 
+00000810: 5661 706f 7572 2070 7265 7373 7572 6520  Vapour pressure 
+00000820: 6f66 2077 6f72 6b69 6e67 2066 6c75 6964  of working fluid
+00000830: 2028 5061 2920 5b75 7365 6420 6f6e 6c79   (Pa) [used only
+00000840: 2077 6865 6e20 4361 7669 7443 6865 636b   when CavitCheck
+00000850: 3d54 7275 655d 0d0a 3d3d 3d3d 3d3d 2020  =True]..======  
+00000860: 426c 6164 652d 456c 656d 656e 742f 4d6f  Blade-Element/Mo
+00000870: 6d65 6e74 756d 2054 6865 6f72 7920 4f70  mentum Theory Op
+00000880: 7469 6f6e 7320 203d 3d3d 3d3d 3d3d 3d3d  tions  =========
+00000890: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000008a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000008b0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 5b75  ============= [u
+000008c0: 6e75 7365 6420 7768 656e 2057 616b 654d  nused when WakeM
+000008d0: 6f64 3d30 206f 7220 335d 0d0a 2020 2020  od=0 or 3]..    
+000008e0: 2020 2020 2020 3220 2020 536b 6577 4d6f        2   SkewMo
+000008f0: 6420 2020 2020 2020 2020 2020 202d 2054  d            - T
+00000900: 7970 6520 6f66 2073 6b65 7765 642d 7761  ype of skewed-wa
+00000910: 6b65 2063 6f72 7265 6374 696f 6e20 6d6f  ke correction mo
+00000920: 6465 6c20 2873 7769 7463 6829 207b 313d  del (switch) {1=
+00000930: 756e 636f 7570 6c65 642c 2032 3d50 6974  uncoupled, 2=Pit
+00000940: 742f 5065 7465 7273 2c20 333d 636f 7570  t/Peters, 3=coup
+00000950: 6c65 647d 205b 756e 7573 6564 2077 6865  led} [unused whe
+00000960: 6e20 5761 6b65 4d6f 643d 3020 6f72 2033  n WakeMod=0 or 3
+00000970: 5d0d 0a22 6465 6661 756c 7422 2020 2020  ].."default"    
+00000980: 2053 6b65 774d 6f64 4661 6374 6f72 2020   SkewModFactor  
+00000990: 2020 2020 2d20 436f 6e73 7461 6e74 2075      - Constant u
+000009a0: 7365 6420 696e 2050 6974 742f 5065 7465  sed in Pitt/Pete
+000009b0: 7273 2073 6b65 7765 6420 7761 6b65 206d  rs skewed wake m
+000009c0: 6f64 656c 207b 6f72 2022 6465 6661 756c  odel {or "defaul
+000009d0: 7422 2069 7320 3135 2f33 322a 7069 7d20  t" is 15/32*pi} 
+000009e0: 282d 2920 5b75 7365 6420 6f6e 6c79 2077  (-) [used only w
+000009f0: 6865 6e20 536b 6577 4d6f 643d 323b 2075  hen SkewMod=2; u
+00000a00: 6e75 7365 6420 7768 656e 2057 616b 654d  nused when WakeM
+00000a10: 6f64 3d30 206f 7220 335d 0d0a 5472 7565  od=0 or 3]..True
+00000a20: 2020 2020 2020 2020 2020 5469 704c 6f73            TipLos
+00000a30: 7320 2020 2020 2020 2020 2020 202d 2055  s            - U
+00000a40: 7365 2074 6865 2050 7261 6e64 746c 2074  se the Prandtl t
+00000a50: 6970 2d6c 6f73 7320 6d6f 6465 6c3f 2028  ip-loss model? (
+00000a60: 666c 6167 2920 5b75 6e75 7365 6420 7768  flag) [unused wh
+00000a70: 656e 2057 616b 654d 6f64 3d30 206f 7220  en WakeMod=0 or 
+00000a80: 335d 0d0a 4661 6c73 6520 2020 2020 2020  3]..False       
+00000a90: 2020 4875 624c 6f73 7320 2020 2020 2020    HubLoss       
+00000aa0: 2020 2020 202d 2055 7365 2074 6865 2050       - Use the P
+00000ab0: 7261 6e64 746c 2068 7562 2d6c 6f73 7320  randtl hub-loss 
+00000ac0: 6d6f 6465 6c3f 2028 666c 6167 2920 5b75  model? (flag) [u
+00000ad0: 6e75 7365 6420 7768 656e 2057 616b 654d  nused when WakeM
+00000ae0: 6f64 3d30 206f 7220 335d 0d0a 5472 7565  od=0 or 3]..True
+00000af0: 2020 2020 2020 2020 2020 5461 6e49 6e64            TanInd
+00000b00: 2020 2020 2020 2020 2020 2020 202d 2049               - I
+00000b10: 6e63 6c75 6465 2074 616e 6765 6e74 6961  nclude tangentia
+00000b20: 6c20 696e 6475 6374 696f 6e20 696e 2042  l induction in B
+00000b30: 454d 5420 6361 6c63 756c 6174 696f 6e73  EMT calculations
+00000b40: 3f20 2866 6c61 6729 205b 756e 7573 6564  ? (flag) [unused
+00000b50: 2077 6865 6e20 5761 6b65 4d6f 643d 3020   when WakeMod=0 
+00000b60: 6f72 2033 5d0d 0a46 616c 7365 2020 2020  or 3]..False    
+00000b70: 2020 2020 2041 4944 7261 6720 2020 2020       AIDrag     
+00000b80: 2020 2020 2020 2020 2d20 496e 636c 7564          - Includ
+00000b90: 6520 7468 6520 6472 6167 2074 6572 6d20  e the drag term 
+00000ba0: 696e 2074 6865 2061 7869 616c 2d69 6e64  in the axial-ind
+00000bb0: 7563 7469 6f6e 2063 616c 6375 6c61 7469  uction calculati
+00000bc0: 6f6e 3f20 2866 6c61 6729 205b 756e 7573  on? (flag) [unus
+00000bd0: 6564 2077 6865 6e20 5761 6b65 4d6f 643d  ed when WakeMod=
+00000be0: 3020 6f72 2033 5d0d 0a46 616c 7365 2020  0 or 3]..False  
+00000bf0: 2020 2020 2020 2054 4944 7261 6720 2020         TIDrag   
+00000c00: 2020 2020 2020 2020 2020 2d20 496e 636c            - Incl
+00000c10: 7564 6520 7468 6520 6472 6167 2074 6572  ude the drag ter
+00000c20: 6d20 696e 2074 6865 2074 616e 6765 6e74  m in the tangent
+00000c30: 6961 6c2d 696e 6475 6374 696f 6e20 6361  ial-induction ca
+00000c40: 6c63 756c 6174 696f 6e3f 2028 666c 6167  lculation? (flag
+00000c50: 2920 5b75 6e75 7365 6420 7768 656e 2057  ) [unused when W
+00000c60: 616b 654d 6f64 3d30 2c33 206f 7220 5461  akeMod=0,3 or Ta
+00000c70: 6e49 6e64 3d46 414c 5345 5d0d 0a22 6465  nInd=FALSE].."de
+00000c80: 6661 756c 7422 2020 2020 2049 6e64 546f  fault"     IndTo
+00000c90: 6c65 7220 2020 2020 2020 2020 2020 2d20  ler           - 
+00000ca0: 436f 6e76 6572 6765 6e63 6520 746f 6c65  Convergence tole
+00000cb0: 7261 6e63 6520 666f 7220 4245 4d54 206e  rance for BEMT n
+00000cc0: 6f6e 6c69 6e65 6172 2073 6f6c 7665 2072  onlinear solve r
+00000cd0: 6573 6964 7561 6c20 6571 7561 7469 6f6e  esidual equation
+00000ce0: 207b 6f72 2022 6465 6661 756c 7422 7d20   {or "default"} 
+00000cf0: 282d 2920 5b75 6e75 7365 6420 7768 656e  (-) [unused when
+00000d00: 2057 616b 654d 6f64 3d30 206f 7220 335d   WakeMod=0 or 3]
+00000d10: 0d0a 2020 2020 2020 2020 3130 3020 2020  ..        100   
+00000d20: 4d61 7849 7465 7220 2020 2020 2020 2020  MaxIter         
+00000d30: 2020 202d 204d 6178 696d 756d 206e 756d     - Maximum num
+00000d40: 6265 7220 6f66 2069 7465 7261 7469 6f6e  ber of iteration
+00000d50: 2073 7465 7073 2028 2d29 205b 756e 7573   steps (-) [unus
+00000d60: 6564 2077 6865 6e20 5761 6b65 4d6f 643d  ed when WakeMod=
+00000d70: 305d 0d0a 3d3d 3d3d 3d3d 2020 4479 6e61  0]..======  Dyna
+00000d80: 6d69 6320 426c 6164 652d 456c 656d 656e  mic Blade-Elemen
+00000d90: 742f 4d6f 6d65 6e74 756d 2054 6865 6f72  t/Momentum Theor
+00000da0: 7920 4f70 7469 6f6e 7320 203d 3d3d 3d3d  y Options  =====
+00000db0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000dc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00000dd0: 3d3d 3d3d 3d3d 3d3d 3d20 5b75 7365 6420  ========= [used 
+00000de0: 6f6e 6c79 2077 6865 6e20 5761 6b65 4d6f  only when WakeMo
+00000df0: 643d 325d 0d0a 2020 2020 2020 2020 2020  d=2]..          
+00000e00: 3220 2020 4442 454d 545f 4d6f 6420 2020  2   DBEMT_Mod   
+00000e10: 2020 2020 2020 202d 2054 7970 6520 6f66         - Type of
+00000e20: 2064 796e 616d 6963 2042 454d 5420 2844   dynamic BEMT (D
+00000e30: 4245 4d54 2920 6d6f 6465 6c20 7b31 3d63  BEMT) model {1=c
+00000e40: 6f6e 7374 616e 7420 7461 7531 2c20 323d  onstant tau1, 2=
+00000e50: 7469 6d65 2d64 6570 656e 6465 6e74 2074  time-dependent t
+00000e60: 6175 312c 2033 3d63 6f6e 7374 616e 7420  au1, 3=constant 
+00000e70: 7461 7531 2077 6974 6820 636f 6e74 696e  tau1 with contin
+00000e80: 756f 7573 2066 6f72 6d75 6c61 7469 6f6e  uous formulation
+00000e90: 7d20 282d 2920 5b75 7365 6420 6f6e 6c79  } (-) [used only
+00000ea0: 2077 6865 6e20 5761 6b65 4d6f 643d 325d   when WakeMod=2]
+00000eb0: 0d0a 2020 2020 2020 2020 2020 3420 2020  ..          4   
+00000ec0: 7461 7531 5f63 6f6e 7374 2020 2020 2020  tau1_const      
+00000ed0: 2020 202d 2054 696d 6520 636f 6e73 7461     - Time consta
+00000ee0: 6e74 2066 6f72 2044 4245 4d54 2028 7329  nt for DBEMT (s)
+00000ef0: 205b 7573 6564 206f 6e6c 7920 7768 656e   [used only when
+00000f00: 2057 616b 654d 6f64 3d32 2061 6e64 2044   WakeMod=2 and D
+00000f10: 4245 4d54 5f4d 6f64 3d31 206f 7220 335d  BEMT_Mod=1 or 3]
+00000f20: 200d 0a3d 3d3d 3d3d 3d20 204f 4c41 4620   ..======  OLAF 
+00000f30: 2d2d 2063 4f6e 7665 6374 696e 6720 4c41  -- cOnvecting LA
+00000f40: 6772 616e 6769 616e 2046 696c 616d 656e  grangian Filamen
+00000f50: 7473 2028 4672 6565 2056 6f72 7465 7820  ts (Free Vortex 
+00000f60: 5761 6b65 2920 5468 656f 7279 204f 7074  Wake) Theory Opt
+00000f70: 696f 6e73 2020 3d3d 3d3d 3d3d 3d3d 3d3d  ions  ==========
+00000f80: 3d3d 3d3d 3d3d 3d3d 205b 7573 6564 206f  ======== [used o
+00000f90: 6e6c 7920 7768 656e 2057 616b 654d 6f64  nly when WakeMod
+00000fa0: 3d33 5d0d 0a22 756e 7573 6564 2220 2020  =3].."unused"   
+00000fb0: 2020 204f 4c41 4649 6e70 7574 4669 6c65     OLAFInputFile
+00000fc0: 4e61 6d65 2020 2d20 496e 7075 7420 6669  Name  - Input fi
+00000fd0: 6c65 2066 6f72 204f 4c41 4620 5b75 7365  le for OLAF [use
+00000fe0: 6420 6f6e 6c79 2077 6865 6e20 5761 6b65  d only when Wake
+00000ff0: 4d6f 643d 335d 0d0a 3d3d 3d3d 3d3d 2020  Mod=3]..======  
+00001000: 4265 6464 6f65 732d 4c65 6973 686d 616e  Beddoes-Leishman
+00001010: 2055 6e73 7465 6164 7920 4169 7266 6f69   Unsteady Airfoi
+00001020: 6c20 4165 726f 6479 6e61 6d69 6373 204f  l Aerodynamics O
+00001030: 7074 696f 6e73 2020 3d3d 3d3d 3d3d 3d3d  ptions  ========
+00001040: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001050: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 5b75  ============= [u
+00001060: 7365 6420 6f6e 6c79 2077 6865 6e20 4146  sed only when AF
+00001070: 4165 726f 4d6f 643d 325d 0d0a 2020 2020  AeroMod=2]..    
+00001080: 2020 2020 2020 3320 2020 5541 4d6f 6420        3   UAMod 
+00001090: 2020 2020 2020 2020 2020 2020 202d 2055               - U
+000010a0: 6e73 7465 6164 7920 4165 726f 204d 6f64  nsteady Aero Mod
+000010b0: 656c 2053 7769 7463 6820 2873 7769 7463  el Switch (switc
+000010c0: 6829 207b 323d 422d 4c20 476f 6e7a 616c  h) {2=B-L Gonzal
+000010d0: 657a 2c20 333d 422d 4c20 4d69 6e6e 656d  ez, 3=B-L Minnem
+000010e0: 612f 5069 6572 6365 2c20 343d 422d 4c20  a/Pierce, 4=B-L 
+000010f0: 4847 4d20 342d 7374 6174 6573 2c20 353d  HGM 4-states, 5=
+00001100: 422d 4c20 3520 7374 6174 6573 2c20 363d  B-L 5 states, 6=
+00001110: 4f79 652c 2037 3d42 6f65 696e 672d 5665  Oye, 7=Boeing-Ve
+00001120: 7274 6f6c 7d20 5b75 7365 6420 6f6e 6c79  rtol} [used only
+00001130: 2077 6865 6e20 4146 4165 726f 4d6f 643d   when AFAeroMod=
+00001140: 325d 0d0a 5472 7565 2020 2020 2020 2020  2]..True        
+00001150: 2020 464c 6f6f 6b75 7020 2020 2020 2020    FLookup       
+00001160: 2020 2020 202d 2046 6c61 6720 746f 2069       - Flag to i
+00001170: 6e64 6963 6174 6520 7768 6574 6865 7220  ndicate whether 
+00001180: 6120 6c6f 6f6b 7570 2066 6f72 2066 2720  a lookup for f' 
+00001190: 7769 6c6c 2062 6520 6361 6c63 756c 6174  will be calculat
+000011a0: 6564 2028 5452 5545 2920 6f72 2077 6865  ed (TRUE) or whe
+000011b0: 7468 6572 2062 6573 742d 6669 7420 6578  ther best-fit ex
+000011c0: 706f 6e65 6e74 6961 6c20 6571 7561 7469  ponential equati
+000011d0: 6f6e 7320 7769 6c6c 2062 6520 7573 6564  ons will be used
+000011e0: 2028 4641 4c53 4529 3b20 6966 2046 414c   (FALSE); if FAL
+000011f0: 5345 2053 312d 5334 206d 7573 7420 6265  SE S1-S4 must be
+00001200: 2070 726f 7669 6465 6420 696e 2061 6972   provided in air
+00001210: 666f 696c 2069 6e70 7574 2066 696c 6573  foil input files
+00001220: 2028 666c 6167 2920 5b75 7365 6420 6f6e   (flag) [used on
+00001230: 6c79 2077 6865 6e20 4146 4165 726f 4d6f  ly when AFAeroMo
+00001240: 643d 325d 0d0a 3d3d 3d3d 3d3d 2020 4169  d=2]..======  Ai
+00001250: 7266 6f69 6c20 496e 666f 726d 6174 696f  rfoil Informatio
+00001260: 6e20 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  n ==============
+00001270: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001280: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001290: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+000012a0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d0d 0a20 2020  ===========..   
+000012b0: 2020 2020 2020 2031 2020 2041 4654 6162         1   AFTab
+000012c0: 4d6f 6420 2020 2020 2020 2020 2020 2d20  Mod           - 
+000012d0: 496e 7465 7270 6f6c 6174 696f 6e20 6d65  Interpolation me
+000012e0: 7468 6f64 2066 6f72 206d 756c 7469 706c  thod for multipl
+000012f0: 6520 6169 7266 6f69 6c20 7461 626c 6573  e airfoil tables
+00001300: 207b 313d 3144 2069 6e74 6572 706f 6c61   {1=1D interpola
+00001310: 7469 6f6e 206f 6e20 416f 4120 2866 6972  tion on AoA (fir
+00001320: 7374 2074 6162 6c65 206f 6e6c 7929 3b20  st table only); 
+00001330: 323d 3244 2069 6e74 6572 706f 6c61 7469  2=2D interpolati
+00001340: 6f6e 206f 6e20 416f 4120 616e 6420 5265  on on AoA and Re
+00001350: 3b20 333d 3244 2069 6e74 6572 706f 6c61  ; 3=2D interpola
+00001360: 7469 6f6e 206f 6e20 416f 4120 616e 6420  tion on AoA and 
+00001370: 5573 6572 5072 6f70 7d20 282d 290d 0a20  UserProp} (-).. 
+00001380: 2020 2020 2020 2020 2031 2020 2049 6e43           1   InC
+00001390: 6f6c 5f41 6c66 6120 2020 2020 2020 2020  ol_Alfa         
+000013a0: 2d20 5468 6520 636f 6c75 6d6e 2069 6e20  - The column in 
+000013b0: 7468 6520 6169 7266 6f69 6c20 7461 626c  the airfoil tabl
+000013c0: 6573 2074 6861 7420 636f 6e74 6169 6e73  es that contains
+000013d0: 2074 6865 2061 6e67 6c65 206f 6620 6174   the angle of at
+000013e0: 7461 636b 2028 2d29 0d0a 2020 2020 2020  tack (-)..      
+000013f0: 2020 2020 3220 2020 496e 436f 6c5f 436c      2   InCol_Cl
+00001400: 2020 2020 2020 2020 2020 202d 2054 6865             - The
+00001410: 2063 6f6c 756d 6e20 696e 2074 6865 2061   column in the a
+00001420: 6972 666f 696c 2074 6162 6c65 7320 7468  irfoil tables th
+00001430: 6174 2063 6f6e 7461 696e 7320 7468 6520  at contains the 
+00001440: 6c69 6674 2063 6f65 6666 6963 6965 6e74  lift coefficient
+00001450: 2028 2d29 0d0a 2020 2020 2020 2020 2020   (-)..          
+00001460: 3320 2020 496e 436f 6c5f 4364 2020 2020  3   InCol_Cd    
+00001470: 2020 2020 2020 202d 2054 6865 2063 6f6c         - The col
+00001480: 756d 6e20 696e 2074 6865 2061 6972 666f  umn in the airfo
+00001490: 696c 2074 6162 6c65 7320 7468 6174 2063  il tables that c
+000014a0: 6f6e 7461 696e 7320 7468 6520 6472 6167  ontains the drag
+000014b0: 2063 6f65 6666 6963 6965 6e74 2028 2d29   coefficient (-)
+000014c0: 0d0a 2020 2020 2020 2020 2020 3420 2020  ..          4   
+000014d0: 496e 436f 6c5f 436d 2020 2020 2020 2020  InCol_Cm        
+000014e0: 2020 202d 2054 6865 2063 6f6c 756d 6e20     - The column 
+000014f0: 696e 2074 6865 2061 6972 666f 696c 2074  in the airfoil t
+00001500: 6162 6c65 7320 7468 6174 2063 6f6e 7461  ables that conta
+00001510: 696e 7320 7468 6520 7069 7463 6869 6e67  ins the pitching
+00001520: 2d6d 6f6d 656e 7420 636f 6566 6669 6369  -moment coeffici
+00001530: 656e 743b 2075 7365 207a 6572 6f20 6966  ent; use zero if
+00001540: 2074 6865 7265 2069 7320 6e6f 2043 6d20   there is no Cm 
+00001550: 636f 6c75 6d6e 2028 2d29 0d0a 2020 2020  column (-)..    
+00001560: 2020 2020 2020 3020 2020 496e 436f 6c5f        0   InCol_
+00001570: 4370 6d69 6e20 2020 2020 2020 202d 2054  Cpmin        - T
+00001580: 6865 2063 6f6c 756d 6e20 696e 2074 6865  he column in the
+00001590: 2061 6972 666f 696c 2074 6162 6c65 7320   airfoil tables 
+000015a0: 7468 6174 2063 6f6e 7461 696e 7320 7468  that contains th
+000015b0: 6520 4370 6d69 6e20 636f 6566 6669 6369  e Cpmin coeffici
+000015c0: 656e 743b 2075 7365 207a 6572 6f20 6966  ent; use zero if
+000015d0: 2074 6865 7265 2069 7320 6e6f 2043 706d   there is no Cpm
+000015e0: 696e 2063 6f6c 756d 6e20 282d 290d 0a20  in column (-).. 
+000015f0: 2020 2020 2020 2020 2038 2020 204e 756d           8   Num
+00001600: 4146 6669 6c65 7320 2020 2020 2020 2020  AFfiles         
+00001610: 2d20 4e75 6d62 6572 206f 6620 6169 7266  - Number of airf
+00001620: 6f69 6c20 6669 6c65 7320 7573 6564 2028  oil files used (
+00001630: 2d29 0d0a 222e 2e2f 354d 575f 4261 7365  -).."../5MW_Base
+00001640: 6c69 6e65 2f41 6972 666f 696c 732f 4379  line/Airfoils/Cy
+00001650: 6c69 6e64 6572 312e 6461 7422 2020 2020  linder1.dat"    
+00001660: 4146 4e61 6d65 7320 2020 2020 2020 2020  AFNames         
+00001670: 2020 202d 2041 6972 666f 696c 2066 696c     - Airfoil fil
+00001680: 6520 6e61 6d65 7320 284e 756d 4146 6669  e names (NumAFfi
+00001690: 6c65 7320 6c69 6e65 7329 2028 7175 6f74  les lines) (quot
+000016a0: 6564 2073 7472 696e 6773 290d 0a22 2e2e  ed strings).."..
+000016b0: 2f35 4d57 5f42 6173 656c 696e 652f 4169  /5MW_Baseline/Ai
+000016c0: 7266 6f69 6c73 2f43 796c 696e 6465 7232  rfoils/Cylinder2
+000016d0: 2e64 6174 220d 0a22 2e2e 2f35 4d57 5f42  .dat".."../5MW_B
+000016e0: 6173 656c 696e 652f 4169 7266 6f69 6c73  aseline/Airfoils
+000016f0: 2f44 5534 305f 4131 372e 6461 7422 0d0a  /DU40_A17.dat"..
+00001700: 222e 2e2f 354d 575f 4261 7365 6c69 6e65  "../5MW_Baseline
+00001710: 2f41 6972 666f 696c 732f 4455 3335 5f41  /Airfoils/DU35_A
+00001720: 3137 2e64 6174 220d 0a22 2e2e 2f35 4d57  17.dat".."../5MW
+00001730: 5f42 6173 656c 696e 652f 4169 7266 6f69  _Baseline/Airfoi
+00001740: 6c73 2f44 5533 305f 4131 372e 6461 7422  ls/DU30_A17.dat"
+00001750: 0d0a 222e 2e2f 354d 575f 4261 7365 6c69  .."../5MW_Baseli
+00001760: 6e65 2f41 6972 666f 696c 732f 4455 3235  ne/Airfoils/DU25
+00001770: 5f41 3137 2e64 6174 220d 0a22 2e2e 2f35  _A17.dat".."../5
+00001780: 4d57 5f42 6173 656c 696e 652f 4169 7266  MW_Baseline/Airf
+00001790: 6f69 6c73 2f44 5532 315f 4131 372e 6461  oils/DU21_A17.da
+000017a0: 7422 0d0a 222e 2e2f 354d 575f 4261 7365  t".."../5MW_Base
+000017b0: 6c69 6e65 2f41 6972 666f 696c 732f 4e41  line/Airfoils/NA
+000017c0: 4341 3634 5f41 3137 2e64 6174 220d 0a3d  CA64_A17.dat"..=
+000017d0: 3d3d 3d3d 3d20 2052 6f74 6f72 2f42 6c61  =====  Rotor/Bla
+000017e0: 6465 2050 726f 7065 7274 6965 7320 203d  de Properties  =
+000017f0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001800: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001810: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001820: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001830: 3d3d 3d3d 0d0a 5472 7565 2020 2020 2020  ====..True      
+00001840: 2020 2020 5573 6542 6c43 6d20 2020 2020      UseBlCm     
+00001850: 2020 2020 2020 202d 2049 6e63 6c75 6465         - Include
+00001860: 2061 6572 6f64 796e 616d 6963 2070 6974   aerodynamic pit
+00001870: 6368 696e 6720 6d6f 6d65 6e74 2069 6e20  ching moment in 
+00001880: 6361 6c63 756c 6174 696f 6e73 3f20 2028  calculations?  (
+00001890: 666c 6167 290d 0a22 2e2e 2f35 4d57 5f42  flag).."../5MW_B
+000018a0: 6173 656c 696e 652f 4e52 454c 4f66 6673  aseline/NRELOffs
+000018b0: 6872 4273 6c69 6e65 354d 575f 4165 726f  hrBsline5MW_Aero
+000018c0: 4479 6e5f 626c 6164 652e 6461 7422 2020  Dyn_blade.dat"  
+000018d0: 2020 4144 426c 4669 6c65 2831 2920 2020    ADBlFile(1)   
+000018e0: 2020 2020 202d 204e 616d 6520 6f66 2066       - Name of f
+000018f0: 696c 6520 636f 6e74 6169 6e69 6e67 2064  ile containing d
+00001900: 6973 7472 6962 7574 6564 2061 6572 6f64  istributed aerod
+00001910: 796e 616d 6963 2070 726f 7065 7274 6965  ynamic propertie
+00001920: 7320 666f 7220 426c 6164 6520 2331 2028  s for Blade #1 (
+00001930: 2d29 0d0a 222e 2e2f 354d 575f 4261 7365  -).."../5MW_Base
+00001940: 6c69 6e65 2f4e 5245 4c4f 6666 7368 7242  line/NRELOffshrB
+00001950: 736c 696e 6535 4d57 5f41 6572 6f44 796e  sline5MW_AeroDyn
+00001960: 5f62 6c61 6465 2e64 6174 2220 2020 2041  _blade.dat"    A
+00001970: 4442 6c46 696c 6528 3229 2020 2020 2020  DBlFile(2)      
+00001980: 2020 2d20 4e61 6d65 206f 6620 6669 6c65    - Name of file
+00001990: 2063 6f6e 7461 696e 696e 6720 6469 7374   containing dist
+000019a0: 7269 6275 7465 6420 6165 726f 6479 6e61  ributed aerodyna
+000019b0: 6d69 6320 7072 6f70 6572 7469 6573 2066  mic properties f
+000019c0: 6f72 2042 6c61 6465 2023 3220 282d 2920  or Blade #2 (-) 
+000019d0: 5b75 6e75 7365 6420 6966 204e 756d 426c  [unused if NumBl
+000019e0: 203c 2032 5d0d 0a22 2e2e 2f35 4d57 5f42   < 2].."../5MW_B
+000019f0: 6173 656c 696e 652f 4e52 454c 4f66 6673  aseline/NRELOffs
+00001a00: 6872 4273 6c69 6e65 354d 575f 4165 726f  hrBsline5MW_Aero
+00001a10: 4479 6e5f 626c 6164 652e 6461 7422 2020  Dyn_blade.dat"  
+00001a20: 2020 4144 426c 4669 6c65 2833 2920 2020    ADBlFile(3)   
+00001a30: 2020 2020 202d 204e 616d 6520 6f66 2066       - Name of f
+00001a40: 696c 6520 636f 6e74 6169 6e69 6e67 2064  ile containing d
+00001a50: 6973 7472 6962 7574 6564 2061 6572 6f64  istributed aerod
+00001a60: 796e 616d 6963 2070 726f 7065 7274 6965  ynamic propertie
+00001a70: 7320 666f 7220 426c 6164 6520 2333 2028  s for Blade #3 (
+00001a80: 2d29 205b 756e 7573 6564 2069 6620 4e75  -) [unused if Nu
+00001a90: 6d42 6c20 3c20 335d 0d0a 3d3d 3d3d 3d3d  mBl < 3]..======
+00001aa0: 2020 4875 6220 5072 6f70 6572 7469 6573    Hub Properties
+00001ab0: 203d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d   ===============
+00001ac0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001ad0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001ae0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001af0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20  =============== 
+00001b00: 5b75 7365 6420 6f6e 6c79 2077 6865 6e20  [used only when 
+00001b10: 4275 6f79 616e 6379 3d54 7275 655d 0d0a  Buoyancy=True]..
+00001b20: 302e 3020 2020 566f 6c48 7562 2020 2020  0.0   VolHub    
+00001b30: 2020 2020 2020 2020 202d 2048 7562 2076           - Hub v
+00001b40: 6f6c 756d 6520 286d 5e33 290d 0a30 2e30  olume (m^3)..0.0
+00001b50: 2020 2048 7562 4365 6e42 7820 2020 2020     HubCenBx     
+00001b60: 2020 2020 2020 2d20 4875 6220 6365 6e74        - Hub cent
+00001b70: 6572 206f 6620 6275 6f79 616e 6379 2078  er of buoyancy x
+00001b80: 2064 6972 6563 7469 6f6e 206f 6666 7365   direction offse
+00001b90: 7420 286d 290d 0a3d 3d3d 3d3d 3d20 204e  t (m)..======  N
+00001ba0: 6163 656c 6c65 2050 726f 7065 7274 6965  acelle Propertie
+00001bb0: 7320 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  s ==============
+00001bc0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001bd0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001be0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001bf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 205b 7573  ============ [us
+00001c00: 6564 206f 6e6c 7920 7768 656e 2042 756f  ed only when Buo
+00001c10: 7961 6e63 793d 5472 7565 5d0d 0a30 2e30  yancy=True]..0.0
+00001c20: 2020 2056 6f6c 4e61 6320 2020 2020 2020     VolNac       
+00001c30: 2020 2020 2020 2d20 4e61 6365 6c6c 6520        - Nacelle 
+00001c40: 766f 6c75 6d65 2028 6d5e 3329 0d0a 302c  volume (m^3)..0,
+00001c50: 302c 3020 4e61 6343 656e 4220 2020 2020  0,0 NacCenB     
+00001c60: 2020 2020 2020 202d 2050 6f73 6974 696f         - Positio
+00001c70: 6e20 6f66 206e 6163 656c 6c65 2063 656e  n of nacelle cen
+00001c80: 7465 7220 6f66 2062 756f 7961 6e63 7920  ter of buoyancy 
+00001c90: 6672 6f6d 2079 6177 2062 6561 7269 6e67  from yaw bearing
+00001ca0: 2069 6e20 6e61 6365 6c6c 6520 636f 6f72   in nacelle coor
+00001cb0: 6469 6e61 7465 7320 286d 290d 0a3d 3d3d  dinates (m)..===
+00001cc0: 3d3d 3d20 2054 6169 6c20 6669 6e20 4165  ===  Tail fin Ae
+00001cd0: 726f 6479 6e61 6d69 6373 203d 3d3d 3d3d  rodynamics =====
+00001ce0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001cf0: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001d00: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001d10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00001d20: 3d3d 3d20 0d0a 4661 6c73 6520 2020 2020  === ..False     
+00001d30: 2020 2020 5446 696e 4165 726f 2020 2020      TFinAero    
+00001d40: 2020 2020 2020 202d 2043 616c 6375 6c61         - Calcula
+00001d50: 7465 2074 6169 6c20 6669 6e20 6165 726f  te tail fin aero
+00001d60: 6479 6e61 6d69 6373 206d 6f64 656c 2028  dynamics model (
+00001d70: 666c 6167 290d 0a22 756e 7573 6564 2220  flag).."unused" 
+00001d80: 2020 2020 2054 4669 6e46 696c 6520 2020       TFinFile   
+00001d90: 2020 2020 2020 2020 2d20 496e 7075 7420          - Input 
+00001da0: 6669 6c65 2066 6f72 2074 6169 6c20 6669  file for tail fi
+00001db0: 6e20 6165 726f 6479 6e61 6d69 6373 205b  n aerodynamics [
+00001dc0: 7573 6564 206f 6e6c 7920 7768 656e 2054  used only when T
+00001dd0: 4669 6e41 6572 6f3d 5472 7565 5d0d 0a3d  FinAero=True]..=
+00001de0: 3d3d 3d3d 3d20 2054 6f77 6572 2049 6e66  =====  Tower Inf
+00001df0: 6c75 656e 6365 2061 6e64 2041 6572 6f64  luence and Aerod
+00001e00: 796e 616d 6963 7320 3d3d 3d3d 3d3d 3d3d  ynamics ========
+00001e10: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00001e20: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
 00001e30: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e40: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e50: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00001e60: 3d3d 3d3d 3d3d 3d3d 0d0a 4661 6c73 6520  ========..False 
-00001e70: 2020 2020 2020 2020 2053 756d 5072 696e           SumPrin
-00001e80: 7420 2020 2020 2020 2020 2020 202d 2047  t            - G
-00001e90: 656e 6572 6174 6520 6120 7375 6d6d 6172  enerate a summar
-00001ea0: 7920 6669 6c65 206c 6973 7469 6e67 2069  y file listing i
-00001eb0: 6e70 7574 206f 7074 696f 6e73 2061 6e64  nput options and
-00001ec0: 2069 6e74 6572 706f 6c61 7465 6420 7072   interpolated pr
-00001ed0: 6f70 6572 7469 6573 2074 6f20 223c 726f  operties to "<ro
-00001ee0: 6f74 6e61 6d65 3e2e 4144 2e73 756d 223f  otname>.AD.sum"?
-00001ef0: 2020 2866 6c61 6729 0d0a 2020 2020 2020    (flag)..      
-00001f00: 2020 2020 3020 2020 4e42 6c4f 7574 7320      0   NBlOuts 
-00001f10: 2020 2020 2020 2020 2020 2020 2d20 4e75              - Nu
-00001f20: 6d62 6572 206f 6620 626c 6164 6520 6e6f  mber of blade no
-00001f30: 6465 206f 7574 7075 7473 205b 3020 2d20  de outputs [0 - 
-00001f40: 395d 2028 2d29 0d0a 2020 2020 2020 2020  9] (-)..        
-00001f50: 2020 312c 2020 426c 4f75 744e 6420 2020    1,  BlOutNd   
-00001f60: 2020 2020 2020 2020 2020 2d20 426c 6164            - Blad
-00001f70: 6520 6e6f 6465 7320 7768 6f73 6520 7661  e nodes whose va
-00001f80: 6c75 6573 2077 696c 6c20 6265 206f 7574  lues will be out
-00001f90: 7075 7420 2028 2d29 0d0a 2020 2020 2020  put  (-)..      
-00001fa0: 2020 2020 3020 2020 4e54 774f 7574 7320      0   NTwOuts 
-00001fb0: 2020 2020 2020 2020 2020 2020 2d20 4e75              - Nu
-00001fc0: 6d62 6572 206f 6620 746f 7765 7220 6e6f  mber of tower no
-00001fd0: 6465 206f 7574 7075 7473 205b 3020 2d20  de outputs [0 - 
-00001fe0: 395d 2020 282d 290d 0a20 2020 2020 2020  9]  (-)..       
-00001ff0: 2020 2031 2c20 2020 5477 4f75 744e 6420     1,   TwOutNd 
-00002000: 2020 2020 2020 2020 2020 2020 2d20 546f              - To
-00002010: 7765 7220 6e6f 6465 7320 7768 6f73 6520  wer nodes whose 
-00002020: 7661 6c75 6573 2077 696c 6c20 6265 206f  values will be o
-00002030: 7574 7075 7420 2028 2d29 0d0a 2020 2020  utput  (-)..    
-00002040: 2020 2020 2020 2020 2020 2020 2020 204f                 O
-00002050: 7574 4c69 7374 2020 2020 2020 2020 2020  utList          
-00002060: 2020 202d 2054 6865 206e 6578 7420 6c69     - The next li
-00002070: 6e65 2873 2920 636f 6e74 6169 6e73 2061  ne(s) contains a
-00002080: 206c 6973 7420 6f66 206f 7574 7075 7420   list of output 
-00002090: 7061 7261 6d65 7465 7273 2e20 2053 6565  parameters.  See
-000020a0: 204f 7574 4c69 7374 5061 7261 6d65 7465   OutListParamete
-000020b0: 7273 2e78 6c73 7820 666f 7220 6120 6c69  rs.xlsx for a li
-000020c0: 7374 696e 6720 6f66 2061 7661 696c 6162  sting of availab
-000020d0: 6c65 206f 7574 7075 7420 6368 616e 6e65  le output channe
-000020e0: 6c73 2c20 282d 290d 0a52 7453 7065 6564  ls, (-)..RtSpeed
-000020f0: 0d0a 5274 5453 520d 0a52 7456 4176 6778  ..RtTSR..RtVAvgx
-00002100: 680d 0a52 7456 4176 6779 680d 0a52 7456  h..RtVAvgyh..RtV
-00002110: 4176 677a 680d 0a52 7453 6b65 770d 0a52  Avgzh..RtSkew..R
-00002120: 7441 6572 6f46 7868 0d0a 5274 4165 726f  tAeroFxh..RtAero
-00002130: 4679 680d 0a52 7441 6572 6f46 7a68 0d0a  Fyh..RtAeroFzh..
-00002140: 5274 4165 726f 4d78 680d 0a52 7441 6572  RtAeroMxh..RtAer
-00002150: 6f4d 7968 0d0a 5274 4165 726f 4d7a 680d  oMyh..RtAeroMzh.
-00002160: 0a52 7441 6572 6f50 7772 0d0a 5274 4172  .RtAeroPwr..RtAr
-00002170: 6561 0d0a 5274 4165 726f 4370 0d0a 5274  ea..RtAeroCp..Rt
-00002180: 4165 726f 4371 0d0a 5274 4165 726f 4374  AeroCq..RtAeroCt
-00002190: 0d0a 4231 4e33 436c 726e 632c 2042 324e  ..B1N3Clrnc, B2N
-000021a0: 3343 6c72 6e63 2c20 4233 4e33 436c 726e  3Clrnc, B3N3Clrn
-000021b0: 630d 0a45 4e44 206f 6620 696e 7075 7420  c..END of input 
-000021c0: 6669 6c65 2028 7468 6520 776f 7264 2022  file (the word "
-000021d0: 454e 4422 206d 7573 7420 6170 7065 6172  END" must appear
-000021e0: 2069 6e20 7468 6520 6669 7273 7420 3320   in the first 3 
-000021f0: 636f 6c75 6d6e 7320 6f66 2074 6869 7320  columns of this 
-00002200: 6c61 7374 204f 7574 4c69 7374 206c 696e  last OutList lin
-00002210: 6529 0d0a 3d3d 3d3d 3d3d 204f 7574 7075  e)..====== Outpu
-00002220: 7473 2066 6f72 2061 6c6c 2062 6c61 6465  ts for all blade
-00002230: 2073 7461 7469 6f6e 7320 2873 616d 6520   stations (same 
-00002240: 656e 6469 6e67 2061 7320 6162 6f76 6520  ending as above 
-00002250: 666f 7220 4231 4e31 2e2e 2e2e 203d 3d3d  for B1N1.... ===
-00002260: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
-00002270: 3d3d 3d3d 3d3d 3d3d 205b 6f70 7469 6f6e  ======== [option
-00002280: 616c 2073 6563 7469 6f6e 5d0d 0a20 2020  al section]..   
-00002290: 3120 2020 2020 2020 2020 2020 2020 2042  1              B
-000022a0: 6c64 4e64 5f42 6c61 6465 734f 7574 2020  ldNd_BladesOut  
-000022b0: 2020 202d 204e 756d 6265 7220 6f66 2062     - Number of b
-000022c0: 6c61 6465 7320 746f 206f 7574 7075 7420  lades to output 
-000022d0: 616c 6c20 6e6f 6465 2069 6e66 6f72 6d61  all node informa
-000022e0: 7469 6f6e 2061 742e 2020 5570 2074 6f20  tion at.  Up to 
-000022f0: 6e75 6d62 6572 206f 6620 626c 6164 6573  number of blades
-00002300: 206f 6e20 7475 7262 696e 652e 2028 2d29   on turbine. (-)
-00002310: 0d0a 2020 2022 416c 6c22 2020 2020 2020  ..   "All"      
-00002320: 2020 2020 426c 644e 645f 426c 4f75 744e      BldNd_BlOutN
-00002330: 6420 2020 2020 2020 2d20 4675 7475 7265  d       - Future
-00002340: 2066 6561 7475 7265 2077 696c 6c20 616c   feature will al
-00002350: 6c6f 7720 7365 6c65 6374 696e 6720 6120  low selecting a 
-00002360: 706f 7274 696f 6e20 6f66 2074 6865 206e  portion of the n
-00002370: 6f64 6573 2074 6f20 6f75 7470 7574 2e20  odes to output. 
-00002380: 204e 6f74 2069 6d70 6c65 6d65 6e74 6564   Not implemented
-00002390: 2079 6574 2e20 282d 290d 0a20 2020 2020   yet. (-)..     
-000023a0: 2020 2020 2020 2020 2020 2020 204f 7574               Out
-000023b0: 4c69 7374 4144 2020 2020 2020 2020 2020  ListAD          
-000023c0: 2020 202d 2054 6865 206e 6578 7420 6c69     - The next li
-000023d0: 6e65 2873 2920 636f 6e74 6169 6e73 2061  ne(s) contains a
-000023e0: 206c 6973 7420 6f66 206f 7574 7075 7420   list of output 
-000023f0: 7061 7261 6d65 7465 7273 2e20 2053 6565  parameters.  See
-00002400: 204f 7574 4c69 7374 5061 7261 6d65 7465   OutListParamete
-00002410: 7273 2e78 6c73 7820 666f 7220 6120 6c69  rs.xlsx for a li
-00002420: 7374 696e 6720 6f66 2061 7661 696c 6162  sting of availab
-00002430: 6c65 206f 7574 7075 7420 6368 616e 6e65  le output channe
-00002440: 6c73 2c20 282d 290d 0a22 4678 220d 0a22  ls, (-).."Fx".."
-00002450: 4679 220d 0a22 616c 7068 6122 0d0a 2243  Fy".."alpha".."C
-00002460: 6c22 0d0a 454e 4420 6f66 2020 696e 7075  l"..END of  inpu
-00002470: 7420 6669 6c65 2028 7468 6520 776f 7264  t file (the word
-00002480: 2022 454e 4422 206d 7573 7420 6170 7065   "END" must appe
-00002490: 6172 2069 6e20 7468 6520 6669 7273 7420  ar in the first 
-000024a0: 3320 636f 6c75 6d6e 7320 6f66 2074 6869  3 columns of thi
-000024b0: 7320 6c61 7374 204f 7574 4c69 7374 206c  s last OutList l
-000024c0: 696e 6529 0d0a 2d2d 2d2d 2d2d 2d2d 2d2d  ine)..----------
-000024d0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000024e0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-000024f0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002500: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
-00002510: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d0d 0a    -------------..
+00001e40: 3d3d 3d3d 205b 7573 6564 206f 6e6c 7920  ==== [used only 
+00001e50: 7768 656e 2054 7772 506f 7465 6e74 2f3d  when TwrPotent/=
+00001e60: 302c 2054 7772 5368 6164 6f77 2f3d 302c  0, TwrShadow/=0,
+00001e70: 2054 7772 4165 726f 3d54 7275 652c 206f   TwrAero=True, o
+00001e80: 7220 4275 6f79 616e 6379 3d54 7275 655d  r Buoyancy=True]
+00001e90: 0d0a 2020 2020 2020 2020 2031 3220 2020  ..         12   
+00001ea0: 4e75 6d54 7772 4e64 7320 2020 2020 2020  NumTwrNds       
+00001eb0: 2020 2d20 4e75 6d62 6572 206f 6620 746f    - Number of to
+00001ec0: 7765 7220 6e6f 6465 7320 7573 6564 2069  wer nodes used i
+00001ed0: 6e20 7468 6520 616e 616c 7973 6973 2020  n the analysis  
+00001ee0: 282d 2920 5b75 7365 6420 6f6e 6c79 2077  (-) [used only w
+00001ef0: 6865 6e20 5477 7250 6f74 656e 742f 3d30  hen TwrPotent/=0
+00001f00: 2c20 5477 7253 6861 646f 772f 3d30 2c20  , TwrShadow/=0, 
+00001f10: 6f72 2054 7772 4165 726f 3d54 7275 655d  or TwrAero=True]
+00001f20: 0d0a 5477 7245 6c65 7620 2020 2020 2020  ..TwrElev       
+00001f30: 2054 7772 4469 616d 2020 2020 2020 2020   TwrDiam        
+00001f40: 5477 7243 6420 2020 2020 2020 2020 2054  TwrCd          T
+00001f50: 7772 5449 2020 2020 2020 2020 2020 5477  wrTI          Tw
+00001f60: 7243 6220 2154 7772 5449 2075 7365 6420  rCb !TwrTI used 
+00001f70: 6f6e 6c79 2077 6974 6820 5477 7253 6861  only with TwrSha
+00001f80: 646f 773d 322c 2054 7772 4362 2075 7365  dow=2, TwrCb use
+00001f90: 6420 6f6e 6c79 2077 6974 6820 4275 6f79  d only with Buoy
+00001fa0: 616e 6379 3d54 7275 650d 0a28 6d29 2020  ancy=True..(m)  
+00001fb0: 2020 2020 2020 2020 2020 2020 286d 2920              (m) 
+00001fc0: 2020 2020 2020 2020 2020 282d 2920 2020            (-)   
+00001fd0: 2020 2020 2020 2020 2028 2d29 2020 2020           (-)    
+00001fe0: 2020 2020 2020 2028 2d29 0d0a 302e 3030         (-)..0.00
+00001ff0: 3030 3030 3045 2b30 3020 2036 2e30 3030  00000E+00  6.000
+00002000: 3030 3030 452b 3030 2020 312e 3030 3030  0000E+00  1.0000
+00002010: 3030 3045 2b30 3020 2031 2e30 3030 3030  000E+00  1.00000
+00002020: 3030 452d 3031 2020 302e 300d 0a38 2e35  00E-01  0.0..8.5
+00002030: 3236 3130 3030 452b 3030 2020 352e 3738  261000E+00  5.78
+00002040: 3730 3030 3045 2b30 3020 2031 2e30 3030  70000E+00  1.000
+00002050: 3030 3030 452b 3030 2020 312e 3030 3030  0000E+00  1.0000
+00002060: 3030 3045 2d30 3120 2030 2e30 0d0a 312e  000E-01  0.0..1.
+00002070: 3730 3533 3030 3045 2b30 3120 2035 2e35  7053000E+01  5.5
+00002080: 3734 3030 3030 452b 3030 2020 312e 3030  740000E+00  1.00
+00002090: 3030 3030 3045 2b30 3020 2031 2e30 3030  00000E+00  1.000
+000020a0: 3030 3030 452d 3031 2020 302e 300d 0a32  0000E-01  0.0..2
+000020b0: 2e35 3537 3930 3030 452b 3031 2020 352e  .5579000E+01  5.
+000020c0: 3336 3130 3030 3045 2b30 3020 2031 2e30  3610000E+00  1.0
+000020d0: 3030 3030 3030 452b 3030 2020 312e 3030  000000E+00  1.00
+000020e0: 3030 3030 3045 2d30 3120 2030 2e30 0d0a  00000E-01  0.0..
+000020f0: 332e 3431 3035 3030 3045 2b30 3120 2035  3.4105000E+01  5
+00002100: 2e31 3438 3030 3030 452b 3030 2020 312e  .1480000E+00  1.
+00002110: 3030 3030 3030 3045 2b30 3020 2031 2e30  0000000E+00  1.0
+00002120: 3030 3030 3030 452d 3031 2020 302e 300d  000000E-01  0.0.
+00002130: 0a34 2e32 3633 3330 3030 452b 3031 2020  .4.2633000E+01  
+00002140: 342e 3933 3530 3030 3045 2b30 3020 2031  4.9350000E+00  1
+00002150: 2e30 3030 3030 3030 452b 3030 2020 312e  .0000000E+00  1.
+00002160: 3030 3030 3030 3045 2d30 3120 2030 2e30  0000000E-01  0.0
+00002170: 0d0a 352e 3131 3538 3030 3045 2b30 3120  ..5.1158000E+01 
+00002180: 2034 2e37 3232 3030 3030 452b 3030 2020   4.7220000E+00  
+00002190: 312e 3030 3030 3030 3045 2b30 3020 2031  1.0000000E+00  1
+000021a0: 2e30 3030 3030 3030 452d 3031 2020 302e  .0000000E-01  0.
+000021b0: 300d 0a35 2e39 3638 3530 3030 452b 3031  0..5.9685000E+01
+000021c0: 2020 342e 3530 3930 3030 3045 2b30 3020    4.5090000E+00 
+000021d0: 2031 2e30 3030 3030 3030 452b 3030 2020   1.0000000E+00  
+000021e0: 312e 3030 3030 3030 3045 2d30 3120 2030  1.0000000E-01  0
+000021f0: 2e30 0d0a 362e 3832 3131 3030 3045 2b30  .0..6.8211000E+0
+00002200: 3120 2034 2e32 3936 3030 3030 452b 3030  1  4.2960000E+00
+00002210: 2020 312e 3030 3030 3030 3045 2b30 3020    1.0000000E+00 
+00002220: 2031 2e30 3030 3030 3030 452d 3031 2020   1.0000000E-01  
+00002230: 302e 300d 0a37 2e36 3733 3830 3030 452b  0.0..7.6738000E+
+00002240: 3031 2020 342e 3038 3330 3030 3045 2b30  01  4.0830000E+0
+00002250: 3020 2031 2e30 3030 3030 3030 452b 3030  0  1.0000000E+00
+00002260: 2020 312e 3030 3030 3030 3045 2d30 3120    1.0000000E-01 
+00002270: 2030 2e30 0d0a 382e 3532 3638 3030 3045   0.0..8.5268000E
+00002280: 2b30 3120 2033 2e38 3730 3030 3030 452b  +01  3.8700000E+
+00002290: 3030 2020 312e 3030 3030 3030 3045 2b30  00  1.0000000E+0
+000022a0: 3020 2031 2e30 3030 3030 3030 452d 3031  0  1.0000000E-01
+000022b0: 2020 302e 300d 0a38 2e37 3630 3030 3030    0.0..8.7600000
+000022c0: 452b 3031 2020 332e 3837 3030 3030 3045  E+01  3.8700000E
+000022d0: 2b30 3020 2031 2e30 3030 3030 3030 452b  +00  1.0000000E+
+000022e0: 3030 2020 312e 3030 3030 3030 3045 2d30  00  1.0000000E-0
+000022f0: 3120 2030 2e30 0d0a 3d3d 3d3d 3d3d 2020  1  0.0..======  
+00002300: 4f75 7470 7574 7320 203d 3d3d 3d3d 3d3d  Outputs  =======
+00002310: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00002320: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00002330: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00002340: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  ================
+00002350: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d0d 0a46  =============..F
+00002360: 616c 7365 2020 2020 2020 2020 2020 5375  alse          Su
+00002370: 6d50 7269 6e74 2020 2020 2020 2020 2020  mPrint          
+00002380: 2020 2d20 4765 6e65 7261 7465 2061 2073    - Generate a s
+00002390: 756d 6d61 7279 2066 696c 6520 6c69 7374  ummary file list
+000023a0: 696e 6720 696e 7075 7420 6f70 7469 6f6e  ing input option
+000023b0: 7320 616e 6420 696e 7465 7270 6f6c 6174  s and interpolat
+000023c0: 6564 2070 726f 7065 7274 6965 7320 746f  ed properties to
+000023d0: 2022 3c72 6f6f 746e 616d 653e 2e41 442e   "<rootname>.AD.
+000023e0: 7375 6d22 3f20 2028 666c 6167 290d 0a20  sum"?  (flag).. 
+000023f0: 2020 2020 2020 2020 2030 2020 204e 426c           0   NBl
+00002400: 4f75 7473 2020 2020 2020 2020 2020 2020  Outs            
+00002410: 202d 204e 756d 6265 7220 6f66 2062 6c61   - Number of bla
+00002420: 6465 206e 6f64 6520 6f75 7470 7574 7320  de node outputs 
+00002430: 5b30 202d 2039 5d20 282d 290d 0a20 2020  [0 - 9] (-)..   
+00002440: 2020 2020 2020 2031 2c20 2042 6c4f 7574         1,  BlOut
+00002450: 4e64 2020 2020 2020 2020 2020 2020 202d  Nd             -
+00002460: 2042 6c61 6465 206e 6f64 6573 2077 686f   Blade nodes who
+00002470: 7365 2076 616c 7565 7320 7769 6c6c 2062  se values will b
+00002480: 6520 6f75 7470 7574 2020 282d 290d 0a20  e output  (-).. 
+00002490: 2020 2020 2020 2020 2030 2020 204e 5477           0   NTw
+000024a0: 4f75 7473 2020 2020 2020 2020 2020 2020  Outs            
+000024b0: 202d 204e 756d 6265 7220 6f66 2074 6f77   - Number of tow
+000024c0: 6572 206e 6f64 6520 6f75 7470 7574 7320  er node outputs 
+000024d0: 5b30 202d 2039 5d20 2028 2d29 0d0a 2020  [0 - 9]  (-)..  
+000024e0: 2020 2020 2020 2020 312c 2020 2054 774f          1,   TwO
+000024f0: 7574 4e64 2020 2020 2020 2020 2020 2020  utNd            
+00002500: 202d 2054 6f77 6572 206e 6f64 6573 2077   - Tower nodes w
+00002510: 686f 7365 2076 616c 7565 7320 7769 6c6c  hose values will
+00002520: 2062 6520 6f75 7470 7574 2020 282d 290d   be output  (-).
+00002530: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00002540: 2020 2020 4f75 744c 6973 7420 2020 2020      OutList     
+00002550: 2020 2020 2020 2020 2d20 5468 6520 6e65          - The ne
+00002560: 7874 206c 696e 6528 7329 2063 6f6e 7461  xt line(s) conta
+00002570: 696e 7320 6120 6c69 7374 206f 6620 6f75  ins a list of ou
+00002580: 7470 7574 2070 6172 616d 6574 6572 732e  tput parameters.
+00002590: 2020 5365 6520 4f75 744c 6973 7450 6172    See OutListPar
+000025a0: 616d 6574 6572 732e 786c 7378 2066 6f72  ameters.xlsx for
+000025b0: 2061 206c 6973 7469 6e67 206f 6620 6176   a listing of av
+000025c0: 6169 6c61 626c 6520 6f75 7470 7574 2063  ailable output c
+000025d0: 6861 6e6e 656c 732c 2028 2d29 0d0a 5274  hannels, (-)..Rt
+000025e0: 5370 6565 640d 0a52 7454 5352 0d0a 5274  Speed..RtTSR..Rt
+000025f0: 5641 7667 7868 0d0a 5274 5641 7667 7968  VAvgxh..RtVAvgyh
+00002600: 0d0a 5274 5641 7667 7a68 0d0a 5274 536b  ..RtVAvgzh..RtSk
+00002610: 6577 0d0a 5274 4165 726f 4678 680d 0a52  ew..RtAeroFxh..R
+00002620: 7441 6572 6f46 7968 0d0a 5274 4165 726f  tAeroFyh..RtAero
+00002630: 467a 680d 0a52 7441 6572 6f4d 7868 0d0a  Fzh..RtAeroMxh..
+00002640: 5274 4165 726f 4d79 680d 0a52 7441 6572  RtAeroMyh..RtAer
+00002650: 6f4d 7a68 0d0a 5274 4165 726f 5077 720d  oMzh..RtAeroPwr.
+00002660: 0a52 7441 7265 610d 0a52 7441 6572 6f43  .RtArea..RtAeroC
+00002670: 700d 0a52 7441 6572 6f43 710d 0a52 7441  p..RtAeroCq..RtA
+00002680: 6572 6f43 740d 0a42 314e 3343 6c72 6e63  eroCt..B1N3Clrnc
+00002690: 2c20 4232 4e33 436c 726e 632c 2042 334e  , B2N3Clrnc, B3N
+000026a0: 3343 6c72 6e63 0d0a 454e 4420 6f66 2069  3Clrnc..END of i
+000026b0: 6e70 7574 2066 696c 6520 2874 6865 2077  nput file (the w
+000026c0: 6f72 6420 2245 4e44 2220 6d75 7374 2061  ord "END" must a
+000026d0: 7070 6561 7220 696e 2074 6865 2066 6972  ppear in the fir
+000026e0: 7374 2033 2063 6f6c 756d 6e73 206f 6620  st 3 columns of 
+000026f0: 7468 6973 206c 6173 7420 4f75 744c 6973  this last OutLis
+00002700: 7420 6c69 6e65 290d 0a3d 3d3d 3d3d 3d20  t line)..====== 
+00002710: 4f75 7470 7574 7320 666f 7220 616c 6c20  Outputs for all 
+00002720: 626c 6164 6520 7374 6174 696f 6e73 2028  blade stations (
+00002730: 7361 6d65 2065 6e64 696e 6720 6173 2061  same ending as a
+00002740: 626f 7665 2066 6f72 2042 314e 312e 2e2e  bove for B1N1...
+00002750: 2e20 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d  . ==============
+00002760: 3d3d 3d3d 3d3d 3d3d 3d3d 3d3d 3d20 5b6f  ============= [o
+00002770: 7074 696f 6e61 6c20 7365 6374 696f 6e5d  ptional section]
+00002780: 0d0a 2020 2031 2020 2020 2020 2020 2020  ..   1          
+00002790: 2020 2020 426c 644e 645f 426c 6164 6573      BldNd_Blades
+000027a0: 4f75 7420 2020 2020 2d20 4e75 6d62 6572  Out     - Number
+000027b0: 206f 6620 626c 6164 6573 2074 6f20 6f75   of blades to ou
+000027c0: 7470 7574 2061 6c6c 206e 6f64 6520 696e  tput all node in
+000027d0: 666f 726d 6174 696f 6e20 6174 2e20 2055  formation at.  U
+000027e0: 7020 746f 206e 756d 6265 7220 6f66 2062  p to number of b
+000027f0: 6c61 6465 7320 6f6e 2074 7572 6269 6e65  lades on turbine
+00002800: 2e20 282d 290d 0a20 2020 2241 6c6c 2220  . (-)..   "All" 
+00002810: 2020 2020 2020 2020 2042 6c64 4e64 5f42           BldNd_B
+00002820: 6c4f 7574 4e64 2020 2020 2020 202d 2046  lOutNd       - F
+00002830: 7574 7572 6520 6665 6174 7572 6520 7769  uture feature wi
+00002840: 6c6c 2061 6c6c 6f77 2073 656c 6563 7469  ll allow selecti
+00002850: 6e67 2061 2070 6f72 7469 6f6e 206f 6620  ng a portion of 
+00002860: 7468 6520 6e6f 6465 7320 746f 206f 7574  the nodes to out
+00002870: 7075 742e 2020 4e6f 7420 696d 706c 656d  put.  Not implem
+00002880: 656e 7465 6420 7965 742e 2028 2d29 0d0a  ented yet. (-)..
+00002890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000028a0: 2020 4f75 744c 6973 7441 4420 2020 2020    OutListAD     
+000028b0: 2020 2020 2020 2020 2d20 5468 6520 6e65          - The ne
+000028c0: 7874 206c 696e 6528 7329 2063 6f6e 7461  xt line(s) conta
+000028d0: 696e 7320 6120 6c69 7374 206f 6620 6f75  ins a list of ou
+000028e0: 7470 7574 2070 6172 616d 6574 6572 732e  tput parameters.
+000028f0: 2020 5365 6520 4f75 744c 6973 7450 6172    See OutListPar
+00002900: 616d 6574 6572 732e 786c 7378 2066 6f72  ameters.xlsx for
+00002910: 2061 206c 6973 7469 6e67 206f 6620 6176   a listing of av
+00002920: 6169 6c61 626c 6520 6f75 7470 7574 2063  ailable output c
+00002930: 6861 6e6e 656c 732c 2028 2d29 0d0a 2256  hannels, (-).."V
+00002940: 556e 6478 220d 0a22 5655 6e64 7922 0d0a  Undx".."VUndy"..
+00002950: 2256 556e 647a 220d 0a22 5644 6973 7822  "VUndz".."VDisx"
+00002960: 0d0a 2256 4469 7379 220d 0a22 5644 6973  .."VDisy".."VDis
+00002970: 7a22 0d0a 2253 5456 7822 0d0a 2253 5456  z".."STVx".."STV
+00002980: 7922 0d0a 2253 5456 7a22 0d0a 2256 5265  y".."STVz".."VRe
+00002990: 6c22 0d0a 2244 796e 5022 0d0a 2252 6522  l".."DynP".."Re"
+000029a0: 0d0a 224d 220d 0a22 5669 6e64 7822 0d0a  .."M".."Vindx"..
+000029b0: 2256 696e 6479 220d 0a22 4178 496e 6422  "Vindy".."AxInd"
+000029c0: 0d0a 2254 6e49 6e64 220d 0a22 416c 7068  .."TnInd".."Alph
+000029d0: 6122 0d0a 2254 6865 7461 220d 0a22 5068  a".."Theta".."Ph
+000029e0: 6922 0d0a 2243 7572 7665 220d 0a22 436c  i".."Curve".."Cl
+000029f0: 220d 0a22 4364 220d 0a22 436d 220d 0a22  ".."Cd".."Cm".."
+00002a00: 4378 220d 0a22 4379 220d 0a22 436e 220d  Cx".."Cy".."Cn".
+00002a10: 0a22 4374 220d 0a22 466c 220d 0a22 4664  ."Ct".."Fl".."Fd
+00002a20: 220d 0a22 4d6d 220d 0a22 4678 220d 0a22  ".."Mm".."Fx".."
+00002a30: 4679 220d 0a22 466e 220d 0a22 4674 220d  Fy".."Fn".."Ft".
+00002a40: 0a22 436c 726e 6322 0d0a 2256 7822 0d0a  ."Clrnc".."Vx"..
+00002a50: 2256 7922 0d0a 2247 656f 6d50 6869 220d  "Vy".."GeomPhi".
+00002a60: 0a22 4368 6922 0d0a 2255 415f 466c 6167  ."Chi".."UA_Flag
+00002a70: 220d 0a45 4e44 206f 6620 2069 6e70 7574  "..END of  input
+00002a80: 2066 696c 6520 2874 6865 2077 6f72 6420   file (the word 
+00002a90: 2245 4e44 2220 6d75 7374 2061 7070 6561  "END" must appea
+00002aa0: 7220 696e 2074 6865 2066 6972 7374 2033  r in the first 3
+00002ab0: 2063 6f6c 756d 6e73 206f 6620 7468 6973   columns of this
+00002ac0: 206c 6173 7420 4f75 744c 6973 7420 6c69   last OutList li
+00002ad0: 6e65 290d 0a2d 2d2d 2d2d 2d2d 2d2d 2d2d  ne)..-----------
+00002ae0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002af0: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b00: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b10: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d  ----------------
+00002b20: 2d2d 2d2d 2d2d 2d2d 2d2d 2d2d 0d0a       ------------..
```

### Comparing `welib-0.0.2/data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat` & `welib-1.0.0/data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Main_Spar_ED.fst` & `welib-1.0.0/data/Spar/Main_Spar_ED.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Main_Spar_ED_HydroExample.fst` & `welib-1.0.0/data/Spar/Main_Spar_ED_HydroExample.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Main_Spar_ED_HydroExample.outb` & `welib-1.0.0/data/Spar/Main_Spar_ED_HydroExample.outb`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Main_Spar_SD.fst` & `welib-1.0.0/data/Spar/Main_Spar_SD.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Spar_ED_ForED.dat` & `welib-1.0.0/data/Spar/Spar_ED_ForED.dat`

 * *Files 8% similar despite different names*

```diff
@@ -1,25 +1,25 @@
 ------- ELASTODYN for OpenFAST INPUT FILE -------------------------------------------
-NREL 5.0 MW Baseline Wind Turbine for Use in Offshore Analysis. Properties from Dutch Offshore Wind Energy Converter (DOWEC) 6MW Pre-Design (10046_009.pdf) and REpower 5M 5MW (5m_uk.pdf)
+Spar no RNA ref height 25, all inertias in ElastoDyn
 ---------------------- SIMULATION CONTROL --------------------------------------
 False         Echo        - Echo input data to "<RootName>.ech" (flag)
           3   Method      - Integration method: {1: RK4, 2: AB4, or 3: ABM4} (-)
 "default"     DT          - Integration time step (s)
 ---------------------- DEGREES OF FREEDOM --------------------------------------
 False          FlapDOF1    - First flapwise blade mode DOF (flag)
 False          FlapDOF2    - Second flapwise blade mode DOF (flag)
 False          EdgeDOF     - First edgewise blade mode DOF (flag)
 False         TeetDOF     - Rotor-teeter DOF (flag) [unused for 3 blades]
 False          DrTrDOF     - Drivetrain rotational-flexibility DOF (flag)
 False          GenDOF      - Generator DOF (flag)
 False          YawDOF      - Yaw DOF (flag)
-False          TwFADOF1    - First fore-aft tower bending-mode DOF (flag)
-False          TwFADOF2    - Second fore-aft tower bending-mode DOF (flag)
-False          TwSSDOF1    - First side-to-side tower bending-mode DOF (flag)
-False          TwSSDOF2    - Second side-to-side tower bending-mode DOF (flag)
+True           TwFADOF1    - First fore-aft tower bending-mode DOF (flag)
+True           TwFADOF2    - Second fore-aft tower bending-mode DOF (flag)
+True           TwSSDOF1    - First side-to-side tower bending-mode DOF (flag)
+True           TwSSDOF2    - Second side-to-side tower bending-mode DOF (flag)
 True           PtfmSgDOF   - Platform horizontal surge translation DOF (flag)
 False          PtfmSwDOF   - Platform horizontal sway translation DOF (flag)
 True           PtfmHvDOF   - Platform vertical heave translation DOF (flag)
 False          PtfmRDOF    - Platform roll tilt rotation DOF (flag)
 True           PtfmPDOF    - Platform pitch tilt rotation DOF (flag)
 False          PtfmYDOF    - Platform yaw rotation DOF (flag)
 ---------------------- INITIAL CONDITIONS --------------------------------------
@@ -150,12 +150,21 @@
 "YawBrMzp"                - Side-to-side bending, fore-aft bending, and yaw moments at the top of the tower (not rotating with nacelle yaw)
 "TwrBsFxt"                - Fore-aft shear, side-to-side shear, and vertical forces at the base of the tower (platform)
 "TwrBsFyt"                - Fore-aft shear, side-to-side shear, and vertical forces at the base of the tower (platform)
 "TwrBsFzt"                - Fore-aft shear, side-to-side shear, and vertical forces at the base of the tower (platform)
 "TwrBsMxt"                - Side-to-side bending, fore-aft bending, and yaw moments at the base of the tower (platform)
 "TwrBsMyt"                - Side-to-side bending, fore-aft bending, and yaw moments at the base of the tower (platform)
 "TwrBsMzt"                - Side-to-side bending, fore-aft bending, and yaw moments at the base of the tower (platform)
-"QD_Sg"
-"QD_Hv"
-"QD_P"
+"Q_Sg"		Displacement of platform horizontal surge translation DOF
+"Q_Sw"		Displacement of platform horizontal sway translation DOF
+"Q_Hv"		Displacement of platform vertical heave translation DOF
+"Q_R"		Displacement of platform roll tilt rotation DOF
+"Q_P"		Displacement of platform pitch tilt rotation DOF
+"Q_Y"		Displacement of platform yaw rotation DOF
+"QD_Sg"		Velocity of platform horizontal surge translation DOF
+"QD_Sw"		Velocity of platform horizontal sway translation DOF
+"QD_Hv"		Velocity of platform vertical heave translation DOF
+"QD_R"		Velocity of platform roll tilt rotation DOF
+"QD_P"		Velocity of platform pitch tilt rotation DOF
+"QD_Y"		Velocity of platform yaw rotation DOF
 END of input file (the word "END" must appear in the first 3 columns of this last OutList line)
 ---------------------------------------------------------------------------------------
```

### Comparing `welib-0.0.2/data/Spar/Spar_ED_ForSD.dat` & `welib-1.0.0/data/Spar/Spar_ED_ForSD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Spar/Spar_HD.dat` & `welib-1.0.0/data/Spar/Spar_HD.dat`

 * *Files 0% similar despite different names*

```diff
@@ -1,13 +1,13 @@
 ------- HydroDyn v2.03.* Input File --------------------------------------------
 Updated HydroDyn input file for the TCF project. Full scale model to verify OpenFAST against HAWC2/OrcaFlex for the TetraSpar project.
 False            Echo           - Echo the input file data (flag)
 ---------------------- ENVIRONMENTAL CONDITIONS --------------------------------
-          1025   WtrDens        - Water density (kg/m^3)
-           320   WtrDpth        - Water depth (meters)
+       default   WtrDens        - Water density (kg/m^3)
+       default   WtrDpth        - Water depth (meters)
              0   MSL2SWL        - Offset between still-water level and mean sea level (meters) [positive upward; unused when WaveMod = 6; must be zero if PotMod=1 or 2]
 ---------------------- WAVES ---------------------------------------------------
              0   WaveMod        - Incident wave kinematics model {0: none=still water, 1: regular (periodic), 1P#: regular with user-specified phase, 2: JONSWAP/Pierson-Moskowitz spectrum (irregular), 3: White noise spectrum (irregular), 4: user-defined spectrum from routine UserWaveSpctrm (irregular), 5: Externally generated wave-elevation time series, 6: Externally generated full wave-kinematics time series [option 6 is invalid for PotMod/=0]} (switch)
              0   WaveStMod      - Model for stretching incident wave kinematics to instantaneous free surface {0: none=no stretching, 1: vertical stretching, 2: extrapolation stretching, 3: Wheeler stretching} (switch) [unused when WaveMod=0 or when PotMod/=0]
           3630   WaveTMax       - Analysis time for incident wave calculations (sec) [unused when WaveMod=0; determines WaveDOmega=2Pi/WaveTMax in the IFFT]
           0.25   WaveDT         - Time step for incident wave calculations     (sec) [unused when WaveMod=0; 0.1<=WaveDT<=1.0 recommended; determines WaveOmegaMax=Pi/WaveDT in the IFFT]
              6   WaveHs         - Significant wave height of incident waves (meters) [used only when WaveMod=1, 2, or 3]
```

### Comparing `welib-0.0.2/data/Spar/Spar_SD.dat` & `welib-1.0.0/data/Spar/Spar_SD.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/Jacket.dat` & `welib-1.0.0/data/SubDyn/Jacket.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/Jacket.dvr` & `welib-1.0.0/data/SubDyn/Jacket.dvr`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/JacketTwr.dat` & `welib-1.0.0/data/SubDyn/JacketTwr.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/JacketTwr.dvr` & `welib-1.0.0/data/SubDyn/JacketTwr.dvr`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/SD_Cable_5Joints.dat` & `welib-1.0.0/data/SubDyn/SD_Cable_5Joints.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/SD_Cable_5Joints.dvr` & `welib-1.0.0/data/SubDyn/SD_Cable_5Joints.dvr`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/Twr.dat` & `welib-1.0.0/data/SubDyn/Twr.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/Twr.dvr` & `welib-1.0.0/data/SubDyn/Twr.dvr`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/TwrSmall.dat` & `welib-1.0.0/data/SubDyn/TwrSmall.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/SubDyn/TwrSmall.dvr` & `welib-1.0.0/data/SubDyn/TwrSmall.dvr`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/Waves/RegularWave.Elev` & `welib-1.0.0/data/Waves/RegularWave.Elev`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/example_files/FASTSum_Pendulum.SD.sum.yaml` & `welib-1.0.0/data/example_files/FASTSum_Pendulum.SD.sum.yaml`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/example_files/FASTSum_PendulumNoCB.SD.sum.yaml` & `welib-1.0.0/data/example_files/FASTSum_PendulumNoCB.SD.sum.yaml`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/data/example_files/fastout_allnodes.outb` & `welib-1.0.0/data/example_files/fastout_allnodes.outb`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/setup.py` & `welib-1.0.0/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 from setuptools import setup, find_packages
 
-VERSION='0.0.2'
+VERSION='1.0.0'
 
 
 EXTRAS = {
     'docs': {
         'readthedocs-sphinx-ext>=0.5.15',
         'Sphinx>=2.0',
         'sphinxcontrib-napoleon>=0.7'
@@ -25,15 +25,14 @@
     python_requires=">=3.6",
     packages=find_packages(exclude=["tests"]),
     install_requires=[
         'matplotlib', 
         'xlrd',
         'numpy',
         'pandas', 
-        'future', 
         'chardet',
         'scipy', 
         'sympy'
     ],
     extras_require       = EXTRAS,
     include_package_date = True,
     zip_safe=False,
```

### Comparing `welib-0.0.2/welib/BEM/_OTHER.py` & `welib-1.0.0/welib/BEM/_OTHER.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/_TODO.py` & `welib-1.0.0/welib/BEM/_TODO.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/examples/Example_AxialInduction.py` & `welib-1.0.0/welib/BEM/examples/Example_AxialInduction.py`

 * *Files 1% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     # Functions that depend on a only
     ax.plot(a ,Ct_MT,'k-' ,label = 'Momentum theory'          )
     ax.plot(a ,Ct_a(a,method='Glauert'),'-' ,label = 'Glauert (ac=1/3)')
     ax.plot(a ,Ct_a(a,method='Spera')  ,'.' ,label = 'Spera (ac=0.3)')
     # Functions that depend on Ct only
-    ax.plot(a_Ct(Ct,method = 'AeroDyn'         ),Ct,'-' ,label = 'AeroDyn'          )
+    ax.plot(a_Ct(Ct,method = 'AeroDyn15'       ),Ct,'-' ,label = 'AeroDyn'          )
     ax.plot(a_Ct(Ct,method = 'HAWC2'           ),Ct,'--',label = 'HAWC2'            )
     ax.plot(a_Ct(Ct,method = 'WEHandbook'      ),Ct,':' ,label = 'Handbook'         )
     ax.plot(a_Ct(Ct,method = 'GlauertEmpirical'),Ct,'-.',label = 'Glauert Empirical')
     ax.set_xlabel('Axial induction, a [-]')
     ax.set_ylabel('Thrust coefficient, Ct [-]')
     ax.set_xlim([0,1])
     ax.set_ylim([0,2])
```

### Comparing `welib-0.0.2/welib/BEM/examples/Example_BEM_1.py` & `welib-1.0.0/welib/BEM/examples/Example_BEM_1.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 """ 
 Performs simple BEM simulations of the NREL 5MW turbine for two operating conditions.
 """
 # --- Common libraries 
-from welib.BEM.steadyBEM import SteadyBEM, FASTFile2SteadyBEM
+from welib.BEM.steadyBEM import calcSteadyBEM, FASTFile2SteadyBEM
 import os
 import glob
 import matplotlib.pyplot as plt
 
 MyDir=os.path.dirname(__file__)
 
 def main(test=False):
@@ -26,15 +26,15 @@
     a0, ap0  = None,None  # inductions, used to speed up parametric study
     for i,ws in enumerate(WS):
         V0     = WS[i]    # [m/s]
         Omega  = RPM[i]   # [rpm]
         pitch  = PITCH[i] # [deg]
         xdot   = 0        # [m/s]
         u_turb = 0        # [m/s]
-        BEM=SteadyBEM(Omega,pitch,V0,xdot,u_turb,
+        BEM=calcSteadyBEM(Omega,pitch,V0,xdot,u_turb,
                     nB,cone,r,chord,twist,polars,
                     rho=rho,KinVisc=KinVisc,bTIDrag=False,bAIDrag=True,
                     a_init =a0,
                     ap_init=ap0
                     )
         a0, ap0 = BEM.a, BEM.aprime
```

### Comparing `welib-0.0.2/welib/BEM/examples/Example_BEM_2.py` & `welib-1.0.0/welib/BEM/examples/Example_UnsteadyBEM_2_PrescribedMotion.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,87 +1,86 @@
 """ 
-Performs simple BEM simulations of the NREL 5MW turbine for a set of operating conditions.
+Performs a simple Unsteady BEM simulations of the NREL 5MW turbine
+with a predefined motion
 """
 # --- Common libraries 
-import sys
 import os
-import glob
-import numpy as np
 import matplotlib.pyplot as plt
-import pandas as pd
 # --- Local libraries
-from welib.BEM.steadyBEM import SteadyBEM, FASTFile2SteadyBEM
-import welib.weio as weio
+from welib.BEM.unsteadyBEM import *
+from welib.tools.figure import defaultRC; defaultRC();
 
 MyDir=os.path.dirname(__file__)
 
 def main(test=False):
-    """ 
-    Performs BEM simulations for different Pitch, RPM and Wind Speed.
-    The wind turbine is initialized using a FAST input file (.fst)
-    """
-    OutDir                 = os.path.join(MyDir,'./')
-    MainFASTFile           = os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst')
-    OperatingConditionFile = os.path.join(MyDir,'../../../data/NREL5MW/NREL5MW_Oper.csv')
-
-    #  --- Reading turbine operating conditions, Pitch, RPM, WS  (From FAST)
-    df=weio.read(OperatingConditionFile).toDataFrame()
-    Pitch = df['BldPitch_[deg]'].values
-    Omega = df['RotSpeed_[rpm]'].values
-    WS    = df['WS_[m/s]'].values
-
-
-    # -- Extracting information from a FAST main file and sub files
-    nB,cone,r,chord,twist,polars,rho,KinVisc = FASTFile2SteadyBEM(MainFASTFile) 
-    BladeData=np.column_stack((r,chord,twist))
-
-    # --- Running BEM simulations for each operating conditions
-    a0 , ap0 = None,None # Initial guess for inductions, to speed up BEM
-    dfOut=None
-    if not os.path.exists(OutDir):
-        os.makedirs(OutDir)
-    # Loop on operating conditions
-    for i,(V0,RPM,pitch), in enumerate(zip(WS,Omega,Pitch)):
-        xdot   = 0        # [m/s]
-        u_turb = 0        # [m/s] 
-        BEM=SteadyBEM(RPM,pitch,V0,xdot,u_turb,
-                    nB,cone,r,chord,twist,polars,
-                    rho=rho,KinVisc=KinVisc,bTIDrag=False,bAIDrag=True,
-                    a_init =a0, ap_init=ap0)
-        a0, ap0 = BEM.a, BEM.aprime
-        # Export radial data to file
-        if not test:
-            filenameRadial = os.path.join(OutDir,'_BEM_ws{:02.0f}_radial.csv'.format(V0))
-            BEM.WriteRadialFile(filenameRadial)
-            print('>>>',filenameRadial)
-        dfOut = BEM.StoreIntegratedValues(dfOut)
 
-    # --- Export integrated values to file
-    filenameOut= os.path.join(OutDir,'_BEM_IntegratedValues.csv')
+    # --- Read a FAST model to get Aerodynamic parameters to initialze unstady BEM code
+    BEM = UnsteadyBEM(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
+
+    # --- Setup a prescribed motion
+    motion = PrescribedRotorMotion()
+    motion.init_from_BEM(BEM)
+    motion.setType('constantRPM x-oscillation', RPM=12.1, frequency=0.1, amplitude=3)
+
+    # --- Define wind at every point and time
+    windSpeed=10
+    windFunction = lambda x,y,z,t : (np.ones(x.shape)*windSpeed, np.zeros(x.shape), np.zeros(y.shape))
+
+    # --- Time simulation
+    dt       = 0.1
+    dtRadOut = 1.0
+    tmax     = 70
+    BEM.timeStepInit(0,tmax,dt) # Allocate memory for time storage
+    xdBEM = BEM.getInitStates() # Initial discrete states 
+    for it,t in enumerate(BEM.time):
+        motion.update(t)
+        u,v,w = windFunction(motion.pos_gl[:,:,0], motion.pos_gl[:,:,1], motion.pos_gl[:,:,2], t)  
+        Vwnd_g = np.moveaxis(np.array([u,v,w]),0,-1) # nB x nr x 3
+        xdBEM = BEM.timeStep(t, dt, xdBEM, motion.psi, motion.psi_B0,
+                motion.origin_pos_gl, motion.omega_gl, motion.R_b2g, 
+                motion.R_ntr2g, motion.R_bld2b,
+                motion.pos_gl, motion.vel_gl, motion.R_s2g, motion.R_a2g,
+                Vwnd_g,
+                firstCallEquilibrium= it==0
+                )
+        if np.mod(t,dtRadOut)<dt/2:
+            pass
+            #dfRad = BEM.toDataFrameRadial(it)
+            #dfRad.to_csv('_BEMRad_t{:04d}.csv'.format(it), index=False)
+
+    df = BEM.toDataFrame()
     if not test:
-        dfOut.to_csv(filenameOut,sep='\t',index=False)
-        print('>>>',filenameOut)
-        print(dfOut.keys())
+        # --- Export
+        df.to_csv('_UnsteadyBEM_Example2.csv', index=False)
         # --- Plot
         fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
         fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-        ax.plot(dfOut['WS_[m/s]'].values, dfOut['AeroPower_[kW]'].values, label='Power')
-        ax.set_xlabel('Wind speed [m/s]')
-        ax.set_ylabel('[-]')
+        ax.plot(df['Time_[s]'], df['AB3N008AxInd_[-]'], label='r/R={:3.1f}'.format((2.25E+01+1.5)/63))
+        ax.plot(df['Time_[s]'], df['AB3N012AxInd_[-]'], label='r/R={:3.1f}'.format((3.89E+01+1.5)/63))
+        ax.plot(df['Time_[s]'], df['AB3N016AxInd_[-]'], label='r/R={:3.1f}'.format((5.46E+01+1.5)/63))
+        ax.set_xlabel('Time [s]')
+        ax.set_ylabel('Axial induction [-]')
         ax.legend()
-        ax.set_title('BEM Steady - Performance curve')
+        ax.set_title('BEM Unsteady - Prescribed surge motion')
         ax.tick_params(direction='in')
+    #import matplotlib.pyplot as plt
+    #from mpl_toolkits.mplot3d import Axes3D
+    #from matplotlib.animation import FuncAnimation
+    #ani = motion.plotAnim(0,10,0.01, ylim=[-80,80], zlim=[-80,80])
+    #plt.show()
 
 
-    return dfOut
-
 
 if __name__=="__main__":
     main()
     plt.show()
 if __name__=="__test__":
-    main(test=True)
-    [os.remove(f) for f in glob.glob(os.path.join(MyDir,'_*.csv'))]
+    main(True)
+    try:
+        os.remove('./_UnsteadyBEM_Example2.csv')
+    except:
+        pass
 if __name__=="__export__":
     main()
     from welib.tools.repo import export_figs_callback
     export_figs_callback(__file__)
+
```

### Comparing `welib-0.0.2/welib/BEM/examples/Example_BEM_CPLambdaPitch.py` & `welib-1.0.0/welib/BEM/examples/Example_BEM_CPLambdaPitch.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,20 @@
 import os
 import numpy as np
 import pandas as pd
-from welib.BEM.steadyBEM import SteadyBEM, FASTFile2SteadyBEM
+from welib.BEM.steadyBEM import calcSteadyBEM, FASTFile2SteadyBEM
+from welib.weio.rosco_performance_file import ROSCOPerformanceFile
 import matplotlib.pyplot as plt
 
 MyDir=os.path.dirname(__file__)
 
 
 def main(test=False,extra=False):
     """ Run a parametric study on lambda and pitch, save CP and CT """
+    exportFmt='rosco' # Export format, rosco or csv
     # --- Turbine data
     nB,cone,r,chord,twist,polars,rho,KinVisc = FASTFile2SteadyBEM(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
 
     if test:
         vlambda = np.linspace( 2,15,3)
         vpitch  = np.linspace(-10,40,2)
     elif extra:
@@ -36,56 +38,57 @@
     for il,lambd in enumerate(vlambda):
         for ip,pitch in enumerate(vpitch):
             i+=1
             Omega=lambd*V0/R * 60/(2*np.pi)
             xdot=0      #[m/s]
             u_turb=0    #[m/s]
             a0,ap0 = None, None
-            BEM=SteadyBEM(Omega,pitch,V0,xdot,u_turb,
+            BEM=calcSteadyBEM(Omega,pitch,V0,xdot,u_turb,
                         nB,cone,r,chord,twist,polars,
                         rho=rho,bTIDrag=True,bAIDrag=True,
                         a_init =a0, ap_init=ap0
                         )
             a0,ap0 = BEM.a, BEM.aprime
             print('{:5d}/{:d} lambda={:4.2f} pitch={:4.0f} CP={:5.3f}'.format(i,ntot,lambd,pitch,BEM.CP))
             CP[il,ip]=BEM.CP
             CT[il,ip]=BEM.CT
     CP[CP<0]=0
     CT[CT<0]=0
 
-    if not test:
+    # --- Create a ROSCO performance file
+    rs = ROSCOPerformanceFile(pitch=vpitch, tsr=vlambda, CP=CP, CT=CT)
+
+    # --- Export performances to a given file format
+    if exportFmt.lower()=='csv':
         np.savetxt('_CP.csv'    , CP     , delimiter=',')
         np.savetxt('_CT.csv'    , CT     , delimiter=',')
         np.savetxt('_Lambda.csv', vlambda, delimiter=',')
         np.savetxt('_Pitch.csv' , vpitch , delimiter=',')
+    elif exportFmt.lower()=='rosco':
+        rs.write('_CPCTCQ.txt')
 
-        # --- Plotting matrix of CP values
-        from mpl_toolkits.mplot3d import Axes3D
-        from matplotlib import cm
-        fig = plt.figure()
-        ax = fig.gca(projection='3d')
-        LAMBDA, PITCH = np.meshgrid(vlambda, vpitch)
-        i,j = np.unravel_index(CP.argmax(), CP.shape)
-
-        CP[CP<0]=0
-        surf = ax.plot_surface(LAMBDA, PITCH, np.transpose(CP), cmap=cm.coolwarm, linewidth=0, antialiased=True,alpha=0.8, label='$C_p$')
-        ax.scatter(LAMBDA[j,i],PITCH[j,i],CP[i,j],c='k',marker='o',s=50, label=r'$C_{p,max}$')
-        ax.view_init(elev=20., azim=26)
-        ax.set_xlabel('Lambda [-]')
-        ax.set_ylabel('Pitch [deg]')
-        ax.set_zlabel(r'Power coefficient [-]')
+    # --- Plotting matrix of CP values
+    try:
+        fig = rs.plotCP3D()
+        ax = fig.gca()
         ax.set_title('BEM Steady - CP-lambda-pitch ')
-        #fig.colorbar(surf, shrink=0.5, aspect=5)
+    except:
+        print('Plot 3D failed. TODO')
+    #fig.colorbar(surf, shrink=0.5, aspect=15)
 
 
 
 
 if __name__=="__main__":
     main()
     plt.show()
 if __name__=="__test__":
     main(True)
+    try:
+        os.remove('_CPCTCQ.txt')
+    except:
+        pass
 if __name__=="__export__":
     main(extra=True)
     from welib.tools.repo import export_figs_callback
     export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/BEM/examples/Example_IdealRotor.py` & `welib-1.0.0/welib/BEM/examples/Example_IdealRotor.py`

 * *Files 15% similar despite different names*

```diff
@@ -36,32 +36,36 @@
 twist_wr = twist
 
 
 
 #fig,axes = plt.subplots(1, 1, sharey=False, figsize=(10.4,3.9)) # (6.4,4.8)
 #fig.subplots_adjust(left=0.12, right=0.98, top=0.98, bottom=0.15, hspace=0.10, wspace=0.13)
 fig,axes = plt.subplots(2, 1, sharex=True, sharey=False, figsize=(6.4,3.9)) # (6.4,4.8)
-fig.subplots_adjust(left=0.09, right=0.97, top=0.98, bottom=0.15, hspace=0.10, wspace=0.13)
+fig.subplots_adjust(left=0.09, right=0.97, top=0.94, bottom=0.15, hspace=0.17, wspace=0.13)
 ax=axes[0]
 ax.plot(r_bar, chord_nw/R ,'k'    , label='Without wake rotation')
 ax.plot(r_bar, chord_wr/R ,'k--'  , label='With wake rotation')
-ax.set_xlabel('Blade radius r/R [-]')
 ax.set_ylabel('Chord, c/R [-]')
-ax.spines['right'].set_visible(False)
-ax.spines['top'].set_visible(False)
 ax.set_yticks([0,0.1,0.2,0.3])
 ax.set_ylim([0,0.3])
 ax.set_xlim([0,1])
 ax.legend()
-ax.set_title('BEM - Ideal rotor planform')
+ax.set_title('BEM Theory - Ideal rotor planform')
 
 ax=axes[1]
 ax.plot(r_bar, twist_nw, 'k' , label='Without wake rotation')
 ax.plot(r_bar, twist_wr, 'k--' , label='With wake rotation')
 ax.set_ylabel('Twist angle [deg]')
+ax.set_xlabel('Blade radius r/R [-]')
 ax.set_xlim([0,1])
 ax.set_ylim([0,40])
-ax.spines['right'].set_visible(False)
-ax.spines['top'].set_visible(False)
+
+for ax in axes:
+    ax.tick_params(direction='in', top=True, right=True)
+    # ax.spines['right'].set_visible(False)
+    # ax.spines['top'].set_visible(False)
 
 if __name__ == '__main__':
     plt.show()
+if __name__=="__export__":
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/BEM/examples/Example_UnsteadyBEM_1_ConstantRPM.py` & `welib-1.0.0/welib/BEM/examples/Example_UnsteadyBEM_1_ConstantRPM.py`

 * *Files 6% similar despite different names*

```diff
@@ -7,16 +7,15 @@
 import os
 
 MyDir=os.path.dirname(__file__)
 
 def main(test=False):
 
     # --- Read a FAST model to get Aerodynamic parameters to initialize unsteady BEM code
-    BEM = AeroBEM()
-    BEM.init_from_FAST(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
+    BEM = UnsteadyBEM(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
     # --- Override BEM options (see unsteadyBEM.setDefaultOptions, or print(BEM))
     #BEM.bSwirl = True  # swirl flow model enabled / disabled
     #BEM.bTipLoss = True # enable / disable tip loss model
     time=np.arange(0,10,0.1)
     RPM=10
     df = BEM.simulationConstantRPM(time, RPM, windSpeed=10, tilt=0, cone=0, firstCallEquilibrium=True)
     if not test:
```

### Comparing `welib-0.0.2/welib/BEM/idealrotors.py` & `welib-1.0.0/welib/BEM/idealrotors.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,11 @@
 """ 
 
+See also welib.wt_theory.idealrotors
+
 References:
   [1] Wind Energy Explained, 3rd edition, Chapter 3
 
 """
 
 import numpy as np
 import pandas as pd
```

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/MainBEMCompAllTipLossAEP.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/MainBEMCompAllTipLossAEP.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_CompAllTipLoss.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_CompAllTipLoss.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_PowerCurve.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_PowerCurve.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_PrescribedGamma.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_PrescribedGamma.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_SetSim.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_SetSim.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_SimpleRun.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_SimpleRun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/Test_SimulationRef.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/Test_SimulationRef.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcode.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcode.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeB49.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeB49.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeLeishman.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeLeishman.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu2.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeManu2.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD2.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD2.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD3.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainBEMcodeTUD3.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/MainFindPitch.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/MainFindPitch.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/OptiminumParam.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/OptiminumParam.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/_incompatible/Test2BEMCodeForoneLambda.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/_incompatible/Test2BEMCodeForoneLambda.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/Simulations/fPlotCodeCompBEM.m` & `welib-1.0.0/welib/BEM/matlab/Simulations/fPlotCodeCompBEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/SimulationsAeroelasticit/MainPb3_2_WT3Dof_Pitch.m` & `welib-1.0.0/welib/BEM/matlab/SimulationsAeroelasticit/MainPb3_2_WT3Dof_Pitch.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/SimulationsUnsteadyBEM/Main_PitchStep.m` & `welib-1.0.0/welib/BEM/matlab/SimulationsUnsteadyBEM/Main_PitchStep.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyNew.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyNew.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyRiso.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyRiso.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyTipLoss.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyTipLoss.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteadyTipLossStandAlone1.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteadyTipLossStandAlone1.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_BACKUP.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_BACKUP.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_mostRecentBackup.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_mostRecentBackup.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/fBEMsteady_try.m` & `welib-1.0.0/welib/BEM/matlab/bkp/fBEMsteady_try.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/AeroFun.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/AeroFun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/LiftDataFun.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/LiftDataFun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/PowerCurve.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/PowerCurve.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/ReadHawc2.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/ReadHawc2.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test2BEMcodeForOneLambda.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test2BEMcodeForOneLambda.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test3OptimumLambda.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test3OptimumLambda.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/bkp/tmp/Test3OptimumLambdaClCd.m` & `welib-1.0.0/welib/BEM/matlab/bkp/tmp/Test3OptimumLambdaClCd.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEM.m` & `welib-1.0.0/welib/BEM/matlab/fBEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMSimulation.m` & `welib-1.0.0/welib/BEM/matlab/fBEMSimulation.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMpseudo_steady.m` & `welib-1.0.0/welib/BEM/matlab/fBEMpseudo_steady.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMsteady.m` & `welib-1.0.0/welib/BEM/matlab/fBEMsteady.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMsteadyTipLoss.m` & `welib-1.0.0/welib/BEM/matlab/fBEMsteadyTipLoss.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMsteadyTipLossStandAlone.m` & `welib-1.0.0/welib/BEM/matlab/fBEMsteadyTipLossStandAlone.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fBEMunsteady.m` & `welib-1.0.0/welib/BEM/matlab/fBEMunsteady.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fCorrectionHighThrust.m` & `welib-1.0.0/welib/BEM/matlab/fCorrectionHighThrust.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fInductionCoefficients.m` & `welib-1.0.0/welib/BEM/matlab/fInductionCoefficients.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fInductionsBEM_Propeller.m` & `welib-1.0.0/welib/BEM/matlab/fInductionsBEM_Propeller.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fRunBEM.m` & `welib-1.0.0/welib/BEM/matlab/fRunBEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_aeroelastic/Runge.m` & `welib-1.0.0/welib/BEM/matlab/f_aeroelastic/Runge.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_aeroelastic/RungeCore.m` & `welib-1.0.0/welib/BEM/matlab/f_aeroelastic/RungeCore.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_aeroelastic/RungeGoOn.m` & `welib-1.0.0/welib/BEM/matlab/f_aeroelastic/RungeGoOn.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_aeroelastic/getMassMatrix.m` & `welib-1.0.0/welib/BEM/matlab/f_aeroelastic/getMassMatrix.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_aeroelastic/solveAcceleration.m` & `welib-1.0.0/welib/BEM/matlab/f_aeroelastic/solveAcceleration.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_optimal/getOptimizedParameters.m` & `welib-1.0.0/welib/BEM/matlab/f_optimal/getOptimizedParameters.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/f_optimal/getOptimizedParametersClCd.m` & `welib-1.0.0/welib/BEM/matlab/f_optimal/getOptimizedParametersClCd.m`

 * *Files 22% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 function [a aprime phi c]=getOptimizedParametersClCd(Cl,Cd,lambda,B)
-global Rotor;
+    global Rotor
 R=Rotor.R;
 r=Rotor.r(:);
 rhub=min(r);
 lambda_r=lambda*r/R;
 Cl_opt=zeros(Rotor.ne,1);
 Cd_opt=zeros(Rotor.ne,1);
 a=zeros(Rotor.ne,1);
@@ -19,8 +19,8 @@
 f=B/2*(R-r)./(r.*sind(phi));
 Fhub=2/pi*acos(exp(-B/2*(r-rhub)./(rhub*sind(phi))));
 Ftip=2/pi*acos(exp(-f));
 F=Ftip.*Fhub;
 
 
 c=(8*pi*R.*F.*a.*lambda_r.*(sind(phi)).^2)./((1-a)*B*lambda.*Cn);
-end
+end
```

### Comparing `welib-0.0.2/welib/BEM/matlab/fakeBEM.m` & `welib-1.0.0/welib/BEM/matlab/fakeBEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/fakeBEMClCd.m` & `welib-1.0.0/welib/BEM/matlab/fakeBEMClCd.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/AeroFun.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/AeroFun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/LiftDataFun.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/LiftDataFun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/MainFindPitch.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/MainFindPitch.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/ReadHtcFileAll.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/ReadHtcFileAll.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/SuperDebug.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/SuperDebug.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/fFindPitch.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/fFindPitch.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/MainFindPitch/fPower.m` & `welib-1.0.0/welib/BEM/matlab/tools/MainFindPitch/fPower.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/__tests__/testAeroCoeff.m` & `welib-1.0.0/welib/BEM/matlab/tools/__tests__/testAeroCoeff.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/__tests__/testCompareIntegration.m` & `welib-1.0.0/welib/BEM/matlab/tools/__tests__/testCompareIntegration.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/__tests__/testRead.m` & `welib-1.0.0/welib/BEM/matlab/tools/__tests__/testRead.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fAeroCoeff.m` & `welib-1.0.0/welib/BEM/matlab/tools/fAeroCoeff.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fAeroCoeffWrap.m` & `welib-1.0.0/welib/BEM/matlab/tools/fAeroCoeffWrap.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fExportWTPerf.m` & `welib-1.0.0/welib/BEM/matlab/tools/fExportWTPerf.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fFindSimFolder.m` & `welib-1.0.0/welib/BEM/matlab/tools/fFindSimFolder.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitAlgo.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitAlgo.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitFlex.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitFlex.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitHawc.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitHawc.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitSim.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitSim.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitVLAlgo_old.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitVLAlgo_old.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitWT.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitWT.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitWTDefault.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitWTDefault.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fInitXblade.m` & `welib-1.0.0/welib/BEM/matlab/tools/fInitXblade.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadBlade.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadBlade.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadCFD_AL.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadCFD_AL.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadCodes.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadCodes.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadHawc2.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadHawc2.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadShen.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadShen.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fLoadVC.m` & `welib-1.0.0/welib/BEM/matlab/tools/fLoadVC.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadAeFile.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadAeFile.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadBtcFile.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadBtcFile.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadBtcFileAll.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadBtcFileAll.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadHawc2.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadHawc2.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadHtcFile.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadHtcFile.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadPcFile.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadPcFile.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadPcFileExtended.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadPcFileExtended.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadSpec.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadSpec.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadWTPerf.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadWTPerf.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fReadXbladeParamFile.m` & `welib-1.0.0/welib/BEM/matlab/tools/fReadXbladeParamFile.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fSetRotorGrid.m` & `welib-1.0.0/welib/BEM/matlab/tools/fSetRotorGrid.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fSetRun.m` & `welib-1.0.0/welib/BEM/matlab/tools/fSetRun.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fSetSim.m` & `welib-1.0.0/welib/BEM/matlab/tools/fSetSim.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTFindPitch.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTFindPitch.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTGetRefRPM.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTGetRefRPM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTParametricCP.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTParametricCP.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTPowerCurve.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTPowerCurve.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTSimRef.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTSimRef.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fWTSimulation.m` & `welib-1.0.0/welib/BEM/matlab/tools/fWTSimulation.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fhawc2_create_output.m` & `welib-1.0.0/welib/BEM/matlab/tools/fhawc2_create_output.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fhawc2_signal.m` & `welib-1.0.0/welib/BEM/matlab/tools/fhawc2_signal.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/fplotCodesComparison.m` & `welib-1.0.0/welib/BEM/matlab/tools/fplotCodesComparison.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/matlab/tools/wind_rose.m` & `welib-1.0.0/welib/BEM/matlab/tools/wind_rose.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/BEM/steadyBEM.py` & `welib-1.0.0/welib/weio/rosco_performance_file.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,360 +1,436 @@
-# -*- coding: utf-8 -*-
 """ 
-Reference:
-     E.Branlard: Wind turbine Aerodynamics and Vorticity Based Method - Chapter 10, Springer, 2017
+Input/output class for the ROSCO performance (Cp,Ct,Cq) fileformat 
 """
-from __future__ import print_function,division
 import numpy as np
-from numpy import pi, cos, exp, sqrt, sin, arctan2, arccos
-from scipy.interpolate import interp1d
 import pandas as pd
-import matplotlib.pyplot as plt
+import os
 
-
-def _fAeroCoeffWrap(fPolars, alpha, phi, bAIDrag=True, bTIDrag=True):
-    """Tabulated airfoil data interpolation
-        Inputs
-        ----------
-        Polars: interpolant function for each alpha
-        alpha: Angle Of Attack [rad]
-        phi  : flow angle  [rad]
-
-        Outputs
-        ----------
-        Cl,Cd  : lift and drag coefficients
-        cnForAI: normal and tangential coefficient  (for induction computation)
-    """
-    alpha[alpha<-pi] += 2*pi
-    alpha[alpha> pi] -= 2*pi
-    Cl = np.zeros(alpha.shape)
-    Cd = np.zeros(alpha.shape)
-    for i,(fPolar,alph) in enumerate(zip(fPolars,alpha)):
-        ClCdCm = fPolar(alph)
-        Cl[i], Cd[i] = ClCdCm[0], ClCdCm[1]
-    # --- Normal and tangential
-    cn = Cl * cos(phi) + Cd * sin(phi)
-    ct = Cl * sin(phi) - Cd * cos(phi)
-    if (bAIDrag):
-        cnForAI = cn
-    else:
-        cnForAI = Cl*cos(phi) # cnNoDrag
-    if (bTIDrag):
-        ctForTI = ct
-    else:
-        ctForTI =  Cl * sin(phi) # ctNoDrag
-    return Cl, Cd, cnForAI, ctForTI
-
-def _fInductionCoefficients(a_last, Vrel_norm, V0, F, cnForAI, ctForTI,
-        lambda_r, sigma, phi, relaxation=0.4,bSwirl=True):
-    """Compute the induction coefficients
-
-        Inputs
-        ----------
-        a_last    : last iteration axial induction factor
-        Vrel_norm : normed relative velocity
-        V0        : free stream velocity
-        F         : total loss
-        cnForAI   : normal force coefficient
-        ctForTI   : tangential force coefficient
-        lambda_r  : speed ratio distribution
-        sigma     : blade solidity
-        phi       : flow angle [deg]
-        relaxation: relaxation factor in axial induction factor
-        bSwirl    : swirl flow model enabled / disabled
-
-        Outputs
-        ----------
-        a: axial induction factor
-        aprime: tangential induction factor
-        Ct: local thrust coefficient
+try:
+    from .file import File, EmptyFileError, WrongFormatError, BrokenFormatError
+except:
+    EmptyFileError    = type('EmptyFileError', (Exception,),{})
+    WrongFormatError  = type('WrongFormatError', (Exception,),{})
+    BrokenFormatError = type('BrokenFormatError', (Exception,),{})
+    File=dict
+
+class ROSCOPerformanceFile(File):
+    """ 
+    Read/write a ROSCO performance file. The object behaves as a dictionary.
+    
+    Main methods
+    ------------
+    - read, write, toDataFrame, keys
+    
+    Examples
+    --------
+        f = ROSCOPerformanceFile('Cp_Ct_Cq.txt')
+        print(f.keys())
+        print(f.toDataFrame().columns)  
+        fig = f.plotCP3D()
+        CPmax, tsr_max, pitch_max = f.CPmax()
+        CP = fCP([0, 1], [5, 5])
+        CT = fCT([0, 1], [5, 5])
+    
     """
-    # --- Default a and CT
-    a = 1. / ((4.*F*sin(phi)**2)/(sigma*(cnForAI+10**-8))+1) # NOTE simgularity avoided
-    # CT=(1-a_last).^2.*sigma.*CnForAI./((sind(phi)).^2)
-    Ct = Vrel_norm**2 * sigma * cnForAI/(V0**2)  # that's a CT loc
-    # --- Hight thrust correction
-    # Glauert correction
-    #>>> NOTE this is:  a = a_Ct_a(Ct, a, method='Glauert') from HighThrust
-    ac = 0.3
-    bHigh = a > ac
-    fg = 0.25*(5.-3.*a[bHigh])
-    a[bHigh] = Ct[bHigh]/(4.*F[bHigh]*(1.-fg*a[bHigh]))
-    #a_high=0.5*(2+K*(1-2*ac)-sqrt((K*(1-2*ac)+2)^2+4*(K*ac^2-1)));
-    # --- Relaxation
-    a = a*relaxation + (1.-relaxation)*a_last
-
-    # --- Swirl
-    if bSwirl is True:
-        #aprime = 1/((4*F*sin(phi)*cos(phi))/(sigma*ctForTI+10**-8)-1)
-        # HAWC2 method:
-        aprime = (Vrel_norm**2*ctForTI*sigma)/(4.*(1.-a)*V0**2*lambda_r)
-    else:
-        aprime = a * 0.
-    # Bounding values for safety
-    aprime = np.clip(aprime,-1,1.5) 
-    a      = np.clip(a     ,-1,1.5)
-    Ct     = np.clip(Ct    ,-1,3)
-    return a, aprime, Ct
-
-
-class SteadyBEM_Outputs:
-    def WriteRadialFile(BEM,filename):
-        header='r_[m] a_[-] a_prime_[-] Ct_[-] Cq_[-] Cp_[-] cn_[-] ct_[-] phi_[deg] alpha_[deg] Cl_[-] Cd_[-] Pn_[N/m] Pt_[N/m] Vrel_[m/s] Un_[m/s] Ut_[m/s] F_[-] Re_[-] Gamma_[m^2/s] uia_[m/s] uit_[m/s] u_turb_[m/s]'
-        header=' '.join(['{:14s}'.format(s) for s in header.split()])
-        M=np.column_stack((BEM.r,BEM.a,BEM.aprime,BEM.Ct,BEM.Cq,BEM.Cp,BEM.cn,BEM.ct,BEM.phi,BEM.alpha,BEM.Cl,BEM.Cd,BEM.Pn,BEM.Pt,BEM.Vrel,BEM.Un,BEM.Ut,BEM.F,BEM.Re,BEM.Gamma,BEM.uia,BEM.uit,BEM.u_turb))
-        np.savetxt(filename,M,header=header,fmt='%14.7e',comments='#')
-
-    def StoreIntegratedValues(BEM,df=None):
-        if df is None:
-            df = pd.DataFrame(columns=['WS_[m/s]','RotSpeed_[rpm]','Pitch_[deg]','AeroThurst_[kN]','AeroTorque_[kNm]','AeroPower_[kW]','AeroCP_[-]','AeroCT_[-]','AeroCQ_[-]','AeroFlap_[kNm]', 'AeroEdge_[kNm]'])
-        df = df.append(pd.Series(dtype='float64'), ignore_index=True)
-        i=len(df)-1
-        df.loc[i,'WS_[m/s]']         = BEM.V0
-        df.loc[i,'RotSpeed_[rpm]']   = BEM.Omega *60/(2*np.pi)
-        df.loc[i,'Pitch_[deg]']      = BEM.Pitch
-        df.loc[i,'AeroThurst_[kN]']  = BEM.Thrust/1000
-        df.loc[i,'AeroTorque_[kNm]'] = BEM.Torque/1000
-        df.loc[i,'AeroPower_[kW]']   = BEM.Power/1000
-        df.loc[i,'AeroFlap_[kNm]']   = BEM.Flap/1000
-        df.loc[i,'AeroEdge_[kNm]']   = BEM.Edge/1000
-        df.loc[i,'AeroCT_[-]']       = BEM.CT
-        df.loc[i,'AeroCP_[-]']       = BEM.CP
-        df.loc[i,'AeroCQ_[-]']       = BEM.CQ
-        return df
-
-def SteadyBEM(Omega,pitch,V0,xdot,u_turb,
-        nB, cone, r, chord, twist, polars, # Rotor
-        rho=1.225,KinVisc=15.68*10**-6,    # Environment
-        nItMax=100, aTol=10**-6, bTipLoss=True, bHubLoss=False, bAIDrag=True, bTIDrag=True, bSwirl=True, relaxation=0.4, a_init=None, ap_init=None):
-    """ Run the BEM main loop
-        Inputs:
-        -------
-        Omega [rpm]:
-        pitch [deg]:
-        twist [deg]:
-        cone  [deg]:
-        r     [m]  : from rhub to R
-        chord [m]  :
-        polars     : nSpan matrices  
-
-        Outputs
-        ----------
-        BEM : class with attributes, such as BEM.r, BEM.a, BEM.Power
+
+    @staticmethod
+    def defaultExtensions():
+        """ List of file extensions expected for this fileformat"""
+        return ['.txt']
+
+    @staticmethod
+    def formatName():
+        """ Short string (~100 char) identifying the file format"""
+        return 'ROSCO Performance file'
+
+    def __init__(self, filename=None, pitch=None, tsr=None, WS=None, CP=None, CT=None, CQ=None, name='',**kwargs):
+        """ Class constructor. If a `filename` is given, the file is read. 
+        Otherwise values may be provided directly
+
+        INPUTS:
+          - filename: input file for ROSCO Performance file
+        OR
+          - pitch: pitch angle [deg], array of length nPitch
+          - tsr: tip-speed ratio [-], array of length nTSR
+          - CP,CT,CQ: aerodynamic coefficients, arrays of shape nTSR x nPitch
+                      CQ is optional since CP = tsr*CQ
+          - name: wind turbine name
+        """
+        self.filename = filename
+        self.name     = name # Turbine name
+        self['pitch'] = pitch
+        self['TSR']   = tsr
+        self['WS']    = WS
+        self['CP']    = CP
+        self['CT']    = CT
+        self['CQ']    = CQ
+
+        if filename:
+            self.read(**kwargs)
+
+        if self['pitch'] is not None:
+            self.checkConsistency()
+
+    def read(self, filename=None, **kwargs):
+        """ Reads the file self.filename, or `filename` if provided 
+        stores data into self. 
+        self is (or behaves like) a dictionary"""
+        # --- Standard tests and exceptions (generic code)
+        if filename:
+            self.filename = filename
+        if not self.filename:
+            raise Exception('No filename provided')
+        if not os.path.isfile(self.filename):
+            raise OSError(2,'File not found:',self.filename)
+        if os.stat(self.filename).st_size == 0:
+            raise EmptyFileError('File is empty:',self.filename)
+
+        pitch, TSR, WS, CP, CT, CQ = load_from_txt(self.filename)
+        self['pitch'] = pitch
+        self['TSR']   = TSR
+        self['WS']    = WS
+        self['CP']    = CP
+        self['CT']    = CT
+        self['CQ']    = CQ
+
+    def write(self, filename=None):
+        """ Rewrite object to file, or write object to `filename` if provided """
+        if filename:
+            self.filename = filename
+        if not self.filename:
+            raise Exception('No filename provided')
+        # Sanity
+        self.checkConsistency()
+        # Write
+        write_rotor_performance(self.filename, self['pitch'], self['TSR'], self['CP'],self['CT'], self['CQ'], self['WS'], TurbineName=self.name)
+
+    def checkConsistency(self):
+        """ 
+        Check that data makes sense.
+         in particular, check if CP=lambda CQ
+        """
+        if self['WS'] is not None:
+            if not hasattr(self['WS'],'__len__' ):
+                self['WS'] = np.array([self['WS']]).astype(float)
+
+        CQ  = self['CQ']
+        CP  = self['CP']
+        tsr = np.asarray(self['TSR'])
+        TSR = np.tile(tsr.flatten(), (len(self['pitch']),1)).T
+        if CQ is None and CP is not None:
+            CQ = CP/TSR
+            print('[INFO] Computing CQ from CP')
+        elif CQ is not None and CP is None:
+            CP = CQ*TSR
+            print('[INFO] Computing CP from CQ')
+        elif CQ is not None and CP is not None:
+            pass
+        else:
+            raise Exception('CP and CQ cannot be None')
+        # Check consistency
+        CP2 = CQ*TSR
+        deltaCP = np.abs(CP-CP2)/0.5*100 # relative difference in %, for a mean CP of 0.5
+        if np.max(deltaCP)>5: # more than 5%
+            raise Exception('Inconsitency between power coefficient and torque coefficient')
+        self['CP'] = CP
+        self['CQ'] = CQ
+
+    def toDataFrame(self):
+        """ Returns object into dictionary of DataFrames"""
+        dfs={}
+        columns = ['TSR_[-]']+['Pitch_{:.2f}_[deg]'.format(p) for p in self['pitch']]
+        dfs['CP'] = pd.DataFrame(np.column_stack((self['TSR'], self['CP'])), columns=columns)
+        dfs['CT'] = pd.DataFrame(np.column_stack((self['TSR'], self['CT'])), columns=columns)
+        dfs['CQ'] = pd.DataFrame(np.column_stack((self['TSR'], self['CQ'])), columns=columns)
+        return dfs
+
+    # --- Optional functions
+    def toAeroDisc(self, filename, R, csv=False, WS=None, omegaRPM=10):
+        """ Convert to AeroDisc Format 
+        INPUTS:
+         - filename: filename to be written 
+         - R: rotor radius [m]
+         - csv: if True write to CSV format, else, use OpenFAST .dat format
+        either:
+         - WS: wind speed [m/s]
+          or
+         - omegaRPM: rotational speed [rpm]
+
+        Logic to determine wind speed or rotational speed:
+         - If user provide a wind speed, we use it. Omega is determined from TSR and WS
+         - If user provide a rotational speed, we use it. WS is determined from TSR and omega
+         - If ROSCO file contain one wind speed, we use it.
+         - Otherwise, we don't know what to do so we raise an exception
+        """
+        # --- Logic to determine wind speed or rotational speed
+        if WS is not None:
+            WS = WS
+        elif omegaRPM is not None:
+            WS = None
+            omega = omegaRPM*(2*np.pi)/60
+        elif self['WS'] is not None and len(self['WS'])==1:
+            WS = self['WS'][0]
+        else:
+            raise Exception('Provide either a wind speed (`WS`) or a rotational speed (`omegaRPM`)')
+
+        with open(filename,'w') as fid:
+            # Header
+            if csv:
+                fid.write("TSR_(-),  RtSpd_(rpm) ,   VRel_(m/s)  ,  Skew_(deg) ,   Pitch_(deg) ,  C_Fx_(-)  ,   C_Fy_(-)   ,  C_Fz_(-)   ,  C_Mx_(-)   ,  C_My_(-)  ,   C_Mz_(-)\n")
+            else:
+                fid.write('     TSR       RtSpd      VRel       Skew       Pitch      C_Fx       C_Fy       C_Fz       C_Mx       C_My       C_Mz\n')
+                fid.write('     (-)       (rpm)      (m/s)      (deg)      (deg)       (-)        (-)        (-)        (-)        (-)        (-)\n')
+            if csv:
+                FMT='{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f},{:10.4f}\n'
+            else:
+                FMT='{:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f} {:10.4f}\n'
+            # Loop on oper
+            for j,tsr in enumerate(self['TSR']):
+                if WS is None:
+                    U0 = omega*R/tsr
+                else:
+                    U0 = WS
+                    omega = tsr*U0/R
+                    omegaRPM = omega*60/(2*np.pi)
+                for i,p in enumerate(self['pitch']):
+                    CP=self['CP'][j,i]
+                    CT=self['CT'][j,i]
+                    CQ=self['CQ'][j,i]
+                    skew=0
+                    cfx=CT
+                    cfy=0
+                    cfz=0
+                    cmx=CQ
+                    cmy=0
+                    cmz=0
+                    fid.write(FMT.format(tsr, omegaRPM, U0, skew, p, cfx,cfy,cfz,cmx,cmy,cmz))
+
+    def computeWeights(self):
+        """ Compute interpolant weights for fast evaluation of CP and CT at intermediate values"""
+        CP = self['CP'].copy()
+        CT = self['CT'].copy()
+        CP = CP[CP<0]=0
+        CT = CT[CT<0]=0
+        self._fCP = interp2d_pairs(self['pitch'], self['TSR'], CP, kind='cubic')
+        self._fCT = interp2d_pairs(self['pitch'], self['TSR'], CT, kind='cubic')
+
+    def fCP(self, pitch, tsr):
+        """ Compute CP for given pitch and tsr, where inputs can be scalar, arrays or matrices"""
+        if self._fCP is None:
+            self.computeWeights()
+        return self.fCP(pitch, tsr)
+
+    def fCT(self, pitch, tsr):
+        """ Compute CT for given pitch and tsr, where inputs can be scalar, arrays or matrices"""
+        if self._fCT is None:
+            self.computeWeights()
+        return self.fCT(pitch, tsr)
+
+    def CPmax(self):
+        """ return values at CPmax
+        TODO: interpolation instead of nearest value..
+        """
+        CP = self['CP']
+        i,j = np.unravel_index(CP.argmax(), CP.shape)
+        CPmax, tsr_max, pitch_max = CP[i,j], self['TSR'][i], self['pitch'][j]
+
+        return CPmax, tsr_max, pitch_max
+
+    def plotCP3D(self, plotMax=True, trajectory=None):
+        """
+        Plot 3D surface of CP
+        Optionally plot the maximum and a controller trajectory
+        """
+        import matplotlib.pyplot as plt
+        from mpl_toolkits.mplot3d import Axes3D
+        from matplotlib import cm
+        # Data
+        LAMBDA, PITCH = np.meshgrid(self['TSR'], self['pitch'])
+        CP = self['CP'].copy()
+        CP[CP<0]=0 # 
+        CP_max, tsr_max, pitch_max = self.CPmax()
+        # plot
+        fig = plt.figure()
+        ax = fig.gca(projection='3d')
+        surf = ax.plot_surface(LAMBDA, PITCH, np.transpose(CP), cmap=cm.coolwarm, linewidth=0, antialiased=True,alpha=0.8, label='$C_p$')
+        if plotMax:
+            ax.scatter(tsr_max, pitch_max, CP_max, c='k', marker='o', s=50, label=r'$C_{p,max}$')
+        if trajectory is not None:
+            if len(trajectory)==3:
+                tsr_, pitch_, CP_ = trajectory
+            else:
+                tsr_, pitch_ = trajectory
+                CP_ = self.fCP(tsr_, pitch_)
+            ax.plot_surface(tsr_, pitch_, CP_, 'k-', linewidth=1 )
+        #fig.tight_layout()
+        #fig.colorbar(surf, shrink=0.5, aspect=15)
+        ax.view_init(elev=20., azim=26)
+        ax.set_xlabel('TSR [-]')
+        ax.set_ylabel('Pitch [deg]')
+        ax.set_zlabel(r'Power coefficient [-]')
+        return fig
+
+    def __repr__(self):
+        """ String that is written to screen when the user calls `print()` on the object. 
+        Provide short and relevant information to save time for the user. 
+        """
+        s='<{} object>:\n'.format(type(self).__name__)
+        s+='|Main attributes:\n'
+        s+='| - filename: {}\n'.format(self.filename)
+        # --- Example printing some relevant information for user
+        s+='|Main keys:\n'
+        s+='| - pitch: {} values: {}\n'.format(len(self['pitch']) if self['pitch'] is not None else 0, self['pitch'])
+        s+='| - TSR:   {} values: {}\n'.format(len(self['TSR']  ) if self['TSR']   is not None else 0, self['TSR']  )
+        s+='| - WS:    {} values: {}\n'.format(len(self['WS']   ) if self['WS']    is not None else 0, self['WS']   )
+        if self['CP'] is not None:
+            s+='| - CP,CT,CQ : shape {}\n'.format(self['CP'].shape)
+        s+='|Main methods:\n'
+        s+='| - read, write, toDataFrame, keys\n'
+        s+='| - CPmax, plotCP3d, fCP, fCT, toAeroDisc'
+        return s
+    
+
+def load_from_txt(txt_filename):
+    '''
+    Adapted from ROSCO_toolbox/utitities.py by Nikhar Abbas
+        https://github.com/NREL/ROSCO
+        Apache 2.0 License
+
+    Load rotor performance data from a *.txt file. 
+    Parameters:
+    -----------
+        txt_filename: str
+                        Filename of the text containing the Cp, Ct, and Cq data. This should be in the format printed by the write_rotorperformance function
+    '''
+
+    pitch = None
+    TSR   = None
+    WS    = None
+
+    with open(txt_filename) as pfile:
+        for iline, line in enumerate(pfile):
+            # Read Blade Pitch Angles (degrees)
+            if 'Pitch angle' in line:
+                pitch = np.array([float(x) for x in pfile.readline().strip().split()])
+
+            # Read Tip Speed Ratios (rad)
+            elif 'TSR' in line:
+                TSR = np.array([float(x) for x in pfile.readline().strip().split()])
+
+            #Read WS
+            elif 'Wind speed' in line:
+                WS = np.array([float(x) for x in pfile.readline().strip().split()])
+            
+            # Read Power Coefficients
+            elif 'Power' in line:
+                pfile.readline()
+                Cp = np.empty((len(TSR),len(pitch)))
+                for tsr_i in range(len(TSR)):
+                    Cp[tsr_i] = np.array([float(x) for x in pfile.readline().strip().split()])
+            
+            # Read Thrust Coefficients
+            elif 'Thrust' in line:
+                pfile.readline()
+                Ct = np.empty((len(TSR),len(pitch)))
+                for tsr_i in range(len(TSR)):
+                    Ct[tsr_i] = np.array([float(x) for x in pfile.readline().strip().split()])
+
+            # Read Torque Coefficients
+            elif 'Torque' in line:
+                pfile.readline()
+                Cq = np.empty((len(TSR),len(pitch)))
+                for tsr_i in range(len(TSR)):
+                    Cq[tsr_i] = np.array([float(x) for x in pfile.readline().strip().split()])
+
+            if pitch is None and iline>10:
+                raise WrongFormatError('This does not appear to be a ROSCO performance file, Pitch vector not found')
+
+        return pitch, TSR, WS, Cp, Ct, Cq
+
+
+def write_rotor_performance(txt_filename, pitch, TSR, CP, CT, CQ, WS=None, TurbineName=''):
+    '''
+    Adapted from ROSCO_toolbox/utitities.py by Nikhar Abbas
+        https://github.com/NREL/ROSCO
+        Apache 2.0 License
+
+    Write text file containing rotor performance data
+    Parameters:
+    ------------
+        txt_filename: str, optional
+                        Desired output filename to print rotor performance data. Default is Cp_Ct_Cq.txt
+    '''
+    file = open(txt_filename,'w')
+    # Headerlines
+    file.write('# ----- Rotor performance tables for the wind turbine: {} ----- \n'.format(TurbineName))
+    file.write('# ------------ Written using weio\n\n')
+
+    # Pitch angles, TSR, and wind speed
+    file.write('# Pitch angle vector, {} entries - x axis (matrix columns) (deg)\n'.format(len(pitch)))
+    for i in range(len(pitch)):
+        file.write('{:0.4}   '.format(pitch[i]))
+    file.write('\n# TSR vector, {} entries - y axis (matrix rows) (-)\n'.format(len(TSR)))
+    for i in range(len(TSR)):
+        file.write('{:0.4}    '.format(TSR[i]))
+    if WS is not None:
+        file.write('\n# Wind speed vector - z axis (m/s)\n')
+        for i in range(len(WS)):
+            file.write('{:0.4f}    '.format(WS[i]))
+        file.write('\n')
+    
+    # Cp
+    file.write('\n# Power coefficient\n\n')
+    for i in range(len(TSR)):
+        for j in range(len(pitch)):
+            file.write('{0:.6f}   '.format(CP[i,j]))
+        file.write('\n')
+    file.write('\n')
+    
+    # Ct
+    file.write('\n#  Thrust coefficient\n\n')
+    for i in range(len(TSR)):
+        for j in range(len(pitch)):
+            file.write('{0:.6f}   '.format(CT[i,j]))
+        file.write('\n')
+    file.write('\n')
+    
+    # Cq
+    file.write('\n# Torque coefficient\n\n')
+    for i in range(len(TSR)):
+        for j in range(len(pitch)):
+            file.write('{0:.6f}   '.format(CQ[i,j]))
+        file.write('\n')
+    file.write('\n')
+    file.close()
+
+
+def interp2d_pairs(*args,**kwargs):
+    """ Same interface as interp2d but the returned interpolant will evaluate its inputs as pairs of values.
+    Inputs can therefore be arrays
+
+    example:
+       f = interp2d_pairs(vx, vy, M, kind='cubic')
+
+    vx: array of length nx
+    vy: array of length ny
+    M : array of shape nx x ny
+    f : interpolant function
+          v = f(x,y) : if x,y are array of length n, v is of length n
+                       with  v_i = f(x_i, y_i)
+    author: E. Branlard
     """
-    VHubHeight = V0
-    # --- Converting units
-    fulltwist = (twist+pitch) *pi/180    # [rad]
-    Omega    = Omega*2*pi/60 # [rad/s]
-    # --- Derived params
-    rhub, R  = r[0], r[-1]
-    # Computing a dr, such that sum(dr)=R-rhub
-    dr    = np.diff(r) 
-    MidPointAfter = np.concatenate((  r[0:-1]+dr/2 , [R] ))
-    MidPointBefore= np.concatenate(( [r[0]] ,  r[1:]-dr/2))
-    dr    = MidPointAfter-MidPointBefore
-    cCone    = cos(cone*pi/180.)
-    sigma    = chord * nB / (2.0 * pi * r * cCone)
-    lambda_r = Omega * r * cCone/ V0
-    # Creating interpolation functions for each polar, now in rad!
-    fPolars = [interp1d(p[:,0]*pi/180,p[:,1:],axis=0) for p in polars]
-    # Initializing outputs
-    if a_init is None:
-        a_init = np.ones((len(r)))*0.2
-    if ap_init is None:
-        ap_init = np.ones(len(r))*0.01
-    # --- Vectorized BEM algorithm
-    # Radial inputs: a_init,ap_init,r,chord,fulltwist,sigma,lambda_r,fPolars
-    a, aprime  = a_init, ap_init
-    for i in np.arange(nItMax):
-        # --------------------------------------------------------------------------------
-        # --- Step 0: Relative wind
-        # --------------------------------------------------------------------------------
-        # --------------------------------------------------------------------------------
-        # --- Step 1: Wind Components
-        # --------------------------------------------------------------------------------
-        Ut = Omega * r * (1. + aprime)
-        Un = V0 * (1. - a) - xdot + u_turb
-        Vrel_norm = np.sqrt(Un** 2 + Ut** 2)
-        # --------------------------------------------------------------------------------
-        # --- Step 2: Flow Angle
-        # --------------------------------------------------------------------------------
-        phi = arctan2(Un, Ut) # flow angle [rad]
-        # --------------------------------------------------------------------------------
-        # --- Tip loss
-        # --------------------------------------------------------------------------------
-        Ftip = np.ones((len(r)))
-        Fhub = np.ones((len(r)))
-        IOK=sin(phi)>0.01
-        try:
-            if bTipLoss:
-                # Glauert tip correction
-                Ftip[IOK] = 2/pi*arccos(exp(-nB/2*(R-r[IOK])/(r[IOK]*sin(phi[IOK]))))
-            if bHubLoss:
-                # Prandtl hub loss correction
-                Fhub[IOK] = 2/pi*arccos(exp(-nB/2*(r[IOK]-rhub)/(rhub*sin(phi[IOK]))));
-        except:
-            raise
-        F=Ftip*Fhub;
-        F[F<=0]=0.5 # To avoid singularities
-        # --------------------------------------------------------------------------------
-        # --- Step 3: Angle of attack
-        # --------------------------------------------------------------------------------
-        alpha = phi - fulltwist # [rad], contains pitch
-        # --------------------------------------------------------------------------------
-        # --- Step 4: Profile Data
-        # --------------------------------------------------------------------------------
-        Cl, Cd, cnForAI, ctForTI = _fAeroCoeffWrap(fPolars, alpha, phi, bAIDrag, bTIDrag)
-        # --------------------------------------------------------------------------------
-        # --- Step 5: Induction Coefficients
-        # --------------------------------------------------------------------------------
-        # Storing last values
-        a_last      = a
-        aprime_last = aprime
-        a, aprime, CT_loc = _fInductionCoefficients(a_last,Vrel_norm,V0, F, cnForAI, ctForTI,
-                                               lambda_r, sigma, phi, relaxation, bSwirl)
-
-        if (i > 3 and (np.mean(np.abs(a-a_last)) + np.mean(np.abs(aprime - aprime_last))) < aTol):  # used to be on alpha
-            break
-    nIt = i + 1
-    if i == nItMax-1:
-        print('Maximum iterations reached : Omega=%.2f V0=%.2f' % (Omega,V0))
-    #print('Converged: V0=%2.f om=%5.2f pit=%3.1f nIt=%d' % (V0,Omega,pitch, nIt))
-    # --------------------------------------------------------------------------------
-    # --- Step 6: Outputs
-    # --------------------------------------------------------------------------------
-    BEM=SteadyBEM_Outputs();
-    BEM.a,BEM.aprime,BEM.phi,BEM.Cl,BEM.Cd,BEM.Un,BEM.Ut,BEM.Vrel,BEM.F,BEM.nIt = a,aprime,phi,Cl,Cd,Un,Ut,Vrel_norm,F,nIt
-    # L = 0.5 * rho * Vrel_norm ** 2 * chord[e] * Cl
-    # D = 0.5 * rho * Vrel_norm ** 2 * chord[e] * Cd
-    # Radial quantities (recomputed since thought as derived outputs)
-    BEM.cn = BEM.Cl * cos(BEM.phi) + BEM.Cd * sin(BEM.phi)
-    BEM.ct = BEM.Cl * sin(BEM.phi) - BEM.Cd * cos(BEM.phi)
-    BEM.Pn    = 0.5 * rho * BEM.Vrel**2 * chord * BEM.cn   # [N/m]
-    BEM.Pt    = 0.5 * rho * BEM.Vrel**2 * chord * BEM.ct   # [N/m] 
-    BEM.alpha = (BEM.phi - fulltwist)*180/pi               # [deg]
-    BEM.phi   = BEM.phi*180/pi                             # [deg]
-    BEM.Re    = BEM.Vrel * chord / KinVisc / 10**6  # Reynolds number in Millions
-    BEM.Gamma = 0.5 * BEM.Vrel * chord * BEM.Cl   # Circulation [m^2/s]
-    # Radial quantities, "dr" formulation
-    BEM.ThrLoc   = dr * BEM.Pn * cCone
-    BEM.ThrLocLn = BEM.Pn * cCone
-    BEM.Ct       = nB * BEM.ThrLoc / (0.5 * rho * VHubHeight** 2 * (2*pi * r * cCone * dr))
-    BEM.TqLoc    = dr * r * BEM.Pt * cCone
-    BEM.TqLocLn  = r * BEM.Pt * cCone
-    BEM.Cq      = nB * BEM.TqLoc / (0.5 * rho * VHubHeight** 2 * (2*pi * r * cCone)) * dr * r * cCone
-    BEM.Cp      = BEM.Cq*lambda_r
-    # --- Integral quantities
-    BEM.Torque = nB * np.trapz(r * (BEM.Pt * cCone), r)  # Rotor shaft torque [N]
-    BEM.Thrust = nB * np.trapz(     BEM.Pn * cCone, r)   # Rotor shaft thrust [N]
-    BEM.Flap   = np.trapz( (BEM.Pn * cCone) * (r - rhub), r)      # Flap moment at blade root [Nm]
-    BEM.Edge   = np.trapz(  BEM.Pt * (r * cCone) * (r - rhub), r) # Edge moment at blade root [Nm]
-    BEM.Power = Omega * BEM.Torque
-    BEM.CP = BEM.Power  / (0.5 * rho * V0**3 * pi * R**2)
-    BEM.CT = BEM.Thrust / (0.5 * rho * V0**2 * pi * R**2)
-    BEM.CQ = BEM.Torque / (0.5 * rho * V0**2 * pi * R**3)
-    BEM.r=r
-    BEM.R=R
-    BEM.uia    = V0 * BEM.a
-    BEM.uit    = Omega * r * BEM.aprime
-    BEM.u_turb = np.ones(r.shape)*u_turb
-    BEM.Omega = Omega
-    BEM.Pitch = pitch
-    BEM.V0 = V0
-    return BEM
-
-
-def FASTFile2SteadyBEM(FASTFileName):
-    from welib.weio.fast_input_deck import FASTInputDeck
-    F = FASTInputDeck(FASTFileName,readlist=['AD','ED','ADbld','AF'])
-    if F.AD is None:
-        raise Exception('Cannot open AD file referenced in:'.format(FASTFileName))
-    if F.ED is None:
-        raise Exception('Cannot open ED file referenced in:'.format(FASTFileName))
-
-    try:
-        rho     = float(F.fst['AirDens'])  # New OF > 3.0
-    except:
-        rho     = float(F.AD['AirDens'])   # Old OF <=3.0
-    try:
-        KinVisc = float(F.fst['KinVisc'])  # New OF > 3.0
-    except:
-        KinVisc = float(F.AD['KinVisc'])   # Old OF <= 3.0
-
-    nB   =  F.ED['NumBl']
-    cone = -F.ED['PreCone(1)']
-    r     = F.AD.Bld1['BldAeroNodes'][:,0] + F.ED['HubRad']
-    chord = F.AD.Bld1['BldAeroNodes'][:,-2] 
-    twist = F.AD.Bld1['BldAeroNodes'][:,-3]
-    polars=[]
-    ProfileID=F.AD.Bld1['BldAeroNodes'][:,-1].astype(int)
-    for ipolar in  ProfileID:
-        polars.append(F.AD.AF[ipolar-1]['AFCoeff'])
-    return nB,cone,r,chord,twist,polars,rho,KinVisc
-
-def FLEX2SteadyBEM(BladeFile,ProfileFile, cone, tilt, r_hub, rho=1.225, nB=3):
-    import welib.weio as weio
-    pro=weio.read(ProfileFile)
-    bld=weio.read(BladeFile).toDataFrame()
-    bld.columns=[v.split('_[')[0] for v in bld.columns.values]
-    # TODO
-    #rho=1.225;
-    #r_hub=2.253;
-    #nB   = 3
-    #cone = 5
-    #tilt = 6; # TODO
-    r     = bld['r'].values+r_hub
-    chord = bld['Chord'].values
-    twist = bld['AeroTwist'].values
-    thick = bld['RelThickness'].values
-    polars=[]
-    ProfileSet = bld['ProfileSet'].astype(int)
-    for iset,thick in zip(ProfileSet,thick):
-        PSet=pro.ProfileSets[iset-1]
-        AOA=PSet.polars[0][:,0]
-        CL = np.column_stack([v[:,1] for v in PSet.polars])
-        CD = np.column_stack([v[:,2] for v in PSet.polars])
-        CM = np.column_stack([v[:,3] for v in PSet.polars])
-        fCL = interp1d(PSet.thickness,CL,axis=1)
-        fCD = interp1d(PSet.thickness,CD,axis=1)
-        fCM = interp1d(PSet.thickness,CM,axis=1)
-        myCL=fCL(thick)
-        myCD=fCD(thick)
-        myCM=fCM(thick)
-        polar=np.zeros(PSet.polars[0].shape)
-        polar[:,0]=AOA
-        polar[:,1]=myCL
-        polar[:,2]=myCD
-        polar[:,3]=myCM
-        polars.append(polar)
-    return nB,cone,r,chord,twist,polars,rho
-
-
-if __name__=="__main__":
-    """ See examples/ for more examples """
-
-    # --- Read a FAST model to get the main parameters needed
-    nB,cone,r,chord,twist,polars,rho,KinVisc = FASTFile2SteadyBEM('../../data/NREL5MW/Main_Onshore.fst')
-
-    # --- Run BEM on a set of operating points
-    WS =[5,10]
-    RPM=[7,12]
-    a0, ap0  = None,None  # inductions, used to speed up parametric study
-    for i,ws in enumerate(WS):
-        V0        = WS[i]
-        Omega     = RPM[i]
-        pitch=2     #[deg]
-        xdot=0      #[m/s]
-        u_turb=0    #[m/s]
-        BEM=SteadyBEM(Omega,pitch,V0,xdot,u_turb,
-                    nB,cone,r,chord,twist,polars,
-                    rho=rho,KinVisc=KinVisc,bTIDrag=False,bAIDrag=True,
-                    a_init =a0,
-                    ap_init=ap0
-                    )
-        a0, ap0 = BEM.a, BEM.aprime
-        print('WS ',V0, 'Power',BEM.Power,'Thrust',BEM.Thrust)
-
-        # --- Save radial distribution to a csv file
-        filename='_BEM_ws{}_radial.csv'.format(V0)
-        BEM.WriteRadialFile(filename)
+    import scipy.interpolate as si
+    # Internal function, that evaluates pairs of values, output has the same shape as input
+    def interpolant(x,y,f):
+        x,y = np.asarray(x), np.asarray(y)
+        return (si.dfitpack.bispeu(f.tck[0], f.tck[1], f.tck[2], f.tck[3], f.tck[4], x.ravel(), y.ravel())[0]).reshape(x.shape)
+    # Wrapping the scipy interp2 function to call out interpolant instead
+    return lambda x,y: interpolant(x,y,si.interp2d(*args,**kwargs))
+
+
+if __name__ == '__main__':
+    f = ROSCOPerformanceFile('./tests/example_files/RoscoPerformance_CpCtCq.txt')
+    print(f)
+    dfs = f.toDataFrame()
+    print(dfs['CP'])
```

### Comparing `welib-0.0.2/welib/BEM/tests/test_BEM.py` & `welib-1.0.0/welib/BEM/tests/test_BEM.py`

 * *Files 20% similar despite different names*

```diff
@@ -20,19 +20,19 @@
 
         # --- Run BEM on a set of operating points
         V0        = 5
         Omega     = 7
         pitch=2     #[deg]
         xdot=0      #[m/s]
         u_turb=0    #[m/s]
-        BEM=SteadyBEM(Omega,pitch,V0,xdot,u_turb,
+        BEM=calcSteadyBEM(Omega,pitch,V0,xdot,u_turb,
                     nB,cone,r,chord,twist,polars,
-                    rho=rho,KinVisc=KinVisc,bTIDrag=False,bAIDrag=True)
+                    rho=rho,KinVisc=KinVisc,bTIDrag=False,bAIDrag=True, bUseCm=False)
 
-        np.testing.assert_almost_equal(BEM.Power ,445183.13,1)
-        np.testing.assert_almost_equal(BEM.Thrust,140978.66,1)
+        np.testing.assert_almost_equal(BEM.Power ,445680.62,1)
+        np.testing.assert_almost_equal(BEM.Thrust,140930.43,1)
 
 
         np.seterr(**old_settings)
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/BEM/tests/test_BEM_unsteady.py` & `welib-1.0.0/welib/BEM/tests/test_BEM_unsteady.py`

 * *Files 6% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 class Test(unittest.TestCase):
     def test_relaxation_issue(self):
         # NOTE: 
         # Without relaxation, high thrust correction will lead to large hysteris 
         # in axial induction
         bSwirl=True
-        CTcorrection='AeroDyn'
+        CTcorrection='AeroDyn15'
         swirlMethod='HAWC2'
         relaxation=0.5
         a_last=np.array([0])
 
         R_a2g = np.array([[ 0.99999829,  0.00185005,  0.        ],
                          [-0.00185005,  0.99999829,  0.        ],
                          [ 0.        ,  0.        ,  1.        ]])
@@ -75,19 +75,23 @@
         np.testing.assert_almost_equal(a_store[-3], a_store[-4], 5)
 
     def test_equilibirumDynWake(self):
         # Test that wake reaches the same equilibrium with or without the dynamic wake
         dt       = 0.1
         RPM=10
         # Read a FAST model to get Aerodynamic parameters to initialze unstady BEM code
-        BEM = AeroBEM()
-        BEM.init_from_FAST(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
-        BEM.CTcorrection = 'AeroDyn' 
+        BEM = UnsteadyBEM(os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst'))
+        BEM.CTcorrection = 'AeroDyn15' 
         BEM.swirlMethod  = 'AeroDyn' 
+        BEM.bUseCm = True  # Use Moment 
         BEM.bSwirl = True 
+        BEM.bTipLoss = True # enable / disable tip loss model
+        BEM.bHubLoss = False # enable / disable hub loss model
+        BEM.bAIDrag = True # influence on drag coefficient on normal force coefficient
+        BEM.bTIDrag = True # influence on drag coefficient on tangential force coefficient
 
         # --- Simulation 1, no dynamic inflow, starting at equilibrium 
         time=np.arange(0,5*dt,dt)
         BEM.bDynaWake = False # dynamic inflow model
         BEM.simulationConstantRPM(time, RPM, windSpeed=10, tilt=0, cone=0, firstCallEquilibrium=True)
         a     = BEM.AxInd.copy()
         aprime= BEM.TnInd.copy()
```

### Comparing `welib-0.0.2/welib/BEM/tests/test_run_Examples.py` & `welib-1.0.0/welib/BEM/tests/test_run_Examples.py`

 * *Files 0% similar despite different names*

```diff
@@ -16,21 +16,21 @@
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
         files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-        try:
-            import matplotlib.pyplot as plt
-            plt.close('all')
-        except:
-            pass
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/BEM/unsteadyBEM.py` & `welib-1.0.0/welib/BEM/unsteadyBEM.py`

 * *Files 11% similar despite different names*

```diff
@@ -1,111 +1,29 @@
 """ 
-Python implemenation of an unsteady BEM code
-
-Default models are provided in this file so it can be shipped as "standalone".
-More models are provided based on other "welib" packages.
+Python implementation of an unsteady BEM code
 
 Reference:
-   [1]: Branlard, 2017, Wind Turbines Aerodynamics and Vorticity Based Methods: Fundamentals and recent applications, Springer
+   [1]:  E. Branlard (2017) "Wind Turbine Aerodynamics and Vorticity Based Method", Chapter 10, Springer
 
 """
 import numpy as np
+import os
 from numpy import cos, sin, arctan2, pi, arccos, exp, abs, min, sqrt
 from scipy.interpolate import interp1d
 import copy
 import pandas as pd
+import matplotlib.pyplot as plt
 
 # Load more models
 # try:
 from welib.BEM.highthrust import a_Ct
 # except: 
 #     pass
 
 
-def _fInductionCoefficients(Vrel_norm, V0, F, cnForAI, ctForTI,
-        lambda_r, sigma, phi, relaxation=0.4, a_last=None, bSwirl=True, CTcorrection='AeroDyn', swirlMethod='AeroDyn'):
-    """Compute the induction coefficients
-
-        Inputs
-        ----------
-        a_last    : last iteration axial induction factor
-        Vrel_norm : normed relative velocity
-        V0        : free stream velocity
-        F         : total loss
-        cnForAI   : normal force coefficient
-        ctForTI   : tangential force coefficient
-        lambda_r  : speed ratio distribution
-        sigma     : blade solidity
-        phi       : flow angle [deg]
-        relaxation: relaxation factor in axial induction factor
-        bSwirl    : swirl flow model enabled / disabled
-
-        Outputs
-        ----------
-        a: axial induction factor
-        aprime: tangential induction factor
-        Ct: local thrust coefficient
-    """
-    # --- Default a and CT
-    a = 1. / ((4.*F*sin(phi)**2)/(sigma*(cnForAI+10**-8))+1) # NOTE singularity avoided
-    # CT=(1-a_last).^2.*sigma.*CnForAI./((sind(phi)).^2)
-    Ct = Vrel_norm**2 * sigma * cnForAI/(V0**2)  # that's a CT loc
-    # AeroDyn
-    #k = sigma*cn/4.0_ReKi/F/sphi/sphi
-    #if (k <= 2/3) then  ! momentum state for a < 0.4
-    # a = k/(1+k)
-
-    # --- Hight thrust correction
-    if CTcorrection=='GlauertCT':
-        # Glauert correction as default
-        #>>> NOTE this is:  a = a_Ct(Ct, a, method='Glauert') from highthrust
-        ac = 0.3 
-        bHigh = a > ac
-        fg = 0.25*(5.-3.*a[bHigh])
-        a[bHigh] = Ct[bHigh]/(4.*F[bHigh]*(1.-fg*a[bHigh]))
-    else:
-        a = a_Ct(Ct, a, F, method=CTcorrection)
-
-    a[F<0.01]=1 # HACK to match aerodyn # TODO make that an option
-
-    # --- Relaxation for high Ct
-    if a_last is not None:
-        bHigh = a>0.3
-        a[bHigh] = a[bHigh]*relaxation + (1.-relaxation)*a_last[bHigh]
-
-    # --- Swirl
-    if bSwirl is True:
-        if swirlMethod=='AeroDynOld':
-            aprime=0.5*(sqrt(1+4*a*F*(1-a)/lambda_r**2)-1);
-
-        elif swirlMethod=='AeroDyn':
-            # NOTE: AeroDyn has more tests (e.g. if cos(phi)=0)
-            aprime=np.zeros(a.shape)
-            b0 = np.logical_or(np.abs(a-1)<1e-5, np.abs(phi)<1e-5)
-            b1 = np.logical_not(b0)
-            aprime[b0] = 0 
-            kp         = sigma[b1]*ctForTI[b1]/(4*F[b1]*sin(phi[b1])*cos(phi[b1]))
-            aprime[b1] = kp/(1-kp)
-        elif swirlMethod=='HAWC2':
-            aprime = (Vrel_norm**2*ctForTI*sigma)/(4.*(1.-a)*V0**2*lambda_r)
-        elif swirlMethod=='Default': # Need a better name
-            aprime=1/((4*F*sin(phi)*cos(phi)) /(sigma*ctForTI)  -1 );
-        else:
-            raise NotImplementedError()
-    else:
-        aprime = a * 0.
-
-    # Bounding values for safety
-    a     [np.isnan(a)]      = 0
-    aprime[np.isnan(aprime)] = 0
-    aprime = np.clip(aprime,-1,1.0) 
-    a      = np.clip(a     ,-1,1.5)
-    Ct     = np.clip(Ct    ,-1,3)
-    return a, aprime, Ct
-
 
 class BEMStates:
     def __init__(self, nB, nr):
         pass
         # Induction
         # Dynamic wake
         # Dynamic stall
@@ -123,96 +41,193 @@
         self.Vind_qs_g  = np.zeros((nB,nr,3)) # Quasi-steady velocity
         self.Vind_int_p = np.zeros((nB,nr,3)) # Intermediate velocity, polar coordinates
         self.Vind_dyn_p = np.zeros((nB,nr,3)) # Dynamic induced velocity (before skew/yaw), polar coordinates
         self.Vind_dyn_g = np.zeros((nB,nr,3)) # Dynamic induced velocity (before skew/yaw), global coordinates
         # Dynamic stall
         self.fs = np.zeros((nB,nr)) # Separation 
 
-class AeroBEM:
+# --------------------------------------------------------------------------------}
+# --- Main Class UnsteadyBEM 
+# --------------------------------------------------------------------------------{
+class UnsteadyBEM():
     """ 
     Perform unsteady BEM calculations
     """
-    def __init__(self):
-
+    def __init__(self, filename=None):
+        """ 
+        filename: an OpenFAST (.fst) or AeroDyn driver (.dvr) input file.
+                  will be used to initialize the parameters and operating conditions
+        """
         # Aero Data
         self.chord  = None
         self.polars = None
         # Environment
         self.rho     = None
-        self.kinVisc = None
+        self.kinVisc = None # Kinematic viscosity [kg/m^3]
 
         # Structural "Inputs"
         # position, velocity, and orientation of all blade station
         #self.cone   = None
         #self.twist  = None
         self.nB     = None
         self.r      = None # radial stations
 
+        # Algorithm
         self.setDefaultOptions()
 
+        # Init from given input file
+        if filename is not None:
+            self.init_from_FAST(filename) # Init from a FAST input file 
+
     def setDefaultOptions(self):
-        self.nbIt = 200  # maximum number of iterations in BEM
+        #self.projMod = 'noSweepPitchTwist' # 
+        #self.projMod = 'liftingLine' # 
+        self.projMod = 'polar' # 
+        self.algorithm = 'legacy' # Main switch for algorithm
+        self.nIt = 200  # maximum number of iterations in BEM
         self.aTol = 10 ** -6 # tolerance for axial induction factor convergence
         self.relaxation = 0.5  # relaxation factor in axial induction factor
-        self.CTcorrection = 'AeroDyn'  #  type of CT correction more model implementated in the future like 'spera'
+        self.CTcorrection = 'AeroDyn15'  #  type of CT correction more model implementated in the future like 'spera'
         self.swirlMethod  = 'AeroDyn' # type of swirl model
-        self.Ngrid = 1.0
+        self.bUseCm = True  # Use Moment 
         self.bSwirl = True  # swirl flow model enabled / disabled
         self.bTipLoss = True # enable / disable tip loss model
         self.bHubLoss = False # enable / disable hub loss model
         self.bTipLossCl = False # enable / disable Cl loss model
         self.TipLossMethod = 'Glauert'  # type of tip loss model
         self.bDynaStall = True # dynamic stall model
         self.bDynaWake = True # dynamic stall model
 #           1   DBEMT_Mod          - Type of dynamic BEMT (DBEMT) model {1=constant tau1, 2=time-dependent tau1} (-) [used only when WakeMod=2]
 #           4   tau1_const         - Time constant for DBEMT (s) [used only when WakeMod=2 and DBEMT_Mod=1]
 
         self.bYawModel = True # Yaw correction
         self.bAIDrag = True # influence on drag coefficient on normal force coefficient
         self.bTIDrag = True # influence on drag coefficient on tangential force coefficient
-        self.bReInterp = False # interpolate the input tabulated airfoil data for Reynolds variation
-        self.bThicknessInterp = True # interpolate the input tabulated airfoil data for thickness variation
         self.WakeMod=1 # 0: no inductions, 1: BEM inductions
-        self.bRoughProfiles = False # use rough profiles for input airfoil data
 
     def init_from_FAST(self, FASTFileName):
         from welib.weio.fast_input_deck import FASTInputDeck
-        F = FASTInputDeck(FASTFileName,readlist=['AD','ED','ADbld','AF'])
+        F = FASTInputDeck(FASTFileName,readlist=['AD','ED','ADbld','AF','IW'])
+        driver =  F.version=='AD_driver'
+        # --- Safety checkes
+        if F.AD is None:
+            raise Exception('steadyBEM: Cannot open AD file referenced in:'.format(FASTFileName))
+        if driver:
+            dvr = F.fst
+            if dvr['NumTurbines']>1:
+                raise NotImplementedError('steadyBEM: Number of turbines should be 1')
+            if not dvr['BasicHAWTFormat(1)']:
+                raise NotImplementedError('steadyBEM: BasicHAWTFormat should be true for now')
+        if not driver:
+            if F.ED is None:
+                raise Exception('steadyBEM: Cannot open ED file referenced in:'.format(FASTFileName))
 
-        # Environment
+        # --- Environment
         try:
-            self.rho     = float(F.fst['AirDens'])  # New OF > 3.0
+            self.rho     = float(F.fst['FldDens'])  # New OF > 3.0
         except:
-            self.rho     = float(F.AD['AirDens'])   # Old OF <=3.0
+            try:
+                self.rho     = float(F.fst['AirDens'])  # New OF > 3.0
+            except:
+                self.rho     = float(F.AD['AirDens'])   # Old OF <=3.0
         try:
             self.kinVisc = float(F.fst['KinVisc'])  # New OF > 3.0
         except:
             self.kinVisc = float(F.AD['KinVisc'])   # Old OF <= 3.0
 
+        # --- Geometry
+        if driver:
+            self.nB       = dvr['NumBlades(1)']
+            r_hub         = dvr['HubRad(1)']
+            # Input geometry (may be overriden by motion/simulations)
+            self.cone0    = dvr['PreCone(1)']
+            self.tilt0    = dvr['ShftTilt(1)']
+            self.OverHang = dvr['OverHang(1)']
+            self.Twr2Shft  = dvr['Twr2Shft(1)']
+
+            HubHt = dvr['HubHt(1)']
+            self.TowerHt  = HubHt - self.Twr2Shft + self.OverHang*sin(self.tilt0*np.pi/180) # TODO double check
+
+        else:
+            self.nB    = F.ED['NumBl']
+            r_hub      = F.ED['HubRad']
+            # Input geometry (may be overriden by motion/simulations)
+            self.cone0     = F.ED['PreCone(1)']
+            self.tilt0     = F.ED['ShftTilt']
+            self.TowerHt   = F.ED['TowerHt']
+            self.OverHang  = F.ED['OverHang']
+            self.Twr2Shft  = F.ED['Twr2Shft']
+
 
-        # Aerodynamics
-        self.nB    = F.ED['NumBl']
-        self.r     = F.AD.Bld1['BldAeroNodes'][:,0] + F.ED['HubRad']
-        chord      = F.AD.Bld1['BldAeroNodes'][:,-2]
+        # --- Aerodynamics
+        self.r     = F.AD.Bld1['BldAeroNodes'][:,0] + r_hub
+        chord      = F.AD.Bld1['BldAeroNodes'][:,5]
         self.chord = np.stack([chord]*self.nB)
-        self.twist = F.AD.Bld1['BldAeroNodes'][:,-3]*np.pi/180
+        self.twist = F.AD.Bld1['BldAeroNodes'][:,4]*np.pi/180
         polars=[]
         ProfileID=F.AD.Bld1['BldAeroNodes'][:,-1].astype(int)
         for ipolar in  ProfileID:
-            polars.append(F.AD.AF[ipolar-1]['AFCoeff'])
+            nTabs = F.AD.AF[ipolar-1]['NumTabs']
+            if nTabs==1:
+                polars.append(F.AD.AF[ipolar-1]['AFCoeff'])
+            else:
+                print('[WARN] unsteadyBEM multiple polar present')
+                vRe   = [F.AD.AF[ipolar-1]['re_{}'.format(i+1)] for i in range(nTabs)]
+                vCtrl = [F.AD.AF[ipolar-1]['Ctrl_{}'.format(i+1)] for i in range(nTabs)]
+                print(vRe)
+                print(vCtrl)
+                # Taking last polar...
+                polars.append(F.AD.AF[ipolar-1]['AFCoeff_{}'.format(nTabs)])
         self.polars = polars
+        self.bAIDrag  = F.AD['AIDrag']
+        self.bTIDrag  = F.AD['TIDrag']
+        self.bHubLoss = F.AD['HubLoss']
+        self.bTipLoss = F.AD['TipLoss']
+        self.bSwirl   = F.AD['TanInd']
+        self.bUseCm   = F.AD['UseBlCm']
 
-        # Input geometry (may be overriden by motion/simulations)
-        self.cone0     = F.ED['PreCone(1)']
-        self.tilt0     = F.ED['ShftTilt']
-        self.TowerHt   = F.ED['TowerHt']
-        self.OverHang  = F.ED['OverHang']
-        self.Twr2Shft  = F.ED['Twr2Shft']
+        # --- Operating conditions
+        # Maybe...
 
+	# trigger once data is set
         self._init()
+     
+     
+    def __repr__(self):
+        s='<{} object>:\n'.format(type(self).__name__)
+        # Aero Data
+        s+='Aerodynamic data:\n'
+        s+=' - r         : size: {}, min: {}, max: {}\n'.format(len(self.r), np.min(self.r), np.max(self.r))
+        s+=' - chord     : size: {}, min: {}, max: {}\n'.format(len(self.chord), np.min(self.chord), np.max(self.chord))
+        s+=' - twist     : size: {}, min: {}, max: {} [deg]\n'.format(len(self.twist), np.min(self.twist), np.max(self.twist))
+        s+=' - polars    : size: {}\n'.format(len(self.polars))
+        s+=' - nB        : {}\n'.format(self.nB)
+        s+=' - cone0     : {} [deg]\n'.format(self.cone0 )
+        # Environment
+        s+='Environmental conditions:\n'
+        s+=' - rho       : {} [kg/m^3]\n'.format(self.rho    )
+        s+=' - kinVisc   : {} [kg/m^3]\n'.format(self.kinVisc)
+        # Latest operating conditions
+        #s+='Latest operating conditions:\n'
+        #s+=' - Omega0    : {} [rpm]\n'.format(self.Omega0)
+        #s+=' - pitch0    : {} [deg]\n'.format(self.pitch0)
+        #s+=' - V0        : {} [m/s]\n'.format(self.V0)
+        s+='Algorithm options:\n'
+        s+=' - projMod   : {}\n'.format(self.projMod )
+        s+=' - algorithm : {}\n'.format(self.algorithm )
+        s+=' - nIt       : {}\n'.format(self.nIt      )
+        s+=' - aTol      : {}\n'.format(self.aTol      )
+        s+=' - relaxation: {}\n'.format(self.relaxation)
+        s+=' - bSwirl    : {}\n'.format(self.bSwirl    )
+        s+=' - bTipLoss  : {}\n'.format(self.bTipLoss  )
+        s+=' - bHubLoss  : {}\n'.format(self.bHubLoss  )
+        s+=' - bAIDrag   : {}\n'.format(self.bAIDrag   )
+        s+=' - bTIDrag   : {}\n'.format(self.bTIDrag  )
+        s+=' - WakeMod   : {}\n'.format(self.WakeMod  )
+        return s
 
     def _init(self):
         # Creating interpolation functions for each polar, now in rad!
         self.fPolars = [interp1d(p[:,0]*np.pi/180,p[:,1:],axis=0) for p in self.polars]
 
     def getInitStates(self):
         return BEMDiscreteStates(self.nB, len(self.r))
@@ -225,14 +240,15 @@
         nr = len(self.r)
         # --- Spanwise data
         # Coeffients
         self.Cl_qs  = np.zeros((nt,nB,nr))
         self.Cd_qs  = np.zeros((nt,nB,nr))
         self.Cl     = np.zeros((nt,nB,nr))
         self.Cd     = np.zeros((nt,nB,nr))
+        self.Cm     = np.zeros((nt,nB,nr))
         self.cn     = np.zeros((nt,nB,nr))
         self.ct     = np.zeros((nt,nB,nr))
         self.Cx_a   = np.zeros((nt,nB,nr))
         self.Cy_a   = np.zeros((nt,nB,nr))
         self.Ct     = np.zeros((nt,nB,nr))
         self.Cq     = np.zeros((nt,nB,nr))
         # Velocities
@@ -240,28 +256,28 @@
         self.Vrel_xa = np.zeros((nt,nB,nr)) # 
         self.Vrel_ya = np.zeros((nt,nB,nr)) # 
         self.Vrel_za = np.zeros((nt,nB,nr)) # 
         self.Vind_p = np.zeros((nt,nB,nr,3))
         self.Vind_s = np.zeros((nt,nB,nr,3))
         self.Vind_qs_p = np.zeros((nt,nB,nr,3))
         self.Vflw_p = np.zeros((nt,nB,nr,3)) # Vwnd-Vstr
-        self.Vflw_s = np.zeros((nt,nB,nr,3)) # Vwnd-Vstr
         self.Vwnd_p = np.zeros((nt,nB,nr,3))
         self.Vwnd_s = np.zeros((nt,nB,nr,3))
         self.Vwnd_a = np.zeros((nt,nB,nr,3))
         self.Vstr_p = np.zeros((nt,nB,nr,3))
         self.Vstr_s = np.zeros((nt,nB,nr,3))
         self.Vstr_xa = np.zeros((nt,nB,nr))
         self.Vstr_ya = np.zeros((nt,nB,nr))
         self.Vrel   = np.zeros((nt,nB,nr))
         self.AxInd  = np.zeros((nt,nB,nr))
         self.TnInd  = np.zeros((nt,nB,nr))
         # Loads per span
         self.L      = np.zeros((nt,nB,nr))
         self.D      = np.zeros((nt,nB,nr))
+        self.Mm     = np.zeros((nt,nB,nr))
         self.Fn     = np.zeros((nt,nB,nr))
         self.Ft     = np.zeros((nt,nB,nr))
         self.F_a   = np.zeros((nt,nB,nr,3))
         self.F_s    = np.zeros((nt,nB,nr,3))
         self.Gamma  = np.zeros((nt,nB,nr))
         self.alpha  = np.zeros((nt,nB,nr))
         self.phi    = np.zeros((nt,nB,nr))
@@ -270,32 +286,39 @@
         self.Thrust   = np.zeros(nt)
         self.Torque   = np.zeros(nt)
         self.Power    = np.zeros(nt)
         self.chi      = np.zeros(nt)
         self.chi0     = np.zeros(nt)
         self.RtVAvg   = np.zeros((nt,3))
         self.psi      = np.zeros(nt)
+        self.Omega    = np.zeros(nt)  # [rpm]
         self.RtArea   = np.zeros(nt)
         self.SkewAzimuth  = np.zeros((nt,nB))
         # Blade blades
         self.BladeTorque = np.zeros((nt,nB))
         self.BladeThrust = np.zeros((nt,nB))
         self.BladeEdge   = np.zeros((nt,nB))
         self.BladeFlap   = np.zeros((nt,nB))
 
 
 
     def calcOutput(self):
+        """ 
+        Compute output for current state variables and inputs.
+        """
         R = np.sqrt(self.RtArea/pi)
         q = 0.5*self.rho*self.RtArea*self.RtVAvg[:,0]**2
         self.CT=self.Thrust/(q)
         self.CQ=self.Torque/(q*R)
         self.CP=self.Power /(q*self.RtVAvg[:,0])
 
 
+    # --------------------------------------------------------------------------------}
+    # --- IO 
+    # --------------------------------------------------------------------------------{
     def toDataFrame(self, BldNd_BladesOut=None, BldNd_BlOutNd=None, BldNd_OutList=None):
         """ Export time series to a pandas dataframe
         Column names are set to match OpenFAST outputs
 
         BldNd_BladesOut: if None, all blades nodal output is output. Otherwise set it to an integer < self.nB
         BldNd_BlOutNd:   if None, all radial position are output.    Otherwise set it to a list of radial indices [0,2,4, etc] 
         BldNd_OutList:   if None, all possible channels are output.  Otherwise, set it to a list of channel names with units. 
@@ -307,34 +330,49 @@
 
         #if not hasattr(self,'CP'):
         self.calcOutput()
 
         df = pd.DataFrame()
         df['Time_[s]']        = self.time
         df['Azimuth_[deg]']   = np.mod(self.psi,360)
+        df['RtSpeed_[rpm]']   = self.Omega
         df['RtAeroFxh_[N]']   = self.Thrust
         df['RtAeroMxh_[N-m]'] = self.Torque
         df['RtAeroPwr_[W]']   = self.Power
         df['RtAeroCt_[-]']    = self.CT
         df['RtAeroCq_[-]']    = self.CQ
         df['RtAeroCp_[-]']    = self.CP
+        # Temporary
+        df['RtFldFxh_[N]']   = self.Thrust
+        df['RtFldMxh_[N-m]'] = self.Torque
+        df['RtFldPwr_[W]']   = self.Power
+        df['RtFldCt_[-]']    = self.CT
+        df['RtFldCq_[-]']    = self.CQ
+        df['RtFldCp_[-]']    = self.CP
 
         df['RtVAvgxh_[m/s]']  = self.RtVAvg[:,0]
         df['RtVAvgyh_[m/s]']  = self.RtVAvg[:,1]
         df['RtVAvgzh_[m/s]']  = self.RtVAvg[:,2]
         df['RtArea_[m^2]']    = self.RtArea
         df['RtSkew_[deg]']    = self.chi0
 
 
 
         for iB in np.arange(self.nB):
-            df['B'+str(iB+1)+'Azimuth_[deg]']  = np.mod(self.SkewAzimuth[:,iB],360)
-
-        Vflw_s = self.Vwnd_s-self.Vstr_s
+            df['B'+str(iB+1)+'Azimuth_[deg]']  = np.mod(self.psi+self.SkewAzimuth[:,iB],360)
 
+        print('>>> {} outputs'.format(self.projMod))
+        if self.projMod=='polar': # TODO replace with "outProj"
+            Vflw_o = self.Vwnd_p-self.Vstr_p
+            Vwnd_o = self.Vwnd_p
+        elif self.projMod=='noSweepPitchTwist':
+            Vflw_o = self.Vwnd_s-self.Vstr_s
+            Vwnd_o = self.Vwnd_s
+        else:
+            raise NotImplementedError()
 
         # --- Creating all the possible column names for all blades and radial position, matching OpenFAST convention
         if BldNd_BladesOut is None: 
             BldNd_BladesOut=np.arange(self.nB)
         else:
             BldNd_BladesOut=np.arange(min(BldNd_BladesOut, self.nB))
         if BldNd_BlOutNd is None: 
@@ -348,32 +386,34 @@
 
         df= pd.concat((df,df_B_r),axis=1)
 
         # AeroDyn x-y is "section coord" s
         # AeroDyn n-t is "airfoil coord" a
         # AeroDyn doesn't have polar coord..
         for iB in np.arange(self.nB):
+            # TODO TODO TODO Might need rethinking with polarProj
             if 'Fx_[N/m]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Fx_[N/m]'] = self.F_s[:,iB,ir,0]
             if 'Fy_[N/m]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Fy_[N/m]'] =-self.F_s[:,iB,ir,1] # NOTE: weird sign
+            # TODO TODO TODO Might need rethinking with polarProj
             if 'Vx_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
-                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Vx_[m/s]'] =      Vflw_s[:,iB,ir,0]
+                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Vx_[m/s]'] =      Vflw_o[:,iB,ir,0]
             if 'Vy_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
-                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Vy_[m/s]'] =      Vflw_s[:,iB,ir,1]
+                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Vy_[m/s]'] =      Vflw_o[:,iB,ir,1]
             if 'VDisx_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
-                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'VDisx_[m/s]'] = self.Vwnd_s[:,iB,ir,0]
+                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'VDisx_[m/s]'] =      Vwnd_o[:,iB,ir,0]
             if 'VDisy_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
-                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'VDisy_[m/s]'] = self.Vwnd_s[:,iB,ir,1]
+                    df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'VDisy_[m/s]'] =      Vwnd_o[:,iB,ir,1]
             if 'STVx_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'STVx_[m/s]'] = self.Vstr_s[:,iB,ir,0]
             if 'STVy_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'STVy_[m/s]'] = self.Vstr_s[:,iB,ir,1]
             if 'STVz_[m/s]' in BldNd_OutList:
@@ -397,14 +437,15 @@
             if 'Vindy_[m/s]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Vindy_[m/s]'] = self.Vind_s[:,iB,ir,1]
             if 'Alpha_[deg]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Alpha_[deg]'] = self.alpha[:,iB,ir]
             #AeroDyn "n-t", is almost like xa but y is switched
+            # TODO TODO TODO Might need rethinking with polarProj
             if 'Fn_[N/m]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Fn_[N/m]'] = self.F_a[:,iB,ir,0]
             if 'Ft_[N/m]' in BldNd_OutList:
                 for ir in np.arange(len(self.r)):
                     df['AB'+str(iB+1)+'N{:03d}'.format(ir+1)+'Ft_[N/m]'] =-self.F_a[:,iB,ir,1]
             if 'Cl_[-]' in BldNd_OutList:
@@ -424,21 +465,39 @@
             df[B+'AxInd_[-]'] = self.AxInd[it,iB,:]
             df[B+'TnInd_[-]'] = self.AxInd[it,iB,:]
         return df
 
 
     def timeStep(self, t, dt, xd0, psi, psiB0,
             origin_pos_gl, omega_gl, R_r2g,  # Kinematics of rotor origin
-            R_ntr2g, R_bld2r, # "polar grid to global" for each blade
+            R_ntr2g, R_bld2r, # for each blade
             pos_gl, Vstr_gl, R_s2g, R_a2g,            # Kinematics of nodes
             Vwnd_gl, # Wind at each positions in global
-            firstCallEquilibrium=False
+            firstCallEquilibrium=False,
+            kappa = None # cant angle, TODO TODO TODO get rid of me, temporary. User EulerExtract of R_ntr2g
             ):
         """ 
         xBEM0: BEM states at t-1
+
+        INPUTS:
+         - t: current time step [s]
+         - dt: time interval [s]
+         - xd0: discreate states at current time step. Instance of BEMDiscreteStates
+         - psi: current azimuth [rad]
+         - psiB0: azimuthal offsets for each blades compared to psi 
+         - origin_pos_gl: position of rotor origin in global coordinates
+         - omega_gl:  rotational speed of rotor in global coordinates
+         - R_r2g   :  transformation from rotor coordinates to global
+         - R_ntr2g :  transformation from polar grid to global" (for each blade) (nB x 3 x 3)
+         - R_bld2r :  transformation from blade to rotor (for each blade)        (nB x 3 x 3)
+                      typically consist of azimuth, cone and pitch
+         - pos_gl: positions of all blade nodes in global              (nB x nr x 3)
+         - Vstr_gl: structural velocity of a llblade nodes in global   (nB x nr x 3)
+         - R_s2g  : transformation matrix from "section" to global     (nB x nr x 3 x 3)
+         - R_a2g  : transformation matrix from airfoil to global       (nB x nr x 3 x 3)
         """
         xd1   = copy.deepcopy(xd0)
         xd1.t = t
         xd1.it = xd0.it+1 # Increase time step 
         # Safety
         if xd0.t is not None:
             if np.abs((xd0.t+dt-t))>dt/10:
@@ -448,88 +507,120 @@
         nB, nr, _ = pos_gl.shape
         p = self # alias
         ### Loop on blades
         # --------------------------------------------------------------------------------
         # --- Step 0: geometry 
         # --------------------------------------------------------------------------------
         # --- Compute rotor radius, hub radius, and section radii
-        r = np.zeros((nB,nr))
-        Rs=[0]*nB
+        r_p = np.zeros((nB,nr)) # radius in polar grid
+        r_b = np.zeros((nB,nr)) # radius in blade coordinates
+        Rs_p=[0]*nB
+        R_bld2g = np.zeros((nB,3,3)) # from blade to global
         for iB in np.arange(nB):
-            R_p2g = R_ntr2g[iB]
+            R_p2g = R_ntr2g[iB] # TODO make it a function of element
+            R_bld2g[iB] =  R_r2g.dot(R_bld2r[iB])
             # radial position (in polar grid) of first and last node taken
-            Rs[iB] = (R_p2g.T).dot(pos_gl[iB,-1,:]-origin_pos_gl)[2]
-            rhub   = (R_p2g.T).dot(pos_gl[iB,0,:] -origin_pos_gl)[2]
+            Rs_p[iB] = (R_p2g.T).dot(pos_gl[iB,-1,:]-origin_pos_gl)[2]
+            rhub_p   = (R_p2g.T).dot(pos_gl[iB, 0,:]-origin_pos_gl)[2]
             # loop on elements
             for ie in np.arange(nr):
-                r[iB,ie] = (R_p2g.T).dot(pos_gl[iB,ie,:]-origin_pos_gl)[2] # radial position in polar grid
-        R = np.max(Rs)
+                r_p[iB,ie] = (R_p2g.T)  .dot(pos_gl[iB,ie,:]-origin_pos_gl)[2] # radial position in polar grid
+                r_b[iB,ie] = (R_bld2g[iB].T).dot(pos_gl[iB,ie,:]-origin_pos_gl)[2] # radial position in blade coordinate (from rotor center) 
+            #print('r_b',r_b[iB])
+            #print('r_p',r_p[iB])
+            #dr = np.diff(r_p[iB])
+            #dz = np.diff(r_b[iB])
+            #print('k', kappa, np.arccos(dr/dz)*180/np.pi) # NOTE: not accurate, need sign as well
+        R_p = np.max(Rs_p) # Rotor radius projected onto polar grid
         # --- Rotor speed for power
         omega_r = R_r2g.T.dot(omega_gl) # rotational speed in rotor coordinate system
         Omega = omega_r[0] # rotation speed of shaft (along x)
 
+        if kappa is None:
+            kappa = 0 # TODO TODO could compute it based on r_p and r_b
+
+        if self.algorithm=='polarProj':
+            drdz = cos(kappa*np.pi/180)
+        else:
+            drdz = 1
+
         if firstCallEquilibrium:
-            nit=50
+            nItMax=50
         else:
-            nit=1
-        for iterations in np.arange(nit):
+            nItMax=1
+        for iterations in np.arange(nItMax):
             # --------------------------------------------------------------------------------
             # --- Step 1: velocity components
             # --------------------------------------------------------------------------------
             Vrel_a  = np.zeros((nB,nr,3))
             Vrel_p  = np.zeros((nB,nr,3))
             Vstr_p  = np.zeros((nB,nr,3))
             Vwnd_p  = np.zeros((nB,nr,3))
+            Vrel_k  = np.zeros((nB,nr,3))
             for iB in np.arange(nB):
                 R_p2g = R_ntr2g[iB]
                 for ie in np.arange(nr):
                     # Velocity in global
                     Vwnd_g = Vwnd_gl[iB,ie]
                     # NOTE: inductions from previous time step, in polar grid (more realistic than global)
                     #Vind_g = xd0.Vind_g[iB,ie] # dynamic inductions at previous time step
                     Vind_g = (R_p2g).dot(xd0.Vind_p[iB,ie]) # dynamic inductions at previous time step
                     Vstr_g = Vstr_gl[iB,ie]
                     Vrel_g = Vwnd_g+Vind_g-Vstr_g
-                    # Airfoil coordinates
-                    Vrel_a[iB,ie] = (R_a2g[iB,ie].T).dot(Vrel_g)
                     # Polar coordinates
                     Vstr_p[iB,ie] = (R_p2g.T).dot(Vstr_g) # Structural velocity in polar coordinates
                     Vrel_p[iB,ie] = (R_p2g.T).dot(Vrel_g)
                     Vwnd_p[iB,ie] = (R_p2g.T).dot(Vwnd_g) # Wind Velocity in polar coordinates
+                    # Kappa coordinates
+                    Vrel_k[iB,ie,0] = Vrel_p[iB,ie,0]*np.cos(kappa*np.pi/180) # n  # TODO TODO use cant
+                    Vrel_k[iB,ie,1] = Vrel_p[iB,ie,1] # t
+                    # Airfoil coordinates
+                    Vrel_a[iB,ie] = (R_a2g[iB,ie].T).dot(Vrel_g) # TODO use R_p2a instead, and remove zp component
             Vflw_p  = Vwnd_p-Vstr_p # Relative flow velocity, including wind and structural motion
             Vflw_g  = Vwnd_gl-Vstr_gl # Relative flow velocity, including wind and structural motion
 
             # Velocity norm and Reynolds
-            Vrel_norm = sqrt(Vrel_a[:,:,0]**2 + Vrel_a[:,:,1]**2)
-            Re        = Vrel_norm*p.chord/p.kinVisc/10**6 # Reynolds in million
+            Vrel_norm_k = sqrt(Vrel_k[:,:,0]**2 + Vrel_k[:,:,1]**2)
+            Vrel_norm_a = sqrt(Vrel_a[:,:,0]**2 + Vrel_a[:,:,1]**2)
+            Re        = Vrel_norm_a*p.chord/p.kinVisc/10**6 # Reynolds in million
             # --------------------------------------------------------------------------------
             # --- Step 2: Flow Angle and tip loss
             # --------------------------------------------------------------------------------
+            phi_k = np.arctan2(Vrel_k[:,:,0],-Vrel_k[:,:,1]) # flow angle [rad] in kappa system
             phi_p = np.arctan2(Vrel_p[:,:,0],-Vrel_p[:,:,1])  # NOTE: using polar grid for phi
-            # --- Tip loss
+            if self.algorithm=='legacy':
+                phi_tl = phi_p
+                phi    = phi_p
+            elif self.algorithm=='polarProj':
+                phi_tl = phi_k
+                phi    = phi_k
+            else:
+                raise Exception()
+            # --- Tip and hub losses
             F = np.ones((nB,nr))
             if (p.bTipLoss): #Glauert tip correction
-                b=sin(phi_p)>0.01
-                F[b] = 2./pi*arccos(exp(-(nB *(R-r[b]))/(2*r[b]*sin(phi_p[b]))))
-                b2=abs(r-R)<1e-3
+                b=sin(phi_tl)>0.01
+                F[b] = 2./pi*arccos(exp(-(nB *(R_p-r_p[b]))/(2*r_p[b]*sin(phi_tl[b]))))
+                b2=abs(r_p-R_p)<1e-3
                 F[b2]=0.001
             # --- Hub loss
             if (p.bHubLoss): #Glauert hub loss correction
-                F = F* 2./pi*arccos(exp(-nB/2. *(r-rhub)/ (rhub*np.sin(phi_p))))
+                F = F* 2./pi*arccos(exp(-nB/2. *(r_p-rhub_p)/ (rhub_p*np.sin(phi_tl))))
             #F[F<=1e-3]=0.5
             # --------------------------------------------------------------------------------
             # --- Step 3: Angle of attack
             # --------------------------------------------------------------------------------
             alpha = np.arctan2(Vrel_a[:,:,0],Vrel_a[:,:,1])        # angle of attack [rad]
             # --------------------------------------------------------------------------------
             # --- Step 4: Aerodynamic Coefficients
             # --------------------------------------------------------------------------------
             ClCdCm = np.array([p.fPolars[ie](alpha[iB,ie]) for iB in np.arange(nB) for ie in np.arange(nr)]).reshape((nB,nr,3))
             Cl=ClCdCm[:,:,0]
             Cd=ClCdCm[:,:,1]
+            Cm=ClCdCm[:,:,2]
             # Project to airfoil coordinates
             C_xa       ,C_ya        = Cl*cos(alpha)+ Cd*sin(alpha  )   ,  -Cl*sin(alpha)+ Cd*cos(alpha)
             C_xa_noDrag,C_ya_noDrag = Cl*cos(alpha)                    ,  -Cl*sin(alpha)
             # Project to polar coordinates
             C_p        = np.zeros((nB,nr,3))
             C_g        = np.zeros((nB,nr,3))
             C_p_noDrag = np.zeros((nB,nr,3))
@@ -556,24 +647,30 @@
             # --------------------------------------------------------------------------------
             # NOTE: all is done in polar grid
             #lambda_r = Vstr_p[:,:,1]/Vwnd_p[:,:,0] # "omega r/ U0n" defined in polar grid # TODO TODO TODO
             lambda_r = -Vflw_p[:,:,1]/Vflw_p[:,:,0] # "omega r/ U0n" defined in polar grid # TODO TODO TODO
             #lambda_r = Vflw_p[:,:,1]/Vflw_p[:,:,0] # "omega r/ U0n" defined in polar grid # TODO TODO TODO
             #V0       = np.sqrt(Vwnd_p[:,:,0]**2 + Vwnd_p[:,:,1]**2) # TODO think about that # TODO TODO TOD
             V0       = np.sqrt(Vflw_p[:,:,0]**2 + Vwnd_p[:,:,1]**2) # TODO think about that
-            sigma    = p.chord*p.nB/(2*pi*r)
+            sigma    = p.chord*p.nB/(2*pi*r_p) # NOTE: using radius in polar grid
             #a,aprime,CT = fInductionCoefficients(a_last,Vrel_in4,Un,Ut,V0_in3,V0_in4,nnW_in4,omega,chord(e),F,Ftip,CnForAI,CtForTI,lambda_r,sigma(e),phi,Algo)
             if p.WakeMod==0:
                 a      = V0*0
                 aprime = V0*0
             else:
-                a,aprime,CT = _fInductionCoefficients(Vrel_norm, V0, F, cnForAI, ctForTI, lambda_r, sigma, phi_p, 
+                a,aprime,CT = _fInductionCoefficients(Vrel_norm_k, V0, F, cnForAI, ctForTI, lambda_r, sigma, phi, 
                         bSwirl=p.bSwirl, CTcorrection=p.CTcorrection, swirlMethod=p.swirlMethod,
-                        relaxation=p.relaxation, a_last=xd0.a
+                        relaxation=p.relaxation, a_last=xd0.a,
+                        algorithm=self.algorithm, drdz=drdz
                 )
+                # TODO consider using these
+                k  = sigma*cnForAI/(4*F)*Vrel_norm_a**2/(Vrel_p[:,:,0]**2)            /drdz
+                kp =-sigma*ctForTI/(4*F)*Vrel_norm_a**2/(Vrel_p[:,:,0]*Vrel_p[:,:,1]) /drdz # NOTE: yp has different convention OpenFAST/WELIB
+                #a[:,:]      = 0.3
+                #aprime[:,:] = 0.02
 
             if np.any(np.isnan(a)):
                 print('>> BEM crashing')
 
             # Storing last values, for relaxation
             xd1.a=a.copy()
             # Quasi steady inductions, polar and global coordinates
@@ -586,28 +683,41 @@
                     xd1.Vind_qs_g[iB,ie] = R_p2g.dot(xd1.Vind_qs_p[iB,ie]) # global
 
             if firstCallEquilibrium:
                 # We update the previous states induction
                 xd0.a      = a.copy()
                 xd0.Vind_g = xd1.Vind_qs_g.copy()
                 xd0.Vind_p = xd1.Vind_qs_p.copy()
+            #print('')
+            #print('Vflw',Vflw_p[0,19,:])
+            #print('F      ',F[0,19])
+            #print('phi tl ',phi_tl[0,19])
+            #print('sigma  ',sigma[0,19])
+            #print('Vrel_p ',Vrel_p[0,19,:])
+            #print('Vrel_a ',Vrel_a[0,19,:])
+            #print('cn     ',cnForAI[0,19], ctForTI[0,19])
+            #print('drdz   ',drdz) # TODO
+            #print('k      ',k[0,19], kp[0,19])
+
+
+
         if firstCallEquilibrium:
             # Initialize dynamic wake variables
             xd0.Vind_qs_p  = xd1.Vind_qs_p.copy()
             xd1.Vind_qs_p  = xd1.Vind_qs_p.copy()
             xd0.Vind_int_p = xd1.Vind_qs_p.copy()
             xd0.Vind_dyn_p = xd1.Vind_qs_p.copy()
         # --------------------------------------------------------------------------------
         # --- Dynamic wake model, in polar coordinates (for "constant" structural velocity)
         # --------------------------------------------------------------------------------
         if (p.bDynaWake):
             a_avg = min([np.mean(a),0.5])
             V_avg = max([np.mean(V0),0.001])
-            tau1 = 1.1 / (1 - 1.3 *a_avg)*R/V_avg
-            tau2 = (0.39 - 0.26 * (r/R)**2) * tau1
+            tau1 = 1.1 / (1 - 1.3 *a_avg)*R_p/V_avg
+            tau2 = (0.39 - 0.26 * (r_p/R_p)**2) * tau1
             tau2 = np.tile(tau2[:,:,None],3)
             # Oye's dynamic inflow model, discrete time integration
             H              = xd1.Vind_qs_p + 0.6 * tau1 * (xd1.Vind_qs_p - xd0.Vind_qs_p) /dt
             xd1.Vind_int_p = H + (xd0.Vind_int_p - H) * exp(-dt/tau1) # intermediate velocity
             xd1.Vind_dyn_p = xd1.Vind_int_p + (xd0.Vind_dyn_p - xd1.Vind_int_p) * exp(-dt/tau2)
             # In global
             for iB in np.arange(nB):
@@ -657,17 +767,17 @@
         # ---  Yaw model, repartition of the induced velocity
         # --------------------------------------------------------------------------------
         if p.bYawModel:
            #xd1.Vind_g = xd1.Vind_dyn_g.copy()
            #xd1.Vind_p = xd1.Vind_dyn_p.copy()
            #psi0 = np.arctan( Vwnd_avg_g[2]/Vwnd_avg_r[1])  # TODO
            # Sections that are about 0.7%R
-           Ir= np.logical_and(r[0]>=0.5*R, r[0] <=0.8*R)
+           Ir= np.logical_and(r_p[0]>=0.5*R_p, r_p[0] <=0.8*R_p)
            if len(Ir)==0:
-               Ir=r[0]>0
+               Ir=r_p[0]>0
            Vind_avg_g = np.mean(np.mean(xd1.Vind_dyn_g[:,Ir,:],axis=0),axis=0)
            Vind_avg_r = (R_r2g.T).dot(Vind_avg_g)
            # Skew angle with induction
            V_r      = Vwnd_avg_r + Vind_avg_r
            V_rn     = V_r[0] # normal to disk
            V_r_norm = sqrt(V_r[0]**2+V_r[1]**2+V_r[2]**2)
            chi = np.arccos(V_rn/V_r_norm)
@@ -675,15 +785,15 @@
            if np.abs(chi)>pi/2:
                print('>>> chi too large')
            yawCorrFactor = 15*np.pi/32 # close to 3/2
            for iB in np.arange(nB):
                R_p2g = R_ntr2g[iB]
                for ie in np.arange(nr):
                    xd1.Vind_p[iB,ie] = xd1.Vind_dyn_p[iB,ie]
-                   xd1.Vind_p[iB,ie,0] = xd1.Vind_dyn_p[iB,ie,0] * (1 + yawCorrFactor*r[iB,ie]/R * np.tan(chi/2)*np.sin(SkewAzimuth[iB])) #* np.cos(psiB0[iB]+psi - psi0))
+                   xd1.Vind_p[iB,ie,0] = xd1.Vind_dyn_p[iB,ie,0] * (1 + yawCorrFactor*r_p[iB,ie]/R_p * np.tan(chi/2)*np.sin(SkewAzimuth[iB])) #* np.cos(psiB0[iB]+psi - psi0))
                    xd1.Vind_g[iB,ie] = R_p2g.dot(xd1.Vind_p[iB,ie]) # global
                    # AeroDyn:
                    #chi = (0.6_ReKi*a + 1.0_ReKi)*chi0
                    #a = a * (1.0 +  yawCorrFactor * yawCorr_tan * (tipRatio) * sin(azimuth))
 
 
         else:
@@ -692,31 +802,33 @@
         # --------------------------------------------------------------------------------
         # --- Step 6: Outputs
         # --------------------------------------------------------------------------------
         it = xd1.it # time step
         # --- Coefficients
         self.Cl[it]   = Cl
         self.Cd[it]   = Cd
+        self.Cm[it]   = Cm
         self.cn[it]   = C_p[:,:,0]
         self.ct[it]   = C_p[:,:,1]
         # C_g also available
         # --- Loads
-        q_dyn = 0.5 * p.rho * Vrel_norm**2 * p.chord # dynamic pressure
+        q_dyn = 0.5 * p.rho * Vrel_norm_a**2 * p.chord # dynamic pressure
         self.L[it]    = q_dyn * Cl
         self.D[it]    = q_dyn * Cd
+        self.Mm[it]   = q_dyn * Cm * p.chord
         self.Fn[it]   = q_dyn * C_p[:,:,0]
         self.Ft[it]   = q_dyn * C_p[:,:,1]
         self.F_a[it,:,:,0] = q_dyn * C_xa
         self.F_a[it,:,:,1] = q_dyn * C_ya
         # --- Velocities
         a_dyn      =-xd1.Vind_p[:,:,0]/Vflw_p[:,:,0] 
         aprime_dyn = xd1.Vind_p[:,:,1]/Vflw_p[:,:,1]
         self.AxInd[it] = a_dyn      
         self.TnInd[it] = aprime_dyn 
-        self.Vrel[it]  = Vrel_norm
+        self.Vrel[it]  = Vrel_norm_a
         # polar system (missing Vind)
         self.Vrel_p[it]  = Vrel_p[:,:,:] # NOTE: Vrel is using previous inductions..
         self.Vstr_p[it]  = Vstr_p[:,:,:]
         self.Vwnd_p[it]  = Vwnd_p[:,:,:]
         self.Vflw_p[it]  = Vflw_p[:,:,:]
         self.Vind_qs_p[it] = xd1.Vind_qs_p[:,:,:]
         self.RtVAvg[it]  = (R_r2g.T).dot(Vflw_avg_g) # in Hub/rotor coordinate
@@ -724,18 +836,19 @@
         self.chi0[it]  = chi0*180/pi
         # airfoil system
         self.Vrel_xa[it] = Vrel_a[:,:,0]
         self.Vrel_ya[it] = Vrel_a[:,:,1]
         self.Vrel_za[it] = Vrel_a[:,:,2]
         # --- Misc
         self.alpha[it] = alpha*180./pi
-        self.phi[it]   = phi_p*180./pi
+        self.phi[it]   = phi*180./pi
         self.Gamma[it]  = 0.5*Re*Cl*p.kinVisc*10**6 # Circulation [m^2/s]
         self.psi[it]  = psi*180/pi
-        self.RtArea[it]  = pi*R**2
+        self.Omega[it]  = Omega*60/(2*np.pi) # [rpm]
+        self.RtArea[it]  = pi*R_p**2
 
         for iB in np.arange(nB):
             R_p2g = R_ntr2g[iB]
             for ie in np.arange(nr):
                 Vind_g = xd1.Vind_g[iB,ie] # dynamic inductions at current time step
                 Vind_s = (R_s2g[iB,ie].T).dot(Vind_g) # Induced velocity in section coordinates
                 #Vind_a = (R_a2g[iB,ie].T).dot(Vind_g) # Induced velocity in airfoil coordinates
@@ -751,19 +864,26 @@
                 Vstr_g = Vstr_gl[iB,ie]
                 #Vstr_a = (R_a2g[iB,ie].T).dot(Vstr_g) # Structural velocity in airfoil coordinates
                 self.Vstr_s[it,iB,ie,:]=(R_s2g[iB,ie].T).dot(Vstr_g)
                 # --- Loads
                 F_g = q_dyn[iB,ie] * C_g[iB,ie]
                 self.F_s[it,iB,ie] = (R_s2g[iB,ie].T).dot(F_g)
 
+        # --- Integral quantities for rotor
+        if self.bUseCm:
+            Mz  = np.trapz(self.Mm[it,0], r_p) # TODO TODO TODO first blade
+            QMz = Mz * np.sin(kappa*np.pi/180) # Contribution for one blade TODO TODO TODO
+        else:
+            QMz = 0
 
-        # Blade integrated loads
-        self.BladeThrust[it,:] = np.trapz(self.Fn[it,:]  , r) # Normal to rotor plane
-        self.BladeTorque[it,:] = np.trapz(self.Ft[it,:]*r, r) # About shaft 
-        self.Thrust[it] = np.sum(self.BladeThrust[it,:])    # Normal to rotor plane
+        # --- Integral quantities for rotor
+        # TODO integration should be with r_b and using forces on airfoil
+        self.BladeThrust[it,:] = np.trapz(self.Fn[it,:]    , r_p)       # Normal to rotor plane
+        self.BladeTorque[it,:] = np.trapz(self.Ft[it,:]*r_p, r_p) +QMz  # About shaft 
+        self.Thrust[it] = np.sum(self.BladeThrust[it,:])            # Normal to rotor plane
         self.Torque[it] = np.sum(self.BladeTorque[it,:])
         self.Power[it]  = Omega*self.Torque[it]
             # TODO TODO
             #self.BladeEdge   = np.zeros((nt,nB))
             #self.BladeFlap   = np.zeros((nt,nB))
                 #         if (WT.Sources.Format=='wtperf'):
                 #             RES.BladeThrust[idB] = sum(np.multiply(Rotor.dr,(Pn * np.cos(np.pi/180*cone))))
@@ -781,15 +901,15 @@
                 #  RES.Edge = sum(RES.BladeEdge)
         return xd1
 
     def simulationConstantRPM(self, time, RPM, windSpeed=None, windExponent=None, windRefH=None, windFunction=None, cone=0, tilt=0, hubHeight=None, firstCallEquilibrium=True):
         """ 
         wrapper function to perform a simple simulation at constant RPM
        
-        IINPUTS:
+        INPUTS:
         Different ways to specify wind:
           - windSpeed: scalar, wind speed (at hub height) along x
           - windExponent power law exponent speed for wind speed (None=uniform wind)
           - windRefH reference height for power law
         OR
           - windFunction: function with interface: f(x,y,z,t)=u,v,w
                        with x,y,z,u arrays of arbitrary shapes
@@ -822,76 +942,179 @@
         self.timeStepInit(time[0],time[-1],dt) 
         for it,t in enumerate(self.time):
             motion.update(t)
             u,v,w = windFunction(motion.pos_gl[:,:,0], motion.pos_gl[:,:,1], motion.pos_gl[:,:,2], t)  
             Vwnd_g = np.moveaxis(np.array([u,v,w]),0,-1) # nB x nr x 3
             xdBEM = self.timeStep(t, dt, xdBEM, motion.psi, motion.psi_B0,
                     motion.origin_pos_gl, motion.omega_gl, motion.R_b2g, 
-                    motion.R_ntr2g, motion.R_bld2b,
+                    motion.R_ntr2g,
+                    motion.R_bld2b, # From blades 2 rotor/shaft
                     motion.pos_gl, motion.vel_gl, motion.R_s2g, motion.R_a2g,
                     Vwnd_g,
-                    firstCallEquilibrium= it==0 and firstCallEquilibrium
+                    firstCallEquilibrium= it==0 and firstCallEquilibrium,
+                    kappa=cone # TODO TODO TODO get rid of me!
                     )
             #if np.mod(t,1)<dt/2:
             #    print(t)
+            # --- Aditional storage
         df = self.toDataFrame()
         return df
 
 # --------------------------------------------------------------------------------}
+# --- Utils common between steady and unsteady BEM
+# --------------------------------------------------------------------------------{
+def rotPolar2Airfoil(tau, kappa, beta):
+    return np.array([
+        [ cos(kappa)*cos(beta),   -cos(tau)*sin(beta)+sin(tau)*sin(kappa)*cos(beta),  -sin(tau)*sin(beta) - cos(tau)*sin(kappa)*cos(beta)],
+        [  cos(kappa)*sin(beta),    cos(tau)*cos(beta)+sin(tau)*sin(kappa)*sin(beta),   sin(tau)*cos(beta) - cos(tau)*sin(kappa)*sin(beta)],
+        [  sin(kappa)          ,   -sin(tau)*cos(kappa)                             ,        cos(tau)*cos(kappa)                        ]]
+        , dtype='object'
+        )
+
+def _fInductionCoefficients(Vrel_norm, V0, F, cnForAI, ctForTI,
+        lambda_r, sigma, phi, relaxation=0.4, a_last=None, bSwirl=True, 
+        drdz=1, algorithm='legacy', 
+        CTcorrection='AeroDyn', swirlMethod='AeroDyn'):
+    """Compute the induction coefficients
+
+        Inputs
+        ----------
+        a_last    : last iteration axial induction factor
+        Vrel_norm : normed relative velocity
+        V0        : free stream velocity
+        F         : total loss
+        cnForAI   : normal force coefficient
+        ctForTI   : tangential force coefficient
+        lambda_r  : speed ratio distribution
+        sigma     : blade solidity
+        phi       : flow angle [deg]
+        relaxation: relaxation factor in axial induction factor
+        bSwirl    : swirl flow model enabled / disabled
+
+        Outputs
+        ----------
+        a: axial induction factor
+        aprime: tangential induction factor
+        Ct: local thrust coefficient
+    """
+    # --- Default a and CT
+    if algorithm=='legacy':
+        a = 1. / ((4.*F*sin(phi)**2)/(sigma*(cnForAI+10**-8))+1) # NOTE singularity avoided
+    elif algorithm=='polarProj':
+        a = 1. / ((4.*F*sin(phi)**2)/(drdz*sigma*(cnForAI+10**-8))+1) # NOTE simgularity avoided
+    else:
+        raise NotImplementedError()
+    # CT=(1-a_last).^2.*sigma.*CnForAI./((sind(phi)).^2)
+    Ct = Vrel_norm**2 * sigma * cnForAI/(V0**2)  # that's a CT loc
+    # AeroDyn
+    #k = sigma*cn/4.0_ReKi/F/sphi/sphi
+    #if (k <= 2/3) then  ! momentum state for a < 0.4
+    # a = k/(1+k)
+
+    # --- Hight thrust correction
+    if CTcorrection=='GlauertCT':
+        # Glauert correction as default
+        #>>> NOTE this is:  a = a_Ct(Ct, a, method='Glauert') from highthrust
+        ac = 0.3 
+        bHigh = a > ac
+        fg = 0.25*(5.-3.*a[bHigh])
+        a[bHigh] = Ct[bHigh]/(4.*F[bHigh]*(1.-fg*a[bHigh]))
+    else:
+        a = a_Ct(Ct, a, F, method=CTcorrection)
+
+    a[F<0.01]=1 # HACK to match aerodyn # TODO make that an option
+
+    # --- Relaxation for high Ct
+    if a_last is not None:
+        bHigh = a>0.3
+        a[bHigh] = a[bHigh]*relaxation + (1.-relaxation)*a_last[bHigh]
+
+    # --- Swirl
+    if bSwirl is True:
+        if swirlMethod=='AeroDynOld':
+            aprime=0.5*(sqrt(1+4*a*F*(1-a)/lambda_r**2)-1);
+
+        elif swirlMethod=='AeroDyn':
+            # NOTE: AeroDyn has more tests (e.g. if cos(phi)=0)
+            aprime=np.zeros(a.shape)
+            b0 = np.logical_or(np.abs(a-1)<1e-5, np.abs(phi)<1e-5)
+            b1 = np.logical_not(b0)
+            aprime[b0] = 0 
+            kp         = sigma[b1]*ctForTI[b1]/(4*F[b1]*sin(phi[b1])*cos(phi[b1]))
+            aprime[b1] = kp/(1-kp)
+        elif swirlMethod=='HAWC2':
+            aprime = (Vrel_norm**2*ctForTI*sigma)/(4.*(1.-a)*V0**2*lambda_r)
+        elif swirlMethod=='Default': # Need a better name
+            aprime=1/((4*F*sin(phi)*cos(phi)) /(sigma*ctForTI)  -1 );
+        else:
+            raise NotImplementedError()
+    else:
+        aprime = a * 0.
+
+    # Bounding values for safety
+    a     [np.isnan(a)]      = 0
+    aprime[np.isnan(aprime)] = 0
+    aprime = np.clip(aprime,-1,1.0) 
+    a      = np.clip(a     ,-1,1.5)
+    Ct     = np.clip(Ct    ,-1,3)
+    return a, aprime, Ct
+
+# --------------------------------------------------------------------------------}
 # --- Helper class to prescribe a motion
 # --------------------------------------------------------------------------------{
 from welib.yams.utils import R_x, R_y, R_z
 class PrescribedRotorMotion():
     """ 
     Class to return:
         position, velocity, and orientation of all blade station
 
      - R_a2g : from airfoil to global (this is well defined, also called "n-t" system in AeroDyn)
-     - R_s2g : from section to blobal (this is ill-defined), this coordinate is used to define the "axial" and "tangential" inductions
+     - R_s2g : from section to global (this is ill-defined), this coordinate is used to define the "axial" and "tangential" inductions
 
     """
     def __init__(self):
-        # body kinematics
+        # body kinematics, Body is "rotor"
         self.R_b2g = np.eye(3) # orientation from body to global
-        self.R_b2g0 = np.eye(3) # orientation from body to global at t=0
-        self.origin_pos_gl0 = np.array([0,0,0]) # body origin at t=0
-        self.origin_pos_gl = np.array([0,0,0]) # body origin
+        self.R_b2g0 = np.eye(3) # orientation from body to global at t=0 (typically: tilt)
+        self.origin_pos_gl0 = np.array([0,0,0]) # body origin at t=0 (position of rotor center)
+        self.origin_pos_gl = np.array([0,0,0]) # body origin   (position of rotor center)
         self.origin_vel_gl = np.array([0,0,0])
         self.omega_gl      = np.array([0,0,0])
 
         # Blades 
-        self.R_bld2b=None # rotation matrix from blade to body
+        self.R_bld2b=None # rotation matrices from blades to body (i.e. rotor), contains azimuth and cone
 
     def init_from_inputs(self,  nB, r, twist, rotorOrigin, tilt, cone, psi0=0):
+        # TODO TODO Pitch!
         self.nB   =  nB
         self.cone = cone*np.pi/180
         self.tilt = -tilt*np.pi/180 
-        self.r     = r
+        self.r     = r               # spanwise position, from hub center (typically r= HubRad->TipRad)
         self.twist = twist
         self.allocate()
         self.origin_pos_gl0 = rotorOrigin
 
         # Basic geometries for nacelle
         self.R_b2g0 = R_y(self.tilt)  # Rotation fromShaft to Nacelle
 
         # Orientation of blades with respect to body
         self.R_bld2b = [np.eye(3)]*self.nB
         self.R_ntr2b = [np.eye(3)]*self.nB
         self.psi_B0  = np.zeros(self.nB)
         for iB in np.arange(self.nB):
             self.psi_B0[iB]= psi0 + iB*2*np.pi/self.nB
             R_SB = R_x(self.psi_B0[iB]) 
-            self.R_bld2b[iB] = R_SB.dot(R_y(self.cone)) # blade2shaft
+            self.R_bld2b[iB] = R_SB.dot(R_y(self.cone)) # blade2shaft / blade2rotor
             self.R_ntr2b[iB] = R_SB.dot(np.array([[1,0,0],[0,-1,0],[0,0,1]])) # "n-t-r" to shaft
 
         # Set initial positions and orientations in body coordinates
         nr=len(self.r)
         meanLine=np.zeros((nr,3))
-        meanLine[:,0]=0 # TODO
-        meanLine[:,1]=0 # TODO
+        meanLine[:,0]=0 # TODO prebend
+        meanLine[:,1]=0 # TODO presweep
         meanLine[:,2]=self.r
         for iB in np.arange(self.nB):
             for ir in np.arange(nr):
                 self.pos0[iB,ir,:] = self.R_bld2b[iB].dot(meanLine[ir,:])
                 R_a2bld = R_z(-self.twist[ir]) # section to blade
                 self.R_a02b[iB,ir,:,:] = self.R_bld2b[iB].dot(R_a2bld)   # TODO curvature
                 self.R_s02b[iB,ir,:,:] = self.R_bld2b[iB]                # TODO curvature
@@ -1034,17 +1257,15 @@
 if __name__=="__main__":
     """ See examples/ for more examples """
     import matplotlib.pyplot as plt
     from mpl_toolkits.mplot3d import Axes3D
     from matplotlib.animation import FuncAnimation
 
     # --- Read a FAST model to get Aerodynamic parameters
-    BEM = AeroBEM()
-    #BEM.init_from_FAST('../../data/NREL5MW/Main_Onshore.fst')
-    BEM.init_from_FAST('./Main_Onshore.fst')
+    BEM = UnsteadyBEM('./Main_Onshore.fst')
     BEM.CTcorrection='AeroDyn' # High Thrust correction
     BEM.swirlMethod ='AeroDyn' # type of swirl model
 #    BEM.swirlMethod ='HAWC2' # type of swirl model
 #     BEM.bSwirl = True  # swirl flow model enabled / disabled
     BEM.WakeMod=1 # 0: no inductions, 1: BEM inductions
 #     BEM.bTipLoss = True # enable / disable tip loss model
 #     BEM.bHubLoss = False # enable / disable hub loss model
```

### Comparing `welib-0.0.2/welib/CFD/_vorticity-rz - Copy.py` & `welib-1.0.0/welib/CFD/_vorticity-rz - Copy.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/CFD/_vorticity-rz.py` & `welib-1.0.0/welib/CFD/_vorticity-rz.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/CFD/_vorticity-rz_lesswalls.py` & `welib-1.0.0/welib/CFD/_vorticity-rz_lesswalls.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/CFD/axisym_streamf.py` & `welib-1.0.0/welib/CFD/axisym_streamf.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/CFD/tests/test_axisym_streamf.py` & `welib-1.0.0/welib/CFD/tests/test_axisym_streamf.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/beam2d.py` & `welib-1.0.0/welib/FEM/beam2d.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,257 +1,257 @@
-00000000: 0d0a 6465 6620 6265 616d 3264 5f4b 654d  ..def beam2d_KeM
-00000010: 6528 4549 2c4c 2c4d 6173 732c 543d 302c  e(EI,L,Mass,T=0,
-00000020: 2074 6865 7461 3d4e 6f6e 652c 204d 4d46   theta=None, MMF
-00000030: 6f72 6d75 6c61 7469 6f6e 3d27 636f 6e73  ormulation='cons
-00000040: 6973 7465 6e74 2720 293a 0d0a 2020 2020  istent' ):..    
-00000050: 2222 2220 0d0a 2020 2020 5374 6966 666e  """ ..    Stiffn
-00000060: 6573 7320 616e 6420 6d61 7373 206d 6174  ess and mass mat
-00000070: 7269 6365 7320 666f 7220 4865 726d 6974  rices for Hermit
-00000080: 6961 6e20 6265 616d 2065 6c65 6d65 6e74  ian beam element
-00000090: 2077 6974 6820 3244 4f46 2070 6572 206e   with 2DOF per n
-000000a0: 6f64 652e 0d0a 2020 2020 2020 2d20 4265  ode...      - Be
-000000b0: 6e64 696e 6720 696e 206f 6e65 2074 7261  nding in one tra
-000000c0: 6e73 7665 7273 6520 6469 7265 6374 696f  nsverse directio
-000000d0: 6e0d 0a20 2020 2045 756c 6572 2d42 6572  n..    Euler-Ber
-000000e0: 6e6f 756c 6c69 2062 6561 6d20 6d6f 6465  noulli beam mode
-000000f0: 6c2e 200d 0a20 2020 2020 2020 200d 0a20  l. ..        .. 
-00000100: 2020 2054 6865 2062 6561 6d20 636f 6f72     The beam coor
-00000110: 6469 6e61 7465 2073 7973 7465 6d20 6973  dinate system is
-00000120: 2073 7563 6820 7468 6174 2074 6865 2063   such that the c
-00000130: 726f 7373 2073 6563 7469 6f6e 2069 7320  ross section is 
-00000140: 6173 7375 6d65 6420 746f 2062 6520 696e  assumed to be in
-00000150: 2074 6865 2079 2d7a 2070 6c61 6e65 0d0a   the y-z plane..
-00000160: 2020 2020 2861 6c6f 6e67 2078 290d 0a20      (along x).. 
-00000170: 2020 2020 2020 200d 0a20 2020 204e 6f64         ..    Nod
-00000180: 616c 2044 4f46 3a20 2020 2028 7520 7468  al DOF:    (u th
-00000190: 6574 6129 0d0a 2020 2020 456c 656d 656e  eta)..    Elemen
-000001a0: 7420 444f 4673 3a20 2875 3120 7431 2075  t DOFs: (u1 t1 u
-000001b0: 3220 7432 2920 0d0a 2020 2020 2020 2020  2 t2) ..        
-000001c0: 0d0a 2020 2020 494e 5055 5453 0d0a 2020  ..    INPUTS..  
-000001d0: 2020 2020 2020 4549 2020 3a20 596f 756e        EI  : Youn
-000001e0: 6720 4d6f 6475 6c75 7320 7469 6d65 7320  g Modulus times 
-000001f0: 506c 616e 6172 2073 6563 6f6e 6420 6d6f  Planar second mo
-00000200: 6d65 6e74 206f 6620 6172 6561 2c6c 6f63  ment of area,loc
-00000210: 616c 2079 2d61 7869 732e 2049 793d 5c69  al y-axis. Iy=\i
-00000220: 696e 7420 7a5e 3220 6479 2064 7a20 5b6d  int z^2 dy dz [m
-00000230: 345d 0d0a 2020 2020 2020 2020 4c20 2020  4]..        L   
-00000240: 3a20 2020 2045 6c65 6d65 6e74 206c 656e  :    Element len
-00000250: 6774 680d 0a20 2020 2020 2020 204d 6173  gth..        Mas
-00000260: 7320 3a20 2020 2045 6c65 6d65 6e74 206d  s :    Element m
-00000270: 6173 7320 3d20 7268 6f20 2a20 4120 2a20  ass = rho * A * 
-00000280: 4c20 5b6b 675d 0d0a 0d0a 2020 2020 4f50  L [kg]....    OP
-00000290: 5449 4f4e 414c 2049 4e50 5554 530d 0a20  TIONAL INPUTS.. 
-000002a0: 2020 2020 2020 2074 6865 7461 3a20 6f72         theta: or
-000002b0: 6965 6e74 6174 696f 6e20 616e 676c 6520  ientation angle 
-000002c0: 6f66 2065 6c65 6d65 6e74 2069 6e20 676c  of element in gl
-000002d0: 6f62 616c 2063 6f6f 7264 696e 6174 6520  obal coordinate 
-000002e0: 7379 7374 656d 0d0a 2020 2020 2020 2020  system..        
-000002f0: 2020 2020 2020 2069 6620 7072 6f76 6964         if provid
-00000300: 6564 2c20 656c 656d 656e 7420 6d61 7472  ed, element matr
-00000310: 6978 2069 7320 7072 6f76 6964 6564 2069  ix is provided i
-00000320: 6e20 676c 6f62 616c 2063 6f6f 7264 0d0a  n global coord..
-00000330: 2020 2020 2020 2020 5420 2020 3a20 4178          T   : Ax
-00000340: 6961 6c20 6c6f 6164 2074 6f20 6265 2075  ial load to be u
-00000350: 7365 6420 666f 7220 7468 6520 636f 6d70  sed for the comp
-00000360: 7561 7469 6f6e 206f 6620 7468 6520 6765  uation of the ge
-00000370: 6f6d 6574 7269 6361 6c20 7374 6966 666e  ometrical stiffn
-00000380: 6573 730d 0a0d 0a20 2020 204f 5554 5055  ess....    OUTPU
-00000390: 5453 0d0a 2020 2020 2020 2020 4b65 3a20  TS..        Ke: 
-000003a0: 456c 656d 656e 7420 7374 6966 666e 6573  Element stiffnes
-000003b0: 7320 6d61 7472 6978 2028 3478 3429 0d0a  s matrix (4x4)..
-000003c0: 2020 2020 2020 2020 4d65 3a20 456c 656d          Me: Elem
-000003d0: 656e 7420 6d61 7373 206d 6174 7269 7820  ent mass matrix 
-000003e0: 2020 2020 2028 3478 3429 0d0a 2020 2020       (4x4)..    
-000003f0: 2020 2020 4b67 3a20 456c 656d 656e 7420      Kg: Element 
-00000400: 6765 6f6d 6574 7269 6361 6c20 7374 6966  geometrical stif
-00000410: 666e 6573 7320 6d61 7472 6978 2028 342c  fness matrix (4,
-00000420: 3429 0d0a 2020 2020 2020 2020 0d0a 2020  4)..        ..  
-00000430: 2020 4155 5448 4f52 3a20 452e 2042 7261    AUTHOR: E. Bra
-00000440: 6e6c 6172 640d 0a20 2020 2022 2222 0d0a  nlard..    """..
-00000450: 2020 2020 2320 4e4f 5445 3a20 6d61 7472      # NOTE: matr
-00000460: 6963 6573 2064 6574 6572 6d69 6e65 6420  ices determined 
-00000470: 7573 696e 6720 7379 6d70 792c 2073 6565  using sympy, see
-00000480: 2073 6372 6970 7473 2069 6e20 6375 7272   scripts in curr
-00000490: 656e 7420 666f 6c64 6572 200d 0a0d 0a20  ent folder .... 
-000004a0: 2020 2023 202d 2d2d 2053 7469 6666 6e65     # --- Stiffne
-000004b0: 7373 206d 6174 7269 6365 730d 0a20 2020  ss matrices..   
-000004c0: 2023 206b 653d 4549 2f28 4c5e 3329 2a5b   # ke=EI/(L^3)*[
-000004d0: 3132 2020 2020 2020 362a 4c20 2020 2d31  12      6*L   -1
-000004e0: 3220 2020 2020 2036 2a4c 203b 202e 2e2e  2      6*L ; ...
-000004f0: 0d0a 2020 2020 2320 2020 2020 2020 2020  ..    #         
-00000500: 2020 2020 2036 2a4c 2020 2034 2a4c 5e32       6*L   4*L^2
-00000510: 2020 202d 362a 4c20 2020 322a 4c5e 3220     -6*L   2*L^2 
-00000520: 3b20 2e2e 2e0d 0a20 2020 2023 2020 2020  ; .....    #    
-00000530: 2020 2020 2020 2020 202d 3132 2020 2020           -12    
-00000540: 202d 362a 4c20 2020 2031 3220 2020 2020   -6*L    12     
-00000550: 2d36 2a4c 203b 202e 2e2e 0d0a 2020 2020  -6*L ; .....    
-00000560: 2320 2020 2020 2020 2020 2020 2020 2036  #              6
-00000570: 2a4c 2020 2032 2a4c 5e32 2020 202d 362a  *L   2*L^2   -6*
-00000580: 4c20 2020 342a 4c5e 325d 3b0d 0a20 2020  L   4*L^2];..   
-00000590: 204b 6520 3d20 6e70 2e61 7272 6179 2820   Ke = np.array( 
-000005a0: 5b0d 0a20 2020 2020 2020 2020 2020 205b  [..            [
-000005b0: 2031 322a 4549 2f4c 2a2a 3320 202c 2036   12*EI/L**3  , 6
-000005c0: 2a45 492f 4c2a 2a32 2020 202c 202d 3132  *EI/L**2   , -12
-000005d0: 2a45 492f 4c2a 2a33 202c 2036 2a45 492f  *EI/L**3 , 6*EI/
-000005e0: 4c2a 2a32 5d20 202c 200d 0a20 2020 2020  L**2]  , ..     
-000005f0: 2020 2020 2020 205b 2036 2a45 492f 4c2a         [ 6*EI/L*
-00000600: 2a32 2020 202c 2034 2a45 492f 4c20 2020  *2   , 4*EI/L   
-00000610: 2020 202c 202d 362a 4549 2f4c 2a2a 3220     , -6*EI/L**2 
-00000620: 202c 2032 2a45 492f 4c5d 2020 2020 202c   , 2*EI/L]     ,
-00000630: 200d 0a20 2020 2020 2020 2020 2020 205b   ..            [
-00000640: 202d 3132 2a45 492f 4c2a 2a33 202c 202d   -12*EI/L**3 , -
-00000650: 362a 4549 2f4c 2a2a 3220 202c 2031 322a  6*EI/L**2  , 12*
-00000660: 4549 2f4c 2a2a 3320 202c 202d 362a 4549  EI/L**3  , -6*EI
-00000670: 2f4c 2a2a 325d 202c 200d 0a20 2020 2020  /L**2] , ..     
-00000680: 2020 2020 2020 205b 2036 2a45 492f 4c2a         [ 6*EI/L*
-00000690: 2a32 2020 202c 2032 2a45 492f 4c20 2020  *2   , 2*EI/L   
-000006a0: 2020 202c 202d 362a 4549 2f4c 2a2a 3220     , -6*EI/L**2 
-000006b0: 202c 2034 2a45 492f 4c5d 0d0a 2020 2020   , 4*EI/L]..    
-000006c0: 2020 2020 2020 2020 5d29 0d0a 2020 2020          ])..    
-000006d0: 4b67 203d 206e 702e 6172 7261 7928 5b0d  Kg = np.array([.
-000006e0: 0a20 2020 2020 2020 2020 2020 205b 2036  .            [ 6
-000006f0: 2a54 2f28 352a 4c29 2020 2c20 542f 3130  *T/(5*L)  , T/10
-00000700: 2020 2020 202c 202d 362a 542f 2835 2a4c       , -6*T/(5*L
-00000710: 2920 2c20 542f 3130 5d20 2020 2020 2c20  ) , T/10]     , 
-00000720: 0d0a 2020 2020 2020 2020 2020 2020 5b20  ..            [ 
-00000730: 542f 3130 2020 2020 2020 202c 2032 2a4c  T/10       , 2*L
-00000740: 2a54 2f31 3520 2c20 2d54 2f31 3020 2020  *T/15 , -T/10   
-00000750: 2020 202c 202d 4c2a 542f 3330 5d20 202c     , -L*T/30]  ,
-00000760: 200d 0a20 2020 2020 2020 2020 2020 205b   ..            [
-00000770: 202d 362a 542f 2835 2a4c 2920 2c20 2d54   -6*T/(5*L) , -T
-00000780: 2f31 3020 2020 202c 2036 2a54 2f28 352a  /10    , 6*T/(5*
-00000790: 4c29 2020 2c20 2d54 2f31 305d 2020 2020  L)  , -T/10]    
-000007a0: 2c20 0d0a 2020 2020 2020 2020 2020 2020  , ..            
-000007b0: 5b20 542f 3130 2020 2020 2020 202c 202d  [ T/10       , -
-000007c0: 4c2a 542f 3330 2020 2c20 2d54 2f31 3020  L*T/30  , -T/10 
-000007d0: 2020 2020 202c 2032 2a4c 2a54 2f31 355d       , 2*L*T/15]
-000007e0: 0d0a 2020 2020 2020 2020 5d29 0d0a 0d0a  ..        ])....
-000007f0: 2020 2020 2320 4d61 7373 206d 6174 7269      # Mass matri
-00000800: 780d 0a20 2020 2069 6620 4d4d 466f 726d  x..    if MMForm
-00000810: 756c 6174 696f 6e3d 3d27 636f 6e73 6973  ulation=='consis
-00000820: 7465 6e74 273a 0d0a 2020 2020 2020 2020  tent':..        
-00000830: 2320 436f 6e73 6973 7465 6e74 2046 6f72  # Consistent For
-00000840: 6d75 6c61 7469 6f6e 0d0a 2020 2020 2020  mulation..      
-00000850: 2020 2320 6d65 3d4d 6173 732f 3432 302a    # me=Mass/420*
-00000860: 5b31 3536 2020 2020 3232 2a4c 2020 2035  [156    22*L   5
-00000870: 3420 2020 202d 3133 2a4c 2020 3b20 2e2e  4    -13*L  ; ..
-00000880: 2e0d 0a20 2020 2020 2020 2023 2020 2020  ...        #    
-00000890: 2020 2020 2020 2020 2020 3232 2a4c 2020            22*L  
-000008a0: 342a 4c5e 3220 2031 332a 4c20 202d 332a  4*L^2  13*L  -3*
-000008b0: 4c5e 3220 203b 202e 2e2e 0d0a 2020 2020  L^2  ; .....    
-000008c0: 2020 2020 2320 2020 2020 2020 2020 2020      #           
-000008d0: 2020 2035 3420 2020 2031 332a 4c20 2020     54    13*L   
-000008e0: 3135 3620 2020 2020 202d 3232 2a4c 3b20  156      -22*L; 
-000008f0: 2e2e 2e0d 0a20 2020 2020 2020 2023 2020  .....        #  
-00000900: 2020 2020 2020 2020 2020 202d 3133 2a4c             -13*L
-00000910: 202d 332a 4c5e 3220 2d32 322a 4c20 2020   -3*L^2 -22*L   
-00000920: 342a 4c5e 325d 203b 200d 0a20 2020 2020  4*L^2] ; ..     
-00000930: 2020 206d 6520 3d20 4d61 7373 202f 2034     me = Mass / 4
-00000940: 3230 202a 206e 702e 6172 7261 7928 5b0d  20 * np.array([.
-00000950: 0a20 2020 2020 2020 2020 2020 205b 3135  .            [15
-00000960: 3620 2020 2020 202c 2032 3220 2a20 4c20  6      , 22 * L 
-00000970: 2020 2020 2020 2c20 3534 2020 2020 2020        , 54      
-00000980: 202c 202d 2031 3320 2a20 4c5d 2020 2020   , - 13 * L]    
-00000990: 202c 200d 0a20 2020 2020 2020 2020 2020   , ..           
-000009a0: 205b 3232 202a 204c 2020 202c 2034 202a   [22 * L   , 4 *
-000009b0: 204c 202a 2a20 3220 2020 2c20 3133 202a   L ** 2   , 13 *
-000009c0: 204c 2020 202c 202d 2033 202a 204c 202a   L   , - 3 * L *
-000009d0: 2a20 325d 202c 200d 0a20 2020 2020 2020  * 2] , ..       
-000009e0: 2020 2020 205b 3534 2020 2020 2020 202c       [54       ,
-000009f0: 2031 3320 2a20 4c20 2020 2020 2020 2c20   13 * L       , 
-00000a00: 3135 3620 2020 2020 202c 202d 2032 3220  156      , - 22 
-00000a10: 2a20 4c5d 2020 2020 202c 200d 0a20 2020  * L]     , ..   
-00000a20: 2020 2020 2020 2020 205b 2d20 3133 202a           [- 13 *
-00000a30: 204c 202c 202d 2033 202a 204c 202a 2a20   L , - 3 * L ** 
-00000a40: 3220 2c20 2d20 3232 202a 204c 202c 2034  2 , - 22 * L , 4
-00000a50: 202a 204c 202a 2a20 325d 0d0a 2020 2020   * L ** 2]..    
-00000a60: 2020 2020 2020 2020 5d29 0d0a 2020 2020          ])..    
-00000a70: 656c 6966 204d 4d46 6f72 6d75 6c61 7469  elif MMFormulati
-00000a80: 6f6e 3d3d 276c 756d 7065 6427 3a0d 0a20  on=='lumped':.. 
-00000a90: 2020 2020 2020 2023 204c 756d 7065 6420         # Lumped 
-00000aa0: 666f 726d 756c 6174 696f 6e0d 0a20 2020  formulation..   
-00000ab0: 2020 2020 206d 6520 3d20 6e70 2e64 6961       me = np.dia
-00000ac0: 6728 5b4d 6173 732f 322c 2030 2c20 4d61  g([Mass/2, 0, Ma
-00000ad0: 7373 2f32 2c20 305d 2929 0d0a 2020 2020  ss/2, 0]))..    
-00000ae0: 2020 2020 2320 2054 4f44 4f3f 0d0a 2020      #  TODO?..  
-00000af0: 2020 2020 2020 2320 2020 2020 616c 7068        #     alph
-00000b00: 6120 3d20 3137 2e35 3b0d 0a20 2020 2020  a = 17.5;..     
-00000b10: 2020 2023 2020 206d 6520 3d20 7268 6f2a     #   me = rho*
-00000b20: 412a 4c20 2f20 3220 2a20 2e2e 2e20 2023  A*L / 2 * ...  #
-00000b30: 206c 756d 7065 640d 0a20 2020 2020 2020   lumped..       
-00000b40: 2023 2020 205b 2031 2020 2030 2020 2020   #   [ 1   0    
-00000b50: 2020 2020 2020 2020 2020 3020 2030 0d0a            0  0..
-00000b60: 2020 2020 2020 2020 2320 2020 2020 3020          #     0 
-00000b70: 2020 616c 7068 612a 4c5e 322f 3231 3020    alpha*L^2/210 
-00000b80: 2030 2020 300d 0a20 2020 2020 2020 2023   0  0..        #
-00000b90: 2020 2020 2030 2020 2030 2020 2020 2020       0   0      
-00000ba0: 2020 2020 2020 2020 3120 2030 0d0a 2020          1  0..  
-00000bb0: 2020 2020 2020 2320 2020 2020 3020 2020        #     0   
-00000bc0: 3020 2020 2020 2020 2020 2020 2020 2030  0              0
-00000bd0: 2020 616c 7068 612a 4c5e 322f 3231 3020    alpha*L^2/210 
-00000be0: 5d3b 0d0a 2020 2020 656c 6966 204d 4d46  ];..    elif MMF
-00000bf0: 6f72 6d75 6c61 7469 6f6e 3d3d 2764 6961  ormulation=='dia
-00000c00: 676f 6e61 6c27 3a0d 0a20 2020 2020 2020  gonal':..       
-00000c10: 2023 2044 6961 676f 6e61 6c20 666f 726d   # Diagonal form
-00000c20: 756c 6174 696f 6e0d 0a20 2020 2020 2020  ulation..       
-00000c30: 206d 6520 3d20 4d61 7373 202a 206e 702e   me = Mass * np.
-00000c40: 6469 6167 285b 312f 322c 204c 2a2a 322f  diag([1/2, L**2/
-00000c50: 3738 2c20 312f 322c 204c 2a2a 322f 3738  78, 1/2, L**2/78
-00000c60: 5d29 0d0a 2020 2020 656c 7365 3a0d 0a20  ])..    else:.. 
-00000c70: 2020 2020 2020 2072 6169 7365 2045 7863         raise Exc
-00000c80: 6570 7469 6f6e 2827 556e 6b6e 6f77 6e20  eption('Unknown 
-00000c90: 206d 6173 7320 6d61 7472 6978 2066 6f72   mass matrix for
-00000ca0: 6d75 6c61 7469 6f6e 207b 7d27 2e66 6f72  mulation {}'.for
-00000cb0: 6d61 7428 4d4d 466f 726d 756c 6174 696f  mat(MMFormulatio
-00000cc0: 6e29 290d 0a0d 0a0d 0a20 2020 2023 202d  n))......    # -
-00000cd0: 2d2d 2043 6f6e 7665 7273 696f 6e20 746f  -- Conversion to
-00000ce0: 2067 6c6f 6261 6c20 7379 7374 656d 2069   global system i
-00000cf0: 6620 7265 7175 6573 7465 640d 0a20 2020  f requested..   
-00000d00: 2069 6620 7468 6574 6120 6973 206e 6f74   if theta is not
-00000d10: 204e 6f6e 653a 0d0a 2020 2020 2020 2020   None:..        
-00000d20: 2320 544f 444f 0d0a 2020 2020 2020 2020  # TODO..        
-00000d30: 2352 203d 206e 702e 6172 7261 7928 5b0d  #R = np.array([.
-00000d40: 0a20 2020 2020 2020 2023 2020 2020 5b6e  .        #    [n
-00000d50: 702e 636f 7328 7468 6574 6129 2020 202c  p.cos(theta)   ,
-00000d60: 206e 702e 7369 6e28 7468 6574 6129 202c   np.sin(theta) ,
-00000d70: 2030 202c 2030 2020 2020 2020 2020 2020   0 , 0          
-00000d80: 2020 2020 202c 2030 2020 2020 2020 2020       , 0        
-00000d90: 2020 2020 202c 2030 5d20 2020 2c20 0d0a       , 0]   , ..
-00000da0: 2020 2020 2020 2020 2320 2020 205b 2d20          #    [- 
-00000db0: 6e70 2e73 696e 2874 6865 7461 2920 2c20  np.sin(theta) , 
-00000dc0: 6e70 2e63 6f73 2874 6865 7461 2920 2c20  np.cos(theta) , 
-00000dd0: 3020 2c20 3020 2020 2020 2020 2020 2020  0 , 0           
-00000de0: 2020 2020 2c20 3020 2020 2020 2020 2020      , 0         
-00000df0: 2020 2020 2c20 305d 2020 202c 200d 0a20      , 0]   , .. 
-00000e00: 2020 2020 2020 2023 2020 2020 5b30 2020         #    [0  
-00000e10: 2020 2020 2020 2020 2020 2020 202c 2030               , 0
-00000e20: 2020 2020 2020 2020 2020 2020 202c 2031               , 1
-00000e30: 202c 2030 2020 2020 2020 2020 2020 2020   , 0            
-00000e40: 2020 202c 2030 2020 2020 2020 2020 2020     , 0          
-00000e50: 2020 202c 2030 5d20 2020 2c20 0d0a 2020     , 0]   , ..  
-00000e60: 2020 2020 2020 2320 2020 205b 3020 2020        #    [0   
-00000e70: 2020 2020 2020 2020 2020 2020 2c20 3020              , 0 
-00000e80: 2020 2020 2020 2020 2020 2020 2c20 3020              , 0 
-00000e90: 2c20 6e70 2e63 6f73 2874 6865 7461 2920  , np.cos(theta) 
-00000ea0: 2020 2c20 6e70 2e73 696e 2874 6865 7461    , np.sin(theta
-00000eb0: 2920 2c20 305d 2020 202c 200d 0a20 2020  ) , 0]   , ..   
-00000ec0: 2020 2020 2023 2020 2020 5b30 2020 2020       #    [0    
-00000ed0: 2020 2020 2020 2020 2020 202c 2030 2020             , 0  
-00000ee0: 2020 2020 2020 2020 2020 202c 2030 202c             , 0 ,
-00000ef0: 202d 206e 702e 7369 6e28 7468 6574 6129   - np.sin(theta)
-00000f00: 202c 206e 702e 636f 7328 7468 6574 6129   , np.cos(theta)
-00000f10: 202c 2030 5d20 2020 2c20 0d0a 2020 2020   , 0]   , ..    
-00000f20: 2020 2020 2320 2020 205b 3020 2020 2020      #    [0     
-00000f30: 2020 2020 2020 2020 2020 2c20 3020 2020            , 0   
-00000f40: 2020 2020 2020 2020 2020 2c20 3020 2c20            , 0 , 
-00000f50: 3020 2020 2020 2020 2020 2020 2020 2020  0               
-00000f60: 2c20 3020 2020 2020 2020 2020 2020 2020  , 0             
-00000f70: 2c20 315d 5d29 0d0a 2020 2020 2020 2020  , 1]])..        
-00000f80: 234d 6520 3d20 6e70 2e74 7261 6e73 706f  #Me = np.transpo
-00000f90: 7365 2852 2920 2a20 4d65 202a 2052 0d0a  se(R) * Me * R..
-00000fa0: 2020 2020 2020 2020 234b 6520 3d20 6e70          #Ke = np
-00000fb0: 2e74 7261 6e73 706f 7365 2852 2920 2a20  .transpose(R) * 
-00000fc0: 4b65 202a 2052 0d0a 2020 2020 2020 2020  Ke * R..        
-00000fd0: 234b 6720 3d20 6e70 2e74 7261 6e73 706f  #Kg = np.transpo
-00000fe0: 7365 2852 2920 2a20 4b67 202a 2052 0d0a  se(R) * Kg * R..
-00000ff0: 0d0a 2020 2020 7265 7475 726e 204b 652c  ..    return Ke,
-00001000: 204d 652c 204b 670d 0a                    Me, Kg..
+00000000: 2222 2220 0d0a 4865 726d 6974 6961 6e20  """ ..Hermitian 
+00000010: 4265 616d 3244 2065 6c65 6d65 6e74 0d0a  Beam2D element..
+00000020: 2d20 4265 6e64 696e 6720 696e 206f 6e65  - Bending in one
+00000030: 2074 7261 6e73 7665 7273 6520 6469 7265   transverse dire
+00000040: 6374 696f 6e0d 0a45 756c 6572 2d42 6572  ction..Euler-Ber
+00000050: 6e6f 756c 6c69 2062 6561 6d20 6d6f 6465  noulli beam mode
+00000060: 6c2e 200d 0a0d 0a54 6865 2062 6561 6d20  l. ....The beam 
+00000070: 636f 6f72 6469 6e61 7465 2073 7973 7465  coordinate syste
+00000080: 6d20 6973 2073 7563 6820 7468 6174 2074  m is such that t
+00000090: 6865 2063 726f 7373 2073 6563 7469 6f6e  he cross section
+000000a0: 2069 7320 6173 7375 6d65 6420 746f 2062   is assumed to b
+000000b0: 6520 696e 2074 6865 2079 2d7a 2070 6c61  e in the y-z pla
+000000c0: 6e65 0d0a 2861 6c6f 6e67 2078 290d 0a0d  ne..(along x)...
+000000d0: 0a4e 6f64 616c 2044 4f46 3a20 2020 2028  .Nodal DOF:    (
+000000e0: 7520 7468 6574 6129 0d0a 456c 656d 656e  u theta)..Elemen
+000000f0: 7420 444f 4673 3a20 2875 3120 7431 2075  t DOFs: (u1 t1 u
+00000100: 3220 7432 2920 0d0a 0d0a 2222 220d 0a64  2 t2) ...."""..d
+00000110: 6566 2062 6561 6d32 645f 4b65 4d65 2845  ef beam2d_KeMe(E
+00000120: 492c 4c2c 4d61 7373 2c54 3d30 2c20 7468  I,L,Mass,T=0, th
+00000130: 6574 613d 4e6f 6e65 2c20 4d4d 466f 726d  eta=None, MMForm
+00000140: 756c 6174 696f 6e3d 2763 6f6e 7369 7374  ulation='consist
+00000150: 656e 7427 2029 3a0d 0a20 2020 2022 2222  ent' ):..    """
+00000160: 200d 0a20 2020 2053 7469 6666 6e65 7373   ..    Stiffness
+00000170: 2061 6e64 206d 6173 7320 6d61 7472 6963   and mass matric
+00000180: 6573 2066 6f72 2048 6572 6d69 7469 616e  es for Hermitian
+00000190: 2062 6561 6d20 656c 656d 656e 7420 7769   beam element wi
+000001a0: 7468 2032 444f 4620 7065 7220 6e6f 6465  th 2DOF per node
+000001b0: 2e0d 0a20 2020 2020 2020 200d 0a20 2020  ...        ..   
+000001c0: 2049 4e50 5554 530d 0a20 2020 2020 2020   INPUTS..       
+000001d0: 2045 4920 2020 3a20 596f 756e 6720 4d6f   EI   : Young Mo
+000001e0: 6475 6c75 7320 7469 6d65 7320 506c 616e  dulus times Plan
+000001f0: 6172 2073 6563 6f6e 6420 6d6f 6d65 6e74  ar second moment
+00000200: 206f 6620 6172 6561 2c6c 6f63 616c 2079   of area,local y
+00000210: 2d61 7869 732e 2049 793d 5c69 696e 7420  -axis. Iy=\iint 
+00000220: 7a5e 3220 6479 2064 7a20 5b6d 345d 0d0a  z^2 dy dz [m4]..
+00000230: 2020 2020 2020 2020 4c20 2020 203a 2020          L    :  
+00000240: 2020 456c 656d 656e 7420 6c65 6e67 7468    Element length
+00000250: 0d0a 2020 2020 2020 2020 4d61 7373 203a  ..        Mass :
+00000260: 2020 2020 456c 656d 656e 7420 6d61 7373      Element mass
+00000270: 203d 2072 686f 202a 2041 202a 204c 205b   = rho * A * L [
+00000280: 6b67 5d0d 0a0d 0a20 2020 204f 5054 494f  kg]....    OPTIO
+00000290: 4e41 4c20 494e 5055 5453 0d0a 2020 2020  NAL INPUTS..    
+000002a0: 2020 2020 7468 6574 613a 206f 7269 656e      theta: orien
+000002b0: 7461 7469 6f6e 2061 6e67 6c65 206f 6620  tation angle of 
+000002c0: 656c 656d 656e 7420 696e 2067 6c6f 6261  element in globa
+000002d0: 6c20 636f 6f72 6469 6e61 7465 2073 7973  l coordinate sys
+000002e0: 7465 6d0d 0a20 2020 2020 2020 2020 2020  tem..           
+000002f0: 2020 2020 6966 2070 726f 7669 6465 642c      if provided,
+00000300: 2065 6c65 6d65 6e74 206d 6174 7269 7820   element matrix 
+00000310: 6973 2070 726f 7669 6465 6420 696e 2067  is provided in g
+00000320: 6c6f 6261 6c20 636f 6f72 640d 0a20 2020  lobal coord..   
+00000330: 2020 2020 2054 2020 203a 2041 7869 616c       T   : Axial
+00000340: 206c 6f61 6420 746f 2062 6520 7573 6564   load to be used
+00000350: 2066 6f72 2074 6865 2063 6f6d 7075 6174   for the compuat
+00000360: 696f 6e20 6f66 2074 6865 2067 656f 6d65  ion of the geome
+00000370: 7472 6963 616c 2073 7469 6666 6e65 7373  trical stiffness
+00000380: 0d0a 0d0a 2020 2020 4f55 5450 5554 530d  ....    OUTPUTS.
+00000390: 0a20 2020 2020 2020 204b 653a 2045 6c65  .        Ke: Ele
+000003a0: 6d65 6e74 2073 7469 6666 6e65 7373 206d  ment stiffness m
+000003b0: 6174 7269 7820 2834 7834 290d 0a20 2020  atrix (4x4)..   
+000003c0: 2020 2020 204d 653a 2045 6c65 6d65 6e74       Me: Element
+000003d0: 206d 6173 7320 6d61 7472 6978 2020 2020   mass matrix    
+000003e0: 2020 2834 7834 290d 0a20 2020 2020 2020    (4x4)..       
+000003f0: 204b 673a 2045 6c65 6d65 6e74 2067 656f   Kg: Element geo
+00000400: 6d65 7472 6963 616c 2073 7469 6666 6e65  metrical stiffne
+00000410: 7373 206d 6174 7269 7820 2834 2c34 290d  ss matrix (4,4).
+00000420: 0a20 2020 2020 2020 200d 0a20 2020 2041  .        ..    A
+00000430: 5554 484f 523a 2045 2e20 4272 616e 6c61  UTHOR: E. Branla
+00000440: 7264 0d0a 2020 2020 2222 220d 0a20 2020  rd..    """..   
+00000450: 2023 204e 4f54 453a 206d 6174 7269 6365   # NOTE: matrice
+00000460: 7320 6465 7465 726d 696e 6564 2075 7369  s determined usi
+00000470: 6e67 2073 796d 7079 2c20 7365 6520 7363  ng sympy, see sc
+00000480: 7269 7074 7320 696e 2063 7572 7265 6e74  ripts in current
+00000490: 2066 6f6c 6465 7220 0d0a 0d0a 2020 2020   folder ....    
+000004a0: 2320 2d2d 2d20 5374 6966 666e 6573 7320  # --- Stiffness 
+000004b0: 6d61 7472 6963 6573 0d0a 2020 2020 2320  matrices..    # 
+000004c0: 6b65 3d45 492f 284c 5e33 292a 5b31 3220  ke=EI/(L^3)*[12 
+000004d0: 2020 2020 2036 2a4c 2020 202d 3132 2020       6*L   -12  
+000004e0: 2020 2020 362a 4c20 3b20 2e2e 2e0d 0a20      6*L ; ..... 
+000004f0: 2020 2023 2020 2020 2020 2020 2020 2020     #            
+00000500: 2020 362a 4c20 2020 342a 4c5e 3220 2020    6*L   4*L^2   
+00000510: 2d36 2a4c 2020 2032 2a4c 5e32 203b 202e  -6*L   2*L^2 ; .
+00000520: 2e2e 0d0a 2020 2020 2320 2020 2020 2020  ....    #       
+00000530: 2020 2020 2020 2d31 3220 2020 2020 2d36        -12     -6
+00000540: 2a4c 2020 2020 3132 2020 2020 202d 362a  *L    12     -6*
+00000550: 4c20 3b20 2e2e 2e0d 0a20 2020 2023 2020  L ; .....    #  
+00000560: 2020 2020 2020 2020 2020 2020 362a 4c20              6*L 
+00000570: 2020 322a 4c5e 3220 2020 2d36 2a4c 2020    2*L^2   -6*L  
+00000580: 2034 2a4c 5e32 5d3b 0d0a 2020 2020 4b65   4*L^2];..    Ke
+00000590: 203d 206e 702e 6172 7261 7928 205b 0d0a   = np.array( [..
+000005a0: 2020 2020 2020 2020 2020 2020 5b20 3132              [ 12
+000005b0: 2a45 492f 4c2a 2a33 2020 2c20 362a 4549  *EI/L**3  , 6*EI
+000005c0: 2f4c 2a2a 3220 2020 2c20 2d31 322a 4549  /L**2   , -12*EI
+000005d0: 2f4c 2a2a 3320 2c20 362a 4549 2f4c 2a2a  /L**3 , 6*EI/L**
+000005e0: 325d 2020 2c20 0d0a 2020 2020 2020 2020  2]  , ..        
+000005f0: 2020 2020 5b20 362a 4549 2f4c 2a2a 3220      [ 6*EI/L**2 
+00000600: 2020 2c20 342a 4549 2f4c 2020 2020 2020    , 4*EI/L      
+00000610: 2c20 2d36 2a45 492f 4c2a 2a32 2020 2c20  , -6*EI/L**2  , 
+00000620: 322a 4549 2f4c 5d20 2020 2020 2c20 0d0a  2*EI/L]     , ..
+00000630: 2020 2020 2020 2020 2020 2020 5b20 2d31              [ -1
+00000640: 322a 4549 2f4c 2a2a 3320 2c20 2d36 2a45  2*EI/L**3 , -6*E
+00000650: 492f 4c2a 2a32 2020 2c20 3132 2a45 492f  I/L**2  , 12*EI/
+00000660: 4c2a 2a33 2020 2c20 2d36 2a45 492f 4c2a  L**3  , -6*EI/L*
+00000670: 2a32 5d20 2c20 0d0a 2020 2020 2020 2020  *2] , ..        
+00000680: 2020 2020 5b20 362a 4549 2f4c 2a2a 3220      [ 6*EI/L**2 
+00000690: 2020 2c20 322a 4549 2f4c 2020 2020 2020    , 2*EI/L      
+000006a0: 2c20 2d36 2a45 492f 4c2a 2a32 2020 2c20  , -6*EI/L**2  , 
+000006b0: 342a 4549 2f4c 5d0d 0a20 2020 2020 2020  4*EI/L]..       
+000006c0: 2020 2020 205d 290d 0a20 2020 204b 6720       ])..    Kg 
+000006d0: 3d20 6e70 2e61 7272 6179 285b 0d0a 2020  = np.array([..  
+000006e0: 2020 2020 2020 2020 2020 5b20 362a 542f            [ 6*T/
+000006f0: 2835 2a4c 2920 202c 2054 2f31 3020 2020  (5*L)  , T/10   
+00000700: 2020 2c20 2d36 2a54 2f28 352a 4c29 202c    , -6*T/(5*L) ,
+00000710: 2054 2f31 305d 2020 2020 202c 200d 0a20   T/10]     , .. 
+00000720: 2020 2020 2020 2020 2020 205b 2054 2f31             [ T/1
+00000730: 3020 2020 2020 2020 2c20 322a 4c2a 542f  0       , 2*L*T/
+00000740: 3135 202c 202d 542f 3130 2020 2020 2020  15 , -T/10      
+00000750: 2c20 2d4c 2a54 2f33 305d 2020 2c20 0d0a  , -L*T/30]  , ..
+00000760: 2020 2020 2020 2020 2020 2020 5b20 2d36              [ -6
+00000770: 2a54 2f28 352a 4c29 202c 202d 542f 3130  *T/(5*L) , -T/10
+00000780: 2020 2020 2c20 362a 542f 2835 2a4c 2920      , 6*T/(5*L) 
+00000790: 202c 202d 542f 3130 5d20 2020 202c 200d   , -T/10]    , .
+000007a0: 0a20 2020 2020 2020 2020 2020 205b 2054  .            [ T
+000007b0: 2f31 3020 2020 2020 2020 2c20 2d4c 2a54  /10       , -L*T
+000007c0: 2f33 3020 202c 202d 542f 3130 2020 2020  /30  , -T/10    
+000007d0: 2020 2c20 322a 4c2a 542f 3135 5d0d 0a20    , 2*L*T/15].. 
+000007e0: 2020 2020 2020 205d 290d 0a0d 0a20 2020         ])....   
+000007f0: 2023 204d 6173 7320 6d61 7472 6978 0d0a   # Mass matrix..
+00000800: 2020 2020 6966 204d 4d46 6f72 6d75 6c61      if MMFormula
+00000810: 7469 6f6e 3d3d 2763 6f6e 7369 7374 656e  tion=='consisten
+00000820: 7427 3a0d 0a20 2020 2020 2020 2023 2043  t':..        # C
+00000830: 6f6e 7369 7374 656e 7420 466f 726d 756c  onsistent Formul
+00000840: 6174 696f 6e0d 0a20 2020 2020 2020 2023  ation..        #
+00000850: 206d 653d 4d61 7373 2f34 3230 2a5b 3135   me=Mass/420*[15
+00000860: 3620 2020 2032 322a 4c20 2020 3534 2020  6    22*L   54  
+00000870: 2020 2d31 332a 4c20 203b 202e 2e2e 0d0a    -13*L  ; .....
+00000880: 2020 2020 2020 2020 2320 2020 2020 2020          #       
+00000890: 2020 2020 2020 2032 322a 4c20 2034 2a4c         22*L  4*L
+000008a0: 5e32 2020 3133 2a4c 2020 2d33 2a4c 5e32  ^2  13*L  -3*L^2
+000008b0: 2020 3b20 2e2e 2e0d 0a20 2020 2020 2020    ; .....       
+000008c0: 2023 2020 2020 2020 2020 2020 2020 2020   #              
+000008d0: 3534 2020 2020 3133 2a4c 2020 2031 3536  54    13*L   156
+000008e0: 2020 2020 2020 2d32 322a 4c3b 202e 2e2e        -22*L; ...
+000008f0: 0d0a 2020 2020 2020 2020 2320 2020 2020  ..        #     
+00000900: 2020 2020 2020 2020 2d31 332a 4c20 2d33          -13*L -3
+00000910: 2a4c 5e32 202d 3232 2a4c 2020 2034 2a4c  *L^2 -22*L   4*L
+00000920: 5e32 5d20 3b20 0d0a 2020 2020 2020 2020  ^2] ; ..        
+00000930: 6d65 203d 204d 6173 7320 2f20 3432 3020  me = Mass / 420 
+00000940: 2a20 6e70 2e61 7272 6179 285b 0d0a 2020  * np.array([..  
+00000950: 2020 2020 2020 2020 2020 5b31 3536 2020            [156  
+00000960: 2020 2020 2c20 3232 202a 204c 2020 2020      , 22 * L    
+00000970: 2020 202c 2035 3420 2020 2020 2020 2c20     , 54       , 
+00000980: 2d20 3133 202a 204c 5d20 2020 2020 2c20  - 13 * L]     , 
+00000990: 0d0a 2020 2020 2020 2020 2020 2020 5b32  ..            [2
+000009a0: 3220 2a20 4c20 2020 2c20 3420 2a20 4c20  2 * L   , 4 * L 
+000009b0: 2a2a 2032 2020 202c 2031 3320 2a20 4c20  ** 2   , 13 * L 
+000009c0: 2020 2c20 2d20 3320 2a20 4c20 2a2a 2032    , - 3 * L ** 2
+000009d0: 5d20 2c20 0d0a 2020 2020 2020 2020 2020  ] , ..          
+000009e0: 2020 5b35 3420 2020 2020 2020 2c20 3133    [54       , 13
+000009f0: 202a 204c 2020 2020 2020 202c 2031 3536   * L       , 156
+00000a00: 2020 2020 2020 2c20 2d20 3232 202a 204c        , - 22 * L
+00000a10: 5d20 2020 2020 2c20 0d0a 2020 2020 2020  ]     , ..      
+00000a20: 2020 2020 2020 5b2d 2031 3320 2a20 4c20        [- 13 * L 
+00000a30: 2c20 2d20 3320 2a20 4c20 2a2a 2032 202c  , - 3 * L ** 2 ,
+00000a40: 202d 2032 3220 2a20 4c20 2c20 3420 2a20   - 22 * L , 4 * 
+00000a50: 4c20 2a2a 2032 5d0d 0a20 2020 2020 2020  L ** 2]..       
+00000a60: 2020 2020 205d 290d 0a20 2020 2065 6c69       ])..    eli
+00000a70: 6620 4d4d 466f 726d 756c 6174 696f 6e3d  f MMFormulation=
+00000a80: 3d27 6c75 6d70 6564 273a 0d0a 2020 2020  ='lumped':..    
+00000a90: 2020 2020 2320 4c75 6d70 6564 2066 6f72      # Lumped for
+00000aa0: 6d75 6c61 7469 6f6e 0d0a 2020 2020 2020  mulation..      
+00000ab0: 2020 6d65 203d 206e 702e 6469 6167 285b    me = np.diag([
+00000ac0: 4d61 7373 2f32 2c20 302c 204d 6173 732f  Mass/2, 0, Mass/
+00000ad0: 322c 2030 5d29 290d 0a20 2020 2020 2020  2, 0]))..       
+00000ae0: 2023 2020 544f 444f 3f0d 0a20 2020 2020   #  TODO?..     
+00000af0: 2020 2023 2020 2020 2061 6c70 6861 203d     #     alpha =
+00000b00: 2031 372e 353b 0d0a 2020 2020 2020 2020   17.5;..        
+00000b10: 2320 2020 6d65 203d 2072 686f 2a41 2a4c  #   me = rho*A*L
+00000b20: 202f 2032 202a 202e 2e2e 2020 2320 6c75   / 2 * ...  # lu
+00000b30: 6d70 6564 0d0a 2020 2020 2020 2020 2320  mped..        # 
+00000b40: 2020 5b20 3120 2020 3020 2020 2020 2020    [ 1   0       
+00000b50: 2020 2020 2020 2030 2020 300d 0a20 2020         0  0..   
+00000b60: 2020 2020 2023 2020 2020 2030 2020 2061       #     0   a
+00000b70: 6c70 6861 2a4c 5e32 2f32 3130 2020 3020  lpha*L^2/210  0 
+00000b80: 2030 0d0a 2020 2020 2020 2020 2320 2020   0..        #   
+00000b90: 2020 3020 2020 3020 2020 2020 2020 2020    0   0         
+00000ba0: 2020 2020 2031 2020 300d 0a20 2020 2020       1  0..     
+00000bb0: 2020 2023 2020 2020 2030 2020 2030 2020     #     0   0  
+00000bc0: 2020 2020 2020 2020 2020 2020 3020 2061              0  a
+00000bd0: 6c70 6861 2a4c 5e32 2f32 3130 205d 3b0d  lpha*L^2/210 ];.
+00000be0: 0a20 2020 2065 6c69 6620 4d4d 466f 726d  .    elif MMForm
+00000bf0: 756c 6174 696f 6e3d 3d27 6469 6167 6f6e  ulation=='diagon
+00000c00: 616c 273a 0d0a 2020 2020 2020 2020 2320  al':..        # 
+00000c10: 4469 6167 6f6e 616c 2066 6f72 6d75 6c61  Diagonal formula
+00000c20: 7469 6f6e 0d0a 2020 2020 2020 2020 6d65  tion..        me
+00000c30: 203d 204d 6173 7320 2a20 6e70 2e64 6961   = Mass * np.dia
+00000c40: 6728 5b31 2f32 2c20 4c2a 2a32 2f37 382c  g([1/2, L**2/78,
+00000c50: 2031 2f32 2c20 4c2a 2a32 2f37 385d 290d   1/2, L**2/78]).
+00000c60: 0a20 2020 2065 6c73 653a 0d0a 2020 2020  .    else:..    
+00000c70: 2020 2020 7261 6973 6520 4578 6365 7074      raise Except
+00000c80: 696f 6e28 2755 6e6b 6e6f 776e 2020 6d61  ion('Unknown  ma
+00000c90: 7373 206d 6174 7269 7820 666f 726d 756c  ss matrix formul
+00000ca0: 6174 696f 6e20 7b7d 272e 666f 726d 6174  ation {}'.format
+00000cb0: 284d 4d46 6f72 6d75 6c61 7469 6f6e 2929  (MMFormulation))
+00000cc0: 0d0a 0d0a 0d0a 2020 2020 2320 2d2d 2d20  ......    # --- 
+00000cd0: 436f 6e76 6572 7369 6f6e 2074 6f20 676c  Conversion to gl
+00000ce0: 6f62 616c 2073 7973 7465 6d20 6966 2072  obal system if r
+00000cf0: 6571 7565 7374 6564 0d0a 2020 2020 6966  equested..    if
+00000d00: 2074 6865 7461 2069 7320 6e6f 7420 4e6f   theta is not No
+00000d10: 6e65 3a0d 0a20 2020 2020 2020 2023 2054  ne:..        # T
+00000d20: 4f44 4f0d 0a20 2020 2020 2020 2023 5220  ODO..        #R 
+00000d30: 3d20 6e70 2e61 7272 6179 285b 0d0a 2020  = np.array([..  
+00000d40: 2020 2020 2020 2320 2020 205b 6e70 2e63        #    [np.c
+00000d50: 6f73 2874 6865 7461 2920 2020 2c20 6e70  os(theta)   , np
+00000d60: 2e73 696e 2874 6865 7461 2920 2c20 3020  .sin(theta) , 0 
+00000d70: 2c20 3020 2020 2020 2020 2020 2020 2020  , 0             
+00000d80: 2020 2c20 3020 2020 2020 2020 2020 2020    , 0           
+00000d90: 2020 2c20 305d 2020 202c 200d 0a20 2020    , 0]   , ..   
+00000da0: 2020 2020 2023 2020 2020 5b2d 206e 702e       #    [- np.
+00000db0: 7369 6e28 7468 6574 6129 202c 206e 702e  sin(theta) , np.
+00000dc0: 636f 7328 7468 6574 6129 202c 2030 202c  cos(theta) , 0 ,
+00000dd0: 2030 2020 2020 2020 2020 2020 2020 2020   0              
+00000de0: 202c 2030 2020 2020 2020 2020 2020 2020   , 0            
+00000df0: 202c 2030 5d20 2020 2c20 0d0a 2020 2020   , 0]   , ..    
+00000e00: 2020 2020 2320 2020 205b 3020 2020 2020      #    [0     
+00000e10: 2020 2020 2020 2020 2020 2c20 3020 2020            , 0   
+00000e20: 2020 2020 2020 2020 2020 2c20 3120 2c20            , 1 , 
+00000e30: 3020 2020 2020 2020 2020 2020 2020 2020  0               
+00000e40: 2c20 3020 2020 2020 2020 2020 2020 2020  , 0             
+00000e50: 2c20 305d 2020 202c 200d 0a20 2020 2020  , 0]   , ..     
+00000e60: 2020 2023 2020 2020 5b30 2020 2020 2020     #    [0      
+00000e70: 2020 2020 2020 2020 202c 2030 2020 2020           , 0    
+00000e80: 2020 2020 2020 2020 202c 2030 202c 206e           , 0 , n
+00000e90: 702e 636f 7328 7468 6574 6129 2020 202c  p.cos(theta)   ,
+00000ea0: 206e 702e 7369 6e28 7468 6574 6129 202c   np.sin(theta) ,
+00000eb0: 2030 5d20 2020 2c20 0d0a 2020 2020 2020   0]   , ..      
+00000ec0: 2020 2320 2020 205b 3020 2020 2020 2020    #    [0       
+00000ed0: 2020 2020 2020 2020 2c20 3020 2020 2020          , 0     
+00000ee0: 2020 2020 2020 2020 2c20 3020 2c20 2d20          , 0 , - 
+00000ef0: 6e70 2e73 696e 2874 6865 7461 2920 2c20  np.sin(theta) , 
+00000f00: 6e70 2e63 6f73 2874 6865 7461 2920 2c20  np.cos(theta) , 
+00000f10: 305d 2020 202c 200d 0a20 2020 2020 2020  0]   , ..       
+00000f20: 2023 2020 2020 5b30 2020 2020 2020 2020   #    [0        
+00000f30: 2020 2020 2020 202c 2030 2020 2020 2020         , 0      
+00000f40: 2020 2020 2020 202c 2030 202c 2030 2020         , 0 , 0  
+00000f50: 2020 2020 2020 2020 2020 2020 202c 2030               , 0
+00000f60: 2020 2020 2020 2020 2020 2020 202c 2031               , 1
+00000f70: 5d5d 290d 0a20 2020 2020 2020 2023 4d65  ]])..        #Me
+00000f80: 203d 206e 702e 7472 616e 7370 6f73 6528   = np.transpose(
+00000f90: 5229 202a 204d 6520 2a20 520d 0a20 2020  R) * Me * R..   
+00000fa0: 2020 2020 2023 4b65 203d 206e 702e 7472       #Ke = np.tr
+00000fb0: 616e 7370 6f73 6528 5229 202a 204b 6520  anspose(R) * Ke 
+00000fc0: 2a20 520d 0a20 2020 2020 2020 2023 4b67  * R..        #Kg
+00000fd0: 203d 206e 702e 7472 616e 7370 6f73 6528   = np.transpose(
+00000fe0: 5229 202a 204b 6720 2a20 520d 0a0d 0a20  R) * Kg * R.... 
+00000ff0: 2020 2072 6574 7572 6e20 4b65 2c20 4d65     return Ke, Me
+00001000: 2c20 4b67 0d0a                           , Kg..
```

### Comparing `welib-0.0.2/welib/FEM/cable.py` & `welib-1.0.0/welib/FEM/cable.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/derivations/GuyanReduction.py` & `welib-1.0.0/welib/FEM/derivations/GuyanReduction.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,9 @@
 """ 
-Show that Guayan-Reduction of a single element result in rigid body modes
+Show that Guyan-Reduction of a single element result in rigid body modes
 
 """
 
 import numpy as np
 import sympy
 from sympy import Symbol
 from sympy import Matrix
```

### Comparing `welib-0.0.2/welib/FEM/direct_elimination.py` & `welib-1.0.0/welib/FEM/direct_elimination.py`

 * *Files 1% similar despite different names*

```diff
@@ -196,15 +196,14 @@
                 aID = -1
                 for iRA, RA0 in enumerate(RA):
                     if er.ID in RA0:
                         aID=iRA
                         break
                 if aID==-1:
                     raise Exception()
-                    import pdb; pdb.set_trace()
                 if aID not in IRA:
                     #print('NID',idNodeSel, 'SKIPPED, the RA',aID, 'has already been processed')
                     continue # We pass to the next joint, important so that:
                     #         - we don't increase iPrev
                     #         - we don't set Tc
                     #         - p%NodesDOFred is not set (assuming it has already been done)
                 else:
```

### Comparing `welib-0.0.2/welib/FEM/examples/Beam_FlexibleProperties_Tower.py` & `welib-1.0.0/welib/FEM/examples/Beam_FlexibleProperties_Tower.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_Monopile.py` & `welib-1.0.0/welib/FEM/examples/Beam_CraigBampton_Monopile.py`

 * *Files 19% similar despite different names*

```diff
@@ -1,33 +1,36 @@
 """
-Use a finite element method (FEM) formulation using frame elements to compute the mode shapes 
-of a uniform beam cantilevered with and without top mass.
+Setup a finite element method (FEM) model of a cantilevered beam (e.g. a monopile)
+with or without top mass
 
-NOTE: all of this can be done in few lines using the class: welib.fast.subdyn.SubDyn
+- Frame elements are used for the FEM representation
+- The mode shapes are computed 
+- A Craig-Bampton reduction is performed
+- The Guyan and Craig-Bampton modes are plotted
 
-NOTE: Script might be unfinished
 
-NOTE: a SubDyn wrapper with a higher level interface should be available in the future in welib/fast/examples
+NOTE: all of this can be done in few lines using the class: welib.fast.subdyn.SubDyn
 
 """
 import unittest
 import os
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 
 from welib.FEM.fem_beam import *
 from welib.FEM.reduction import CraigBampton, augmentModes
+from welib.FEM.fem_model import FEMModel
 
 import welib.weio as weio
 
 MyDir=os.path.dirname(__file__)
 
 
-def MonopileFEM(TopMass=False):
+def MonopileFEM(TopMass=False, verbose=False):
     # --- Parameters
     BC       = 'clamped-free' # Boundary condition: free-free or clamped-free
     element  = 'frame3d'      # Type of element used in FEM
     UseSubDynModel=True
     TopMass = False
 
     # Add an optional top mass and ineria
@@ -40,15 +43,15 @@
 
     if UseSubDynModel:
         # --- Option 1 - Read data from SubDyn
         # Read SubDyn file
         sdFilename=os.path.join(MyDir,'../../../data/Monopile/MT100_SD.dat')
         sd = weio.read(sdFilename)
         # Convert to "welib.fem.Graph" class to easily handle the model (overkill for a monopile)
-        graph = sd.toGraph()
+        graph = sd.toGraph(propToNodes=True)
         graph.divideElements(sd['NDiv'])
         graph.sortNodesBy('z')
         df = graph.nodalDataFrame()
         x   = df['z'] # NOTE: FEM uses "x" as main axis
         D   = df['D'] # Diameter [m]
         t   = df['t'] # thickness [m]
         E   = df['E'] # Young modules [N/m^2]
@@ -71,50 +74,65 @@
     Ip  = 2*I                   # Polar second moment of area [m^4]
     L = np.max(x)-np.min(x) # Monopile length
 
     # --- Compute FEM model and mode shapes
     FEM=cbeam(x,m=rho*A,EIx=E*Ip,EIy=E*I,EIz=E*I,EA=E*A,A=A,E=E,G=G,Kt=Kt,
                 element=element, BC=BC, M_tip=M_tip)
 
-    # --- Perform Craig-Bampton reduction, fixing the top node of the beam
-    Q_G,_Q_CB, df_G, df_CB, Modes_G, Modes_CB, CB = CB_topNode(FEM, nCB=8, element='frame3d', main_axis='x')
+    # --- Show frequencies to screen
+    if verbose:
+        print('Mode   Frequency  Label ')
+        for i in np.arange(8):
+            print('{:4d} {:10.3f}   {:s}'.format(i+1,FEM['freq'][i],FEM['modeNames'][i]))
 
+    # --- Perform Craig-Bampton reduction, fixing the top node of the beam
+    Q_G,_Q_CB, df_G, df_CB, Modes_G, Modes_CB, CB = CB_topNode(FEM, nCB=8, element=element, main_axis='x')
     df_CB.to_csv('_CB.csv',index=False)
     df_G.to_csv('_Guyan.csv',index=False)
 
-    nModesPlot=8
 
-    # --- Show frequencies to screen
-    print('Mode   Frequency  Label ')
-    for i in np.arange(8):
-        print('{:4d} {:10.3f}   {:s}'.format(i+1,FEM['freq'][i],FEM['modeNames'][i]))
+    # --- Convert to higher-level "FEM-Model" class
+    model = FEMModel.from_cbeam(FEM, CB)
+    model.toJSON('_CBEAM.json') # <<<
+
 
     # --- Plot mode components for first few modes
-    print(x.shape)
-    #Q=FEM['Q'] ; modeNames = FEM['modeNames']
-    #Q=Q_CB ;modeNames = names_CB
-    Modes=Modes_CB
-    nModesPlot=min(len(Modes),nModesPlot)
-
-    fig,axes = plt.subplots(1, nModesPlot, sharey=False, figsize=(12.4,2.5))
-    fig.subplots_adjust(left=0.04, right=0.98, top=0.91, bottom=0.11, hspace=0.40, wspace=0.30)
-    for i in np.arange(nModesPlot):
-        key= list(Modes.keys())[i]
-
-        axes[i].plot(x, Modes[key]['comp'][:,0]  ,'-'  , label='ux')
-        axes[i].plot(x, Modes[key]['comp'][:,1]  ,'-'  , label='uy')
-        axes[i].plot(x, Modes[key]['comp'][:,2]  ,'-'  , label='uz')
-        axes[i].plot(x, Modes[key]['comp'][:,3]  ,':'  , label='vx')
-        axes[i].plot(x, Modes[key]['comp'][:,4]  ,':'  , label='vy')
-        axes[i].plot(x, Modes[key]['comp'][:,5]  ,':'  , label='vz')
-        axes[i].set_xlabel('')
-        axes[i].set_ylabel('')
-        axes[i].set_title(Modes[key]['label'])
-        if i==0:
-            axes[i].legend()
+#     #Q=FEM['Q'] ; modeNames = FEM['modeNames']
+#     #Q=Q_CB ;modeNames = names_CB
+#     Modes=Modes_CB
+#     nModesPlot=min(len(Modes), 8)
+# 
+#     fig,axes = plt.subplots(1, nModesPlot, sharey=False, figsize=(12.4,2.5))
+#     fig.subplots_adjust(left=0.04, right=0.98, top=0.91, bottom=0.11, hspace=0.40, wspace=0.30)
+#     for i in np.arange(nModesPlot):
+#         key= list(Modes.keys())[i]
+# 
+#         axes[i].plot(x, Modes[key]['comp'][:,0]  ,'-'  , label='ux')
+#         axes[i].plot(x, Modes[key]['comp'][:,1]  ,'-'  , label='uy')
+#         axes[i].plot(x, Modes[key]['comp'][:,2]  ,'-'  , label='uz')
+#         axes[i].plot(x, Modes[key]['comp'][:,3]  ,':'  , label='vx')
+#         axes[i].plot(x, Modes[key]['comp'][:,4]  ,':'  , label='vy')
+#         axes[i].plot(x, Modes[key]['comp'][:,5]  ,':'  , label='vz')
+#         axes[i].set_xlabel('')
+#         axes[i].set_ylabel('')
+#         axes[i].set_title(Modes[key]['label'])
+#         if i==0:
+#             axes[i].legend()
+    return FEM, CB
 
 if __name__=='__main__':
-    FEM = MonopileFEM() 
-
+    FEM, CB = MonopileFEM(verbose=False) 
     plt.show()
 
+if __name__=='__test__':
+    FEM, CB = MonopileFEM() 
+    np.testing.assert_array_almost_equal(FEM['freq'][:3], [0.83419, 0.83419, 5.227776],3 )
+    np.testing.assert_array_almost_equal(CB['f_CB'][:3], [5.30816, 5.30816, 11.2390], 3 )
+    import os
+    try:
+        os.remove('_CBEM.json')
+        os.remove('_CB.csv')
+        os.remove('_Guyan.csv')
+    except:
+        pass
+
```

### Comparing `welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_Tower.py` & `welib-1.0.0/welib/FEM/examples/Beam_ModeShapes_Tower.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,29 +14,30 @@
 
 from welib.FEM.fem_beam import *
 import welib.weio as weio
 from welib.tools.clean_exceptions import *
 
 MyDir=os.path.dirname(__file__)
 
-def ModeShapesElastoDynTower():
+def ModeShapesElastoDynTower(verbose=False):
     # --- Parameters
     nel      = 100            # Number of elements along the beam
     BC       = 'clamped-free' # Boundary condition: free-free or clamped-free
     element  = 'frame3d'      # Type of element used in FEM
     useFASTModel = True       # Use FAST model to find relevant quantities (RNA mass, tower length, etc.)
 
     if useFASTModel:
         # --- Option 1 obtain data from FAST model
         # fst file
         fstFile=os.path.join(MyDir,'./../../../data/NREL5MW/Main_Onshore.fst')
         from welib.yams.windturbine import WindTurbineStructure
         WT = WindTurbineStructure().fromFAST(fstFile)
-        print(WT.twr)
-        print(WT.RNA)
+        if verbose:
+            print(WT.twr)
+            print(WT.RNA)
         TowerLen = WT.twr.length
         RNAMass  = WT.RNA.mass
         RNA_J_G  = WT.RNA.masscenter_inertia
         RNA_G    = WT.RNA.masscenter
     else:
         # --- Option 2 user inputs
         TowerLen = 87.6
@@ -49,21 +50,23 @@
     # --- Convert for OpenFAST coord to FEM coordinate system
     R_OF2FEM = np.array(
             [[0,0,1],
              [1,0,0],
              [0,1,0]])
     RNA_J_G= R_OF2FEM.dot(RNA_J_G).dot(R_OF2FEM.T)
     RNA_G  = R_OF2FEM.dot(RNA_G)
-    print('RNA_J_G\n',np.around(RNA_J_G,6))
-    print('RNA_G\n',RNA_G)
+    if verbose:
+        print('RNA_J_G\n',np.around(RNA_J_G,6))
+        print('RNA_G\n',RNA_G)
 
     # --- Set RNA rigid body mass matrix at tower top
     #M_tip= None
     M_tip= rigidBodyMassMatrixAtP(m=RNAMass, J_G=RNA_J_G*0, Ref2COG=RNA_G)
-    print('M_Tip\n',np.around(M_tip,2))
+    if verbose:
+        print('M_Tip\n',np.around(M_tip,2))
 
     TwrFile=os.path.join(MyDir,'./../../../data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_Onshore_ElastoDyn_Tower.dat')
     twr = weio.FASTInputFile(TwrFile).toDataFrame()
     x   = twr['HtFract_[-]']*(TowerLen)
     m   = twr['TMassDen_[kg/m]']
     EIz = twr['TwFAStif_[Nm^2]']        # FA/Flap = IyOpenFAST = Iz(when x is axis)
     EIy = twr['TwSSStif_[Nm^2]']        # SS/Edge = IxOpenFAST = Iy(when x is axis)
@@ -79,64 +82,68 @@
 
     # --- Compute FEM model and mode shapes
     FEM=cbeam(x,m=m,EIx=EIx,EIy=EIy,EIz=EIy,EA=E*A,A=A,E=E,G=G,Kt=Kt,
             element=element, nel=nel, BC=BC, M_tip=M_tip)
 
     return FEM
 
-def compareFEMwithTheory():
+def compareFEMwithTheory(FEM):
     # --- Compare modes with theory
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+    fig.subplots_adjust(left=0.12, right=0.95, top=0.94, bottom=0.11, hspace=0.30, wspace=0.30)
     COLORS=plt.rcParams['axes.prop_cycle'].by_key()['color']
 
     x =FEM['xNodes'][0,:]
     Q =FEM ['Q']
     QY1 = [Q [1::6, iMode] for iMode in range(10) if FEM ['modeNames'][iMode].startswith('uy')]
 
     for iModeY in range(3):
-        ax.plot(x   , QY1[iModeY], 's', c=COLORS[iModeY], label='FEM (no top mass) Mode {}'.format(iModeY+1)) # FEM no top mass
+        ax.plot(x   , QY1[iModeY], '-', c=COLORS[iModeY], label='FEM Mode {}'.format(iModeY+1)) # FEM no top mass
     ax.set_xlabel('Beam span [m]')
     ax.set_ylabel('Deflection [m]')
     ax.tick_params(direction='in')
-    ax.set_title('FEM - mode shapes of a beam')
+    ax.set_title('FEM - mode shapes of tower')
     ax.legend()
 
     return FEM
 
-def plotModes(FEM):
-    nModesPlot=8
+def plotModes(FEM, print=False):
     # --- Show frequencies to screen
-    print('Mode   Frequency  Label ')
-    for i in np.arange(nModesPlot):
-        print('{:4d} {:10.3f}   {:s}'.format(i+1,FEM['freq'][i],FEM['modeNames'][i]))
+    if print:
+        print('Mode   Frequency  Label ')
+        for i in np.arange(nModesPlot):
+            print('{:4d} {:10.3f}   {:s}'.format(i+1,FEM['freq'][i],FEM['modeNames'][i]))
 
     # --- Plot mode components for first few modes
+    nModesPlot=4
     x=FEM['xNodes'][0,:]
     Q=FEM['Q']
 
-    fig,axes = plt.subplots(1, nModesPlot, sharey=False, figsize=(12.4,2.5))
-    fig.subplots_adjust(left=0.04, right=0.98, top=0.91, bottom=0.11, hspace=0.40, wspace=0.30)
-    for i in np.arange(nModesPlot):
-        axes[i].plot(x, Q[0::6,i]  ,'-'  , label='ux')
-        axes[i].plot(x, Q[1::6,i]  ,'-'  , label='uy')
-        axes[i].plot(x, Q[2::6,i]  ,'-'  , label='uz')
-        axes[i].plot(x, Q[3::6,i]  ,':'  , label='vx')
-        axes[i].plot(x, Q[4::6,i]  ,':'  , label='vy')
-        axes[i].plot(x, Q[5::6,i]  ,':'  , label='vz')
-        axes[i].set_xlabel('')
-        axes[i].set_ylabel('')
-        axes[i].set_title(FEM['modeNames'][i])
+    fig,axes = plt.subplots(2, int(nModesPlot/2), sharex=True, sharey=False, figsize=(6.4,3.9)) # (6.4,4.8)
+    fig.subplots_adjust(left=0.09, right=0.97, top=0.94, bottom=0.15, hspace=0.27, wspace=0.23)
+    axes=np.array(axes).flatten()
+    for i,ax in enumerate(axes):
+        ax.plot(x, Q[0::6,i]  ,'-'  , label=r'$u_x$')
+        ax.plot(x, Q[1::6,i]  ,'--'  , label=r'$u_y$')
+        ax.plot(x, Q[2::6,i]  ,':'  , label=r'$u_z$')
+        #axes[i].plot(x, Q[3::6,i]  ,':'  , label='vx')
+        #axes[i].plot(x, Q[4::6,i]  ,':'  , label='vy')
+        #axes[i].plot(x, Q[5::6,i]  ,':'  , label='vz')
+        ax.set_xlabel('x [m]')
+        ax.set_ylabel('')
+        ax.set_title(FEM['modeNames'][i])
         if i==0:
             axes[i].legend()
+    for ax in axes:
+        ax.tick_params(direction='in', top=True, right=True)
 
 if __name__=='__main__':
     FEM  = ModeShapesElastoDynTower()
-
     plotModes(FEM)
+    FEM = compareFEMwithTheory(FEM) # TODO unfinished
 
     plt.show()
 
 if __name__=='__test__':
     FEM  = ModeShapesElastoDynTower()
 #     MM        = FEM['MM']
 #     KK        = FEM['KK']
@@ -159,11 +166,13 @@
 #     if modeNames[0] not in ['uz1','uy1']:
 #         raise Exception('First mode not labelled properly')
 #     if modeNames[2] not in ['uz2','uy2']:
 #         raise Exception('Second mode not labelled properly')
 #     np.testing.assert_equal(modeNames[7], 'vx1')
 
 if __name__=='__export__':
-    pass
-#     from welib.tools.repo import export_figs_callback
-#     FEM= compareFEMwithTheory()
-#     export_figs_callback(__file__)
+    from welib.tools.repo import export_figs_callback
+
+    FEM  = ModeShapesElastoDynTower()
+    FEM = compareFEMwithTheory(FEM) # TODO unfinished
+
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py` & `welib-1.0.0/welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 import matplotlib.pyplot as plt
 
 from welib.FEM.fem_beam import *
 from welib.beams.theory import *
 
 MyDir=os.path.dirname(__file__)
 
-def UniformBeam(TopMass=False):
+def UniformBeam(TopMass=False): # TODO add this to FEM
     # --- Parameters
     nel      = 10             # Number of elements along the beam
     BC       = 'clamped-free' # Boundary condition: free-free or clamped-free
     element  = 'frame3d'      # Type of element used in FEM
     if TopMass:
         Mtop = 50000  # Top mass [kg]
         M_tip= rigidBodyMassMatrixAtP(m=Mtop, J_G=None, Ref2COG=None)
```

### Comparing `welib-0.0.2/welib/FEM/examples/Graph_CreateSimpleGraph.py` & `welib-1.0.0/welib/FEM/examples/Graph_CreateSimpleGraph.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/examples/README.md` & `welib-1.0.0/welib/FEM/examples/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/examples/frame2d_element.py` & `welib-1.0.0/welib/FEM/examples/frame2d_element.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/fem_beam.py` & `welib-1.0.0/welib/FEM/fem_beam.py`

 * *Files 7% similar despite different names*

```diff
@@ -20,15 +20,15 @@
 
 
 
 """
 import pandas as pd
 import numpy as np
 import scipy
-from welib.FEM.utils    import skew, elementDCMfromBeamNodes
+from welib.FEM.utils    import skew, elementDCMfromBeamNodes, rigidBodyMassMatrixAtP, xNodesInputToArray
 from welib.FEM.fem_core import insertFixedBCinModes
 from welib.system.eva import eig
 
 # --------------------------------------------------------------------------------}
 # --- Main wrapper functions 
 # --------------------------------------------------------------------------------{
 def cbeam(xNodes, m, EIx=None, EIy=None, EIz=None, EA=None, A=None, Kt=None, E=None, G=None, phi=None, 
@@ -129,36 +129,38 @@
     xNodes = FEM['xNodes']
     # Find top node DOF
     IDOF_tip = FEM['Nodes2DOF'][FEM['Elem2Nodes'][-1,:][1],:] # NOTE: index in full system
     Ileader=FEM['IFull2BC'][IDOF_tip] # NOTE: index in system with BC
     # --- Craig-Bampton reduction
     MMr, KKr, Phi_G, Phi_CB, f_G, f_CB,_,_ = CraigBampton(MM, KK, Ileader, nModesCB=nCB, Ifollow=None, F=None, DD=None, fullModesOut=True)
 
+    # Insert Boundary conditions back in mode
+    Q_G  = insertFixedBCinModes(Phi_G, FEM['Tr'])
+    Q_CB = insertFixedBCinModes(Phi_CB, FEM['Tr'])
+
     CB=dict()
     CB['MM']     = MMr
     CB['KK']     = KKr
     CB['Phi_G']  = Phi_G
     CB['Phi_CB'] = Phi_CB
     CB['f_G']    = f_G
     CB['f_CB']   = f_CB
+    CB['Q_G']    = Q_G
+    CB['Q_CB']   = Q_CB
 
 
-    # Insert Boundary conditions back in mode
-    Q_G  = insertBCinModes(Phi_G, FEM['Tr'])
-    Q_CB = insertBCinModes(Phi_CB, FEM['Tr'])
-
     # Identify modes for convenience
     _, names_G= identifyAndNormalizeModes(Q_G, element=element, normalize=False)
     _, names_CB= identifyAndNormalizeModes(Q_CB, element=element, normalize=False)
 
     if main_axis!='x':
         # Perform permutations
         raise NotImplementedError()
 
-    if element =='frame3d':
+    if element in ['frame3d', 'frame3dlin']:
         DN = ['ux','uy','uz','tx','ty','tz']
     else:
         raise NotImplementedError()
 
     # --- Create dataframe and mode dict for Guyan modes
     MN = ['G{}'.format(i+1) for i in np.arange(Q_G.shape[1])]
     M=FEM['xNodes'][0,:]
@@ -191,50 +193,14 @@
     return Q_G, Q_CB, df_G, df_CB, Modes_G, Modes_CB, CB
 
 
 
 # --------------------------------------------------------------------------------}
 # --- Helpers, consider adding to utils 
 # --------------------------------------------------------------------------------{
-def rigidBodyMassMatrixAtP(m=None, J_G=None, Ref2COG=None):
-    """ 
-    Rigid body mass matrix (6x6) at a given reference point: 
-      the center of gravity (if Ref2COG is None) 
-
-
-    INPUTS:
-     - m/tip: (scalar) body mass 
-                     default: None, no mass
-     - J_G: (3-vector or 3x3 matrix), diagonal coefficients or full inertia matrix
-                     with respect to COG of body! 
-                     The inertia is transferred to the reference point if Ref2COG is not None
-                     default: None 
-     - Ref2COG: (3-vector) x,y,z position of center of gravity (COG) with respect to a reference point
-                     default: None, at first/last node.
-    OUTPUTS:
-      - M66 (6x6) : rigid body mass matrix at COG or given point 
-    """
-    # Default values
-    if m is None: m=0
-    if Ref2COG is None: Ref2COG=(0,0,0)
-    if J_G is None: J_G=np.zeros((3,3))
-    if len(J_G.flatten()==3): J_G = np.eye(3).dot(J_G)
-
-    M66 = np.zeros((6,6))
-    x,y,z = Ref2COG
-    Jxx,Jxy,Jxz = J_G[0,:]
-    _  ,Jyy,Jyz = J_G[1,:]
-    _  ,_  ,Jzz = J_G[2,:]
-    M66[0, :] =[   m     ,   0     ,   0     ,   0                 ,  z*m                , -y*m                 ]
-    M66[1, :] =[   0     ,   m     ,   0     , -z*m                ,   0                 ,  x*m                 ]
-    M66[2, :] =[   0     ,   0     ,   m     ,  y*m                , -x*m                ,   0                  ]
-    M66[3, :] =[   0     , -z*m    ,  y*m    , Jxx + m*(y**2+z**2) , Jxy - m*x*y         , Jxz  - m*x*z         ]
-    M66[4, :] =[  z*m    ,   0     , -x*m    , Jxy - m*x*y         , Jyy + m*(x**2+z**2) , Jyz  - m*y*z         ]
-    M66[5, :] =[ -y*m    , x*m     ,   0     , Jxz - m*x*z         , Jyz - m*y*z         , Jzz  + m*(x**2+y**2) ]
-    return M66
 
 def LinearDOFMapping(nElem, nNodesPerElem, nDOFperNode):
     """ 
     returns the mappings from nodes to DOF and element to nodes and DOF
     for a structure with the same type of elements, assuming nodes are one after the other
     """
     nNodes = (nNodesPerElem-1)*nElem+1 # total number of nodes in system
@@ -267,19 +233,19 @@
 def BuildGlobalMatrix(KK, Ke, index):
     """Assembly of element matrices into the system matrix
     INPUTS
         KK - system matrix
         Ke  - element matrix
         index - d.o.f. vector associated with an element
     """
-    for i,ii in enumerate(index):
-        for j,jj in enumerate(index):
-            KK[ii,jj] += Ke[i,j]
-    #
-    #KK[np.ix_(index,index)] += Ke
+    #for i,ii in enumerate(index):
+    #    for j,jj in enumerate(index):
+    #        KK[ii,jj] += Ke[i,j]
+    ##
+    KK[np.ix_(index,index)] += Ke
     return KK
 
 
 # --------------------------------------------------------------------------------}
 # --- Multi purpose assembly method 
 # --------------------------------------------------------------------------------{
 def cbeam_assembly(xNodes, m, EIx=None, EIy=None, EIz=None, EA=None, A=None, Kt=None, E=None, G=None, phi=None, element='frame3d',nel=None):
@@ -354,52 +320,23 @@
     if E is None:  E = 211e9       # Young modulus
     if G is None:  G = E/2/(1+0.3) # Young modulus
     if EIz is None: EIz=EIy
     if A is None:  A= m*0+100      # Area, TODO
     if EA is None: EA=E*A
     if Kt is None: Kt= m*0+100     # Saint Venant torsion, TODO
 
-    if not hasattr(xNodes,'__len__'):
-        xNodes=[xNodes]
-    xNodes = np.asarray(xNodes)
-    if len(xNodes)==1:
-        xNodes0=xNodes
-        # Constant beam properties
-        xNodes=np.zeros((3,2))
-        xNodes[0,:] =[0, xNodes0[0]]     # Beam directed about x
-        EIx    = np.array([1, 1])*EIx
-        EIy    = np.array([1, 1])*EIy
-        EIz    = np.array([1, 1])*EIz
-        EA     = np.array([1, 1])*EA 
-        Kt     = np.array([1, 1])*Kt
-        A      = np.array([1, 1])*A  
-        m      = np.array([1, 1])*m  
-    elif len(xNodes.shape)==1:
-        xNodes0=xNodes
-        xNodes=np.zeros((3,len(xNodes)))
-        xNodes[0,:]=xNodes0
-
-
-    # --- Create node locations if user specified nElem
-    le0 = np.sqrt((xNodes[0,1:]-xNodes[0,0:-1])**2+(xNodes[1,1:]-xNodes[1,0:-1])**2+(xNodes[2,1:]-xNodes[2,0:-1])**2)
-    s_span0 = np.concatenate(([0],np.cumsum(le0)))
-
-    if nel is None:
-        # we will use xNodes provided by the user
-        nel=xNodes.shape[0]-1
-        interp_needed=False
-    else:
-        # We create elements with linear spacing along the curvilinear span
-        xNodes0=xNodes
-        xNodes=np.zeros((3,nel+1))
-        s_span     = np.linspace(0,s_span0[-1],nel+1)
-        xNodes[0,:] = np.interp(s_span, s_span0, xNodes0[0,:])
-        xNodes[1,:] = np.interp(s_span, s_span0, xNodes0[1,:])
-        xNodes[2,:] = np.interp(s_span, s_span0, xNodes0[2,:])
-        interp_needed=True
+    xNodes, xNodes0, s_span0, interp_needed = xNodesInputToArray(xNodes, main_axis='x', nel=nel)
+    if not hasattr(EIx,'__len__'):
+        EIx    = np.ones(xNodes0.shape[1])*EIx
+        EIy    = np.ones(xNodes0.shape[1])*EIy
+        EIz    = np.ones(xNodes0.shape[1])*EIz
+        EA     = np.ones(xNodes0.shape[1])*EA 
+        Kt     = np.ones(xNodes0.shape[1])*Kt
+        A      = np.ones(xNodes0.shape[1])*A  
+        m      = np.ones(xNodes0.shape[1])*m  
 
     # Recompute spanwise
     le = np.sqrt((xNodes[0,1:]-xNodes[0,0:-1])**2+(xNodes[1,1:]-xNodes[1,0:-1])**2+(xNodes[2,1:]-xNodes[2,0:-1])**2)
     s_span = np.concatenate(([0],np.cumsum(le)))
     s_span_mid = s_span[:-1]+np.diff(s_span)/2
 
     # --- Interpolate properties based on curvilinear length along the beam to get nel Elements
@@ -440,25 +377,25 @@
     """
     Assembly a FEM model of a beam made of n elements (n+1 nodes)
     Node positions are given in 3D
     Element properties are given for each elements (n)
 
     INPUTS
       xNodes: (3x n+1) Nodes positions x,y,z along the beam for 3d beam [m]
-      G   : (scalar or n) Shear modulus. Steel: 79.3  [Pa] [N/m^2]
       E   : (scalar or n) Elastic (Young) modulus
+      G   : (scalar or n) Shear modulus. Steel: 79.3  [Pa] [N/m^2]
       me   : (n) Mass per length of elements [kg/m]
       A    : (n) Beam cross section area along the beam, for elements [m^2]
-      EIy  : (n) Elastic Modulus times Second Moment of Area of cross section [Nm2]
-      EIz  : (n) Elastic Modulus times Second Moment of Area of cross section [Nm2]
-      EIz  : (n) Elastic Modulus times Second Moment of Area of cross section [Nm2]
+      EIx  : (n) Elastic Modulus times Polar  second moment of area,local x-axis. Ix=\iint(y^2+z^2) dy dz [m4], EIx,[Nm2]
+      EIy  : (n) Elastic Modulus times Planar second moment of area,local y-axis. Iy=\iint z^2 dy dz [m4],      EIy,[Nm2]
+      EIz  : (n) Elastic Modulus times Planar second moment of area,local z-axis. Iz=\iint y^2 dy dz [m4],      EIz,[Nm2]
+
       Kt   : (n) Torsion constant [m^4]
       phi : (n) rotation of principal axes wrt mean line (tangent) of the beam [rad]
 
-
       nel  : Number of elements. If provided Structural propeties and nodes will be interpolated to match nel. 
              Otherwise, the length of xNodes determines the discretization
     
     OUTPUTS
       MM: (nDOF x nDOF)  Mass matrix
       KK: (nDOF x nDOF)  Stiffness matrix
       x : (1 x nel)   Span vector
@@ -569,16 +506,24 @@
         A2  = A[iNode2]
         Kv1 = Kv[iNode1]
         Kv2 = Kv[iNode2]
         Iy1 = Iy[iNode1]
         Iy2 = Iy[iNode2]
         Iz1 = Iz[iNode1]
         Iz2 = Iz[iNode2]
-        ke,me = frame3dlin_KeMe(E,G,Kv1,Kv2,A1,A2,Iy1,Iy2,Iz1,Iz2,le,me1,me2, R=None)
-        #ke,me= frame3dlin_KeMe(me1, me2, le)
+        # TODO
+        if hasattr(E,'__len__'):
+            E1=E[iNode1]
+        else:
+            E1=E
+        if hasattr(G,'__len__'):
+            G1=G[iNode1]
+        else:
+            G1=G
+        ke,me = frame3dlin_KeMe(E1,G1,Kv1,Kv2,A1,A2,Iy1,Iy2,Iz1,Iz2,le,me1,me2, R=None)
         Me[:,:,ie]=me
         Ke[:,:,ie]=ke
 
     # --- Assembly
     MM = np.zeros((nDOF_tot,nDOF_tot))
     KK = np.zeros((nDOF_tot,nDOF_tot))
     for ie in np.arange(nElem):
@@ -737,20 +682,23 @@
     Se:   FEM Modes (nDOF x nModes) (elastic modes, e)
     
     """
     dpn=6 # Number of DOF per nodes
 
     assert(xNodes.shape[0]==3)
     nDOF=MM.shape[0]
+    #
+    nNodes = xNodes.shape[1]
 
     # --- Rigid body modes (t: translation, r:rotation)
     St = np.zeros((nDOF, 3))
     Sr = np.zeros((nDOF, 3))
-    for i in np.arange(xNodes.shape[1]):
-        R= skew(xNodes[:,i])
+    # Loop on node points
+    for i, nodeP in enumerate(xNodes.T):
+        R= skew(nodeP)
         St[i*dpn   : i*dpn+3, :]= np.eye(3)
         Sr[i*dpn   : i*dpn+3, :]= -R
         Sr[i*dpn+3 : i*dpn+6, :]= np.eye(3)
     # Se: Selected modes (e:elastic)
 
     # --- Generalized mass matrix
     # Rigid body part             # Different Notations:
@@ -966,15 +914,15 @@
 # V2= T(1, 2)*V(:, mode_pair(1)) + T(2, 2)*V(:, mode_pair(2));
 # 
 # V(:, mode_pair(1))= V1;
 # V(:, mode_pair(2))= V2;
 
 
 
-def identifyAndNormalizeModes(Q, nModes=None, element='frame3d', normalize=True):
+def identifyAndNormalizeModes(Q, nModes=None, element='frame3d', normalize=True, physicalScale=1):
     """ 
     Attempts to identify and normalized the first `nModes` modes
     Modes are normalized by last values unless this value is too small compared to the max
     in which case the max is used.
     Mode names are returned of the form [u,v][x,y,z][n]
       where "u": displacements, "v": slopes, and "n" is the mode number in that direction
     """
@@ -986,22 +934,22 @@
     cDOF=np.zeros(nDOF,dtype=int) # Counter on Modes in each DOF
     modeNames=[]
 
     for i in np.arange(nModes):
         q=Q[:,i]
         mag = modeNorms(q, iDOFstart=0, nDOF=nDOF)
         idx= np.argsort(mag)[-1::-1]
-        iMax = idx[0]
-        U = Q[iMax::nDOF,i]
+        iMax = idx[0] # DOF (between 1-6) with macimum component
+        U = Q[iMax::nDOF,i] # Main component of the mode
         # Detect rigid body mode (0 or NaN frequencies), component constant and non-zero
         rigid=False
         for idof in np.arange(nDOF):
             Ui = Q[idof::nDOF,i]
             Umax  = max(abs(Ui))
-            if Umax>1e-6:
+            if Umax>1e-6*physicalScale:
                 if len(np.unique(np.around(Ui/Umax,3)))==1:
                     icst=idof
                     rigid=True
                     break
         # Mode name
         if rigid:
             mode_name =sDOF[iMax]+'_'+sDOF[icst]+'_rigid'
@@ -1013,15 +961,15 @@
         #if sDOF[iMax] in ['vy','vz']:
         #    print('Mode {} has strong slope, double check identification'.format(i))
         #print('>>>Mode',i, 'name:',mode_name, mag)
 
         # Normalization by max or last
         Umax  = max(abs(U))
         Ulast = abs(U[-1])
-        if Ulast*100< Umax: # some tuning factor if last is close to 0
+        if Ulast*100*physicalScale< Umax: # some tuning factor if last is close to 0
             # Normalize by max
             fact = Umax*np.sign(U[-1])
         else:
             # Normalize by last
             fact = Ulast*np.sign(U[-1])
         if normalize:
             Q[:,i]= Q[:,i]/fact
```

### Comparing `welib-0.0.2/welib/FEM/fem_model.py` & `welib-1.0.0/welib/yams/models/FTNSB_sympy.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,708 +1,686 @@
-"""
-A FEM Model is a special kind of Graph
-   Graphs have: Nodes, Elements, Node properties, and a "Model" storing it all
-
-"""
 import numpy as np
-import pandas as pd
+from sympy import Matrix, symbols, simplify, Function, expand_trig, Symbol, diff
+from sympy import cos, sin, transpose, pi
+from sympy import latex, python
+from sympy.physics.mechanics import dynamicsymbols, ReferenceFrame, Point, inertia
+
+#from welib.yams.sympy_tools import *
+#from welib.yams.yams_sympy import DCMtoOmega
+from welib.yams.yams_sympy       import YAMSRigidBody, YAMSInertialBody, YAMSFlexibleBody
+from welib.yams.yams_sympy_model import YAMSModel
+from welib.yams.models.FTNSB_sympy_symbols import *
+from welib.yams.models.utils import stiffness6DOF
+
+
+_defaultOpts={
+    'floating':True,
+    'yaw'    : 'fixed',  # 'fixed', 'dynamic' or 'zero'
+    'tilt'   : 'fixed',  # 'fixed', 'dynamic' or 'zero'
+    # Blades Options
+    'nB':3                , # Number of blades
+    'azimuth_init': 'fixed',# 'fixed', or 'zero'
+    'pitch'  : 'fixed',# '','fixed', 'dynamic', 'or 'zero'
+    'cone'   : 'fixed',# '','fixed', or 'zero'
+    'coneAtRotorCenter': False,  # Ture in OpenFAST, coning starts at the rotor center, not at the blade root
+    'r_hub': 'fixed',  # 'fixed' or 'zero', hub radius depend on coneAtRotorCenter
+    #
+    'Mform'  : 'TaylorExpanded', # 'symbolic',or 'TaylorExpanded'
+    'mergeFndTwr':True, # Use one body for FND and TWR
+    'tiltShaft':False, # Tilt shaft or nacelle
+    'twrDOFDir':['x','y','x','y'], # Order in which the flexible DOF of the tower are set
+    'collectiveBldDOF':False,      # Use the same degrees of freedom for all blades "collective"
+    'linRot' : False,              #<<< Very important if True will assume that omegas are time derivatives of DOFs
+    'rot_elastic_type':'Body',     #<<< Very important, SmallRot, or Body, will affect the rotation matrix
+    'rot_elastic_subs':True,       #<<< Very important, will substitute alpha_y with nuy q. Recommended True
+    'rot_elastic_smallAngle':False,#<<< Very important, will perform small angle approx: sin(nu q) = nu q and nu^2=0 !!! Will remove all nu^2 and nu^3 terms!! might not be recommended
+    'moor_loads':False, # Add mooring loads on the foundation
+    'hydro_loads':False, # Add hydro on the foundation 
+    'aero_torques':False, # Add aerodynamic torques
+    'aero_forces':True, # Add aerodynamic torques
+    'orderMM':2, #< order of taylor expansion for Mass Matrix
+    'orderH':2,  #< order of taylor expansion for H term
+    'verbose':False, 
+}
 
 
-from welib.FEM.utils import DCM, rigidTransformationMatrix
-from welib.FEM.fem_elements import *   # Elements used
-from welib.FEM.fem_core import insertFixedBCinModes
-from welib.FEM.graph import NodeProperty
-from welib.FEM.graph import GraphModel 
-
-# class MaterialProperty(NodeProperty):
-#     def __init__(self):
-#         Property.__init__(self)
-#         pass
-
-# --------------------------------------------------------------------------------}
-# --- Main FEM model class  
-# --------------------------------------------------------------------------------{
-class FEMModel(GraphModel):
-    @classmethod
-    def from_graph(cls, graph, ndiv=None, mainElementType='frame3d', refPoint=None, gravity=9.81):
-        """ 
-        Returns FEM model from graph
-        DOFs number are attributed to graph
-        """
-        import copy
-        # Copying graph to avoid any access of memory by reference
-        g = copy.deepcopy(graph)
-        # Creating "FEM" Nodes without DOFs
-        for i,n in enumerate(g.Nodes):
-            g.Nodes[i] = FEMNode(n.ID, n.x, n.y, n.z, DOFs=[], **n.data)
-        # Creating "FEM" Elements without DOFs
-        for i,e in enumerate(g.Elements):
-            if e.data['Type']=='Beam':
-                if mainElementType=='frame3d':
-                    g.Elements[i] = SubDynFrame3dElement(e.ID, e.nodeIDs, None, e.propset, e.propIDs, None, **e.data)
-                elif mainElementType=='timoshenko':
-                    g.Elements[i] = SubDynTimoshenko3dElement(e.ID, e.nodeIDs, None, e.propset, e.propIDs, None, **e.data)
-                else:
-                    raise NotImplementedError()
-            elif e.data['Type']=='Cable':
-                if mainElementType in ['frame3d', 'timoshenko']:
-                    g.Elements[i] = SubDynCable3dElement(e.ID, e.nodeIDs, None, e.propset, e.propIDs, None, **e.data)
-                else:
-                    raise NotImplementedError()
-            elif e.data['Type']=='Rigid':
-                if mainElementType in ['frame3d', 'timoshenko']:
-                    g.Elements[i] = SubDynRigid3dElement(e.ID, e.nodeIDs, None, e.propset, e.propIDs, None, **e.data)
-                else:
-                    raise NotImplementedError()
-            else:
-                raise NotImplementedError()
-        #print('----------------------- GRAPH')
-        #print(graph)
-        #print('----------------------- G')
-        #print(g)
-        # Update connectivity
-        g.connecticityHasChanged()
-        g.updateConnectivity()
-        # Distribute DOF to nodes and elements
-        g = distributeDOF(g, mainElementType=mainElementType)
-        # Create instance of FEM Model
-        self = cls(Elements=g.Elements, Nodes=g.Nodes, NodePropertySets=g.NodePropertySets, 
-                ElemPropertySets=g.ElemPropertySets, MiscPropertySets=g.MiscPropertySets, refPoint=refPoint, gravity=gravity)
-        #print(self)
-        return self
-
-    def __init__(self, Elements=None, Nodes=None, NodePropertySets=None, ElemPropertySets=None, MiscPropertySets=None,
-            mainElementType='frame3d', gravity=9.81, main_axis='z', refPoint=None): # FEM specific
-        """ 
-
-         - refPoint: reference point from which a rigid body connection to the interface is computed
-        """
-
-        GraphModel.__init__(self, Elements=Elements, Nodes=Nodes, NodePropertySets=NodePropertySets,
-                ElemPropertySets=ElemPropertySets, MiscPropertySets=MiscPropertySets)
-
-        self.refPoint        = refPoint
-        self.gravity         = gravity
-        self.main_axis       = main_axis
-        self.mainElementType = mainElementType
-        # Main data generated
-        self.MM_init  = None # Initial mass matrix, before internal constaints
-        self.KK_init  = None # Initial stiffness matrix, before internal constaints
-        self.FF_init  = None # Initial load vector     , before internal constaints
-        self.MM       = None # Mass matrix   without boundary conditions
-        self.KK       = None # Stiff matrix  without boundary conditions
-        self.CC       = None # Damping matrix ..
-        self.FF       = None # 
-        self.freq     = None # Frequency of the Full FEM system after Boundary conditions and internal constraints
-        self.Q        = None # Modes of the full FEM system after Boundary conditions and internal constraints
-                             # NOTE: augmented to include the boundary condition in them
-
-        # internal data
-        self._nDOF    = None
-
-        # 
-        if 'DOFs' not in self.Nodes[0].data.keys():
-            print('>>> Attributing DOFs to Nodes and Elements')
-            g = distributeDOF(self, mainElementType=mainElementType)
+def get_model(model_name, **opts):
+    """ 
+
+    model: string defining model
+
+    opts: dictionary of options with keys:
+        see _defaultOpts
+    
+    """
+
+    for k,v in _defaultOpts.items():
+        if k not in opts.keys():
+            opts[k]=v
+    for k,v in opts.items():
+        if k not in _defaultOpts.keys():
+            raise Exception('Key {} not supported for model options.'.format(k))
+    #print(opts)
+    verbose=opts['verbose']
 
     # --------------------------------------------------------------------------------}
-    # --- Handling of DOFs nodes elements 
+    # --- Extract info from model name
     # --------------------------------------------------------------------------------{
-    @property
-    def nDOF(self):
-        if self._nDOF is None:
-            self._nDOF = np.max(self.Nodes[-1].data['DOFs'])+1
-        return self._nDOF
-    @property
-    def nDOFc(self):
-        DOFs = []
-        for n in self.Nodes:
-            DOFs += n.data['DOFs_c']
-        return np.max(DOFs)+1
-
-
-    @property
-    def DOF2Nodes(self):
-        """ 
-        Return mapping from DOF to nodes.
-        Using "DOF" for system *before* internal constraints have been eliminated
-
-        Return array nDOF x 4, with columns: 
-          0: DOF index (not ID),   (starts at 0)
-          1: Node index (not ID),  (starts at 0)
-          2: Number of DOF on node,
-          3: DOF number out of all the DOF on node (starts at 1)
-        """
-        DOF2Nodes=np.zeros((self.nDOF,4),int)
-        for iN,node in enumerate(self.Nodes):
-            for iiDOF,iDOF in enumerate(node.data['DOFs']):
-                DOF2Nodes[iDOF,0] = iDOF
-                DOF2Nodes[iDOF,1] = iN
-                DOF2Nodes[iDOF,2] = len(node.data['DOFs'])
-                DOF2Nodes[iDOF,3] = iiDOF+1
-        return DOF2Nodes
-
-    @property
-    def DOFc2Nodes(self):
-        """ 
-        Return mapping from DOF to nodes.
-        Using "DOF" for system where internal constraints have been eliminated
-
-        Return array nDOF x 4, with columns: 
-          0: DOF index (not ID),   (starts at 0)
-          1: Node index (not ID),  (starts at 0)
-          2: Number of DOF on node,
-          3: DOF number out of all the DOF on node (starts at 1)
-        """
-        DOF2Nodes=np.zeros((self.nDOFc,4),int)
-        for iN,node in enumerate(self.Nodes):
-            DOFs = node.data['DOFs_c']
-            #if len(DOFs)==0:
-            #    if 'ID_link' in node.data.keys():
-            #        print('>>>>>>  node' , node.ID, 'linked to', node.data['ID_link'] )
-            #        DOFs = self.getNode(node.data['ID_link']).data['DOFs_c']
-            for iiDOF,iDOF in enumerate(DOFs):
-                DOF2Nodes[iDOF,0] = iDOF
-                DOF2Nodes[iDOF,1] = iN
-                DOF2Nodes[iDOF,2] = len(DOFs)
-                DOF2Nodes[iDOF,3] = iiDOF+1
-        return DOF2Nodes
-
-
-    # Interface, reaction, internal nodes TODO, make this cleaner
-    @property
-    def interfaceNodes(self): return [n for n in self.Nodes if 'IBC' in n.data]
-    @property
-    def reactionNodes(self): return [n for n in self.Nodes if 'RBC' in n.data]
-    @property
-    def internalNodes(self): return [n for n in self.Nodes if 'RBC' not in n.data and 'IBC' not in n.data]
-    
+    # Nicknames
+    bFullRNA   = model_name.find('RNA')==-1
+    bRotorOnly = model_name.find('R')==0
+
+    if bRotorOnly and not bFullRNA:
+        raise Exception('Cannot have "Rotor" and RNA')
+
+    if bRotorOnly:
+        # Rotor only, overriding options
+        bFullRNA=True
+        opts['nB']=int(model_name.split('R')[1][0]) 
+        opts['mergeFndTwr'] = True
+        opts['floating'] = False
+        opts['yaw' ] = 'zero'
+        opts['tilt'] = 'zero'
+
+    # Default values, no DOF
+    bFndDOFs = [False]*6
+    bNac=False   # Is there Nacelle DOFs
+    bSft=False   # Is there Shaft DOFs
+    bBld=False   # Is there blade DOF
+    nDOF_fnd   = 0 # Number of DOFs for foundation
+    nDOF_twr   = 0 # Number of DOFs for tower
+    nDOF_nac   = 0 # Number of DOFs for nacelle 
+    nDOF_sft   = 0 # Number of DOFs for shaft
+    nDOF_bld   = 0 # Total number of DOF per blade = nDOF_bld_e+nDOF_bld_f+nDOF_bld_t
+    nDOF_bld_e = 0 # Number of edge DOF per blade
+    nDOF_bld_f = 0 # Number of flap DOF per blade
+    nDOF_bld_t = 0 # Number of torsion DOF per blade
+
+    if not bRotorOnly:
+        # "Foundation"/substructure
+        sFnd= model_name.split('T')[0][1:] # TODO why not F????
+        if len(sFnd)==1:
+            bFndDOFs   = [False]*6
+            nDOF_fnd = int(sFnd[0])
+            bFndDOFs[0]=nDOF_fnd>=1 # x
+            bFndDOFs[4]=nDOF_fnd>=2 # phiy
+            bFndDOFs[2]=nDOF_fnd==3 or nDOF_fnd==6 # z
+            bFndDOFs[1]=nDOF_fnd>=5 # y
+            bFndDOFs[3]=nDOF_fnd>=5 # phi_x
+            bFndDOFs[5]=nDOF_fnd>=5 # phi_z
+        else:
+            bFndDOFs=[s=='1' for s in sFnd]
+
+    if not bRotorOnly:
+        # Tower
+        nDOF_twr = int(model_name.split('T')[1][0])
+
+    if bFullRNA:
+        # Rotor nacelle assembly is made of several bodies and DOFs
+        bNac = model_name.find('N')>0
+        bSft = model_name.find('S')>0
+        bBld = model_name.find('B')>0
+        if bNac:
+            nDOF_nac = int(model_name.split('N')[1][0])
+        if bSft:
+            nDOF_sft = int(model_name.split('S')[1][0])
+        if bBld:
+            sDOF_bld = model_name.split('B')[1]
+            if len(sDOF_bld)==1:
+                nDOF_bld_f = int(sDOF_bld[0])
+            elif len(sDOF_bld)==3:
+                nDOF_bld_f = int(sDOF_bld[0])
+                nDOF_bld_e = int(sDOF_bld[1])
+                nDOF_bld_t = int(sDOF_bld[2])
+            else:
+                raise NotImplementedError()
+
+    else:
+        # Rotor nacelle assembly is one rigid body
+        pass
+
+    nDOF_fnd = sum(bFndDOFs)
+    nDOF_bld = nDOF_bld_f+nDOF_bld_e+nDOF_bld_t
+
+    bldDOFDir = []
+    if True:
+        bldDOFDir += ['x']*nDOF_bld_f
+        bldDOFDir += ['y']*nDOF_bld_e
+        bldDOFDir += ['t']*nDOF_bld_t
+    else:
+        pass # TODO distribute DOFs 1st flap, ed tors, 2nd flap, ed tors, ets
+
+
+    if verbose:
+        print('Degrees of freedom:')
+        print('fnd',','.join(['1' if b else '0' for b in bFndDOFs]), 'twr',nDOF_twr, 'nac',nDOF_nac, 'sft',nDOF_sft, 'nB:{}'.format(opts['nB']), 'bld',nDOF_bld, '({},{},{}) {:s}'.format(nDOF_bld_f,nDOF_bld_e,nDOF_bld_t, ''.join(bldDOFDir)) )
+
     # --------------------------------------------------------------------------------}
-    # --- FEM
+    # --- Isolated bodies 
     # --------------------------------------------------------------------------------{
-    def assembly(self,  gravity=None, Elements=None,):
-        if Elements is None:
-            Elements = self.Elements
-        if gravity is None:
-            gravity=self.gravity
-
-        nDOF=self.nDOF # np.max(self.Nodes[-1].data['DOFs'])+1
-        MM = np.zeros((nDOF,nDOF))
-        KK = np.zeros((nDOF,nDOF))
-        FF = np.zeros(nDOF)
-        
-        # loop over all elements, compute element matrices and assemble into global matrices
-        for e in Elements:
-            # --- Element mass, stiffness, gravity force and other force
-            Ke   = e.Ke()
-            Me   = e.Me()
-            Fe_g = e.Fe_g(gravity)
-            Fe_o = e.Fe_o()
-            IDOF = e.data['DOFs']
-
-            # --- Assembly in global unconstrained system
-            IDOF = e.data['DOFs']
-            KK[np.ix_(IDOF,IDOF)] += Ke
-            MM[np.ix_(IDOF,IDOF)] += Me
-            FF[IDOF] += Fe_g + Fe_o
-
-        # Add concentrated masses to Mass matrix and gravity vector
-        for n in self.Nodes:
-            if 'addedMassMatrix' in n.data.keys():
-                IDOF = n.data['DOFs']
-                MM[np.ix_(IDOF,IDOF)] += n.data['addedMassMatrix']
-                FF[IDOF[2]] -= n.data['addedMassMatrix'][0,0]*gravity # gravity along z DOF index "2"
-
-        self.KK_init= KK
-        self.MM_init= MM 
-        self.FF_init= FF
-        return self
+    # --- Reference frame
+    ref = YAMSInertialBody('E') 
+
+    # --- Fnd Floater/Foundation/Substructure
+    fnd = None
+    if not bRotorOnly:
+        # Foundation, floater, always rigid for now
+        if (not opts['floating']) or opts['mergeFndTwr']:
+            fnd = None # the floater is merged with the twr, or we are not floating
+        else:
+            fnd = YAMSRigidBody('F', rho_G = [0,0,z_FG], J_form='diag') 
+    # --- Tower
+    twr = None
+    if not bRotorOnly:
+        if nDOF_twr==0:
+            # Ridid tower
+            twr = YAMSRigidBody('T', rho_G = [0,0,z_TG], J_form='diag') 
+        elif nDOF_twr<=4:
+            # Flexible tower
+            twr = YAMSFlexibleBody('T', nDOF_twr, directions=opts['twrDOFDir'], orderMM=opts['orderMM'], orderH=opts['orderH'], predefined_kind='twr-z')
+
+    # --- Nacelle rotor assembly
+    blds = []
+    rot  = None
+    nac  = None
+    if bFullRNA:
+        if not bRotorOnly:
+            # Nacelle
+            nac = YAMSRigidBody('N', rho_G = [x_NG ,0, z_NG], J_form='cross') 
+
+        # Shaft
+        # TODO shaft mass and inertia...
+
+        # Individual blades or rotor
+        if bBld:
+            # Creating a fake "rotor body" with no inertia for convenience
+            rot = YAMSRigidBody('R', rho_G = [0,0,0], J_G=[0,0,0], mass=0)
+            #rot.inertia = (inertia(rot.frame, Jxx_R, JO_R, JO_R), rot.origin)  # defining inertia at orign
+            if nDOF_bld==0:
+                print('>>> Rigid blades')
+                # NOTE: for now we assume the blades to be identical, hence the use of name_for_var
+                for ib, b in enumerate(np.arange(opts['nB'])):
+                    B = YAMSRigidBody('B{:d}'.format(ib+1), rho_G = [x_BG ,y_BG, z_BG], name_for_var='B')
+                    blds.append(B)
+            else:
+                print('>>> Flexible blades')
+                # NOTE: for now we assume the blades to be identical, hence the use of name_for_var
+
+                if opts['collectiveBldDOF']:
+                    for ib, b in enumerate(np.arange(opts['nB'])):
+                        B = YAMSFlexibleBody('B{:d}'.format(ib+1), rho_G = [x_BG ,y_BG, z_BG], name_for_var='B', name_for_DOF='B') # <<< Collective DOF (same name)
+                        blds.append(B)
+                else:
+                    for ib, b in enumerate(np.arange(opts['nB'])):
+                        B = YAMSFlexibleBody('B{:d}'.format(ib+1), nDOF_bld, directions=bldDOFDir, orderMM=opts['orderMM'], orderH=opts['orderH'], predefined_kind='bld-z',
+                                name_for_var='B')
+                        blds.append(B)
+        else:
+            # Rotor
+            rot = YAMSRigidBody('R', rho_G = [0,0,0], J_form='diag')
+            rot.inertia = (inertia(rot.frame, Jxx_R, JO_R, JO_R), rot.origin)  # defining inertia at orign
+    else:
+        # Nacelle
+        #nac = YAMSRigidBody('RNA', rho_G = [x_RNAG ,0, z_RNAG], J_diag=True) 
+        nac = YAMSRigidBody('RNA', rho_G = [x_RNAG ,0, z_RNAG], J_form='cross') 
+        rot = None
 
     # --------------------------------------------------------------------------------}
-    # --- Direct elimination of Internal Constraints (Rigid links and rotational joints)
+    # --- Body DOFs
     # --------------------------------------------------------------------------------{
-    def applyInternalConstraints(self):
-        """ 
-        Apply internal constraints such as rigid links and rotational joints
-        using a direct elminination technique
-
-        - Tc: reduction matrix such that x_init= Tc.x     dimension: n x n_c
-              where x is the reduced vector of DOF and x_init is the intial vector (more DOF)
-
-        """
-        rotJoints  = [n.ID for n in self.Nodes    if n.data['Type']!=idJointCantilever]
-        rigidLinks = [e.ID for e in self.Elements if e.data['TypeID']==idMemberRigid    ]
-        if len(rotJoints)>0 or len(rigidLinks)>0:
-            print('Number of Rotational joints:',len(rotJoints))
-            print('Number of Rigid Links      :',len(rigidLinks))
-            from .direct_elimination import nDOF_c, buildTMatrix, rigidLinkAssemblies
-            RA = rigidLinkAssemblies(self)
-            self.T_c = buildTMatrix(self, RA)
-
-        else:
-            self.T_c = np.eye(self.MM_init.shape[0])
-            # Store new DOF indices
-            for n in self.Nodes:
-                n.data['DOFs_c'] = list(n.data['DOFs'])
-                
-        # Distribute Nodal DOFs to Element DOFs
-        for e in self.Elements:
-            e.data['DOFs_c'] =[]
-            for n in e.nodes:
-                e.data['DOFs_c'] +=n.data['DOFs_c']
-
-        self.MM = (self.T_c.T).dot(self.MM_init).dot(self.T_c)
-        self.KK = (self.T_c.T).dot(self.KK_init).dot(self.T_c)
-
-        # --- Creating a convenient Map from DOF to Nodes
-        #p%DOFred2Nodes=-999
-        #do iNode=1,p%nNodes
-        #   nDOFPerNode = len(p%NodesDOFred(iNode))
-        #   do iiDOF = 1, nDOFPerNode
-        #      iDOF = p%NodesDOFred(iNode)%List(iiDOF)
-        #      p%DOFred2Nodes(iDOF,1) = iNode       ! First column is Node index
-        #      p%DOFred2Nodes(iDOF,2) = nDOFPerNode ! Second column is number of DOF per node
-        #      p%DOFred2Nodes(iDOF,3) = iiDOF       ! Third column is number of DOF per node
-
-
-    def partition(self):
-        """
-        Partition DOFs into leader/follower and fixed, following the order convention of SubDyn.
-        
-        Intermediate variables:
-            Partition DOFs and Nodes into sets: 
-            Nodes are partitioned into the I,C,L (and R) sets, Nodes_I, Nodes_C, Nodes_L, with:
-                    I="Interface" nodes
-                    C="Reaction" nodes
-                    L=Interior nodes
-                    R=I+C
-            DOFs indices are partitioned into B, F, L
-                    B=Leader DOFs (Rbar in SubDyn documentation)
-                    F=Fixed DOFS
-                    L=Interior DOFs
-            Subpartitions of both categories use the convention: "NodePartition_DOFPartition"
-               e.g. C_F : "reaction" nodes DOFs that are fixed
-                    C_L : "reaction" nodes DOFs that will be counted as internal
-                    I_B : "interface" nodes DOFs that are leader DOFs
-        """
-        reactionNodes  = self.reactionNodes
-        interfaceNodes = self.interfaceNodes
-        # --- Count DOFs - NOTE: we count node by node
-        nDOF___  = sum([len(n.data['DOFs_c'])                                 for n in self.Nodes])
-        # Interface DOFs
-        nDOFI__  = sum([len(n.data['DOFs_c'])                       for n in interfaceNodes])
-        nDOFI_B = sum([sum(np.array(n.data['IBC'])==idDOF_Leader)   for n in interfaceNodes])
-        # DOFs of reaction nodes
-        nDOFC__ = sum([len(n.data['DOFs_c'])                        for n in reactionNodes]) 
-        nDOFC_B = sum([sum(np.array(n.data['RBC'])==idDOF_Leader)   for n in reactionNodes])
-        # Total number of DOFs in each category:
-        self.nDOFR__ = nDOFI__ + nDOFC__ # Total number, used to be called "nDOFR"
-        self.nDOF__B = nDOFC_B + nDOFI_B
-
-        # --- Distibutes the I, L, C nodal DOFs into  B, F, L sub-categories 
-        # NOTE: order is important for compatibility with SubDyn
-        # TODO: list comprehension
-        IDI__ = []
-        IDI_B = []
-        IDI_F = []
-        for n in interfaceNodes:
-            IDI__ += n.data['DOFs_c'] # NOTE: respects order
-            IDI_B += [dof for i,dof in enumerate(n.data['DOFs_c']) if n.data['IBC'][i]==idDOF_Leader]
-            IDI_F += [dof for i,dof in enumerate(n.data['DOFs_c']) if n.data['IBC'][i]==idDOF_Fixed ]
-        IDI__ = IDI_B+IDI_F
-        IDC__ = []
-        IDC_B = []
-        IDC_L = []
-        IDC_F = []
-        for n in reactionNodes:
-            IDC__ += n.data['DOFs_c'] # NOTE: respects order
-            IDC_B += [dof for i,dof in enumerate(n.data['DOFs_c']) if n.data['RBC'][i]==idDOF_Leader  ]
-            IDC_L += [dof for i,dof in enumerate(n.data['DOFs_c']) if n.data['RBC'][i]==idDOF_Internal]
-            IDC_F += [dof for i,dof in enumerate(n.data['DOFs_c']) if n.data['RBC'][i]==idDOF_Fixed   ]
-        IDR=IDC__+IDI__
-        IDL_L = []
-        for n in self.internalNodes:
-            IDL_L += n.data['DOFs_c']
-
-        # --- Total indices per partition B, F, L
-        self.DOFc_Leader     =         IDC_B + IDI_B  # boundary/retained/leader DOFs
-        self.DOFc_Fixed      =         IDC_F + IDC_B  # Fixed DOFs
-        self.DOFc_Follower   = IDL_L + IDC_L          # internal DOFs
-        self.DOFc_Boundary   = IDR    # I+C Boundary nodes for rigid body equivalent
-        self.DOFc_Internal   = IDL_L  # L   Internal nodes for rigid body equivalent
-        self.DOFc_Interface  = IDI__  # I   Interface
-        ID_ALL = self.DOFc_Leader + self.DOFc_Fixed + self.DOFc_Follower
-        for i in np.arange(nDOF___):
-            if i not in ID_ALL:
-                raise Exception('DOF {} not found in DOF list after partition'.format(i))
+    # --- Fnd
+    if (not opts['floating']):
+        fndDOFs   = []
+        fndSpeeds = []
+    else:
+        fndDOFsAll    = [x, y, z, phi_x,     phi_y,       phi_z]
+        fndSpeedsAll  = [xd,yd,zd,omega_x_T,omega_y_T,omega_z_T]
+        fndDOFs    = [dof for active,dof in zip(bFndDOFs,fndDOFsAll)   if active]
+        fndSpeeds  = [dof for active,dof in zip(bFndDOFs,fndSpeedsAll) if active]
+    # --- Twr
+    twrDOFs   = []
+    twrSpeeds = []
+    if nDOF_twr>0: # flexible tower
+        twrDOFs   = twr.q
+        twrSpeeds = twr.qd
+
+    # --- Nac
+    if nDOF_nac==2:
+        opts['yaw']='dynamic'
+        opts['tilt']='dynamic'
+    if opts['tiltShaft'] and opts['tilt']=='dynamic':
+        raise Exception('Cannot do tiltshaft with tilt dynamic')
+
+    yawDOF  = {'zero':0, 'fixed':theta_yaw,  'dynamic':q_yaw }[opts['yaw']]
+    tiltDOF = {'zero':0, 'fixed':theta_tilt, 'dynamic':q_tilt}[opts['tilt']]
+    nacDOFs     = []
+    nacSpeeds   = []
+    nacKDEqSubs = []
+    if opts['yaw']=='dynamic':
+        nacDOFs     += [q_yaw]
+        nacSpeeds   += [qd_yaw]
+        nacKDEqSubs += [(qd_yaw, diff(q_yaw, time))]
+    if opts['tilt']=='dynamic':
+        nacDOFs     += [q_tilt]
+        nacSpeeds   += [qd_tilt]
+        nacKDEqSubs += [(qd_tilt, diff(q_tilt, time))]
+
+    nacDOFsAct=(opts['yaw']=='dynamic',opts['tilt']=='dynamic')
+    if nDOF_nac==0:
+        if not (nacDOFsAct==(False,False)):
+            raise Exception('If nDOF_nac is 0, yaw and tilt needs to be "fixed" or "zero"')
+    elif nDOF_nac==1:
+        if not (nacDOFsAct==(True,False) or nacDOFsAct==(False,True) ):
+            raise Exception('If nDOF_nac is 1, yaw or tilt needs to be "dynamic"')
+    else:
+        if not (nacDOFsAct==(True,True)):
+            raise Exception('If nDOF_nac is 2, yaw and tilt needs to be "dynamic"')
+
+    # --- Shaft
+    sftDOFs  =[]
+    sftSpeeds=[]
+    if bFullRNA:
+        if nDOF_sft==1:
+            sftDOFs   = [q_psi]
+            sftSpeeds = [omega_x_R]
+        elif nDOF_sft==0:
+            pass
+        else:
+            raise Exception('nDOF shaft should be 0 or 1')
+
+    # --- Blade/Rotor
+    bldDOFs=[] 
+    bldSpeeds=[] 
+    if bFullRNA:
+        bldDOFs   = []
+        bldSpeeds = []
+        if nDOF_bld>0: # flexible tower
+            for ib, bld in enumerate(blds): 
+                bldDOFs   += bld.q
+                bldSpeeds += bld.qd
+
+
+    pitchDOF  = {'zero':0, 'fixed':theta_pitch,  'dynamic':q_pitch }[opts['pitch']]
+    coneDOF   = {'zero':0, 'fixed':theta_cone}[opts['cone']]
+    psi0      = {'zero':0, 'fixed':psi_0}[opts['azimuth_init']]
+    rh        = {'zero':0, 'fixed':r_hub}[opts['r_hub']]
+
+    coordinates = fndDOFs   + twrDOFs   + nacDOFs   + sftDOFs   + bldDOFs 
+    speeds      = fndSpeeds + twrSpeeds + nacSpeeds + sftSpeeds + bldSpeeds  # Order determine eq order
+
+    if verbose:
+        print('>>> Coordinates:',coordinates)
+        print('    speeds     :',speeds)
+
+
 
     # --------------------------------------------------------------------------------}
-    # ---  
+    # --- Connections between bodies
     # --------------------------------------------------------------------------------{
-    def applyFixedBC(self, IFixed=None):
-        """ 
-        Apply boundary conditions. (Fixed boundary conditions only)
-        """
-        # NOTE: we use the matrices where internal constraints have been eliminated 
-        MM = self.MM
-        KK = self.KK
-        nDOF_tot = MM.shape[0]
-        IDOF_All = np.arange(0,nDOF_tot)
-
-        # Tip and root degrees of freedom
-        #IDOF_root = Nodes2DOF[Elem2Nodes[0,:][0] ,:]
-        #IDOF_tip  = Nodes2DOF[Elem2Nodes[-1,:][1],:]
-
-        # --- Boundary condition transformation matrix (removes row/columns)
-        Tr=np.eye(nDOF_tot)
-
-        
-        # Root and Tip BC
-        if IFixed is None:
-            IFixed=[]
-            for n in self.reactionNodes:
-                I = n.data['RBC'][:6]
-                IFixed += [n.data['DOFs_c'][ii] for ii,i in enumerate(I) if int(i)==idDOF_Fixed]
-
-        Tr = np.delete(Tr, IFixed, axis=1) # removing columns
-
-        Mr = (Tr.T).dot(MM).dot(Tr)
-        Kr = (Tr.T).dot(KK).dot(Tr)
-
-        # --- Create mapping from M to Mr
-        nDOF_r = Mr.shape[0]
-        IDOF_BC = list(np.setdiff1d(IDOF_All, IFixed))
-        IFull2BC = np.zeros(nDOF_tot,dtype=int)
-        IBC2Full = np.zeros(nDOF_r,dtype=int)
-        k=0
-        for i in IDOF_All:
-            if i in IFixed:
-                IFull2BC[i]=-1
+    z_OT = Symbol('z_OT')
+    if opts['floating']:
+        rel_pos=[0,0,0]
+        rel_pos[0] = x      if bFndDOFs[0] else 0
+        rel_pos[1] = y      if bFndDOFs[1] else 0
+        rel_pos[2] = z+z_OT if bFndDOFs[2] else z_OT
+        rots =[0,0,0]
+        rots[0] = phi_x if bFndDOFs[3] else 0
+        rots[1] = phi_y if bFndDOFs[4] else 0
+        rots[2] = phi_z if bFndDOFs[5] else 0
+        if nDOF_fnd==0:
+            #print('Rigid connection ref twr', rel_pos)
+            ref.connectTo(twr, type='Rigid' , rel_pos=rel_pos)
+        elif nDOF_fnd==1: 
+            #print('Constraint connection ref twr')
+            #ref.connectTo(twr, type='Free' , rel_pos=(x,0,z_OT), rot_amounts=(0    , x * symbols('nu'), 0   ), rot_order='XYZ')
+            print('>>>> TODO TODO TODO FTNSB_sympy, commented hacked case for nDOF_fnd==1')
+            ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=rots, rot_order='XYZ')  #NOTE: rot order is not "optimal".. phi_x should be last
+        else:
+            #print('Free connection ref twr', rel_pos, rots)
+            ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=rots, rot_order='XYZ')  #NOTE: rot order is not "optimal".. phi_x should be last
+            #ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=(rots[2],rots[1],rots[0]), rot_order='ZYX')  #NOTE: rot order is not "optimal".. phi_x should be last
+    else:
+        if not bRotorOnly:
+            #print('Rigid connection ref twr')
+            ref.connectTo(twr, type='Rigid' , rel_pos=(0,0,0))
+
+    if not bRotorOnly:
+        # Rigid connection between twr and fnd if fnd exists
+        if fnd is not None:
+            #print('Rigid connection twr fnd')
+            if nDOF_twr==0:
+                twr.connectTo(fnd, type='Rigid', rel_pos=(0,0,0)) # -L_F
             else:
-                IFull2BC[i]=k
-                IBC2Full[k]=i
-                k+=1
-
-        self.MM_BC = Mr
-        self.KK_BC = Kr
-        self.T_BC  = Tr
-        #
-        self.DOFr_Leader   = [IFull2BC[i] for i in self.DOFc_Leader]
-        self.DOFr_Follower = [IFull2BC[i] for i in self.DOFc_Follower]
-        self.DOFr_Fixed    = [IFull2BC[i] for i in self.DOFc_Fixed]
-
-        return Mr, Kr, Tr, IFull2BC, IBC2Full
-
-
-    def eig(self, normQ='byMax'):
-        from welib.system.eva import eig
-        KK = self.KK_BC
-        MM = self.MM_BC
-
-        # --- Compute modes and frequencies
-        [Q, freq]= eig(KK, MM, freq_out=True, normQ=normQ, discardIm=True)
-
-        Q   = insertFixedBCinModes(Q, self.T_BC)
-        self.freq = freq
-        self.Q    = Q
-        return Q, freq
+                twr.connectTo(fnd, type='Rigid', rel_pos=(0,0,0)) # -L_F
 
+        if nDOF_twr==0:
+            # Tower rigid -> Rigid connection to nacelle
+            # TODO TODO L_T or twr.L
+            #if nDOF_nac==0:
+            #print('Rigid connection twr nac')
+            #else:
+            #print('Dynamic connection twr nac')
+
+            if opts['tiltShaft']:
+                # Shaft will be tilted, not nacelle
+                twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(yawDOF,0,0), rot_order='ZYX')
+            else:
+                # Nacelle is tilted
+                twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(yawDOF,tiltDOF,0), rot_order='ZYX')
+
+        else:
+            # Flexible tower -> Flexible connection to nacelle
+            #print('Flexible connection twr nac')
+            if opts['tiltShaft']:
+                twr.connectToTip(nac, type='Joint', rel_pos=(0,0,twr.L)  , rot_amounts=(yawDOF, 0      , 0), rot_order='ZYX', rot_type_elastic=opts['rot_elastic_type'], doSubs=opts['rot_elastic_subs'])
+            else:
+                twr.connectToTip(nac, type='Joint', rel_pos=(0,0,twr.L)  , rot_amounts=(yawDOF, tiltDOF, 0), rot_order='ZYX', rot_type_elastic=opts['rot_elastic_type'], doSubs=opts['rot_elastic_subs'])
+
+    # --- Ref to blades
+    if opts['coneAtRotorCenter']:
+        # Like in OpenFAST we cone at the rotor center
+        x_RB = rh * sin(coneDOF) # NOTE: cone <0 for wind turbines, so x_RB<0 (downstream)
+        z_RB = rh * cos(coneDOF)
+    else:
+        x_RB = 0
+        z_RB = rh
+
+    nB = opts['nB']
+    psi_b = [psi0+ib*2 * pi/nB for ib,_ in enumerate(blds)] # blade default azimuthal position
+    if not bRotorOnly:
+        # --- Nacelle to rotor/blades
+        if bFullRNA:
+            if opts['tiltShaft']:
+                if nDOF_sft==0:
+                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,tiltDOF,0), rot_order='ZYX')
+                else:
+                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,tiltDOF,q_psi), rot_order='ZYX')
+            else:
+                if nDOF_sft==0:
+                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,0      ,0), rot_order='ZYX')
+                else:
+                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,0      ,q_psi), rot_order='ZYX')
+            if bBld:
+                print('>>> Rigid connection from rotating shaft to each blades')
+                for ib,bld in enumerate(blds): 
+                    rot.connectTo(bld, type='Rigid', rel_pos=(x_RB,-z_RB*sin(psi_b[ib]), z_RB*cos(psi_b[ib])), rot_amounts=(psi_b[ib], coneDOF, pitchDOF), rot_order='XYZ')
+    else:
+
+        # --- Rotor Only
+        if nDOF_sft==0:
+            ref.connectTo(rot, type='Rigid', rel_pos=(0,0,0), rot_amounts=(0,0,0), rot_order='ZYX')
+        else:
+            ref.connectTo(rot, type='Rigid', rel_pos=(0,0,0), rot_amounts=(0,0,q_psi), rot_order='ZYX')
+
+        print('>>> TODO TODO hub radius, and precone')
+        for ib,bld in enumerate(blds): 
+            print('x_RB', x_RB, 'z_RB',z_RB, psi_b[ib])
+            rot.connectTo(bld, type='Rigid', rel_pos=(x_RB, -z_RB*sin(psi_b[ib]), z_RB*cos(psi_b[ib])), rot_amounts=(psi_b[ib], coneDOF, pitchDOF), rot_order='XYZ')
 
     # --------------------------------------------------------------------------------}
-    # --- Reference point 
+    # --- bodies
     # --------------------------------------------------------------------------------{
-    @property
-    def T_refPoint(self):
-        """ Rigid body transformation matrix from interface DOFs to refpoint"""
-        if self.refPoint is None: 
-            raise Exception('Cannot compute T_refPoint, refPoint is None')
-        return rigidTransformationMatrix(self.DOFc_Interface, self.refPoint, self.DOFc2Nodes, self.points)
+    bodies           = []
+    if fnd is not None:
+        bodies+= [fnd]
+    if twr is not None:
+        bodies      += [twr]
+    if nac is not None:
+        bodies      += [nac]
+    if rot is not None:
+        bodies      += [rot]
+    for ib,bld in enumerate(blds):
+        bodies      += [bld]
+    if verbose:
+        print('>>> Bodies:')
+        for b in bodies:
+            print('name',b.name)
+
     # --------------------------------------------------------------------------------}
-    # --- General FEM Utils
+    # --- Kinetics
     # --------------------------------------------------------------------------------{
-    def setFullMatrices(self,MM,KK,CC=None):
-        self.MM=MM
-        self.KK=KK
-        if CC is not None:
-            self.CC=CC
-
-    def CraigBampton(self, nModesCB=None, BC_before_CB=True):
-        """
-        Perform Craig-Bampton reduction
-
-        nModesCB: number of CB modes to retain
-        zeta :  damping ratios for CB modes 
-        BC_before_CB: if true, using the matrices where the fixed BC have been applied 
-        """
-        from welib.FEM.reduction import CraigBampton
-        if BC_before_CB:
-            M, K = self.MM_BC, self.KK_BC
-            Ileader, Ifollow = self.DOFr_Leader, self.DOFr_Follower
-            if nModesCB is None:
-                nModesCB=M.shape[0] - len(Ileader)
-            # NOTE: we return all CB modes at first
-            Mr, Kr, Phi_G, Phi_CB, f_G, f_CB, I1, I2 = CraigBampton(M, K, Ileader=Ileader, Ifollow=Ifollow, nModesCB=None, discardIm=True)
-            # Small cleanup
-            Phi_G [np.abs(Phi_G )<1e-11] = 0
-            Phi_CB[np.abs(Phi_CB)<1e-11] = 0
-            Mr    [np.abs(Mr    )<1e-11] = 0
-            Kr    [np.abs(Kr    )<1e-11] = 0
-
-            self.DOF_Leader_CB   = I1
-            self.DOF_Follower_CB = I2
-            self.MM_CB  = Mr
-            self.KK_CB  = Kr
-            self.Phi_G  = Phi_G
-            self.Phi_CB = Phi_CB
-            self.f_G    = np.real(f_G)
-            self.f_CB   = f_CB[:nModesCB]
-            omega_CB = 2*np.pi*f_CB[:nModesCB]
-
-            self.nModesCB= nModesCB
-        else:
-            raise NotImplementedError()
-        #if Ifixed is not None:
-        #    M,K = self.applyFixBC()
-        #else:
-        #    M,K = self.MM, self.KK
-
-    def rigidBodyEquivalent(self):
-        """ 
-        Compute Rigid body equivalent mass matrix at origin, 
-        NOTE: Without SSI mass
-        """
-        # 
-        from welib.yams.utils import identifyRigidBodyMM, rigidBodyMassMatrixAtP
-        # Transformation matrix from leader DOFs to Origin
-        TIR= rigidTransformationMatrix(self.DOFc_Boundary, (0,0,0), self.DOFc2Nodes, self.points)
-        # Compute Rigid body mass matrix (without Soil, and using both Interface and Reactions nodes as leader DOF)
-        if self.nDOFR__!=self.nDOF__B: # Most likely the case
-            MBB = self.rigidBody() 
-        else:
-            MBB = model.MM_CB[np.ix_(model.DOF_Leader_CB, model.DOF_Leader_CB)]
-        M_O = TIR.T.dot(MBB).dot(TIR)
-        # Clean up for values that ought to be 0
-        M_O[0,1:3] = 0; 
-        M_O[1,0  ] = 0; M_O[1,2] = 0; M_O[1,4] = 0;
-        M_O[2,0:1] = 0; M_O[2,5] = 0;
-        M_O[3,0  ] = 0; M_O[4,1] = 0; M_O[5,2] = 0;
-        M_O[np.abs(M_O)<1e-6]=0
-        self.M_O            = M_O
-        mass, J_G, Ref2COG  = identifyRigidBodyMM(M_O) # NOTE ref is (0,0,0)
-        self.mass           = mass
-        self.center_of_mass = Ref2COG
-        self.M_G    = rigidBodyMassMatrixAtP(mass, J_G, (0,0,0))
-        if self.refPoint is not None:
-            self.M_ref = rigidBodyMassMatrixAtP(mass, J_G, -np.array(self.refPoint)+np.array(Ref2COG))
-
-    def rigidBody(self):
-        """ Extract rigid body mass without SSI
-        Both "interface" and "reaction" nodes are fixed
-        NOTE: effectively performs a Guyan reduction """
-        from welib.FEM.reduction import CraigBampton
-        # --- Remove SSI from Mass and stiffness matrix (NOTE: use NodesDOFred, reduced matrix)
-        #CALL InsertSoilMatrices(Init%M, Init%K, p%NodesDOFred, Init, p, ErrStat2, ErrMsg2, Substract=.True.);
-        # --- Perform Guyan reduction to get MBB
-        Ileader = self.DOFc_Boundary
-        Ifollow = self.DOFc_Internal
-        Mr, Kr, Phi_G, Phi_CB, f_G, f_CB, I1, I2 = CraigBampton(self.MM, self.KK, Ileader=Ileader, Ifollow=Ifollow, nModesCB=0)
-        #! --- Insert SSI from Mass and stiffness matrix again
-        #CALL InsertSoilMatrices(Init%M, Init%K, p%NodesDOFred, Init, p, ErrStat2, ErrMsg2, Substract=.False.); if(Failed()) return
-        return Mr[np.ix_(I1,I1)] # return Guyan only
+    body_loads       = []
+    g_vect           = -gravity * ref.frame.z
+    # --- Foundation/floater loads
+    if fnd is not None:
+        grav_F = (fnd.masscenter, -fnd.mass * gravity * ref.frame.z)
+        # Point of application for Buoyancy and mooring
+
+        P_O = twr.origin                                       # Body origin
+        #P_M = twr.origin.locatenew('P_M', z_TM * fnd.frame.z) # Mooring      <<<< Measured from T
+        P_M = twr.origin                                       # Mooring (transfered to tower origin)
+        #P_M = twr.origin.locatenew('P_M', z_TM * fnd.frame.z) # <<<< Measured from T
+        #P_0 = twr.origin.locatenew('P_0', (-z_OT) * twr.frame.z) # 0- sea level <<<< Measured from T
+        P_0 = twr.origin.locatenew('P_0', (-z_OT) * fnd.frame.z) # 0- sea level <<<< Measured from T
+        P_M.v2pt_theory(twr.origin, ref.frame, twr.frame); # PM & T are fixed in e_T
+        P_0.v2pt_theory(twr.origin, ref.frame, twr.frame); # P0 & T are fixed in e_T
+
+        if opts['moor_loads']:
+            #K_Mx, K_My, K_Mz          = symbols('K_x_M, K_y_M, K_z_M') # Mooring restoring
+            #K_Mphix, K_Mphiy, K_Mphiz = symbols('K_phi_x_M, K_phi_y_M, K_phi_z_M') # Mooring restoring
+            ### Restoring mooring and torques
+            #fr=0
+            #fr += -K_Mx * x *ref.frame.x if bFndDOFs[0] else 0
+            #fr += -K_My * y *ref.frame.y if bFndDOFs[1] else 0
+            #fr += -K_Mz * z *ref.frame.z if bFndDOFs[2] else 0
+            #Mr += -K_MPhix * phi_x *ref.frame.x if bFndDOFs[3] else 0
+            #Mr += -K_MPhiy * phi_y *ref.frame.y if bFndDOFs[4] else 0
+            #Mr += -K_MPhiz * phi_z *ref.frame.z if bFndDOFs[5] else 0
+            KMoorKeep=[(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(0,4),(1,5)]
+            DOFs=[x, y, z, phi_x, phi_y, phi_z]
+            fr, Mr, KM = stiffness6DOF(DOFs, ref.frame, label='KM', bDOFs=bFndDOFs, IKeep=KMoorKeep)
+            body_loads  += [(fnd, (P_M,  fr))]
+            body_loads  += [(fnd, (fnd.frame, Mr))]
+            print('>>> Adding mooring loads')
+
+        if opts['hydro_loads']:
+            # Hydro force
+            #F_B = dynamicsymbols('F_B') # Buoyancy force
+            F_hx, F_hy, F_hz = dynamicsymbols('F_hx, F_hy, F_hz') # Hydrodynamic force, function to time 
+            M_hx, M_hy, M_hz = dynamicsymbols('M_hx, M_hy, M_hz') # Hydrodynamic moment, function to time 
+            fh = F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z
+            Mh = M_hx * ref.frame.x + M_hy * ref.frame.y + M_hz * ref.frame.z
+            if model_name.find('hydroO')>1:
+                body_loads  += [(fnd, (P_O,  fh))] # NOTE: using P_O
+                print('>>> Adding hydro loads at Tower Origin')
+            else:
+                body_loads  += [(fnd, (P_0,  fh))] # NOTE: using P_0
+                print('>>> Adding hydro loads at Hydro 0-Point')
+            body_loads  += [(fnd, (fnd.frame, Mh))] 
+
+            ##P_0 = body.origin.locatenew('P_0', z_B0 * ref.frame.z) # 0- sea level <<<< Measured from T Does not work
+            ##P_0 = body.origin.locatenew('P_0', z_B0*cos(phi_y) * body.frame.z - z_B0*sin(phi_y) * body.frame.x) # 0- sea level <<<< Measured from T Does not Work
+            ## Hydro force
+            #if modelName.find('hydro0')>1:
+            #    model.addForce(body,  P_0,        F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z)
+            #elif modelName.find('hydroO')>1:
+            #    model.addForce(body,  P_O,        F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z)
+            #else:
+            #    raise NotImplementedError()
+            #model.addMoment(body, body.frame, M_hx * ref.frame.x + M_hy * ref.frame.y + M_hz * ref.frame.z)
+
+
+        # Gravity
+        body_loads  += [(fnd,grav_F)]
+
+    # --- Tower loads
+    if twr is not None:
+        grav_T       = (twr.masscenter, -twr.mass * gravity * ref.frame.z)
+        body_loads  += [(twr,grav_T)]  
+
+    # --- Nacelle loads
+    if nac is not None:
+        grav_N = (nac.masscenter, -nac.mass * gravity * ref.frame.z)
+        body_loads  += [(nac,grav_N)]  
+
+
+    # --- Aero loads
+    T_a              = dynamicsymbols('T_a') # NOTE NOTE
+    #T_a              = Function('T_a')(dynamicsymbols._t, *coordinates, *speeds) # NOTE: to introduce it in the linearization, add coordinates
+    M_ax, M_ay, M_az = dynamicsymbols('M_x_a, M_y_a, M_z_a') # Aero torques
+    if bFullRNA:
+        if bBld:
+            # Gravity on blades
+            for ib,bld in enumerate(blds):
+                grav_B       = (bld.masscenter, -bld.mass * gravity * ref.frame.z)
+                body_loads  += [(bld,grav_B)]  
+
+            print('>>>> TODO aero/misc loads on blades')
+        else:
+            # Rotor loads
+            grav_R = (rot.masscenter, -M_R * gravity * ref.frame.z)
+            body_loads  += [(rot,grav_R)]  
+
+            # NOTE: loads on rot, but expressed in N frame
+            # TODO more than just thrust
+            if opts['tiltShaft']:
+                # TODO actually tilt shaft, introduce non rotating shaft body
+                #thrustR = (rot.origin, T_a *cos(tiltDOF) * nac.frame.x -T_a *sin(tiltDOF) * nac.frame.z)
+                fa_R = (rot.origin, T_a * rot.frame.x)
+                Ma_R = (rot.frame, M_ax*rot.frame.x )# TODO TODO
+            else:
+                fa_R = (rot.origin, T_a * nac.frame.x )
+                #thrustR = (rot.origin, T_a * rot.frame.x )
+                #M_a_R = (nac.frame, M_ax*nac.frame.x +  M_ay*nac.frame.y  + M_az*nac.frame.z) 
+                Ma_R = (rot.frame, M_ax*rot.frame.x +  M_ay*rot.frame.y  + M_az*rot.frame.z)  # TODO TODO TODO introduce a non rotating shaft
+            if opts['aero_forces']:
+                body_loads  += [(rot,fa_R)]
+            if opts['aero_torques']:
+                print('>>> Adding aero torques ')
+                body_loads+=[(nac, Ma_R)]
+
+    else:
+        # RNA loads, point load at R
+        R=Point('R')
+        R.set_pos(nac.origin, x_NR * nac.frame.x + z_NR* nac.frame.z)
+        R.set_vel(nac.frame, 0 * nac.frame.x)
+        R.v2pt_theory(nac.origin, ref.frame, nac.frame)
+        #thrustN = (nac.masscenter, T * nac.frame.x)
+        if opts['tiltShaft']:
+            thrustN = (R, T_a *cos(tiltDOF) * nac.frame.x -T_a *sin(tiltDOF) * nac.frame.z)
+        else:
+            thrustN = (R, T_a * nac.frame.x )
+        if opts['aero_forces']:
+            body_loads  += [(nac,thrustN)]
+
+        if opts['aero_torques']:
+            print('>>> Adding aero torques 3')
+            if opts['tiltShaft']:
+                # NOTE: for a rigid RNA we keep only M_y and M_z, no shaft torque
+                x_tilted = cos(tiltDOF) * nac.frame.x - sin(tiltDOF) * nac.frame.z
+                z_tilted = cos(tiltDOF) * nac.frame.y + sin(tiltDOF) * nac.frame.x
+                M_a_N = (nac.frame,                  M_ay*nac.frame.y + M_az*z_tilted) 
+            else:
+                M_a_N = (nac.frame, M_ax*nac.frame.x +  M_ay*nac.frame.y  + M_az*nac.frame.z)
+            body_loads  += [(nac, M_a_N)]  
+    if verbose:
+        print('>>> Loads:')
+        for (b,l) in body_loads:
+            print(b.name, l)
 
-    
     # --------------------------------------------------------------------------------}
-    # --- IO 
+    # --- Kinematic equations 
     # --------------------------------------------------------------------------------{
-    def nodesDisp(self, UDOF_c, IDOF=None, scale=True, maxAmplitude=None, sortDim=None,):
-        """ 
-        Returns nNodes x 3 x nShapes array of nodal displacements 
-
-        INPUTS:
-          - UDOF: nDOF_c x nModes: array of DOF "displacements" for each mode
-                  in the system wher internal constraints have been eliminated
-          - IDOF: Optional array of subset/reordered DOF. 1:nDOF_c if not provided
-          - scale: if True, modes are shapes according based on `maxAmplitude`
-          - maxAmplitude: if provided, scale used for the mode scaling. If not provided,
-                     maxAmplitude is set to 10% of the maximum dimension of the structure
-          - sortDim: 0,1,2: sort by x,y,z
-        """
-        if IDOF is None:
-            IDOF = list(np.arange(self.nDOF))
-        if maxAmplitude is None:
-            maxAmplitude = self.maxDimension * 0.1 # 10% of max dimension of the structure
-        if True:
-            DOF2Nodes = self.DOF2Nodes
-            UDOF      = self.T_c.dot(UDOF_c)
-        else:
-            DOF2Nodes = self.DOF2Nodes
-            UDOF      = UDOF_c
-        # dimension: n x n_c
-        #self.extent
-        #self.points
-        # --- 
-        INodes = list(np.sort(np.unique(DOF2Nodes[IDOF,1]))) # Sort nodes
-        nShapes = UDOF.shape[1]
-        disp = np.empty((len(INodes),3,nShapes)); disp.fill(np.nan)
-        pos  = np.empty((len(INodes),3))         ; pos.fill(np.nan)
-
-        # --- METHOD 1 - Loop through DOFs KEEP ME
-        #for i,iDOF in enumerate(IDOF):
-        #    iNode       = DOF2Nodes[iDOF,1]
-        #    nDOFPerNode = DOF2Nodes[iDOF,2]
-        #    nodeDOF     = DOF2Nodes[iDOF,3]
-        #    iiNode      = INodes.index(iNode)
-        #    node = self.Nodes[iNode-1]
-        #    if nodeDOF<=3:
-        #        pos[iiNode, 0]= node.x
-        #        pos[iiNode, 1]= node.y
-        #        pos[iiNode, 2]= node.z
-        #        for iShape in np.arange(nShapes):
-        #            disp[iiNode, nodeDOF-1, iShape] = UDOF[i, iShape]
-        # --- METHOD 2 - Loop through DOFs
-        Ix=[]; Iy=[]; Iz=[]
-        for i,n in enumerate(self.Nodes):
-            Ix.append(n.data['DOFs'][0])
-            Iy.append(n.data['DOFs'][1])
-            Iz.append(n.data['DOFs'][2])
-        for iShape in np.arange(nShapes):
-            disp[:, 0, iShape] = UDOF[Ix, iShape]
-            disp[:, 1, iShape] = UDOF[Iy, iShape]
-            disp[:, 2, iShape] = UDOF[Iz, iShape]
-
-        # Scaling 
-        if scale:
-            for iShape in np.arange(nShapes):
-                maxDisp=np.nanmax(np.abs(disp[:, :, iShape]))
-                if maxDisp>1e-5:
-                    disp[:, :, iShape] *= maxAmplitude/maxDisp
-        # Sorting according to a dimension
-        if sortDim is not None: 
-            I=np.argsort(pos[:,sortDim])
-            INodes = np.array(INodes)[I]
-            disp   = disp[I,:,:]
-            pos    = pos[I,:]
-        return disp, pos, INodes
-
-
-    def getModes(self, scale=True, maxAmplitude=None, sortDim=None):
-        """ return Guyan and CB modes
-
-          - maxAmplitude: if provided, scale used for the mode scaling. If not provided,
-                     maxAmplitude is set to 10% of the maximum dimension of the structure
-          - sortDim: 0,1,2: sort by x,y,z
-
-        """
-        if maxAmplitude is None:
-            maxAmplitude = self.maxDimension * 0.1 # 10% of max dimension of the structure
-
-        # CB modes
-        PhiM     = self.Phi_CB
-        PhiM_aug = np.zeros((self.nDOFc, PhiM.shape[1]))
-        PhiM_aug[self.DOFc_Follower, : ] = PhiM
-        dispCB, posCB, INodesCB = self.nodesDisp(PhiM_aug, scale=scale, maxAmplitude=maxAmplitude, sortDim=sortDim)
-
-        # Guyan modes
-        PhiR     = self.Phi_G
-        PhiR_aug = np.zeros((self.nDOFc, PhiR.shape[1]))
-        for i in np.arange(len(self.DOFc_Leader)):
-            PhiR_aug[self.DOFc_Leader[i] , i] = 1
-        PhiR_aug[self.DOFc_Follower, : ] = PhiR
-        PhiR_Intf = PhiR_aug.dot(self.T_refPoint) # nDOF x 6 (since TI is nGY x 6)
-        dispGy, posGy, INodesGy = self.nodesDisp(PhiR_Intf, scale=scale, maxAmplitude=maxAmplitude, sortDim=sortDim)
-
-        return dispGy, posGy, INodesGy, dispCB, posCB, INodesCB
-
-
-    def setModes(self, nModesFEM=30, nModesCB=None):
-        if nModesCB is None:
-            nModesCB = len(self.f_CB)
-
-        # FEM Modes
-        dispFEM, posFEM, INodesFEM = self.nodesDisp(self.Q)
-        for iMode in range(min(dispFEM.shape[2], nModesFEM)):
-            self.addMode(displ=dispFEM[:,:,iMode], name='FEM{:d}'.format(iMode+1), freq=self.freq[iMode], group='FEM')
-
-        # GY CB Modes
-        dispGy, posGy, InodesGy, dispCB, posCB, InodesCB = self.getModes(sortDim=None) 
-        for iMode in range(dispGy.shape[2]):
-            self.addMode(displ=dispGy[:,:,iMode], name='GY{:d}'.format(iMode+1), freq=self.f_G[iMode], group='GY')
-
-        for iMode in range(min(len(self.f_CB), nModesCB)):
-            self.addMode(displ=dispCB[:,:,iMode], name='CB{:d}'.format(iMode+1), freq=self.f_CB[iMode], group='CB') 
-
-
-
-# --------------------------------------------------------------------------------}
-# --- Helper functions 
-# --------------------------------------------------------------------------------{
-def distributeDOF(g, mainElementType='frame3d'):
-    """ 
-    Given a list of Nodes and Elements, distribute degrees of freedom (DOFs) 
-    to each node and elements.
-     For Cantilever Joint -> Condensation into 3 translational and 3 rotational DOFs
-     For other joint type -> Condensation of the 3 translational DOF
-                          -> Keeping 3 rotational DOF for each element connected to the joint
+    # --- Defining Body rotational velocities
+    if not bRotorOnly:
+        omega_TE = twr.ang_vel_in(ref)        # Angular velocity of nacelle in inertial frame
+        omega_NT = nac.ang_vel_in(twr.frame)  # Angular velocity of nacelle in inertial frame
+        if rot is not None:
+            omega_RN = rot.ang_vel_in(nac.frame)  # Angular velocity of rotor wrt Nacelle (omega_R-omega_N)
+    else:
+        # Rotor only
+        omega_RN = diff(q_psi, time) * ref.frame.x  # Angular velocity of rotor wrt Nacelle (omega_R-omega_N)
+
+
+    kdeqsSubs =[]
+    # --- Fnd
+    if not opts['floating']:
+        # fixed bottom
+        pass
+    else:
+        # Kdeqs for fnd: 
+        #  : (xd, diff(x,time)) and  (omega_y_T, diff(phi_y,time))
+        fndVelAll = [diff(x,time), diff(y,time),  diff(z,time)]
+        if opts['linRot']:
+            fndVelAll += [diff(phi_x,time), diff(phi_y,time),  diff(phi_z,time)]  
+        else:
+            #print('>>>>>>>> TODO sort out which frame')
+            #fndVelAll +=[ omega_TE.dot(ref.frame.x).simplify(), omega_TE.dot(ref.frame.y).simplify(), omega_TE.dot(ref.frame.z).simplify()]  
+            fndVelAll +=[ omega_TE.dot(twr.frame.x).simplify(), omega_TE.dot(twr.frame.y).simplify(), omega_TE.dot(twr.frame.z).simplify()]  
+        kdeqsSubs+=[ (fndSpeedsAll[i], fndVelAll[i]) for i,dof in enumerate(bFndDOFs) if dof] 
+
+    # --- Twr
+    if nDOF_twr>0:
+        kdeqsSubs +=[ (twr.qd[i], twr.qdot[i]) for i,_ in enumerate(twr.q)]; 
+
+    # --- Nac
+    kdeqsSubs+=nacKDEqSubs
+
+    # --- Shaft
+    if bFullRNA:
+        if bBld:
+            if nDOF_sft==1:
+                #print('>>>>>>>> TODO sort out which frame')
+                # I believe we should use omega_RE
+                if rot is None:
+                    kdeqsSubs+=[ (omega_x_R,  omega_RN.dot(ref.frame.x).simplify()) ]  
+                else:
+                    kdeqsSubs+=[ (omega_x_R,  omega_RN.dot(rot.frame.x).simplify()) ]  
+            if nDOF_bld>0:
+                for bld in blds:
+                    kdeqsSubs +=[ (bld.qd[i], bld.qdot[i]) for i,_ in enumerate(bld.q)]; 
+        else:
+            if nDOF_sft==1:
+                #print('>>>>>>>> TODO sort out which frame')
+                # I believe we should use omega_RE
+                kdeqsSubs+=[ (omega_x_R, omega_RN.dot(rot.frame.x).simplify()) ]  
+
+    if verbose:
+        print('>>> kdeqsSubs:', kdeqsSubs)
 
-    INPUTS:
-       g: graph
-    """
 
-    if mainElementType in ['frame3d', 'timoshenko']:
-        nDOFPerElem  = 12
-        nRotPerNode  = 3
-        nDispPerNode = 3
-        nDOFPerNode  = 6
-    else:
-        raise NotImplementedError()
-
-    # --- Attributing DOF to each elements
-    NodesDOF={}
-    ElemsDOF={}
-    for e in g.Elements:
-        ElemsDOF[e.ID] = [-1]*nDOFPerElem
-
-    iPrev=0
-    for iNode, n in enumerate(g.Nodes):
-        # --- Distribute to joints iPrev + 1:6, or, iPrev + 1:(3+3m)
-        elems = g.nodeIDs2Elements[n.ID] # elements connected to current node
-
-        if int(n.data['Type']) == idJointCantilever:
-            nRot=nRotPerNode
-        else:
-            nRot= nRotPerNode*len(elems) 
-        NodesDOF[n.ID] = list(np.arange(0,3+nRot) + iPrev)
-        # --- Distribute to elements
-        for e in elems:
-            nodeIDlist = g.elementIDs2NodeIDs[e.ID]
-            if nodeIDlist.index(n.ID) ==0: # then current node is elem node 1
-                iOff = 0
-            else:                          # current node is elem node 2
-                iOff = 6
-            # Displacements
-            ElemsDOF[e.ID][iOff:iOff+nDispPerNode] =  NodesDOF[n.ID][0:nDispPerNode]
-            # Rotations
-            if int(n.data['Type']) == idJointCantilever:
-                ElemsDOF[e.ID][iOff+nDispPerNode:iOff+nDOFPerNode] =  NodesDOF[n.ID][nDispPerNode:nDOFPerNode]
-            else:
-                ElemsDOF[e.ID][iOff+nDispPerNode:iOff+nDOFPerNode] = NodesDOF[n.ID][nRotPerNode*iElem:nRotPerNode*(iElem+1)] # TODO verify
 
-        iPrev = iPrev + len(NodesDOF[n.ID])
+    # --------------------------------------------------------------------------------}
+    # --- Create a YAMS wrapper model
+    # --------------------------------------------------------------------------------{
+    model = YAMSModel(name=model_name)
+    model.opts        = opts
+    model.ref         = ref
+    model.bodies      = bodies
+    model.body_loads  = body_loads
+    model.coordinates = coordinates
+    model.speeds      = speeds
+    model.kdeqsSubs   = kdeqsSubs
+    #print(model)
+
+    model.fnd=fnd
+    model.twr=twr
+    model.nac=nac
+    model.rot=rot
+    #model.sft=sft
+    model.blds=blds
+    model.g_vect=g_vect
+
+    # Small angles
+    model.smallAnglesFnd    = [phi_x,phi_y,phi_z]
+    if nDOF_twr>0:
+        if opts['rot_elastic_smallAngle']:
+            model.smallAnglesTwr    = twr.vcList
+        else:
+            model.smallAnglesTwr    = []
+    else:
+        model.smallAnglesTwr    = []
 
-    # --- Safety check
-    for e in g.Elements:
-        if any(ElemsDOF[e.ID])<0:
-            Exception('Implementation error in Distribute DOF, some element DOF were not allocated')
-
-    # --- Store DOFs
-    for n in g.Nodes:
-        n.data['DOFs'] = NodesDOF[n.ID]
-    for e in g.Elements:
-        e.data['DOFs'] = ElemsDOF[e.ID]
-    return g
-
-
-if __name__=='__main__':
-    np.set_printoptions(linewidth=500)
-    mdl=SubDynModel()
-    mdl.fromSummaryFile('../../data/Monopile/Pendulum.SD.sum.yaml')
+    model.smallAnglesNac = []
+    if opts['yaw']=='dynamic':
+        model.smallAnglesNac += [q_yaw]
+    if opts['tilt']=='dynamic':
+        model.smallAnglesNac += [q_tilt]
+    model.smallAngles=model.smallAnglesFnd + model.smallAnglesTwr + model.smallAnglesNac
+
+    # Shape normalization
+    if nDOF_twr>0:
+        model.shapeNormSubs= [(v,1) for v in twr.ucList]
+    else:
+        model.shapeNormSubs= []
 
+    return model
```

### Comparing `welib-0.0.2/welib/FEM/fem_sympy.py` & `welib-1.0.0/welib/FEM/fem_sympy.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/frame2d.py` & `welib-1.0.0/welib/FEM/frame2d.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,7 +1,20 @@
+"""
+Hermitian beam element with 3DOF per node.
+  - Elongation (along x)
+  - Bending in one transverse direction (y)
+Euler-Bernoulli beam model. 
+        
+The beam coordinate system is such that the cross section is assumed to be in the y-z plane
+(along x)
+    
+Nodal DOF   : (ux uy theta)
+Element DOFs: (ux1 uy1 t1 ux2 uy2 t2) or (u1,u2,u3,u4,u5,u6)
+"""
+
 import numpy as np
 
 # --------------------------------------------------------------------------------}
 # --- Shape functions, displacement field, energy
 # --------------------------------------------------------------------------------{
 def b1(s) :
     return 1-s 
@@ -29,23 +42,15 @@
 
 # --------------------------------------------------------------------------------}
 # --- Element formulation 
 # --------------------------------------------------------------------------------{
 def frame2d_KeMe(EA,EI,L,Mass,T=0,theta=None, MMFormulation='consistent'):
     r""" 
     Stiffness and mass matrices for Hermitian beam element with 3DOF per node.
-      - Elongation (along x)
-      - Bending in one transverse direction (y)
-    Euler-Bernoulli beam model. 
-        
-    The beam coordinate system is such that the cross section is assumed to be in the y-z plane
-    (along x)
-        
-    Nodal DOF   : (ux uy theta)
-    Element DOFs: (ux1 uy1 t1 ux2 uy2 t2) or (u1,u2,u3,u4,u5,u6)
+    See element description at top of script.
         
     INPUTS
         EA  : Young Modulus times Cross section.
         EI  : Young Modulus times Planar second moment of area,local y-axis. Iy=\iint z^2 dy dz [m4]
         L   :    Element length
         Mass :    Element mass = rho * A * L [kg]
```

### Comparing `welib-0.0.2/welib/FEM/frame3d.py` & `welib-1.0.0/welib/FEM/frame3d.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,27 +1,69 @@
+""" 
+Low level functions for frame3D finite element models
+
+See folder derivation for sympy derivations.
+
+Euler-Bernoulli beam model. The torsion is de-coupled to the rest, not like Timoshenko.
+The beam coordinate system is such that the cross section is assumed to be in the y-z plane
+    
+(ux uy uz thetax thetay thetaz)
+(ux1 uy1 uz1 tx1 ty1 tz1 ux2 uy2 yz2 tx2 ty2 tz2)
+    
+The torsional equation is fully decoupled and as follows:
+  Ipx/3A Mass txddot  + G Kv /L tx = Torsional Moment
+
+
+main_axis='x' (assumed by default here)
+ ^x
+ |
+ |
+ |
+ | 
+ ------> y
+
+main_axis='z'
+ ^z
+ |
+ | 
+ | 
+ | 
+ ------> x
+
+
+"""
 import numpy as np
 import sympy
-import scipy
+from scipy.linalg import block_diag
     
 # --------------------------------------------------------------------------------}
 # --- Shape functions, displacement field, energy
 # --------------------------------------------------------------------------------{
-def b1(s) :
+def b1(s):  #Na
     return 1-s 
-def b4(s) :
+def b4(s):  #N2a
     return s 
-def b2(s) :
+def b2(s):    # N1
     return 1 -3*s**2 + 2*s**3
-def b3(s,L) :
+def b3(s,L):  # N2
     return L*s*(1-s)**2       
-def b5(s) :
+def b5(s):    # N3
     return 3*s**2 - 2*s**3     
-def b6(s,L) :
+def b6(s,L):  # N4
     return  L*s**2*(s-1)       
 
+def N1(x,L):
+    return b2(x/L)
+def N2(x,L):
+    return b3(x/L,L)
+def N3(x,L):
+    return b5(x/L,L)
+def N4(x,L):
+    return b6(x/L,L)
+
 def frame3d_N(x,L):
     """  Interpolation matrix from nodal DOF to deflections for a 3d frame
      [   u_x   ]  = N(x) * [ux1,uy1,uz1,tx1,...,tz2]^t
      [   u_y   ]
      [   u_z   ]
      [\theta_x ]
     """
@@ -64,61 +106,62 @@
     s=x/L
     return  u_2*b2(s) + u_3*b3(s,L) +u_5*b5(s) + u_6*b6(s,L)
 
 
 # --------------------------------------------------------------------------------}
 # --- Element formulation 
 # --------------------------------------------------------------------------------{
-
 def frame3d_KeMe(E,G,Kv,EA,EIx,EIy,EIz,L,A,Mass,T=0,R=None, main_axis='x'): 
     """ 
     Stiffness and mass matrices for Hermitian beam element with 6DOF per node
     Beam directed along x
-    See folder derivation for sympy derivations.
 
-    Euler-Bernoulli beam model. The torsion is de-coupled to the rest, not like Timoshenko.
-    The beam coordinate system is such that the cross section is assumed to be in the y-z plane
-        
-    (ux uy uz thetax thetay thetaz)
-    (ux1 uy1 uz1 tx1 ty1 tz1 ux2 uy2 yz2 tx2 ty2 tz2)
-        
-    The torsional equation is fully decoupled and as follows:
-      Ipx/3A Mass txddot  + G Kv /L tx = Torsional Moment
+    See element description at top of script.
         
     INPUTS
-        E : Young's (elastic) modulus
-        Gs: Shear modulus. For an isotropic material G = E/2(nu+1) with nu the Poission's ratio
-        Kv: Saint-Venant's torsion constant, Polar moment of i
-        L :    Element length
-        A :    Cross section area
-        Mass :    Element mass = rho * A * L [kg]
-        EA  : Young Modulus times Cross section.
-        EIx : Young Modulus times Polar  second moment of area,local x-axis. Ix=\iint(y^2+z^2) dy dz [m4]
-        EIy : Young Modulus times Planar second moment of area,local y-axis. Iy=\iint z^2 dy dz [m4]
-        EIz : Young Modulus times Planar second moment of area,local z-axis. Iz=\iint y^2 dy dz [m4]
+      - E : Young's (elastic) modulus [N/m2]
+      - G : Shear modulus. For an isotropic material G = E/2(nu+1) with nu the Poission's ratio [N/m^2]
+      - Kv: Saint-Venant's torsion constant. For circular sections Kv = Polar moment of area (Ixx or Izz)
+      - L :    Element length
+      - A :    Cross section area
+      - Mass :    Element mass = rho * A * L [kg]
+      - EA  : Young Modulus times Cross section.
+      IF: main-axis='x'
+      - EIx : Young Modulus times Polar  second moment of area,local x-axis. Ixx=\iint(y^2+z^2) dy dz [m4]
+      - EIy : Young Modulus times Planar second moment of area,local y-axis. Iyy=\iint z^2 dy dz [m4]
+      - EIz : Young Modulus times Planar second moment of area,local z-axis. Izz=\iint y^2 dy dz [m4]
+      IF: main-axis='z'
+      - EIx : Young Modulus times Planar second moment of area
+      - EIy : Young Modulus times Planar second moment of area
+      - EIz : Young Modulus times Polar  second moment of area 
     OPTIONAL INPUTS
-        T   : Axial loads (along x) to use for the geometric stiffness matrix Kg
-        R   : Transformation matrix (3x3) from global coord to element coord: x_e = R.x_g
+      - T   : Axial loads (along x) to use for the geometric stiffness matrix Kg
+      - R   : Transformation matrix (3x3) from global coord to element coord: x_e = R.x_g
              if provided, element matrix is provided in global coord
     OUTPUTS
-        ke: Element stiffness matrix (12x12)
-        me: Element mass matrix (12x12)
-        Kg: Element geometrical stiffness matrix (12x12)
+      - ke: Element stiffness matrix (12x12)
+      - me: Element mass matrix (12x12)
+      - Kg: Element geometrical stiffness matrix (12x12)
 
         
     AUTHOR: E. Branlard
     """
+    if main_axis=='z':
+        # TODO might need double checking
+        EIx, EIy, EIz = EIz, EIx, EIy # Transfer from main_axis z to main_axis=x
+
+    # NOTE: Equations below are for an element along x
     
     # --- Stiffness matrix
     a = EA / L
     b = 12 * EIz / L ** 3
     c = 6 * EIz / L ** 2
     d = 12 * EIy / L ** 3
     e = 6 * EIy / L ** 2
-    f = G * Kv / L
+    f = G * Kv / L     # torsion torque = Kv * G / L *  torsion_angle
     g = 2 * EIy / L
     h = 2 * EIz / L
     Ke = np.array([
         [a  , 0  , 0  , 0  , 0     , 0     , -a , 0  , 0  , 0  , 0     , 0]     , 
         [0  , b  , 0  , 0  , 0     , c     , 0  , -b , 0  , 0  , 0     , c]     , 
         [0  , 0  , d  , 0  , -e    , 0     , 0  , 0  , -d , 0  , -e    , 0]     , 
         [0  , 0  , 0  , f  , 0     , 0     , 0  , 0  , 0  , -f , 0     , 0]     , 
@@ -128,14 +171,15 @@
         [0  , -b , 0  , 0  , 0     , -c    , 0  , b  , 0  , 0  , 0     , -c]    , 
         [0  , 0  , -d , 0  , e     , 0     , 0  , 0  , d  , 0  , e     , 0]     , 
         [0  , 0  , 0  , -f , 0     , 0     , 0  , 0  , 0  , f  , 0     , 0]     , 
         [0  , 0  , -e , 0  , g     , 0     , 0  , 0  , e  , 0  , 2 * g , 0]     , 
         [0  , c  , 0  , 0  , 0     , h     , 0  , -c , 0  , 0  , 0     , 2 * h]
         ])
     # ---  Mass matrix
+    # NOTE: this mass matrix does not consider Iyy and Izz (see Timoshenko crossterms instead)
     a = L / 2
     a2 = a ** 2
     r2 = EIx / E / A
     Me = Mass / 2 / 105 * np.array( [
                 [70 , 0       , 0       , 0       , 0       , 0       , 35 , 0       , 0       , 0       , 0       , 0]       , 
                 [0  , 78      , 0       , 0       , 0       , 22 * a  , 0  , 27      , 0       , 0       , 0       , -13 * a] , 
                 [0  , 0       , 78      , 0       , -22 * a , 0       , 0  , 0       , 27      , 0       , 13 * a  , 0]       , 
@@ -162,19 +206,29 @@
         [0 , -6./(5*L) , 0         , 0 , 0      , -1./10 , 0 , 6./(5*L)  , 0         , 0 , 0      , -1./10] , 
         [0 , 0         , -6./(5*L) , 0 , 1./10  , 0      , 0 , 0         , 6./(5*L)  , 0 , 1./10  , 0]      , 
         [0 , 0         , 0         , 0 , 0      , 0      , 0 , 0         , 0         , 0 , 0      , 0]      , 
         [0 , 0         , -1./10    , 0 , -L/30  , 0      , 0 , 0         , 1./10     , 0 , 2*L/15 , 0]      , 
         [0 , 1./10     , 0         , 0 , 0      , -L/30  , 0 , -1./10    , 0         , 0 , 0      , 2*L/15]
        ])
 
-
+    # Put element formulation such that main axis is "z"
+    if main_axis=='z':
+        Rx2z = np.array([
+            [0,1,0],
+            [0,0,1],
+            [1,0,0],
+            ])
+        RRx2z = block_diag(Rx2z,Rx2z,Rx2z,Rx2z)
+        Me = RRx2z.dot(Me).dot(RRx2z.T)
+        Ke = RRx2z.dot(Ke).dot(RRx2z.T)
+        Kg = RRx2z.dot(Kg).dot(RRx2z.T)
 
     ## Element in global coord
     if (R is not None):
-        RR = scipy.linalg.block_diag(R,R,R,R)
+        RR = block_diag(R,R,R,R)
         Me = np.transpose(RR).dot(Me).dot(RR)
         Ke = np.transpose(RR).dot(Ke).dot(RR)
         Kg = np.transpose(RR).dot(Kg).dot(RR)
     return Ke, Me, Kg
     
     # ---
     # SOURCE: Panzer-Hubele - Generating a Parametric Finite Element Model of a 3D Cantilever Timoshenko Beam Using Matlab
```

### Comparing `welib-0.0.2/welib/FEM/frame3dlin.py` & `welib-1.0.0/welib/FEM/frame3dlin.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/graph.py` & `welib-1.0.0/welib/FEM/graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -106,19 +106,24 @@
 # --------------------------------------------------------------------------------{
 class Element(dict):
     def __init__(self, ID, nodeIDs, nodes=None, propset=None, propIDs=None, properties=None, **kwargs):
         """ 
 
         """
         self.ID      = int(ID)
+        if nodeIDs is None:
+            if nodes is not None:
+                nodeIDs = [n.ID for n in nodes]
+            else:
+                raise Exception('If `nodeIDs` are not provided, provide `nodes`')
         self.nodeIDs = nodeIDs
         self.propset = propset  # String representing the key in the graph.NodePropertySets dict
         self.propIDs = propIDs
         self.data    = kwargs     # Nodal data
-        self.nodes   = nodes      # Typically a trigger based on nodeIDs
+        self.nodes   = nodes      # Typically a trigger based on nodeIDs # NOTE: Uppercase 
         self.nodeProps= properties # Typically a trigger based on propIDs. Otherwise list of dictionaries
         if (self.propIDs is not None) and (self.propset is None):
             raise Exception('`propset` should be provided if `propIDs` are provided')
         if (self.propIDs is not None) and (self.propset is not None) and properties is not None:
             raise Exception('When providing `propset` & `propIDs`, properties should not be provided')
         if nodes is not None:
             if len(nodes)!=len(nodeIDs):
@@ -129,14 +134,21 @@
         
     @property
     def length(self):
         n1=self.nodes[0]
         n2=self.nodes[1]
         return np.sqrt((n1.x-n2.x)**2+(n1.y-n2.y)**2+(n1.z-n2.z)**2)
 
+    #@property
+    #def nodes(self):
+    #    if self._nodes is None:
+    #        if self.nodeIDs is not None:
+    #            self._nodes=[self.getNode(i) for i in elem.nodeIDs]
+    #    return self._nodes
+
     def swapNodes(self):
         self.nodeIDs   = self.nodeIDs[-1::-1]
         self.nodes     = self.nodes  [-1::-1]
         if self.propIDs is not None:
             self.propIDs   = self.propIDs[-1::-1]
         if self.nodeProps is not None:
             self.nodeProps = self.nodeProps[-1::-1]
@@ -145,14 +157,43 @@
         s='<Elem{:4d}> NodeIDs: {} {}'.format(self.ID, self.nodeIDs, self.data)
         if self.propIDs is not None:
             s+=' {'+'propIDs:{} propset:{}'.format(self.propIDs, self.propset)+'}'
         if self.nodes is not None:
             s+=' l={:.2f}'.format(self.length)
         return s
 
+# --------------------------------------------------------------------------------}
+# --- Member
+# --------------------------------------------------------------------------------{
+class Member(dict):
+    """ Members are used when a graph is divided, to keep track of parent elements"""
+    def __init__(self, ID, elemIDs):
+        """ 
+
+        """
+        self.ID      = int(ID)
+        self.elemIDs = elemIDs
+
+    def nodeIDs(self, graph):
+        nodeIDs=[]
+        for eID in self.elemIDs:
+            E = graph.getElement(eID)
+            nodeIDs.append(E.nodeIDs[0])
+        nodeIDs.append(E.nodeIDs[1])
+        return nodeIDs
+
+    def getNodes(self, graph):
+        return [graph.getNode(nID) for nID in self.nodeIDs(graph)]
+
+    def getElements(self, graph):
+        return [graph.getElement(eID) for eID in self.elemIDs]
+
+    def __repr__(self):
+        s='<Memb{:4d}> ElemIDs{}'.format(self.ID, self.elemIDs)
+        return s
 
 # --------------------------------------------------------------------------------}
 # --- Mode 
 # --------------------------------------------------------------------------------{
 class Mode(dict):
     def __init__(self, displ, name, freq=1, group='default', **kwargs):
         """ """
@@ -458,14 +499,16 @@
 class GraphModel(object):
     def __init__(self, Elements=None, Nodes=None, NodePropertySets=None, ElemPropertySets=None, MiscPropertySets=None): # NOTE: do not initialize with [] or dict()!!!
         self.Elements         = Elements if Elements is not None else []
         self.Nodes            = Nodes    if Nodes    is not None else []
         self.NodePropertySets = NodePropertySets if NodePropertySets is not None else dict()
         self.ElemPropertySets = ElemPropertySets if ElemPropertySets is not None else dict()
         self.MiscPropertySets = MiscPropertySets if MiscPropertySets is not None else dict()
+        # Optional if division happens 
+        self.Members = []
         # Dynamics
         self.Modes   = []
         self.TimeSeries = []
         # Optimization variables
         self._nodeIDs2Elements   = {} # dictionary with key NodeID and value list of ElementID
         self._nodeIDs2Elements   = {} # dictionary with key NodeID and value list of elements
         self._elementIDs2NodeIDs = {} # dictionary with key ElemID and value list of nodes IDs
@@ -492,14 +535,28 @@
 
     def getElement(self, elemID):
         for e in self.Elements:
             if e.ID==elemID:
                 return e
         raise KeyError('ElemID {} not found in Elements'.format(elemID))
 
+    def getMember(self, membID):
+        for m in self.Members:
+            if m.ID==membID:
+                return m
+        raise KeyError('MemberID {} not found in Members'.format(membID))
+
+    def getMemberElements(self, membID):
+        m = self.getMember(membID)
+        return m.getElements(graph=self)
+
+    def getMemberNodes(self, membID):
+        m = self.getMember(membID)
+        return m.getNodes(graph=self)
+
     def getNodeProperty(self, setname, propID):
         for p in self.NodePropertySets[setname]:
             if p.ID==propID:
                 return p
         raise KeyError('PropID {} not found for Node propset {}'.format(propID,setname))
 
     def getElementProperty(self, setname, propID):
@@ -624,14 +681,16 @@
 
     def __repr__(self):
         s='<{} object> with keys:\n'.format(type(self).__name__)
         s+='- Nodes ({}):\n'.format(len(self.Nodes))
         s+='\n'.join(str(n) for n in self.Nodes)
         s+='\n- Elements ({}):\n'.format(len(self.Elements))
         s+='\n'.join(str(n) for n in self.Elements)
+        s+='\n- Members ({}):\n'.format(len(self.Members))
+        s+='\n'.join(str(n) for n in self.Members)
         s+='\n- NodePropertySets ({}):'.format(len(self.NodePropertySets))
         for k,v in self.NodePropertySets.items():
             s+='\n> {} ({}):\n'.format(k, len(v))
             s+='\n'.join(str(p) for p in v)
         s+='\n- ElementPropertySets ({}):'.format(len(self.ElemPropertySets))
         for k,v in self.ElemPropertySets.items():
             s+='\n> {} ({}):\n'.format(k, len(v))
@@ -721,14 +780,43 @@
     def nodeIDsHaveChanged(self):
         """ 
         If User changes node.ID for the nodes, change the elements to reflect that
         """
         for e in self.Elements:
             e.nodeIDs=[n.ID for n in e.nodes]
 
+    def sortNodesBy(self,key):
+        """ Sort nodes, will affect the connectivity, but node IDs remain the same"""
+
+        # TODO, that's quite doable
+        if len(self.Modes)>0:
+            raise Exception('Cannot sort nodes when mode data is present')
+        if len(self.TimeSeries)>0:
+            raise Exception('Cannot sort nodes when timeseries are present')
+
+        nNodes = len(self.Nodes)
+        if key=='x':
+            values=[n.x for n in self.Nodes]
+        elif key=='y':
+            values=[n.y for n in self.Nodes]
+        elif key=='z':
+            values=[n.z for n in self.Nodes]
+        elif key=='ID':
+            values=[n.ID for n in self.Nodes]
+        else:
+            values=[n[key] for n in self.Nodes]
+        I= np.argsort(values)
+        self.Nodes=[self.Nodes[i] for i in I]
+
+        # Trigger, remove precomputed values related to connectivity:
+        self.connecticityHasChanged()
+
+        return self
+
+
     def _divideElement(self, elemID, nPerElement, maxElemId, keysNotToCopy=None):
         """ divide a given element by nPerElement (add nodes and elements to graph) """ 
         if len(self.Modes)>0:
             raise Exception('Cannot divide graph when mode data is present')
         if len(self.TimeSeries)>0:
             raise Exception('Cannot divide graph when motion data is present')
         keysNotToCopy = [] if keysNotToCopy is None else keysNotToCopy
@@ -776,42 +864,14 @@
                     else:
                         raise NotImplementedError('Division of element with different properties on both ends. TODO add new property.')
                 elem= Element(maxElemId, [subNodes[i].ID, subNodes[i+1].ID], propset=propset, propIDs=propIDs, **elem_dict )
                 newElems.append(elem)
         return newElems
 
 
-    def sortNodesBy(self,key):
-        """ Sort nodes, will affect the connectivity, but node IDs remain the same"""
-
-        # TODO, that's quite doable
-        if len(self.Modes)>0:
-            raise Exception('Cannot sort nodes when mode data is present')
-        if len(self.TimeSeries)>0:
-            raise Exception('Cannot sort nodes when timeseries are present')
-
-        nNodes = len(self.Nodes)
-        if key=='x':
-            values=[n.x for n in self.Nodes]
-        elif key=='y':
-            values=[n.y for n in self.Nodes]
-        elif key=='z':
-            values=[n.z for n in self.Nodes]
-        elif key=='ID':
-            values=[n.ID for n in self.Nodes]
-        else:
-            values=[n[key] for n in self.Nodes]
-        I= np.argsort(values)
-        self.Nodes=[self.Nodes[i] for i in I]
-
-        # Trigger, remove precomputed values related to connectivity:
-        self.connecticityHasChanged()
-
-        return self
-
     def divideElements(self, nPerElement, excludeDataKey='', excludeDataList=None, method='append', keysNotToCopy=None):
         """ divide all elements by nPerElement (add nodes and elements to graph)
 
         - excludeDataKey: is provided, will exclude elements such that e.data[key] in `excludeDataList`
 
         - method: append or insert
 
@@ -831,24 +891,35 @@
         maxNodeId=np.max([n.ID for n in self.Nodes])
         maxElemId=np.max([e.ID for e in self.Elements])
 
         if nPerElement<=0:
             raise Exception('nPerElement should be more than 0')
 
         newElements=[]
+        self.Members=[] 
         for ie in np.arange(len(self.Elements)): # cannot enumerate since length increases
-            elemID = self.Elements[ie].ID
+            E = self.Elements[ie]
+            # Store member as the element might get changed
+            memberElemIDs=[E.ID]
+            memberNodeIDs=E.nodeIDs
+            elemID = E.ID
             if method=='insert':
                 newElements+=[self.getElement(elemID)] # newElements contains
-            if (len(excludeDataKey)>0 and self.Elements[ie].data[excludeDataKey] not in excludeDataList) or len(excludeDataKey)==0:
+            if (len(excludeDataKey)>0 and E.data[excludeDataKey] not in excludeDataList) or len(excludeDataKey)==0:
                 elems = self._divideElement(elemID, nPerElement, maxElemId, keysNotToCopy)
                 maxElemId+=len(elems)
                 newElements+=elems
+                memberElemIDs+= [e.ID for e in elems]
             else:
-                print('Not dividing element with ID {}, based on key `{}` with value `{}`'.format(elemID, excludeDataKey,self.Elements[ie].data[excludeDataKey]))
+                print('Not dividing element with ID {}, based on key `{}` with value `{}`'.format(elemID, excludeDataKey, E.data[excludeDataKey]))
+            # We create a member
+            m = Member(ID=elemID, elemIDs=memberElemIDs)
+            self.Members.append(m)
+
+
         # Adding elements at the end
         if method=='append':
             pass
         elif method=='insert':
             self.Elements=[] # We clear all elements
         else:
             raise NotImplementedError('Element Insertions')
```

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/Main_CraigBampton_2D.m` & `welib-1.0.0/welib/FEM/matlab/examples/Main_CraigBampton_2D.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/Main_CraigBampton_3D.m` & `welib-1.0.0/welib/FEM/matlab/examples/Main_CraigBampton_3D.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/Main_TowerTopExcitation.m` & `welib-1.0.0/welib/FEM/matlab/examples/Main_TowerTopExcitation.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/RefDisp.csv` & `welib-1.0.0/welib/FEM/matlab/examples/RefDisp.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/ThinBeam3D.m` & `welib-1.0.0/welib/FEM/matlab/examples/ThinBeam3D.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/ThinRotatingBeam_FEM.m` & `welib-1.0.0/welib/FEM/matlab/examples/ThinRotatingBeam_FEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/examples/fTowerTopMDKR.m` & `welib-1.0.0/welib/FEM/matlab/examples/fTowerTopMDKR.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fBeamMatrices2D_2DOF.m` & `welib-1.0.0/welib/FEM/matlab/fBeamMatrices2D_2DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fBeamMatrices3D_Frame6DOF.m` & `welib-1.0.0/welib/FEM/matlab/fBeamMatrices3D_Frame6DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamFEM2D.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamFEM2D.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamFEM3D_Frame.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamFEM3D_Frame.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamModes2D_2DOF.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamModes2D_2DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRayleighRitz.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRayleighRitz.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRayleighRitzHermitian.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRayleighRitzHermitian.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fClampedBeamModesRotating.m` & `welib-1.0.0/welib/FEM/matlab/fClampedBeamModesRotating.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fCraigBamptonReduce.m` & `welib-1.0.0/welib/FEM/matlab/fCraigBamptonReduce.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fElementMatricesBeam2D_2DOF.m` & `welib-1.0.0/welib/FEM/matlab/fElementMatricesBeam2D_2DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fElementMatricesFrame2D_3DOF.m` & `welib-1.0.0/welib/FEM/matlab/fElementMatricesFrame2D_3DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fElementMatricesFrame3D_6DOF.m` & `welib-1.0.0/welib/FEM/matlab/fElementMatricesFrame3D_6DOF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/matlab/fGuyanReduce.m` & `welib-1.0.0/welib/FEM/matlab/fGuyanReduce.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/reduction.py` & `welib-1.0.0/welib/FEM/reduction.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/tests/_FEMBeam2SID.py` & `welib-1.0.0/welib/FEM/tests/_FEMBeam2SID.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/tests/test_beam_linear_element.py` & `welib-1.0.0/welib/FEM/tests/test_beam_linear_element.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/tests/test_reduction.py` & `welib-1.0.0/welib/FEM/tests/test_reduction.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/tests/test_run_Examples.py` & `welib-1.0.0/welib/airfoils/tests/test_run_Examples.py`

 * *Files 0% similar despite different names*

```diff
@@ -15,23 +15,22 @@
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
         files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
+        print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
-            print('\n--------------------------------------------------------------')
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-
-        try:
-            import matplotlib.pyplot as plt
-            plt.close('all')
-        except:
-            pass
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/FEM/tests/test_utils.py` & `welib-1.0.0/welib/FEM/tests/test_utils.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/FEM/timoshenko.py` & `welib-1.0.0/welib/FEM/timoshenko.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,38 +1,62 @@
-import numpy as np
-import scipy
+"""
+
+main_axis='z' (assumed by default here)
+ ^z
+ |
+ | 
+ | 
+ | 
+ ------> x
+
+main_axis='x'
+ ^x
+ |
+ |
+ |
+ | 
+ ------> y
 
+"""
+
+import numpy as np
+from scipy.linalg import block_diag
 
-def timoshenko_KeMe(L, A, Ixx, Iyy, Jzz, kappa, E, G, rho, R=None, main_axis='z'): 
-    Me = timoshenko_Me(L, A, Ixx, Iyy, Jzz, rho, R=R, main_axis=main_axis)
-    Ke = timoshenko_Ke(L, A, Ixx, Iyy, Jzz, kappa, E, G, shear=True, R=R, main_axis=main_axis)
+def timoshenko_KeMe(L, A, Ixx, Iyy, Izz, kappa, E, G, rho, R=None, main_axis='z', shear=True, crossterms=True): 
+    Me = timoshenko_Me(L, A, Ixx, Iyy, Izz, rho, R=R, main_axis=main_axis, crossterms=crossterms)
+    Ke = timoshenko_Ke(L, A, Ixx, Iyy, Izz, kappa, E, G, shear=shear, R=R, main_axis=main_axis)
     return Ke, Me
 
-def timoshenko_Me(L, A, Ixx, Iyy, Jzz, rho, R=None, main_axis='z'):
+def timoshenko_Me(L, A, Ixx, Iyy, Izz, rho, R=None, main_axis='z', crossterms=True):
     """ Element Mass matrix for Timoshenko beam elements
 
     NOTE: beam is along z
 
     INPUTS:
-     - E : Young'se (elastic) modulus
-     - L : Elemente length
-     - A : Cross seection area
+     - E : Young's (elastic) modulus [N/m2]
+     - L : Element length [m]
+     - A : Cross section area [m^2]
+     - rho: Material density [kg/m^3] 
 
     OPTIONAL INPUTeS
         R   : Transformation matrix (3x3) from global coord to element coord: x_e = R.x_g
              if provided, element matrix is provided in global coord
 
     """
-    if main_axis!='z':
-        raise NotImplementedError()
+    if main_axis=='x':
+        Ixx, Iyy, Izz = Iyy, Izz, Ixx  # Transfer from main_axis=x to main_axis=z
 
     t = rho*A*L
-    rx = rho*Ixx
-    ry = rho*Iyy
-    po = rho*Jzz*L   
+    if crossterms:
+        rx = rho*Ixx
+        ry = rho*Iyy
+    else:
+        rx=0
+        ry=0
+    po = rho*Izz*L   
 
     Me = np.zeros((12,12))
        
     Me[ 8,  8] = t/3.
     Me[ 6,  6] = 13.*t/35. + 6.*ry/(5.*L)
     Me[ 7,  7] = 13.*t/35. + 6.*rx/(5.*L)
     Me[11, 11] = po/3.
@@ -69,51 +93,63 @@
     Me[ 9,  7] = Me[ 7,  9]
     Me[10,  6] = Me[ 6, 10]
     Me[ 6,  0] = Me[ 0,  6]
     Me[ 7,  1] = Me[ 1,  7]
     Me[ 9,  3] = Me[ 3,  9]
     Me[10,  4] = Me[ 4, 10]
 
+    # Put element formulation such that main axis is "x"
+    if main_axis=='x':
+        Rz2x = np.array([
+            [0,0,1],
+            [1,0,0],
+            [0,1,0],
+            ])
+        RRz2x = block_diag(Rz2x,Rz2x,Rz2x,Rz2x)
+        Me = RRz2x.dot(Me).dot(RRz2x.T)
+
     if (R is not None):
-        RR = scipy.linalg.block_diag(R,R,R,R)
+        RR = block_diag(R,R,R,R)
         Me = np.transpose(RR).dot(Me).dot(RR)
-        Me = (Me + Me.T)/2 # enforcing symmetry
+        #Me = (Me + Me.T)/2 # enforcing symmetry
 
     return Me
 
 
-def timoshenko_Ke(L, A, Ixx, Iyy, Jzz, kappa, E, G, shear=True, R=None, main_axis='z'):
+def timoshenko_Ke(L, A, Ixx, Iyy, Izz, kappa, E, G, shear=True, R=None, main_axis='z'):
     """ Element stiffness matrix for Timoshenko beam elements
 
     NOTE: Beam directed along z
 
     INPUTS:
      - E : Young's (elastic) modulus
      - L : Element length
      - A : Cross section area
      - shear: if true, Timoshenko, else Euler-Bernoulli
      - R    : Transformation matrix (3x3) from global coord to element coord: x_e = R.x_g
               if provided, element matrix is provided in global coord
      """
-    if main_axis!='z':
-        raise NotImplementedError()
+    if main_axis=='x':
+        Ixx, Iyy, Izz = Iyy, Izz, Ixx  # Transfer from main_axis=x to main_axis=z
+
+    # NOTE: equations below are for beam directed along z
     Ke = np.zeros((12,12))
     
-    Ax = kappa*A
-    Ay = kappa*A
     if (shear):
+       Ax = kappa*A
+       Ay = kappa*A
        Kx = 12*E*Iyy / (G*Ax*L*L)
        Ky = 12*E*Ixx / (G*Ay*L*L)
     else:
        Kx = 0
        Ky = 0
     Ke[ 8 , 8 ] = E*A/L
     Ke[ 6 , 6 ] = 12.0*E*Iyy/( L*L*L*(1.0 + Kx))
     Ke[ 7 , 7 ] = 12.0*E*Ixx/( L*L*L*(1.0 + Ky))
-    Ke[11 , 11] = G*Jzz/L
+    Ke[11 , 11] = G*Izz/L 
     Ke[9 , 9  ] = (4.0 + Ky                    ) *E*Ixx / ( L*(1.0+Ky )  )
     Ke[10 , 10] = (4.0 + Kx                    ) *E*Iyy / ( L*(1.0+Kx )  )
     Ke[ 1 , 3 ] = -6.*E*Ixx / ( L*L*(1.0+Ky   ))
     Ke[ 0 , 4 ] = 6.*E*Iyy / ( L*L*(1.0+Kx   ))
     Ke[ 3 , 9 ] = (2.0-Ky                      ) *E*Ixx / ( L*(1.0+Ky )  )
     Ke[ 4 , 10] = (2.0-Kx                      ) *E*Iyy / ( L*(1.0+Kx )  )
 
@@ -147,19 +183,31 @@
     Ke[7  , 9 ] = -Ke[3 , 1 ]
 
     Ke[6  , 4 ] = -Ke[4 , 0 ]
     Ke[4  , 6 ] = -Ke[4 , 0 ]
     Ke[7  , 3 ] = -Ke[3 , 1 ]
     Ke[3  , 7 ] = -Ke[3 , 1 ]
 
+
+    # Put element formulation such that main axis is "x"
+    if main_axis=='x':
+        Rz2x = np.array([
+            [0,0,1],
+            [1,0,0],
+            [0,1,0],
+            ])
+        RRz2x = block_diag(Rz2x,Rz2x,Rz2x,Rz2x)
+        Ke = RRz2x.dot(Ke).dot(RRz2x.T)
+
+
     if (R is not None):
-        RR = scipy.linalg.block_diag(R,R,R,R)
+        RR = block_diag(R,R,R,R)
         #Ke = np.transpose(RR).dot(Ke).dot(RR)
         Ke = np.transpose(RR).dot( ( Ke.dot(RR) ) )
-        Ke = (Ke + Ke.T)/2 # enforcing symmetry 
+        #Ke = (Ke + Ke.T)/2 # enforcing symmetry 
     return Ke
 
 
 def timoshenko_Fe_g(L, A, rho, g, R=np.eye(3), main_axis='z'):
     """
     Calculates the lumped forces and moments due to gravity on a given element.
     The element has two nodes, with the loads for both elements stored in array F. 
@@ -171,27 +219,40 @@
         rho:   material density [kg/m^3]
         g:     acceleration of gravity (along z vertical)
         R:     Transformation matrix (3x3) from global coord to element coord: x_e = R.x_g
                if provided, element matrix is provided in global coord
     """
     F = np.zeros(12)
     w = rho*A*g       # weight per unit length
-    # lumped forces on both nodes (z component only):
-    F[2] = -0.5*L*w 
-    F[8] = F[2]
-    # lumped moments on node 1 (x and y components only):
     TempCoeff = L*L*w/12
-    F[3] = -TempCoeff * R[2,1] # = -L*w*Dy/12
-    F[4] =  TempCoeff * R[2,0] # =  L*w*Dx/12
-    # lumped moments on node 2: (note the opposite sign of node 1 moment)
-    F[9]  = -F[3]
-    F[10] = -F[4]
-    #F(12) is 0 for g along z alone
+    if main_axis=='z':
+        # lumped forces on both nodes (z component only):
+        F[2] = -0.5*L*w 
+        F[8] = F[2]
+        # lumped moments on node 1 (x and y components only):
+        F[3] = -TempCoeff * R[2,1] # = -L*w*Dy/12
+        F[4] =  TempCoeff * R[2,0] # =  L*w*Dx/12
+        # lumped moments on node 2: (note the opposite sign of node 1 moment)
+        F[9]  = -F[3]
+        F[10] = -F[4]
+        #F(12) is 0 for g along z alone
+    else:
+        # lumped forces on both nodes (z component only):
+        F[0] = -0.5*L*w  # gravity along x? waht to do?
+        F[6] = F[2]
+
+        raise NotImplementedError()
     return F
 
+# TODO implement general function for distributed loads px, py, pz
+# For instance, 
+#  eq = [qx qy qz qw];    distributed loads
+#      qx=eq(1); qy=eq(2); qz=eq(3); qw=eq(4);
+#    fle=L/2*[qx qy qz qw -1/6*qz*L 1/6*qy*L qx qy qz qw 1/6*qz*L -1/6*qy*L]';
+
 # SUBROUTINE ElemG(A, L, rho, DirCos, F, g)
 #    REAL(ReKi), INTENT( IN ) :: A     !< area
 #    REAL(ReKi), INTENT( IN ) :: L     !< element length
 #    REAL(ReKi), INTENT( IN ) :: rho   !< density
 #    REAL(FEKi), INTENT( IN)  :: DirCos(3,3)      !< From element to global: xg = DC.xe,  Kg = DC.Ke.DC^t
 #    REAL(ReKi), INTENT( IN ) :: g     !< gravity
 #    REAL(FEKi), INTENT( OUT) :: F(12) !< returned loads. positions 1-6 are the loads for node 1 ; 7-12 are loads for node 2.
```

### Comparing `welib-0.0.2/welib/FEM/utils.py` & `welib-1.0.0/welib/yams/utils.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,262 +1,252 @@
+""" 
+Set of utils useful for Structural and Multi-Body dynamics
+
+"""
+
 import numpy as np
 
+# --- Definitions to ease comparison with sympy versions
+from numpy import cos ,sin
+from welib.yams.rotations import R_x, R_y, R_z
+
+def Matrix(m):
+    return np.asarray(m)
+
 def skew(x):
     """ Returns the skew symmetric matrix M, such that: cross(x,v) = M v 
     [ 0, -z , y]
     [ z,  0 ,-x]
     [-y,  x , 0]
     """
     x=np.asarray(x).ravel()
     return np.array([[0, -x[2], x[1]],[x[2],0,-x[0]],[-x[1],x[0],0]])
 
+def skew2(x):
+    """ Returns the skew(x).skew(x) 
+         [ 0 -z  y]   [ 0 -z  y]   [  -y**2 - z**2  ,       xy       ,         xz      ]
+    S2 = [ z  0 -x] . [ z  0 -x] = [       yx       , - x**2 - z**2  ,         yz      ]
+         [-y  x  0]   [-y  x  0]   [       zx       ,       zy       ,   - x**2 - y**2 ]
+    """
+    x,y,z=np.asarray(x).flatten()
+    return np.array( [
+            [ - y**2 - z**2  ,       x*y      ,         x*z      ],
+            [       y*x      , - x**2 - z**2  ,         y*z      ],
+            [       z*x      ,       z*y      ,   - x**2 - y**2 ]])
+
+def extractVectFromSkew(M):
+    """ Return a 3-vector from a skew matrix """
+    # [ 0, -z , y]
+    # [ z,  0 ,-x]
+    # [-y,  x , 0]
+    M = np.asarray(M)
+    x = 0.5*( M[2,1]-M[1,2])
+    y = 0.5*( M[0,2]-M[2,0])
+    z = 0.5*(-M[0,1]+M[1,0])
+    return np.array([x,y,z])
 
-# --------------------------------------------------------------------------------}
-# --- Direction cosine matrix 
-# --------------------------------------------------------------------------------{
-def DCM(P1, P2, main_axis='z'):
-    """ Computes directional cosine matrix between two points, where `main_axis` is the direction between the two"""
-    return DCM_T(P1,P2, main_axis=main_axis).transpose()
-
-def DCM_T(P1, P2, main_axis='z'):
-    """
-    Computes transpose of directional cosine matrix, where `main_axis` is the direction between the two points.
-    Transforms from element to global coordinates:  xg = DC_T.xe,  Kg = DC_T.Ke.DC_T^t
-    NOTE that this is the transpose of what is normally considered the Direction Cosine Matrix  
-    """
-    Dx = P2[0]-P1[0]
-    Dy = P2[1]-P1[1]
-    Dz = P2[2]-P1[2]
-    Dxy = np.sqrt( Dx**2 + Dy**2 )
-    L   = np.sqrt( Dx**2 + Dy**2 + Dz**2)
-    if L==0:
-        raise Exception('Length is zero')
-
-    R = np.zeros((3,3))
-
-    if main_axis=='z':
-        if Dxy == 0.0: # TODO tolerance?
-            if Dz < 0:   #x is kept along global x
-                R[0, 0] =  1.0
-                R[1, 1] = -1.0
-                R[2, 2] = -1.0
-            else:
-                R[0, 0] = 1.0
-                R[1, 1] = 1.0
-                R[2, 2] = 1.0
-        else:
-            R[0, 0] =  Dy/Dxy
-            R[0, 1] = +Dx*Dz/(L*Dxy)
-            R[0, 2] =  Dx/L
-            R[1, 0] = -Dx/Dxy
-            R[1, 1] = +Dz*Dy/(L*Dxy)
-            R[1, 2] =  Dy/L
-            R[2, 0] = 0.0
-            R[2, 1] = -Dxy/L
-            R[2, 2] = +Dz/L
-    else:
-        raise NotImplementedError()
-    return R
-
-
-# TODO verify that these are DCM and not the transpose
-def elementDCMfromBeamNodes(xNodes, phi=None):
-    """ Generate element Direction cosine matricse (DCM) 
-    from a set of ordered node coordinates defining a beam mean line
 
+def rigidBodyMassMatrix(Mass, J, COG=None): # TODO change interface
+    """ Mass matrix for a rigid body (i.e. mass matrix) Eq.(15) of [1] 
     INPUTS:
-        xNodes: 3 x nNodes
-        phi (optional): nNodes angles about mean line to rotate the section axes
-    OUTPUTS:
-        DCM:  3 x 3 x (nNodes-1)
-    """
-    def null(a, rtol=1e-5):
-        u, s, v = np.linalg.svd(a)
-        rank = (s > rtol*s[0]).sum()
-        return v[rank:].T.copy()
-
-    assert(xNodes.shape[0]==3)
-    nElem=xNodes.shape[1]-1
-    DCM = np.zeros((3,3,nElem))
-    for i in np.arange(nElem):
-        dx= (xNodes[:,i+1]-xNodes[:,i]).reshape(3,1)
-        le = np.linalg.norm(dx) # element length
-        e1 = dx/le # tangent vector
-        if i==0:
-            e1_last = e1
-            e2_last = null(e1.T)[:,0].reshape(3,1) # x,z-> y , y-> -x 
-        # normal vector
-        de1 = e1 - e1_last
-        if np.linalg.norm(de1)<1e-8:
-            e2 = e2_last
-        else:
-            e2 = de1/np.linalg.norm(de1)
-        # Rotation about e1
-        if phi is not None:
-            R  = np.cos(phi[i])*np.eye(3) + np.sin(phi[i])*skew(e1) + (1-np.cos(phi[i]))*e1.dot(e1.T);
-            e2 = R.dot(e2)
-        # Third vector
-        e3=np.cross(e1.ravel(),e2.ravel()).reshape(3,1)
-        DCM[:,:,i]= np.column_stack((e1,e2,e3)).T;
-        e1_last= e1
-        e2_last= e2
-    return DCM
-
+      - Mass: (scalar) mass of the body
+      - J: (3-vector or 3x3 matrix), diagonal coefficients or full inertia matrix at COG
+      - COG: (3-vector) x,y,z position of center of mass
+    """
+    print('[WARN] yams.utils.rigidBodyMassMatrix: the interface of this function does not make much sense and should not be used')
+    S=Mass*skew(COG)
+    MM=np.zeros((6,6))
+    MM[0:3,0:3] = Mass*np.eye(3);
+    MM[0:3,3:6] = -S;
+    MM[3:6,0:3] = S ; # transpose(S)=-S;
+    MM[3:6,3:6] = J ;
+    return MM
 
-
-# --------------------------------------------------------------------------------}
-# --- Rigid transformations 
-# --------------------------------------------------------------------------------{
-def rigidTransformationMatrix(DOF, refPoint, DOF2Nodes, Nodes) :
+def rigidBodyMassMatrixAtP(m=None, J_G=None, Ref2COG=None):
     """ 
-    Returns a rigid body transformation matrix from nDOF to 6 reference DOF: T_ref (6 x nDOF), such that Uref = T_ref.U_subset
-    Typically called to get: 
-      - the transformation from the interface points to the TP point
-      - the transformation from the bottom nodes to SubDyn origin (0,0,)
+    Rigid body mass matrix (6x6) at a given reference point: 
+      the center of gravity (if Ref2COG is None) 
+
 
     INPUTS:
-      DOF(nDOF)   : DOF indices that are used to create the transformation matrix
-      RefPoint(3) : Coordinate of the reference point 
-      DOF2Nodes   : array(nDOF x 4), where columns are: index, node, number of DOF per node, index of DOF in node
-      Nodes       : array(nNodes x 3),  x,y,z coordinates of Nodes
+     - m/tip: (scalar) body mass 
+                     default: None, no mass
+     - J_G: (3-vector or 3x3 matrix), diagonal coefficients or full inertia matrix
+                     with respect to COG of body! 
+                     The inertia is transferred to the reference point if Ref2COG is not None
+                     default: None 
+     - Ref2COG: (3-vector) x,y,z position of center of gravity (COG) with respect to a reference point
+                     default: None, at first/last node.
     OUTPUTS:
-      T_ref(nDOF,6): matrix that relates the subset of DOFs to the reference point
+      - M66 (6x6) : rigid body mass matrix at COG or given point 
     """
-    T_ref = np.zeros((len(DOF), 6))
-    for i,iDOF in enumerate(DOF):
-        iNode       = DOF2Nodes[iDOF,1] # node 
-        nDOFPerNode = DOF2Nodes[iDOF,2] # number of DOF per node
-        iiDOF       = DOF2Nodes[iDOF,3] # dof index for this joint (1-6 for cantilever)
-        if iiDOF<1 or iiDOF>6:
-            import pdb; pdb.set_trace()
-            raise Exception('Node DOF number is not valid. DOF: {} Node: {}'.format(iDOF, iNode))
-        if nDOFPerNode!=6:
-            raise Exception('Node doesnt have 6 DOFs. DOF: {} Node: {}'.format(iDOF, iNode))
-        dx = Nodes[iNode, 0] - refPoint[0]
-        dy = Nodes[iNode, 1] - refPoint[1]
-        dz = Nodes[iNode, 2] - refPoint[2]
-        T_ref[i,: ] = rigidTransformationLine(dx, dy, dz, iiDOF)
-    return T_ref
-
-
+    # Default values
+    if m is None: m=0
+    if Ref2COG is None: Ref2COG=(0,0,0)
+    if J_G is None: J_G=np.zeros((3,3))
+    if len(J_G.flatten()==3): J_G = np.eye(3).dot(J_G)
+
+    M66 = np.zeros((6,6))
+    x,y,z = Ref2COG
+    Jxx,Jxy,Jxz = J_G[0,:]
+    _  ,Jyy,Jyz = J_G[1,:]
+    _  ,_  ,Jzz = J_G[2,:]
+    M66[0, :] =[   m     ,   0     ,   0     ,   0                 ,  z*m                , -y*m                 ]
+    M66[1, :] =[   0     ,   m     ,   0     , -z*m                ,   0                 ,  x*m                 ]
+    M66[2, :] =[   0     ,   0     ,   m     ,  y*m                , -x*m                ,   0                  ]
+    M66[3, :] =[   0     , -z*m    ,  y*m    , Jxx + m*(y**2+z**2) , Jxy - m*x*y         , Jxz  - m*x*z         ]
+    M66[4, :] =[  z*m    ,   0     , -x*m    , Jxy - m*x*y         , Jyy + m*(x**2+z**2) , Jyz  - m*y*z         ]
+    M66[5, :] =[ -y*m    , x*m     ,   0     , Jxz - m*x*z         , Jyz - m*y*z         , Jzz  + m*(x**2+y**2) ]
+    return M66
+
+def identifyRigidBodyMM(MM):
+    """ 
+    Based on a 6x6 mass matrix at a reference point:
+     - Identify the position of the center of mass
+     - Compute the inertia at the center of mass
+    """
+    mass = MM[0,0]
+    # Using average of two coeffs to get estimate of COG
+    xCM = 0.5*( MM[1,5]-MM[2,4])/mass
+    zCM = 0.5*( MM[0,4]-MM[1,3])/mass
+    yCM = 0.5*(-MM[0,5]+MM[2,3])/mass
+    # Distance from refopint to COG
+    Ref2COG=np.array((xCM,yCM,zCM))
+    # Inertia at ref oint
+    J_P = MM[3:6,3:6].copy()
+    # Inertia at COG
+    J_G = translateInertiaMatrixToCOG(J_P, mass, r_PG=Ref2COG ) 
+    return mass, J_G, Ref2COG
+
+
+def translateRigidBodyMassMatrix(M, r_P1P2):
+    """ 
+    Translate a 6x6 rigid mass matrix from point 1 to point 2
+    r_P1P2: vector from point1 to point2 
+    """
+    # First identify main properties (mass, inertia, location of center of mass from previous ref point)
+    mass, J_G, Ref2COG = identifyRigidBodyMM(M)
+    # New COG location from new (x,y) ref point
+    Ref2COG -= np.asarray(r_P1P2)
+    # Compute mass matrix 
+    M_new =  rigidBodyMassMatrixAtP(mass, J_G, Ref2COG)
+    return M_new
 
-def rigidTransformationLine(dx,dy,dz,iLine):
-    """ """
-    if   iLine ==1: Line = (1, 0, 0, 0 ,  dz, -dy)
-    elif iLine ==2: Line = (0, 1, 0,-dz,  0 ,  dx)
-    elif iLine ==3: Line = (0, 0, 1, dy, -dx,  0 )
-    elif iLine ==4: Line = (0, 0, 0, 1 ,  0 ,  0 )
-    elif iLine ==5: Line = (0, 0, 0, 0 ,  1 ,  0 )
-    elif iLine ==6: Line = (0, 0, 0, 0 ,  0 ,  1 )
-    return Line
-
-def rigidTransformationTwoPoints(Ps, Pd):
-    """
-    Linear rigid transformation matrix between DOFs of node j and k where node j (source) is the leader node. 
-        Ps: source
-        Pd: destination
-        T =[ I3   skew(Psource - Pdest)  ] =[ I3   skew(r_0)  ]
-           [ 0    I3                     ]  [ 0    I3         ]
-    """
-    T = np.eye(6) # 1 on the diagonal
-    T[0,4] =  (Pd[2] - Ps[2]) 
-    T[0,5] = -(Pd[1] - Ps[1])
-    T[1,3] = -(Pd[2] - Ps[2])
-    T[1,5] =  (Pd[0] - Ps[0])
-    T[2,3] =  (Pd[1] - Ps[1])
-    T[2,4] = -(Pd[0] - Ps[0]);
-    #T[0:3,3:6] = skew(Ps-Pd)
-    return T
 
-def rigidTransformationTwoPoints_Loads(Ps, Pd):
+def rotateRigidBodyMassMatrix(M_ss, R_s2d):
     """ 
-    Relate loads at source node to destination node:
-      fd = T.dot(fs)
+    Rotate a 6x6 rigid body mass matrix from a source (s) coordinate to destination (d) coordinate system
 
-       T =[ I3           0  ] =  [ I3         0  ]
-          [ skew(Ps-Pd)  I3 ]    [ skew(r0)   I3 ]
+    INPUTS:
+     - M_ss: mass matrix in source coordinate, 6x6 array
+     - R_s2d: transformation matrix source two destination
     """
-    Ps=np.asarray(Ps)
-    Pd=np.asarray(Pd)
-    T = np.eye(6) # 1 on the diagonal
-    T[3:6,0:3] = skew(Ps-Pd)
-    #T_rigid[0,4] =  (Pd[2] - Ps[2]) 
-    #T_rigid[0,5] = -(Pd[1] - Ps[1])
-    #T_rigid[1,3] = -(Pd[2] - Ps[2])
-    #T_rigid[1,5] =  (Pd[0] - Ps[0])
-    #T_rigid[2,3] =  (Pd[1] - Ps[1])
-    #T_rigid[2,4] = -(Pd[0] - Ps[0]);
-    return T
-
+    R66_s2d = np.block(R_s2d)
+    M_dd = R66_s2d.dot(M_ss).dot(R66_s2d.T)
+    return M_dd
 
 
-def rigidTransformationTwoPoints18(Ps, Pd):
-    """
-    Linear rigid body transformation matrix relating the motion between two points
-        motion = position, velocity, acceleration in all 6 DOFs (translation rotation)
-        TODO: in theory, this should be a function fo the operating point velocities
-        Simplified "steady state" version for now
-    """
-    T6 = rigidTransformationTwoPoints(Ps, Pd)
-    T = np.zeros((18,18))
-    T[0:6  ,0:6]   = T6
-    T[6:12 ,6:12]  = T6
-    T[12:18,12:18] = T6
-    return T
 
-def rigidTransformationOnePointToPoints18(Psource, DestPoints):
-    """ 
-    Psource: 3-array: location of the source point
-    DestPoints: n x 3-array: location of the destination points
+# --------------------------------------------------------------------------------}
+# --- Inertia functions 
+# --------------------------------------------------------------------------------{
+def translateInertiaMatrix(I_A, Mass, r_BG, r_AG = np.array([0,0,0])):
     """
-    assert(DestPoints.shape[1]==3)
-    nNodes = DestPoints.shape[0] 
-    T = np.zeros((18*nNodes, 18))
-    for iNode, Pdest in enumerate(DestPoints):
-        T[iNode*18:(iNode+1)*18,:] = rigidTransformationTwoPoints18(Psource, Pdest)
-    return T
-
-def rigidTransformationOnePointToPoints(Psource, DestPoints):
-    """ 
+    Transform inertia matrix with respect to point A to the inertia matrix with respect to point B
+    NOTE: the vectors and the inertia matrix needs to be expressed in the same coordinate system. 
+    NOTE: one of the vector r_BG or r_AG may be empty or 0 instead of [0,0,0];
+    NOTE: if r_AG is not provided it is assumed to be 0, i.e. A=G
+    To avoid this confusion you can use translateInertiaMatrixFromCOG  and translateInertiaMatrixToCOG
+    
     INPUTS:
-     - Psource: 3-array: location of the source point
-     - DestPoints: n x 3-array: location of the destination points
-    OUTPUTS:
-     - matrix 6*nNodes x 6
-    """
-    assert(DestPoints.shape[1]==3)
-    nNodes = DestPoints.shape[0] 
-    T = np.zeros((6*nNodes, 6))
-    for iNode, Pdest in enumerate(DestPoints):
-        T[iNode*6:(iNode+1)*6,:] = rigidTransformationTwoPoints(Psource, Pdest)
-    return T
-
-def rigidTransformationOnePointToPoints_Loads(Psource, DestPoints):
-    """ 
+       I_A  : Inertia matrix 3x3 in the coordinate system A
+       Mass : Mass of the body
+       r_BG: vector from point B to COG of the body
+    
+    OPTIONAL INPUTS:
+       r_AG: vector from point A to point G
+    """
+    if len(r_AG) < 3:
+        r_AG = np.array([0,0,0])
+    if len(r_BG) < 3:
+        r_BG = np.array([0,0,0])   
+    I_B = I_A - Mass*(skew2(r_BG)-skew2(r_AG))
+    #I_G = translateInertiaMatrixToCOG(I_A, Mass, r_AG)
+    #I_B = translateInertiaMatrixFromCOG(I_G, Mass, -np.array(r_BG))
+    return I_B
+
+def translateInertiaMatrixToCOG(I_P, Mass, r_PG): 
+    """ Transform inertia matrix with respect to point P to the inertia matrix with respect to the COG
+    NOTE: the vectors and the inertia matrix needs to be expressed in the same coordinate system.
+    
     INPUTS:
-     - Psource: 3-array: location of the source point
-     - DestPoints: n x 3-array: location of the destination points
-    OUTPUTS:
-     - matrix 6*nNodes x 6
+      I_P  : Inertia matrix 3x3 with respect to point P
+      Mass : Mass of the body
+      r_PG: vector from P to COG 
     """
-    assert(DestPoints.shape[1]==3)
-    nNodes = DestPoints.shape[0] 
-    T = np.zeros((6*nNodes, 6))
-    for iNode, Pdest in enumerate(DestPoints):
-        T[iNode*6:(iNode+1)*6,:] = rigidTransformationTwoPoints_Loads(Psource, Pdest)
-    return T
+    I_G = I_P + Mass * skew2(r_PG)
+    return I_G
 
+def translateInertiaMatrixFromCOG(I_G, Mass, r_GP): 
+    """
+    Transform inertia matrix with respect to COG to the inertia matrix with respect to point P
+    NOTE: the vectors and the inertia matrix needs to be expressed in the same coordinate system.
+    INPUTS:
+       I_G  : Inertia matrix 3x3 with respect to COG
+       Mass : Mass of the body
+       r_GP: vector from COG of the body to point P
+    """
+    I_P = I_G - Mass * skew2(r_GP)
+    return I_P
+    
 
 
-def transferRigidLoads(l6, Ps, Pd, verbose=False):
+# --------------------------------------------------------------------------------}
+# --- Loads 
+# --------------------------------------------------------------------------------{
+def transferLoadsZPoint(ls, z, phi_x, phi_y, phi_z, rot_type='default'):
     """ 
-    Transfer loads (fx,fy,fz,mx,my,mz) from source poinr Ps to destination point Pd
+    Used to transfer loads from HydroF*i to the Platform ref point
 
-    l6:  6-array or (6 x nt) array
-    """
-    l6=np.asarray(l6)
-    if l6.shape[0]!=6:
-        raise Exception('First dimension of l6 should be 6 ({})'.format(l6.shape))
-    T = rigidTransformationTwoPoints_Loads(Ps, Pd)
-    return T.dot(l6)
+    HydroF*i are translated similarly to the ref point, but due to rotation, an extra laver arm is present
 
+    Undisplaced  ->   Displaced:
+           P     ->      P
+           |              \
+           |               \
+           0     ->         0
+
+    HydroF*i are computed at "0" above. 
+    They need to be transfered to P
+
+    z: destination to source (z_s - z_d) = (z_0 - z_P)
+    """
+    # --- Rotation
+    s_b=[0,0,z]
+    from welib.yams.rotations import BodyXYZ_A, smallRot_OF, smallRot_A
+    if rot_type=='default' or rot_type=='bodyXYZ':
+        #  BodyXYZ_A.dot(s_b)
+        r = (  z*np.sin(phi_y) , -z * np.sin(phi_x) * np.cos(phi_y),  z *np.cos(phi_x)* np.cos(phi_y))
+
+    elif rot_type=='smallRot_OF':
+        #  smallRot_OF.T .dot(s_b)
+        r = np.zeros((3,len(phi_z)))
+        for i,(phi_x1,phi_y1, phi_z1) in enumerate(zip(phi_x,phi_y,phi_z)):
+            R_b2g = smallRot_OF(phi_x1, phi_y1, phi_z1).T
+            r[:,i] = R_b2g.dot(s_b)
+
+    elif rot_type=='smallRot':
+        #  smallRot_A .dot(s_b)
+        r = (z*phi_y, -z*phi_x , z)
 
+    else:
+        raise Exception()
+    ld    = np.zeros(ls.shape)
+    # Forces
+    ld[0] = ls[0]
+    ld[1] = ls[1]
+    ld[2] = ls[2]
+    # Moments
+    ld[3] = ls[3] + r[1] * ls[2] - r[2] * ls[1]
+    ld[4] = ls[4] + r[2] * ls[0] - r[0] * ls[2]
+    ld[5] = ls[5] + r[0] * ls[1] - r[1] * ls[0]
+    return ld
```

### Comparing `welib-0.0.2/welib/airfoils/DynamicStall.py` & `welib-1.0.0/welib/airfoils/DynamicStall.py`

 * *Files 4% similar despite different names*

```diff
@@ -5,26 +5,35 @@
 
 # --------------------------------------------------------------------------------}
 # --- Wagner function 
 # --------------------------------------------------------------------------------{
 A1_Jones, A2_Jones, b1_Jones, b2_Jones = 0.165 , 0.335 , 0.0455 , 0.3
 A1_FAST,  A2_FAST,  b1_FAST,  b2_FAST  = 0.3   , 0.7   , 0.14   , 0.53
 
-def wagner(tau_t, constants='Jones'):
+def wagner(tau_t, constants=None, A1=None, A2=None, b1=None, b2=None):
     """ 
     Lift coefficient, Cl, from Wagner function
     INPUTS:
     - tau_t: dimensionless time
+    - constants: string in ['Jones', 'OpenFAST'] or None 
+    - A1, A2, b1, b2 : wagner constants, should be provided if constants is None
 
     Reference:  Wagner - R.T Jones approximation (Jones 1938)
     """
     if constants in ['Jones','HAWC2']: # R.T Jones approximation to Wagner's function (Jones 1938)
         A1, A2, b1, b2 = A1_Jones, A2_Jones, b1_Jones, b2_Jones
     elif constants=='OpenFAST':
         A1, A2, b1, b2 = A1_FAST, A2_FAST, b1_FAST, b2_FAST
+    elif constants is None:
+        if all([A1, A2, b1, b2]):
+            pass # all good
+        else:
+            raise Exception('Provide A1, A2, b1, b2 if constants is None')
+
+
     else:
         raise NotImplementedError('Constants {}'.format(constants))
 
     Cl = 1-A1_Jones*np.exp(-b1_Jones*tau_t)-A2_Jones*np.exp(-b2_Jones*tau_t)
 
     return Cl
 
@@ -97,15 +106,15 @@
     df['x2'] = y[1,:]
     df['x3'] = y[2,:]
     df['x4'] = y[3,:]
     df['alphaE']   = np.zeros(len(time))
     df['alphaF']   = np.zeros(len(time))
     df['ClP']   = np.zeros(len(time))
     for it,t in enumerate(time):
-        Cl, Cd, Cm, alphaE, Tu, fs_aE, Cl_fs, alpha_34, omega, U, alphaF, Clp, fs_aF = dynstall_mhh_outputs(t, y[:,it], u, p, more=True)
+        Cl, Cd, Cm, alphaE, Tu, fs_aE, Cl_fs, alpha_34, omega, U, alphaF, Clp, fs_aF = dynstall_mhh_outputs(t, y[:,it], u, p, calcOutput=True)
         df.loc[it,prefix + 'Vrel_[m/s]']     = U
         df.loc[it,prefix + 'alpha_34_[deg]'] = alpha_34*180/np.pi
         df.loc[it,prefix + 'Cl_[-]']         = Cl
         df.loc[it,prefix + 'Cd_[-]']         = Cd
         df.loc[it,prefix + 'Cm_[-]']         = Cm
         df.loc[it,prefix + 'Tu_[-]']         = Tu
         df.loc[it,prefix + 'alphaE_[deg]']   = alphaE*180/np.pi
@@ -124,15 +133,15 @@
     df[prefix + 'x1_[rad]'] = y[0,:]
     df[prefix + 'x2_[rad]'] = y[1,:]
     df[prefix + 'x3_[-]']   = y[2,:]
     df[prefix + 'x4_[-]']   = y[3,:]
     return df
 
 
-def dynstall_mhh_param_from_polar(P, chord, Tf0=6.0, Tp0=1.5, A1=A1_Jones, A2=A2_Jones, b1=b1_Jones, b2=b2_Jones, constants='Jones'):
+def dynstall_mhh_param_from_polar(P, chord, Tf0=6.0, Tp0=1.5, A1=A1_Jones, A2=A2_Jones, b1=b1_Jones, b2=b2_Jones, constants='Jones', p=None):
     if not isinstance(P,Pol):
         raise Exception('Input should be an instance of the `Polar` class')
     if not P._radians :
         raise Exception('MHH dynamic stall implemented for polars in radians only')
 
     if constants in ['Jones','HAWC2']: 
         A1, A2, b1, b2 = A1_Jones, A2_Jones, b1_Jones, b2_Jones
@@ -141,21 +150,26 @@
     elif constants=='OpenFAST': 
         A1, A2, b1, b2 = A1_FAST, A2_FAST, b1_FAST, b2_FAST
         Tf0 = 3.0
         Tp0 = 1.7
     else:
         raise NotImplementedError('Constants {}'.format(constants))
 
-    p=dict()
+    if p is None:
+        p=dict()
     # Airfoil parameters
-    p['alpha0']     = P._alpha0
+    p['alpha0']     = P._alpha0 # TODO TODO requires compute params
     p['Cla']        = P._linear_slope
+    if p['alpha0'] is None:
+        raise Exception('>>>> TODO need to compute params on polar for MHH dyn stall model')
+    if p['Cla'] is None:
+        raise Exception('>>>> TODO need to compute params on polar for MHH dyn stall model')
     p['chord']      = chord
     # Polar functions
-    p['F_st']  = P.f_st_interp
+    p['F_st']  = P.fs_interp
     p['Cl_fs'] = P.cl_fs_interp
     p['Cl']    = P.cl_interp
     p['Cd']    = P.cd_interp
     p['Cm']    = P.cm_interp
     # Dynamics constants
     p['Tf0'] = Tf0
     p['Tp0'] = Tp0
@@ -167,36 +181,37 @@
     p['U_in_x1x2']       = False
     p['scale_x1_x2']     = False
     p['old_ClCd_dyn']    = True
     return p
 
 def dynstall_mhh_dxdt(t,x,u,p):
     """ Time derivative of states for continous formulation """
-    # States
-    x1=x[0] # Downwash memory term 1
-    x2=x[1] # Downwash memory term 2
-    x3=x[2] # Clp', Lift coefficient with a time lag to the attached lift coeff
-    x4=x[3] # f'' , Final separation point function
     # Inputs
     U         = u['U'](t)
     U_dot     = u['U_dot'](t)
-    #alpha     = u['alpha'](t)
     omega     = u['omega'](t)
     alpha_34  = u['alpha_34'](t)
+    return dynstall_mhh_dxdt_simple(t, x, U, U_dot, omega, alpha_34, p)
+
+def dynstall_mhh_dxdt_simple(t, x, U, U_dot, omega, alpha_34, p):
+    """ Time derivative of states for continous formulation """
+    # States
+    x1=x[0] # Downwash memory term 1
+    x2=x[1] # Downwash memory term 2
+    x3=x[2] # Clp', Lift coefficient with a time lag to the attached lift coeff
+    x4=x[3] # f'' , Final separation point function
     # Parameters
     alpha0 = p['alpha0']
     Cla    = p['Cla']
     c      = p['chord']
     A1     = p['A1']
     A2     = p['A2']
     b1     = p['b1']
     b2     = p['b2']
     F_st   = p['F_st']
-    Cl_fs  = p['Cl_fs']
-    Cd     = p['Cd']
     # Variables derived from inputs
     U  = max(U, 0.01)
     Tu = max(c/(2*U), 1e-4)                                     # Eq. 23
     Tf     = p['Tf0']*Tu  # OLD was twice: Tf = p['Tf0']*c/U
     Tp     = p['Tp0']*Tu  # OLD was twice: Tp = p['Tp0']*c/U
     # Variables derived from states
     if p['alpha0_in_x1x2']:
@@ -218,18 +233,18 @@
         xdot[0] = -1/Tu * (b1 + c * U_dot/(2*U**2)) * x1 + b1 * A1 / Tu * alpha_34
         xdot[1] = -1/Tu * (b2 + c * U_dot/(2*U**2)) * x2 + b2 * A2 / Tu * alpha_34
     else:
         xdot[0] = -1/Tu * (b1 + c * U_dot/(2*U**2)) * x1 + b1 * A1 / Tu * (alpha_34-alpha0)
         xdot[1] = -1/Tu * (b2 + c * U_dot/(2*U**2)) * x2 + b2 * A2 / Tu * (alpha_34-alpha0)
     xdot[2] = -1/Tp                             * x3 + 1/Tp * Clp
     xdot[3] = -1/Tf                             * x4 + 1/Tf * fs_aF
-#     print(t,xdot[3],fs_aF,x4)
     return xdot
 
 
+
 def dynstall_mhh_update_discr(t, dt, xd_old, u, p):
     """ Update discrete states 
     NOTE: discrete states include additional discrete states
     """
     # States
     x1_old       = xd_old[0] # Downwash memory term 1
     x2_old       = xd_old[1] # Downwash memory term 2
@@ -312,21 +327,22 @@
     # Store "old" values
     xd[4] = alpha_34
     xd[5] = Cl_p
     xd[6] = fs_aF
     xd[7] = U
     return xd
 
-def dynstall_mhh_steady(t,u,p):
+def dynstall_mhh_steady(t, u, p):
     """ Return steady state values for the 4 states of the MHH/HGM model"""
     # Inputs
     U         = u['U'](t)
-    U_dot     = u['U_dot'](t)
-    omega     = u['omega'](t)
     alpha_34  = u['alpha_34'](t)
+    return dynstall_mhh_steady_simple(U, alpha_34, p)
+
+def dynstall_mhh_steady_simple(U, alpha_34, p):
     # Parameters
     c      = p['chord']
     alpha0 = p['alpha0']
     Cla    = p['Cla']
     A1     = p['A1']
     A2     = p['A2']
     b1     = p['b1']
@@ -345,26 +361,29 @@
         x2     = A2*(alpha_34 - alpha0)
         alphaE = (alpha_34-alpha0)*(1-A1-A2) + x1 + x2 + alpha0 # Eq. 12
     x3     = Cla * (alphaE-alpha0)
     alphaF = x3/Cla+alpha0               # p. 13
     x4     = F_st(alphaF)
     return [x1,x2,x3,x4]
 
-def dynstall_mhh_outputs(t,x,u,p,more=False):
-    # States
-    x1=x[0] # Downwash memory term 1
-    x2=x[1] # Downwash memory term 2
-    x3=x[2] # Clp', Lift coefficient with a time lag to the attached lift coeff
-    x4=x[3] # f'' , Final separation point function
+def dynstall_mhh_outputs(t, x, u, p, calcOutput=False):
     # Inputs
     U         = u['U'](t)
     U_dot     = u['U_dot'](t)
     alpha     = u['alpha'](t)
     omega     = u['omega'](t)
     alpha_34  = u['alpha_34'](t)
+    return  dynstall_mhh_outputs_simple(t, x, U, U_dot, omega, alpha_34, p, calcOutput=calcOutput)
+
+def dynstall_mhh_outputs_simple(t, x, U, U_dot, omega, alpha_34, p, calcOutput=False):
+    # States
+    x1=x[0] # Downwash memory term 1
+    x2=x[1] # Downwash memory term 2
+    x3=x[2] # Clp', Lift coefficient with a time lag to the attached lift coeff
+    x4=x[3] # f'' , Final separation point function
     # Parameters
     alpha0 = p['alpha0']
     Cla    = p['Cla']
     c      = p['chord']
     A1     = p['A1']
     A2     = p['A2']
     b1     = p['b1']
@@ -429,15 +448,15 @@
         Cd_sep  = (Cd_e-Cd(alpha0))*DeltaCdfpp # <<< TODO alpha_34 or alpha_ac
         # Outputs
         Cl_dyn =  Cl_circ +  Cl_tors + Cl_acc
         Cd_dyn =  Cd_e + Cd_ind + Cd_sep + Cd_tors 
     #Cd_dyn =  Cd(alphaE) + (alpha-alphaE)*Cl(alphaE)
     #Cd_dyn =  Cd(alphaE) + Tu*omega
     Cm_dyn =  Cm_e + Cl_dyn*DeltaCmfpp - np.pi/2*Tu*omega    
-    if more:
+    if calcOutput:
         alphaF = x3/Cla + alpha0
         Clp     = Cla * (alphaE-alpha0) + np.pi * Tu * omega      # Eq. 13
         alphaF  = x3/Cla+alpha0                                   # p. 13
         fs_aF   = F_st(alphaF)                                    # p. 13
 
 
         return Cl_dyn, Cd_dyn, Cm_dyn, alphaE, Tu, fs_aE, Cl_sep_e, alpha_34, omega, U, alphaF, Clp, fs_aF
@@ -446,29 +465,42 @@
 
 
 
 
 # --------------------------------------------------------------------------------}
 # --- Oye's dynamic stall 
 # --------------------------------------------------------------------------------{
-def dynstall_oye_param_from_polar(P,tau=None,tau_chord=None):
+def dynstall_oye_param_from_polar(P,tau=None,tau_chord=None, p=None):
     if tau_chord is None and tau is None:
         raise Exception('Provide `tau` or provide `tau_chord`')
-    p=dict()
+    if p is None:
+        p=dict()
     p['tau']   = 3*tau_chord if tau is None else tau
-    p['F_st']  = P.f_st_interp
+    p['F_st']  = P.fs_interp
     p['Clinv'] = P.cl_inv_interp
     p['Clfs']  = P.cl_fs_interp
     return p
 
 def dynstall_oye_dxdt(t,fs,u,p):
     """ d(fs)/dt = 1/tau (fs_st - fs) """
     alpha   = u['alpha'](t)
     f_st    = p['F_st'](alpha)
     return 1/p['tau'] * (f_st - fs)
 
+def dynstall_oye_dxdt_simple(fs, fs_alpha, tau):
+    """ d(fs)/dt = 1/tau (fs_st - fs) """
+    return 1/tau * (fs_alpha - fs)
+
+def dynstall_oye_steady(alpha, p):
+    """ """
+    return p['F_st'](alpha)
+
 def dynstall_oye_output(t,fs,u,p):
     alpha   = u['alpha'](t)
     Clfs    = p['Clfs'](alpha)
     Clinv   = p['Clinv'](alpha)
     Cl      = fs*Clinv+(1-fs)*Clfs               
     return Cl
+
+def dynstall_oye_output_simple(fs, Clfs, Clinv, Cl_qs, Cd_qs, Cm_qs):
+    Cl      = fs*Clinv+(1-fs)*Clfs               
+    return Cl, Cd_qs, Cm_qs
```

### Comparing `welib-0.0.2/welib/airfoils/Polar.py` & `welib-1.0.0/welib/airfoils/_Polar_Wisdem.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,44 +1,56 @@
-from __future__ import print_function, division
-import numpy as np
+from __future__ import division, print_function
+
 import os
-""" This module contains: 
+import logging
+
+import numpy as np
+
+logger = logging.getLogger("wisdem/weis")
+
+
+""" This module contains:
   - Polar: class to represent a polar (computes steady/unsteady parameters, corrections etc.)
   - blend: function to blend two polars
-  - thicknessinterp_from_one_set: interpolate polars at different thickeness based on one set of polars 
-"""
+  - thicknessinterp_from_one_set: interpolate polars at different thickeness based on one set of polars
 
+  JPJ 7/20 : This class can probably be combined with Polar() from airfoilprep.py.
+  They do not have one-to-one matching for the methods.
+  Because both are not tested extensively, we first need to write tests for both
+  before attempting to combine them.
+"""
 
 
 class Polar(object):
     """
     Defines section lift, drag, and pitching moment coefficients as a
     function of angle of attack at a particular Reynolds number.
     Different parameters may be computed and different corrections applied.
 
     Available routines:
         - cl_interp         : cl at given alpha values
         - cd_interp         : cd at given alpha values
         - cm_interp         : cm at given alpha values
+        - cn_interp         : cn at given alpha values
         - f_st_interp       : separation function (compared to fully separated polar)
         - cl_fs_interp      : cl fully separated at given alpha values
-        - fromfile          : reads of polar from csv of FAST AD15 file
+        - cl_inv_interp     : cl inviscid at given alpha values
         - correction3D      : apply 3D rotatational correction
         - extrapolate       : extend polar data set using Viterna's method
         - unsteadyParams    : computes unsteady params e.g. needed by AeroDyn15
-        - unsteadyparam     : same but (old)
-        - plot              : plot's the polar
-        - alpha0            : computes and return alpha0, also stored in _alpha0
+        - plot              : plots the polar
+        - alpha0            : computes and returns alpha0, also stored in _alpha0
+        - linear_region     : determines the alpha and cl values in the linear region
         - cl_max            : cl_max
         - cl_linear_slope   : linear slope and the linear region
-        - cl_fully_separated: fully separated cl
-        - toAeroDyn: write AeroDyn file 
+        - cl_fully_separated : fully separated cl
+        - dynaStallOye_DiscreteStep : compute aerodynamical force from aerodynamic data
     """
 
-    def __init__(self, FileName_or_Re, alpha=None, cl=None, cd=None, cm=None, compute_params=False, radians=None):
+    def __init__(self, Re, alpha, cl, cd, cm, compute_params=False, radians=None):
         """Constructor
 
         Parameters
         ----------
         Re : float
             Reynolds number
         alpha : ndarray (deg)
@@ -46,210 +58,201 @@
         cl : ndarray
             lift coefficient
         cd : ndarray
             drag coefficient
         cm : ndarray
             moment coefficient
         """
-        if isinstance(FileName_or_Re,str):
-            alpha, cl, cd, cm, Re = loadPolarFile(FileName_or_Re, fformat='auto', to_radians=False)
-        else:
-            Re = FileName_or_Re
 
         self.Re = Re
         self.alpha = np.array(alpha)
         self.cl = np.array(cl)
         self.cd = np.array(cd)
         self.cm = np.array(cm)
-        self.f_st          = None # separation function
-        self.cl_fs         = None # cl_fully separated
+        self.f_st = None  # separation function
+        self.cl_fs = None  # cl_fully separated
         self._linear_slope = None
-        self._alpha0       = None
+        self._alpha0 = None
         if radians is None:
             # If the max alpha is above pi, most likely we are in degrees
-            self._radians = np.mean(np.abs(self.alpha))<=np.pi/2
+            self._radians = np.mean(np.abs(self.alpha)) <= np.pi / 2
         else:
             self._radians = radians
 
         # NOTE: method needs to be in harmony for linear_slope and the one used in cl_fully_separated
         if compute_params:
-            self._linear_slope,self._alpha0=self.cl_linear_slope(method='max') 
+            self._linear_slope, self._alpha0 = self.cl_linear_slope(method="max")
             self.cl_fully_separated()
-            self.cl_inv = self._linear_slope*(self.alpha - self._alpha0)
-
-    def __repr__(self):
-        s='<{} object>:\n'.format(type(self).__name__)
-        s+='Parameters:\n'
-        s+=' - alpha, cl, cd, cm  : arrays of size {}\n'.format(len(self.alpha))
-        s+=' - Re     :            {} \n'.format(self.Re)
-        s+=' - _radians:           {} (True if alpha in radians)\n'.format(self._radians)
-        s+=' - _alpha0:            {} \n'.format(self._alpha0)
-        s+=' - _linear_slope:      {} \n'.format(self._linear_slope)
-        s+='Derived parameters:\n'
-        s+=' * cl_lin             : array of size {} \n'.format(len(self.alpha))
-        s+=' * alpha0 :            {} \n'.format(self.alpha0())
-        s+=' * cl_linear_slope :   {} \n'.format(self.cl_linear_slope())
-        s+=' * cl_max :            {} \n'.format(self.cl_max())
-        s+=' * unsteadyParams :    {} \n'.format(self.unsteadyParams())
-        s+='Useful functions:   cl_interp, cd_interp, cm_interp, f_st_interp \n'
-        s+='                      plot, extrapolate\n'
-        return s
-
+            self.cl_inv = self._linear_slope * (self.alpha - self._alpha0)
 
-    def cl_interp(self,alpha):
+    def cl_interp(self, alpha):
         return np.interp(alpha, self.alpha, self.cl)
 
-    def cd_interp(self,alpha):
+    def cd_interp(self, alpha):
         return np.interp(alpha, self.alpha, self.cd)
 
-    def cm_interp(self,alpha):
+    def cm_interp(self, alpha):
         return np.interp(alpha, self.alpha, self.cm)
 
-    def cn_interp(self,alpha):
+    def cn_interp(self, alpha):
         return np.interp(alpha, self.alpha, self.cn)
 
-    def f_st_interp(self,alpha):
+    def f_st_interp(self, alpha):
         if self.f_st is None:
             self.cl_fully_separated()
         return np.interp(alpha, self.alpha, self.f_st)
 
-    def cl_fs_interp(self,alpha):
+    def cl_fs_interp(self, alpha):
         if self.cl_fs is None:
             self.cl_fully_separated()
         return np.interp(alpha, self.alpha, self.cl_fs)
 
-    def cl_inv_interp(self,alpha):
+    def cl_inv_interp(self, alpha):
         if (self._linear_slope is None) and (self._alpha0 is None):
-            self._linear_slope,self._alpha0=self.cl_linear_slope()
-        return self._linear_slope*(alpha-self._alpha0)
+            self._linear_slope, self._alpha0 = self.cl_linear_slope()
+        return self._linear_slope * (alpha - self._alpha0)
 
     @property
     def cn(self):
-        """ returns  : Cl cos(alpha) +  Cd      sin(alpha)  
-                  NOT: Cl cos(alpha) + (Cd-Cd0) sin(alpha) 
-        """ 
+        """returns  : Cl cos(alpha) +  Cd      sin(alpha)
+        NOT: Cl cos(alpha) + (Cd-Cd0) sin(alpha)
+        """
         if self._radians:
-            return self.cl*np.cos(self.alpha) + self.cd*np.sin(self.alpha)
+            return self.cl * np.cos(self.alpha) + self.cd * np.sin(self.alpha)
         else:
-            return self.cl*np.cos(self.alpha*np.pi/180) + self.cd*np.sin(self.alpha*np.pi/180)
-
-    @property
-    def cl_lin(self):
-        if (self._linear_slope is None) and (self._alpha0 is None):
-            self._linear_slope,self._alpha0=self.cl_linear_slope()
-        return self._linear_slope*(self.alpha-self._alpha0)
-
-
+            return self.cl * np.cos(self.alpha * np.pi / 180) + self.cd * np.sin(self.alpha * np.pi / 180)
 
-
-
-    @classmethod
-    def fromfile(cls,filename,fformat='auto',compute_params=False, to_radians=False):
-        """Constructor based on a filename"""
-        alpha, cl, cd, cm, Re = loadPolarFile(filename, fformat=fformat, to_radians=to_radians)
-        return cls(Re,alpha,cl,cd,cm,compute_params,radians=to_radians)
-
-    def correction3D(self, r_over_R, chord_over_r, tsr, alpha_max_corr=30,
-                     alpha_linear_min=-5, alpha_linear_max=5,
-                     max_cl_corr=0.25,
-                     blending='linear_25_45'
-                     ):
+    def correction3D(
+        self,
+        r_over_R,
+        chord_over_r,
+        tsr,
+        lift_method="DuSelig",
+        drag_method="None",
+        blending_method="linear_25_45",
+        max_cl_corr=0.25,
+        alpha_max_corr=None,
+        alpha_linear_min=None,
+        alpha_linear_max=None,
+    ):
         """Applies 3-D corrections for rotating sections from the 2-D data.
 
         Parameters
         ----------
         r_over_R : float
             local radial position / rotor radius
         chord_over_r : float
             local chord length / local radial location
         tsr : float
             tip-speed ratio
+        lift_method : string, optional
+            flag switching between Du-Selig and Snel corrections
+        drag_method : string, optional
+            flag switching between Eggers correction and None
+        blending_method: string:
+             blending method used to blend from 3D to 2D polar. default 'linear_25_45'
+        max_cl_corr: float, optional
+             maximum correction allowed, default is 0.25.
         alpha_max_corr : float, optional (deg)
             maximum angle of attack to apply full correction
         alpha_linear_min : float, optional (deg)
             angle of attack where linear portion of lift curve slope begins
         alpha_linear_max : float, optional (deg)
             angle of attack where linear portion of lift curve slope ends
-        max_cl_corr: float, optional
-             maximum correction allowed, default is 0.25.
-        blending: string:
-             blending method used to blend from 3D to 2D polar. default 'linear_25_45'
 
         Returns
         -------
         polar : Polar
             A new Polar object corrected for 3-D effects
-
-        Notes
-        -----
-        The Du-Selig method :cite:`Du1998A-3-D-stall-del` is used to correct lift, and
-        the Eggers method :cite:`Eggers-Jr2003An-assessment-o` is used to correct drag.
-
         """
 
+        if alpha_max_corr == None and alpha_linear_min == None and alpha_linear_max == None:
+            alpha_linear_region, _, cl_slope, alpha0 = self.linear_region()
+            alpha_linear_min = alpha_linear_region[0]
+            alpha_linear_max = alpha_linear_region[-1]
+            _, alpha_max_corr = self.cl_max()
+            find_linear_region = False
+        elif alpha_max_corr * alpha_linear_min * alpha_linear_max == None:
+            raise Exception(
+                "Define all or none of the keyword arguments alpha_max_corr, alpha_linear_min, and alpha_linear_max"
+            )
+        else:
+            find_linear_region = True
+
         # rename and convert units for convenience
         alpha = np.radians(self.alpha)
         cl_2d = self.cl
         cd_2d = self.cd
-        alpha_max_corr   = np.radians(alpha_max_corr)
+        alpha_max_corr = np.radians(alpha_max_corr)
         alpha_linear_min = np.radians(alpha_linear_min)
         alpha_linear_max = np.radians(alpha_linear_max)
 
         # parameters in Du-Selig model
         a = 1
         b = 1
         d = 1
-        lam = tsr/(1+tsr**2)**0.5  # modified tip speed ratio
-        expon = d/lam/r_over_R
+        lam = tsr / (1 + tsr ** 2) ** 0.5  # modified tip speed ratio
+        expon = d / lam / r_over_R
 
-        # find linear region
-        idx = np.logical_and(alpha >= alpha_linear_min,
-                             alpha <= alpha_linear_max)
-        p = np.polyfit(alpha[idx], cl_2d[idx], 1)
-        m = p[0]
-        alpha0 = -p[1]/m
-
-        cl_linear = m*(alpha-alpha0)
-
-        # --- correction factor
-        # Du Selig
-        #fcl = 1.0/m*(1.6*chord_over_r/0.1267*(a-chord_over_r**expon)/(b+chord_over_r**expon)-1)
-        # Snel
-        fcl = 3*(chord_over_r)**2
-
-        # not sure where this adjustment comes from (besides AirfoilPrep spreadsheet of course)
-        #adj = ((np.pi/2-alpha)/(np.pi/2-alpha_max_corr))**2
-        #adj[alpha <= alpha_max_corr] = 1.0
+        # find linear region with numpy polyfit
+        if find_linear_region:
+            idx = np.logical_and(alpha >= alpha_linear_min, alpha <= alpha_linear_max)
+            p = np.polyfit(alpha[idx], cl_2d[idx], 1)
+            cl_slope = p[0]
+            alpha0 = -p[1] / cl_slope
+        else:
+            cl_slope = np.degrees(cl_slope)
+            alpha0 = np.radians(alpha0)
+
+        if lift_method == "DuSelig":
+            # Du-Selig correction factor
+            fcl = (
+                1.0
+                / cl_slope
+                * (1.6 * chord_over_r / 0.1267 * (a - chord_over_r ** expon) / (b + chord_over_r ** expon) - 1)
+            )
+        elif lift_method == "Snel":
+            # Snel correction
+            fcl = 3.0 * chord_over_r ** 2.0
+        else:
+            raise Exception("The keyword argument lift_method (3d correction for lift) can only be DuSelig or Snel.")
 
         # 3D correction for lift
-        cl_corr = fcl*(cl_linear-cl_2d)
+        cl_linear = cl_slope * (alpha - alpha0)
+        cl_corr = fcl * (cl_linear - cl_2d)
         # Bound correction +/- max_cl_corr
         cl_corr = np.clip(cl_corr, -max_cl_corr, max_cl_corr)
         # Blending
-        if blending=='linear_25_45':
-            # We adjust fully between +/- 25 deg, linearly to 45
-            adj_alpha=np.radians([-180, -45, -25, 25, 45,180])
-            adj_value=np.array  ([0   ,   0,   1,  1,  0, 0 ])
+        if blending_method == "linear_25_45":
+            # We adjust fully between +/- 25 deg, linearly to +/- 45
+            adj_alpha = np.radians([-180, -45, -25, 25, 45, 180])
+            adj_value = np.array([0, 0, 1, 1, 0, 0])
             adj = np.interp(alpha, adj_alpha, adj_value)
-        elif blending=='heaviside':
-            pass
+        elif blending_method == "heaviside":
+            # Apply (arbitrary!) smoothing function to smoothen the 3D corrections and zero them out away from alpha_max_corr
+            delta_corr = 10
+            y1 = 1.0 - smooth_heaviside(alpha, k=1, rng=(alpha_max_corr, alpha_max_corr + np.deg2rad(delta_corr)))
+            y2 = smooth_heaviside(alpha, k=1, rng=(0.0, np.deg2rad(delta_corr)))
+            adj = y1 * y2
         else:
-            raise NotImplementedError('blending :',blending)
-        cl_3d = cl_2d + cl_corr*adj
+            raise NotImplementedError("blending :", blending_method)
+        cl_3d = cl_2d + cl_corr * adj
 
         # Eggers 2003 correction for drag
-        delta_cl = cl_3d-cl_2d
+        if drag_method == "Eggers":
+            delta_cd = cl_corr * (np.sin(alpha) - 0.12 * np.cos(alpha)) / (np.cos(alpha) + 0.12 * np.sin(alpha)) * adj
+        elif drag_method == "None":
+            delta_cd = 0.0
+        else:
+            raise Exception("The keyword argument darg_method (3d correction for drag) can only be Eggers or None.")
 
-        delta_cd = delta_cl*(np.sin(alpha) - 0.12*np.cos(alpha))/(np.cos(alpha) + 0.12*np.sin(alpha))
         cd_3d = cd_2d + delta_cd
 
         return type(self)(self.Re, np.degrees(alpha), cl_3d, cd_3d, self.cm)
 
-
-
     def extrapolate(self, cdmax, AR=None, cdmin=0.001, nalpha=15):
         """Extrapolates force coefficients up to +/- 180 degrees using Viterna's method
         :cite:`Viterna1982Theoretical-and`.
 
         Parameters
         ----------
         cdmax : float
@@ -277,106 +280,110 @@
 
         >>> cdmax = 1.11 + 0.018*AR
 
 
         """
 
         if cdmin < 0:
-            raise Exception('cdmin cannot be < 0')
+            raise Exception("cdmin cannot be < 0")
 
         # lift coefficient adjustment to account for assymetry
         cl_adj = 0.7
 
         # estimate CD max
         if AR is not None:
-            cdmax = 1.11 + 0.018*AR
+            cdmax = 1.11 + 0.018 * AR
         self.cdmax = max(max(self.cd), cdmax)
 
         # extract matching info from ends
         alpha_high = np.radians(self.alpha[-1])
         cl_high = self.cl[-1]
         cd_high = self.cd[-1]
         cm_high = self.cm[-1]
 
         alpha_low = np.radians(self.alpha[0])
         cl_low = self.cl[0]
         cd_low = self.cd[0]
 
-        if alpha_high > np.pi/2:
-            raise Exception('alpha[-1] > pi/2')
+        if alpha_high > np.pi / 2:
+            raise Exception("alpha[-1] > pi/2")
             return self
-        if alpha_low < -np.pi/2:
-            raise Exception('alpha[0] < -pi/2')
+        if alpha_low < -np.pi / 2:
+            raise Exception("alpha[0] < -pi/2")
             return self
 
         # parameters used in model
         sa = np.sin(alpha_high)
         ca = np.cos(alpha_high)
-        self.A = (cl_high - self.cdmax*sa*ca)*sa/ca**2
-        self.B = (cd_high - self.cdmax*sa*sa)/ca
+        self.A = (cl_high - self.cdmax * sa * ca) * sa / ca ** 2
+        self.B = (cd_high - self.cdmax * sa * sa) / ca
 
         # alpha_high <-> 90
-        alpha1 = np.linspace(alpha_high, np.pi/2, nalpha)
+        alpha1 = np.linspace(alpha_high, np.pi / 2, nalpha)
         alpha1 = alpha1[1:]  # remove first element so as not to duplicate when concatenating
         cl1, cd1 = self.__Viterna(alpha1, 1.0)
 
         # 90 <-> 180-alpha_high
-        alpha2 = np.linspace(np.pi/2, np.pi-alpha_high, nalpha)
+        alpha2 = np.linspace(np.pi / 2, np.pi - alpha_high, nalpha)
         alpha2 = alpha2[1:]
-        cl2, cd2 = self.__Viterna(np.pi-alpha2, -cl_adj)
+        cl2, cd2 = self.__Viterna(np.pi - alpha2, -cl_adj)
 
         # 180-alpha_high <-> 180
-        alpha3 = np.linspace(np.pi-alpha_high, np.pi, nalpha)
+        alpha3 = np.linspace(np.pi - alpha_high, np.pi, nalpha)
         alpha3 = alpha3[1:]
-        cl3, cd3 = self.__Viterna(np.pi-alpha3, 1.0)
-        cl3 = (alpha3-np.pi)/alpha_high*cl_high*cl_adj  # override with linear variation
+        cl3, cd3 = self.__Viterna(np.pi - alpha3, 1.0)
+        cl3 = (alpha3 - np.pi) / alpha_high * cl_high * cl_adj  # override with linear variation
 
         if alpha_low <= -alpha_high:
             alpha4 = []
             cl4 = []
             cd4 = []
             alpha5max = alpha_low
         else:
             # -alpha_high <-> alpha_low
             # Note: this is done slightly differently than AirfoilPrep for better continuity
             alpha4 = np.linspace(-alpha_high, alpha_low, nalpha)
             alpha4 = alpha4[1:-2]  # also remove last element for concatenation for this case
-            cl4 = -cl_high*cl_adj + (alpha4+alpha_high)/(alpha_low+alpha_high)*(cl_low+cl_high*cl_adj)
-            cd4 = cd_low + (alpha4-alpha_low)/(-alpha_high-alpha_low)*(cd_high-cd_low)
+            cl4 = -cl_high * cl_adj + (alpha4 + alpha_high) / (alpha_low + alpha_high) * (cl_low + cl_high * cl_adj)
+            cd4 = cd_low + (alpha4 - alpha_low) / (-alpha_high - alpha_low) * (cd_high - cd_low)
             alpha5max = -alpha_high
 
         # -90 <-> -alpha_high
-        alpha5 = np.linspace(-np.pi/2, alpha5max, nalpha)
+        alpha5 = np.linspace(-np.pi / 2, alpha5max, nalpha)
         alpha5 = alpha5[1:]
         cl5, cd5 = self.__Viterna(-alpha5, -cl_adj)
 
         # -180+alpha_high <-> -90
-        alpha6 = np.linspace(-np.pi+alpha_high, -np.pi/2, nalpha)
+        alpha6 = np.linspace(-np.pi + alpha_high, -np.pi / 2, nalpha)
         alpha6 = alpha6[1:]
-        cl6, cd6 = self.__Viterna(alpha6+np.pi, cl_adj)
+        cl6, cd6 = self.__Viterna(alpha6 + np.pi, cl_adj)
 
         # -180 <-> -180 + alpha_high
-        alpha7 = np.linspace(-np.pi, -np.pi+alpha_high, nalpha)
-        cl7, cd7 = self.__Viterna(alpha7+np.pi, 1.0)
-        cl7 = (alpha7+np.pi)/alpha_high*cl_high*cl_adj  # linear variation
+        alpha7 = np.linspace(-np.pi, -np.pi + alpha_high, nalpha)
+        cl7, cd7 = self.__Viterna(alpha7 + np.pi, 1.0)
+        cl7 = (alpha7 + np.pi) / alpha_high * cl_high * cl_adj  # linear variation
 
         alpha = np.concatenate((alpha7, alpha6, alpha5, alpha4, np.radians(self.alpha), alpha1, alpha2, alpha3))
         cl = np.concatenate((cl7, cl6, cl5, cl4, self.cl, cl1, cl2, cl3))
         cd = np.concatenate((cd7, cd6, cd5, cd4, self.cd, cd1, cd2, cd3))
 
         cd = np.maximum(cd, cdmin)  # don't allow negative drag coefficients
 
-
         # Setup alpha and cm to be used in extrapolation
         cm1_alpha = np.floor(self.alpha[0] / 10.0) * 10.0
         cm2_alpha = np.ceil(self.alpha[-1] / 10.0) * 10.0
-        alpha_num = abs(int((-180.0-cm1_alpha)/10.0 - 1))
+        if cm2_alpha == self.alpha[-1]:
+            self.alpha = self.alpha[:-1]
+            self.cm = self.cm[:-1]
+        alpha_num = abs(int((-180.0 - cm1_alpha) / 10.0 - 1))
         alpha_cm1 = np.linspace(-180.0, cm1_alpha, alpha_num)
-        alpha_cm2 = np.linspace(cm2_alpha, 180.0, int((180.0-cm2_alpha)/10.0 + 1))
-        alpha_cm = np.concatenate((alpha_cm1, self.alpha, alpha_cm2))  # Specific alpha values are needed for cm function to work
+        alpha_cm2 = np.linspace(cm2_alpha, 180.0, int((180.0 - cm2_alpha) / 10.0 + 1))
+        alpha_cm = np.concatenate(
+            (alpha_cm1, self.alpha, alpha_cm2)
+        )  # Specific alpha values are needed for cm function to work
         cm1 = np.zeros(len(alpha_cm1))
         cm2 = np.zeros(len(alpha_cm2))
         cm_ext = np.concatenate((cm1, self.cm, cm2))
         if np.count_nonzero(self.cm) > 0:
             cmCoef = self.__CMCoeff(cl_high, cd_high, cm_high)  # get cm coefficient
             cl_cm = np.interp(alpha_cm, np.degrees(alpha), cl)  # get cl for applicable alphas
             cd_cm = np.interp(alpha_cm, np.degrees(alpha), cd)  # get cd for applicable alphas
@@ -387,66 +394,68 @@
                 if cm_new is None:
                     pass  # For when it reaches the range of cm's that the user provides
                 else:
                     cm_ext[i] = cm_new
         cm = np.interp(np.degrees(alpha), alpha_cm, cm_ext)
         return type(self)(self.Re, np.degrees(alpha), cl, cd, cm)
 
-
-
-
     def __Viterna(self, alpha, cl_adj):
         """private method to perform Viterna extrapolation"""
 
         alpha = np.maximum(alpha, 0.0001)  # prevent divide by zero
 
-        cl = self.cdmax/2*np.sin(2*alpha) + self.A*np.cos(alpha)**2/np.sin(alpha)
-        cl = cl*cl_adj
+        cl = self.cdmax / 2 * np.sin(2 * alpha) + self.A * np.cos(alpha) ** 2 / np.sin(alpha)
+        cl = cl * cl_adj
 
-        cd = self.cdmax*np.sin(alpha)**2 + self.B*np.cos(alpha)
+        cd = self.cdmax * np.sin(alpha) ** 2 + self.B * np.cos(alpha)
 
         return cl, cd
 
     def __CMCoeff(self, cl_high, cd_high, cm_high):
         """private method to obtain CM0 and CMCoeff"""
 
         found_zero_lift = False
 
-        for i in range(len(self.cm)-1):
-            if abs(self.alpha[i]) < 20.0 and self.cl[i] <= 0 and self.cl[i+1] >= 0:
+        for i in range(len(self.cm) - 1):
+            if abs(self.alpha[i]) < 20.0 and self.cl[i] <= 0 and self.cl[i + 1] >= 0:
                 p = -self.cl[i] / (self.cl[i + 1] - self.cl[i])
-                cm0 = self.cm[i] + p * (self.cm[i+1] - self.cm[i])
+                cm0 = self.cm[i] + p * (self.cm[i + 1] - self.cm[i])
                 found_zero_lift = True
                 break
 
         if not found_zero_lift:
             p = -self.cl[0] / (self.cl[1] - self.cl[0])
             cm0 = self.cm[0] + p * (self.cm[1] - self.cm[0])
         self.cm0 = cm0
         alpha_high = np.radians(self.alpha[-1])
         XM = (-cm_high + cm0) / (cl_high * np.cos(alpha_high) + cd_high * np.sin(alpha_high))
-        cmCoef = (XM - 0.25) / np.tan((alpha_high - np.pi/2))
+        cmCoef = (XM - 0.25) / np.tan((alpha_high - np.pi / 2))
         return cmCoef
 
     def __getCM(self, i, cmCoef, alpha, cl_ext, cd_ext, alpha_low_deg, alpha_high_deg):
         """private method to extrapolate Cm"""
 
         cm_new = 0
         if alpha[i] >= alpha_low_deg and alpha[i] <= alpha_high_deg:
             return
         if alpha[i] > -165 and alpha[i] < 165:
             if abs(alpha[i]) < 0.01:
                 cm_new = self.cm0
             else:
                 if alpha[i] > 0:
-                    x = cmCoef * np.tan(np.radians(alpha[i]) - np.pi/2) + 0.25
-                    cm_new = self.cm0 - x * (cl_ext[i] * np.cos(np.radians(alpha[i])) + cd_ext[i] * np.sin(np.radians(alpha[i])))
+                    x = cmCoef * np.tan(np.radians(alpha[i]) - np.pi / 2) + 0.25
+                    cm_new = self.cm0 - x * (
+                        cl_ext[i] * np.cos(np.radians(alpha[i])) + cd_ext[i] * np.sin(np.radians(alpha[i]))
+                    )
                 else:
-                    x = cmCoef * np.tan(-np.radians(alpha[i]) - np.pi/2) + 0.25
-                    cm_new = -(self.cm0 - x * (-cl_ext[i] * np.cos(-np.radians(alpha[i])) + cd_ext[i] * np.sin(-np.radians(alpha[i]))))
+                    x = cmCoef * np.tan(-np.radians(alpha[i]) - np.pi / 2) + 0.25
+                    cm_new = -(
+                        self.cm0
+                        - x * (-cl_ext[i] * np.cos(-np.radians(alpha[i])) + cd_ext[i] * np.sin(-np.radians(alpha[i])))
+                    )
         else:
             if alpha[i] == 165:
                 cm_new = -0.4
             elif alpha[i] == 170:
                 cm_new = -0.5
             elif alpha[i] == 175:
                 cm_new = -0.25
@@ -457,240 +466,173 @@
             elif alpha[i] == -170:
                 cm_new = 0.4
             elif alpha[i] == -175:
                 cm_new = 0.2
             elif alpha[i] == -180:
                 cm_new = 0
             else:
-                print("Angle encountered for which there is no CM table value "
-                      "(near +/-180 deg). Program will stop.")
+                print("Angle encountered for which there is no CM table value " "(near +/-180 deg). Program will stop.")
         return cm_new
 
     def unsteadyParams(self, window_offset=None):
         """compute unsteady aero parameters used in AeroDyn input file
 
-        TODO Questions to solve:
-          - Is alpha 0 defined at zero lift or zero Cn?
-          - Are Cn1 and Cn2 the stall points of Cn or the regions where Cn deviates from the linear region?
-          - Is Cd0 Cdmin?
-          - Should Cd0 be used in cn?
-          - Should the TSE points be used? 
-          - If so, should we use the linear points or the points on the cn-curve
-          - Should we prescribe alpha0cn when determining the slope?
-        NOTE:
-          alpha0Cl and alpha0Cn are usually within 0.005 deg of each other, less thatn 0.3% difference, with alpha0Cn > alpha0Cl. The difference increase thought towards the root of the blade
-
-          Using the f=0.7 points doesnot change much for the lower point
-                    but it has quite an impact on the upper point
-%
-
-        Parameters
-        ----------
-        window_dalpha0: the linear region will be looked for in the region alpha+window_offset
-
-        Returns
-        -------
-        alpha0   : lift or 0 cn (TODO TODO) angle of attack (deg)
-        alpha1   : angle of attack at f=0.7 (approximately the stall angle) for AOA>alpha0 (deg)
-        alpha2   : angle of attack at f=0.7 (approximately the stall angle) for AOA<alpha0 (deg)
-        cnSlope  : slope of 2D normal force coefficient curve (1/rad)
-        Cn1      : Critical value of C0n at leading edge separation. It should be extracted from airfoil data at a given Mach and Reynolds number. It can be calculated from the static value of Cn at either the break in the pitching moment or the loss of chord force at the onset of stall. It is close to the condition of maximum lift of the airfoil at low Mach numbers.
-        Cn2      : As Cn1 for negative AOAs.
-        Cd0      : Drag coefficient at zero lift TODO
-        Cm0      : Moment coefficient at zero lift TODO
+                TODO Questions to solve:
+                  - Is alpha 0 defined at zero lift or zero Cn?
+                  - Are Cn1 and Cn2 the stall points of Cn or the regions where Cn deviates from the linear region?
+                  - Is Cd0 Cdmin?
+                  - Should Cd0 be used in cn?
+                  - Should the TSE points be used?
+                  - If so, should we use the linear points or the points on the cn-curve
+                  - Should we prescribe alpha0cn when determining the slope?
+                NOTE:
+                  alpha0Cl and alpha0Cn are usually within 0.005 deg of each other, less thatn 0.3% difference, with alpha0Cn > alpha0Cl. The difference increase thought towards the root of the blade
+
+                  Using the f=0.7 points doesnot change much for the lower point
+                            but it has quite an impact on the upper point
+        %
+
+                Parameters
+                ----------
+                window_dalpha0: the linear region will be looked for in the region alpha+window_offset
+
+                Returns
+                -------
+                alpha0   : lift or 0 cn (TODO TODO) angle of attack (deg)
+                alpha1   : angle of attack at f=0.7 (approximately the stall angle) for AOA>alpha0 (deg)
+                alpha2   : angle of attack at f=0.7 (approximately the stall angle) for AOA<alpha0 (deg)
+                cnSlope  : slope of 2D normal force coefficient curve (1/rad)
+                Cn1      : Critical value of C0n at leading edge separation. It should be extracted from airfoil data at a given Mach and Reynolds number. It can be calculated from the static value of Cn at either the break in the pitching moment or the loss of chord force at the onset of stall. It is close to the condition of maximum lift of the airfoil at low Mach numbers.
+                Cn2      : As Cn1 for negative AOAs.
+                Cd0      : Drag coefficient at zero lift TODO
+                Cm0      : Moment coefficient at zero lift TODO
 
 
         """
         if window_offset is None:
-            dwin = np.array([-5,10])
+            dwin = np.array([-5, 10])
             if self._radians:
                 dwin = np.radians(dwin)
         cl = self.cl
         cd = self.cd
-        cl[np.abs(cl)<1e-10]=0
         alpha = self.alpha
 
         if self._radians:
-            cn = cl*np.cos(alpha) + cd*np.sin(alpha)
+            cn = cl * np.cos(alpha) + cd * np.sin(alpha)
         else:
-            cn = cl*np.cos(alpha*np.pi/180) + cd*np.sin(alpha*np.pi/180)
+            cn = cl * np.cos(alpha * np.pi / 180) + cd * np.sin(alpha * np.pi / 180)
 
         # --- Zero lift
         alpha0 = self.alpha0()
-        cd0    = self.cd_interp(alpha0)
-        cm0    = self.cm_interp(alpha0)
+        cd0 = self.cd_interp(alpha0)
+        cm0 = self.cm_interp(alpha0)
 
         # --- Zero cn
         if self._radians:
-            window=[np.radians(-20),np.radians(20)]
+            window = [np.radians(-20), np.radians(20)]
         else:
-            window=[-20,20]
-        alpha0cn = _find_alpha0(alpha,cn,window)
+            window = [-20, 20]
+        alpha0cn = _find_alpha0(alpha, cn, window)
 
         # checks for inppropriate data (like cylinders)
-        if len(np.unique(cl))==1:
-            return (alpha0,0.0,0.0,0.0,0.0,0.0,cd0,cm0)
+        if len(np.unique(cl)) == 1:
+            return (alpha0, 0.0, 0.0, 0.0, 0.0, 0.0, cd0, cm0)
 
         # --- cn "inflection" or "Max" points
-        # These point are detected from slope changes of cn, positive of negative inflections 
+        # These point are detected from slope changes of cn, positive of negative inflections
         # The upper stall point is the first point after alpha0 with a "hat" inflection
         # The lower stall point is the first point below alpha0 with a "v" inflection
-        a_MaxUpp, cn_MaxUpp, a_MaxLow, cn_MaxLow = _find_max_points(alpha,cn,alpha0,method='inflections')
+        a_MaxUpp, cn_MaxUpp, a_MaxLow, cn_MaxLow = _find_max_points(alpha, cn, alpha0, method="inflections")
 
         # --- cn slope
         # Different method may be used. The max method ensures the the curve is always below its tangent
         # Leastsquare fit in the region alpha0cn+window_offset
-        cnSlope_poly,a0cn_poly = _find_slope(alpha, cn, window=alpha0cn+dwin, method='leastsquare', x0=alpha0cn)
-        cnSlope_poly,a0cn_poly = _find_slope(alpha, cn, window=alpha0cn+dwin, method='leastsquare')
+        cnSlope_poly, a0cn_poly = _find_slope(alpha, cn, window=alpha0cn + dwin, method="leastsquare", x0=alpha0cn)
+        cnSlope_poly, a0cn_poly = _find_slope(alpha, cn, window=alpha0cn + dwin, method="leastsquare")
         # Max (KEEP ME)
-        #cnSlope_max,a0cn_max = _find_slope(alpha, cn, window=[alpha0cn,a_StallUpp], method='max', xi=alpha0cn)
+        # cnSlope_max,a0cn_max = _find_slope(alpha, cn, window=[alpha0cn,a_StallUpp], method='max', xi=alpha0cn)
         # Optim
-        #cnSlope_optim,a0cn_optim = _find_slope(alpha, cn, window=[alpha0-5,alpha0+20], method='optim', x0=alpha0cn)
+        # cnSlope_optim,a0cn_optim = _find_slope(alpha, cn, window=[alpha0-5,alpha0+20], method='optim', x0=alpha0cn)
         ## FiniteDiff
-        #cnSlope_FD,a0cn_FD = _find_slope(alpha, cn, method='finitediff_1c', xi=alpha0cn)
+        # cnSlope_FD,a0cn_FD = _find_slope(alpha, cn, method='finitediff_1c', xi=alpha0cn)
         # slopesRel=np.array([cnSlope_poly,cnSlope_max,cnSlope_optim,cnSlope_FD])*180/np.pi/(2*np.pi)
         cnSlope = cnSlope_poly
 
         # --- cn at "stall onset" (Trailling Edge Separation) locations, when cn deviates from the linear region
-        a_TSELow, a_TSEUpp = _find_TSE_region(alpha,cn,cnSlope,alpha0cn,deviation=0.05)
-        cn_TSEUpp_lin = cnSlope*(a_TSEUpp-alpha0cn)
-        cn_TSELow_lin = cnSlope*(a_TSELow-alpha0cn)
-        cn_TSEUpp     = np.interp(a_TSEUpp, alpha, cn)
-        cn_TSELow     = np.interp(a_TSELow, alpha, cn)
+        a_TSELow, a_TSEUpp = _find_TSE_region(alpha, cn, cnSlope, alpha0cn, deviation=0.05)
+        cn_TSEUpp_lin = cnSlope * (a_TSEUpp - alpha0cn)
+        cn_TSELow_lin = cnSlope * (a_TSELow - alpha0cn)
+        cn_TSEUpp = np.interp(a_TSEUpp, alpha, cn)
+        cn_TSELow = np.interp(a_TSELow, alpha, cn)
 
         # --- cn at points where f=0.7
-        cn_f  = cnSlope* (alpha - alpha0cn)*((1+np.sqrt(0.7))/2)**2;
-        xInter,_ = _intersections(alpha,cn_f,alpha,cn)
-        if len(xInter)==3:
-           a_f07_Upp = xInter[2]
-           a_f07_Low = xInter[0]
-        else:
-           #print(xInter)
-           print('[WARN] Polar, unsteady params: cn_f does not intersect cn 3 times.')
-           a_f07_Upp =  abs(xInter[0]) 
-           a_f07_Low = -abs(xInter[0])
+        cn_f = cnSlope * (alpha - alpha0cn) * ((1 + np.sqrt(0.7)) / 2) ** 2
+        xInter, _ = _intersections(alpha, cn_f, alpha, cn)
+        if len(xInter) == 3:
+            a_f07_Upp = xInter[2]
+            a_f07_Low = xInter[0]
+        else:
+            raise Exception("cn_f does not ntersect cn 3 times.")
+            # alpha1 =  abs(xInter[0])
+            # alpha2 = -abs(xInter[0])
 
         # --- DEBUG plot
-#         import matplotlib.pyplot as plt
-#         plt.plot(alpha, cn,label='cn')
-#         plt.xlim([-50,50])
-#         plt.ylim([-3,3])
-#         plt.plot([alpha0-5,alpha0-5]  ,[-3,3],'k--')
-#         plt.plot([alpha0+10,alpha0+10],[-3,3],'k--')
-#         plt.plot([alpha0,alpha0],[-3,3],'r-')
-#         plt.plot([alpha0cn,alpha0cn],[-3,3],'b-')
-# 
-#         plt.plot(alpha, cn_f,label='cn_f')
-#         plt.plot(a_f07_Upp,self.cn_interp(a_f07_Upp),'d',label='Cn f07 Up')
-#         plt.plot(a_f07_Low,self.cn_interp(a_f07_Low),'d',label='Cn f07 Low')
-#         plt.plot(a_TSEUpp,cn_TSEUpp,'o',label='Cn TSEUp')
-#         plt.plot(a_TSELow,cn_TSELow,'o',label='Cn TSELow')
-#         plt.plot(a_TSEUpp,cn_TSEUpp_lin,'+',label='Cn TSEUp lin')
-#         plt.plot(a_TSELow,cn_TSELow_lin,'+',label='Cn TSELow lin')
-#         plt.plot(alpha,cnSlope *(alpha-alpha0cn),'--',  label ='Linear')
-# #         plt.plot(a_MaxUpp,cnMaxUpp,'o',label='Cn MaxUp')
-# #         plt.plot(a_MaxLow,cnMaxLow,'o',label='Cn MaxLow')
-# #         plt.plot(alpha,cnSlope_poly *(alpha-a0cn_poly),'--',  label ='Polyfit   '+sSlopes[0])
-# #         plt.plot(alpha,cnSlope_max  *(alpha-a0cn_max),'--',   label ='Max       '+sSlopes[1])
-# #         plt.plot(alpha,cnSlope_optim*(alpha-a0cn_optim),'--', label ='Optim     '+sSlopes[2])
-# #         plt.plot(alpha,cnSlope_FD   *(alpha-a0cn_FD),'--',    label ='FiniteDiff'+sSlopes[3])
-# # #         plt.plot(alpha      , np.pi/180*cnSlope*(alpha-alpha0),label='cn lin')
-# # #         plt.plot(alpha1, np.pi/180*cnSlope*(alpha1-alpha0),'o',label='cn Stall')
-# # #         plt.plot(alpha2, np.pi/180*cnSlope*(alpha2-alpha0),'o',label='cn Stall')
-#         plt.legend()
-#         mng=plt.get_current_fig_manager()
-#         mng.full_screen_toggle()
-#         plt.show()
-#         raise Exception()
+        #         import matplotlib.pyplot as plt
+        #         plt.plot(alpha, cn,label='cn')
+        #         plt.xlim([-50,50])
+        #         plt.ylim([-3,3])
+        #         plt.plot([alpha0-5,alpha0-5]  ,[-3,3],'k--')
+        #         plt.plot([alpha0+10,alpha0+10],[-3,3],'k--')
+        #         plt.plot([alpha0,alpha0],[-3,3],'r-')
+        #         plt.plot([alpha0cn,alpha0cn],[-3,3],'b-')
+        #
+        #         plt.plot(alpha, cn_f,label='cn_f')
+        #         plt.plot(a_f07_Upp,self.cn_interp(a_f07_Upp),'d',label='Cn f07 Up')
+        #         plt.plot(a_f07_Low,self.cn_interp(a_f07_Low),'d',label='Cn f07 Low')
+        #         plt.plot(a_TSEUpp,cn_TSEUpp,'o',label='Cn TSEUp')
+        #         plt.plot(a_TSELow,cn_TSELow,'o',label='Cn TSELow')
+        #         plt.plot(a_TSEUpp,cn_TSEUpp_lin,'+',label='Cn TSEUp lin')
+        #         plt.plot(a_TSELow,cn_TSELow_lin,'+',label='Cn TSELow lin')
+        #         plt.plot(alpha,cnSlope *(alpha-alpha0cn),'--',  label ='Linear')
+        # #         plt.plot(a_MaxUpp,cnMaxUpp,'o',label='Cn MaxUp')
+        # #         plt.plot(a_MaxLow,cnMaxLow,'o',label='Cn MaxLow')
+        # #         plt.plot(alpha,cnSlope_poly *(alpha-a0cn_poly),'--',  label ='Polyfit   '+sSlopes[0])
+        # #         plt.plot(alpha,cnSlope_max  *(alpha-a0cn_max),'--',   label ='Max       '+sSlopes[1])
+        # #         plt.plot(alpha,cnSlope_optim*(alpha-a0cn_optim),'--', label ='Optim     '+sSlopes[2])
+        # #         plt.plot(alpha,cnSlope_FD   *(alpha-a0cn_FD),'--',    label ='FiniteDiff'+sSlopes[3])
+        # # #         plt.plot(alpha      , np.pi/180*cnSlope*(alpha-alpha0),label='cn lin')
+        # # #         plt.plot(alpha1, np.pi/180*cnSlope*(alpha1-alpha0),'o',label='cn Stall')
+        # # #         plt.plot(alpha2, np.pi/180*cnSlope*(alpha2-alpha0),'o',label='cn Stall')
+        #         plt.legend()
+        #         mng=plt.get_current_fig_manager()
+        #         mng.full_screen_toggle()
+        #         plt.show()
+        #         raise Exception()
 
         # --- Deciding what we return
         # Critical value of C0n at leading edge separation
-#         cn1   = cn_TSEUpp_lin
-#         cn2   = cn_TSELow_lin
-        cn1   = cn_MaxUpp
-        cn2   = cn_MaxLow
+        #         cn1   = cn_TSEUpp_lin
+        #         cn2   = cn_TSELow_lin
+        cn1 = cn_MaxUpp
+        cn2 = cn_MaxLow
         # Alpha at f=0.7
-#         alpha1= a_TSEUpp
-#         alpha2= a_TSELow
-        alpha1= a_f07_Upp
-        alpha2= a_f07_Low
+        #         alpha1= a_TSEUpp
+        #         alpha2= a_TSELow
+        alpha1 = a_f07_Upp
+        alpha2 = a_f07_Low
 
-        # 
+        #
         if self._radians:
-            alpha0  = np.degrees(alpha0)
-            alpha1  = np.degrees(alpha1)
-            alpha2  = np.degrees(alpha2)
+            alpha0 = np.degrees(alpha0)
+            alpha1 = np.degrees(alpha1)
+            alpha2 = np.degrees(alpha2)
             cnSlope = cnSlope
         else:
-            cnSlope = cnSlope*180/np.pi
-        return (alpha0,alpha1,alpha2,cnSlope,cn1,cn2,cd0,cm0)
-
-    def unsteadyparam(self, alpha_linear_min=-5, alpha_linear_max=5):
-        """compute unsteady aero parameters used in AeroDyn input file
-
-        Parameters
-        ----------
-        alpha_linear_min : float, optional (deg)
-            angle of attack where linear portion of lift curve slope begins
-        alpha_linear_max : float, optional (deg)
-            angle of attack where linear portion of lift curve slope ends
-
-        Returns
-        -------
-        aerodynParam : tuple of floats
-            (control setting, stall angle, alpha for 0 cn, cn slope,
-            cn at stall+, cn at stall-, alpha for min CD, min(CD))
-
-        """
-
-        alpha = np.radians(self.alpha)
-        cl = self.cl
-        cd = self.cd
-
-        alpha_linear_min = np.radians(alpha_linear_min)
-        alpha_linear_max = np.radians(alpha_linear_max)
-
-        cn = cl*np.cos(alpha) + cd*np.sin(alpha)
-
-        # find linear region
-        idx = np.logical_and(alpha >= alpha_linear_min,
-                             alpha <= alpha_linear_max)
-
-        # checks for inppropriate data (like cylinders)
-        if len(idx) < 10 or len(np.unique(cl)) < 10:
-            return 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,0.0
-
-        # linear fit
-        p = np.polyfit(alpha[idx], cn[idx], 1)
-        m = p[0]
-        alpha0 = -p[1]/m
-
-        # find cn at "stall onset" locations, when cn deviates from the linear region
-        alphaUpper    = np.radians(np.arange(40.0))
-        alphaLower    = np.radians(np.arange(5.0, -40.0, -1))
-        cnUpper       = np.interp(alphaUpper, alpha, cn)
-        cnLower       = np.interp(alphaLower, alpha, cn)
-        cnLinearUpper = m*(alphaUpper - alpha0)
-        cnLinearLower = m*(alphaLower - alpha0)
-        deviation     = 0.05                  # threshold for cl in detecting stall
-
-        alphaU = np.interp(deviation, cnLinearUpper-cnUpper, alphaUpper)
-        alphaL = np.interp(deviation, cnLower-cnLinearLower, alphaLower)
-
-        # compute cn at stall according to linear fit
-        cnStallUpper = m*(alphaU-alpha0)
-        cnStallLower = m*(alphaL-alpha0)
-
-        # find min cd
-        minIdx = cd.argmin()
-
-        # return: control setting, stall angle, alpha for 0 cn, cn slope,
-        #         cn at stall+, cn at stall-, alpha for min CD, min(CD)
-        return (0.0, np.degrees(alphaU), np.degrees(alpha0), m,
-                cnStallUpper, cnStallLower, alpha[minIdx], cd[minIdx])
+            cnSlope = cnSlope * 180 / np.pi
+        return (alpha0, alpha1, alpha2, cnSlope, cn1, cn2, cd0, cm0)
 
     def plot(self):
         """plot cl/cd/cm polar
 
         Returns
         -------
         figs : list of figure handles
@@ -702,291 +644,214 @@
 
         figs = []
 
         # plot cl
         fig = plt.figure()
         figs.append(fig)
         ax = fig.add_subplot(111)
-        plt.plot(p.alpha, p.cl, label='Re = ' + str(p.Re/1e6) + ' million')
-        ax.set_xlabel('angle of attack (deg)')
-        ax.set_ylabel('lift coefficient')
-        ax.legend(loc='best')
+        plt.plot(p.alpha, p.cl, label="Re = " + str(p.Re / 1e6) + " million")
+        ax.set_xlabel("angle of attack (deg)")
+        ax.set_ylabel("lift coefficient")
+        ax.legend(loc="best")
 
         # plot cd
         fig = plt.figure()
         figs.append(fig)
         ax = fig.add_subplot(111)
-        ax.plot(p.alpha, p.cd, label='Re = ' + str(p.Re/1e6) + ' million')
-        ax.set_xlabel('angle of attack (deg)')
-        ax.set_ylabel('drag coefficient')
-        ax.legend(loc='best')
+        ax.plot(p.alpha, p.cd, label="Re = " + str(p.Re / 1e6) + " million")
+        ax.set_xlabel("angle of attack (deg)")
+        ax.set_ylabel("drag coefficient")
+        ax.legend(loc="best")
 
         # plot cm
         fig = plt.figure()
         figs.append(fig)
         ax = fig.add_subplot(111)
-        ax.plot(p.alpha, p.cm, label='Re = ' + str(p.Re/1e6) + ' million')
-        ax.set_xlabel('angle of attack (deg)')
-        ax.set_ylabel('moment coefficient')
-        ax.legend(loc='best')
+        ax.plot(p.alpha, p.cm, label="Re = " + str(p.Re / 1e6) + " million")
+        ax.set_xlabel("angle of attack (deg)")
+        ax.set_ylabel("moment coefficient")
+        ax.legend(loc="best")
 
         return figs
 
-    def alpha0(self,window=None):
+    def alpha0(self, window=None):
         """ Finds alpha0, angle of zero lift """
         if window is None:
             if self._radians:
-                window=[np.radians(-20),np.radians(20)]
+                window = [np.radians(-30), np.radians(30)]
             else:
-                window=[-20,20]
-        window = _alpha_window_in_bounds(self.alpha,window)
-        #print(window)
-        #print(self.alpha)
-        #print(self._radians)
-        #print(self.cl)
-        #print(window)
-
-        return _find_alpha0(self.alpha,self.cl,window)
-
-    def linear_region(self):
-        slope, alpha0 = self.cl_linear_slope()
-        alpha_linear_region = np.asarray(_find_TSE_region(self.alpha,self.cl, slope, alpha0, deviation=0.05))
-        cl_linear_region = (alpha_linear_region-alpha0)*slope
-        return alpha_linear_region, cl_linear_region, slope, alpha0
+                window = [-30, 30]
+        window = _alpha_window_in_bounds(self.alpha, window)
+        # print(window)
+        # print(self.alpha)
+        # print(self._radians)
+        # print(self.cl)
+        # print(window)
 
-    def cl_max(self,window=None):
+        return _find_alpha0(self.alpha, self.cl, window)
+
+    def linear_region(self, delta_alpha0=4, method_linear_fit="max"):
+        alpha0 = self.alpha0()
+        cl_slope, _ = self.cl_linear_slope(window=[alpha0, alpha0 + delta_alpha0], method=method_linear_fit)
+        alpha_linear_region = np.asarray(_find_TSE_region(self.alpha, self.cl, cl_slope, alpha0, deviation=0.05))
+        cl_linear_region = (alpha_linear_region - alpha0) * cl_slope
+
+        return alpha_linear_region, cl_linear_region, cl_slope, alpha0
+
+    def cl_max(self, window=None):
         """ Finds cl_max , returns (Cl_max,alpha_max) """
         if window is None:
             if self._radians:
-                window=[np.radians(-40),np.radians(40)]
+                window = [np.radians(-40), np.radians(40)]
             else:
-                window=[-40,40]
+                window = [-40, 40]
 
         # Constant case or only one value
-        if np.all(self.cl == self.cl[0]) or len(self.cl)==1:
+        if np.all(self.cl == self.cl[0]) or len(self.cl) == 1:
             return self.cl, self.alpha
 
         # Ensuring window is within our alpha values
-        window = _alpha_window_in_bounds(self.alpha,window)
-        
+        window = _alpha_window_in_bounds(self.alpha, window)
+
         # Finding max within window
-        iwindow=np.where((self.alpha>=window[0]) & (self.alpha<=window[1]))
+        iwindow = np.where((self.alpha >= window[0]) & (self.alpha <= window[1]))
         alpha = self.alpha[iwindow]
-        cl    = self.cl[iwindow]
-        i_max  = np.argmax(cl)
-        if i_max==len(iwindow):
-            raise Exception('Max cl is at the window boundary ([{};{}]), increase window (TODO automatically)'.format(window[0],window[1]))
+        cl = self.cl[iwindow]
+        i_max = np.argmax(cl)
+        if i_max == len(iwindow):
+            raise Exception(
+                "Max cl is at the window boundary ([{};{}]), increase window (TODO automatically)".format(
+                    window[0], window[1]
+                )
+            )
             pass
-        cl_max       = cl[i_max]
+        cl_max = cl[i_max]
         alpha_cl_max = alpha[i_max]
-
+        #         alpha_zc,i_zc = _zero_crossings(x=alpha,y=cl,direction='up')
+        #         if len(alpha_zc)>1:
+        #             raise Exception('Cannot find alpha0, {} zero crossings of Cl in the range of alpha values: [{} {}] '.format(len(alpha_zc),window[0],window[1]))
+        #         elif len(alpha_zc)==0:
+        #             raise Exception('Cannot find alpha0, no zero crossing of Cl in the range of alpha values: [{} {}] '.format(window[0],window[1]))
+        #
+        #         alpha0=alpha_zc[0]
         return cl_max, alpha_cl_max
 
-
-    def cl_linear_slope(self,window=None,method='optim',radians=False):
-        """ Find slope of linear region 
-        Outputs: a 2-tuplet of:  
+    def cl_linear_slope(self, window=None, method="optim", radians=False):
+        """Find slope of linear region
+        Outputs: a 2-tuplet of:
            slope (in inverse units of alpha, or in radians-1 if radians=True)
            alpha_0 in the same unit as alpha, or in radians if radians=True
         """
         # --- Return function
-        def myret(sl,a0):
+        def myret(sl, a0):
             # wrapper function to return degrees or radians
             if radians:
                 return np.rad2deg(sl), np.deg2rad(a0)
             else:
                 return sl, a0
 
         # finding our alpha0
         alpha0 = self.alpha0()
 
         # Constant case or only one value
-        if np.all(self.cl == self.cl[0]) or len(self.cl)==1:
-            return myret(0,alpha0)
+        if np.all(self.cl == self.cl[0]) or len(self.cl) == 1:
+            return myret(0, alpha0)
 
         if window is None:
-            if np.nanmin(self.cl)>0 or np.nanmax(self.cl)<0:
-                window =[self.alpha[0],self.alpha[-1]]
+            if np.nanmin(self.cl) > 0 or np.nanmax(self.cl) < 0:
+                window = [self.alpha[0], self.alpha[-1]]
             else:
                 # define a window around alpha0
                 if self._radians:
-                    window = alpha0 + np.radians(np.array([-5, +20]))
+                    window = alpha0 + np.radians(np.array([-2, +6]))
                 else:
-                    window = alpha0 +            np.array([-5, +20])
+                    window = alpha0 + np.array([-2, +6])
 
         # Ensuring window is within our alpha values
-        window = _alpha_window_in_bounds(self.alpha,window)
+        window = _alpha_window_in_bounds(self.alpha, window)
 
-        if method=='max':
-            slope,off =  _find_slope(self.alpha,self.cl,xi=alpha0,window=window,method='max')
-        elif method=='leastsquare':
-            slope,off =  _find_slope(self.alpha,self.cl,xi=alpha0,window=window,method='leastsquare')
-        elif method=='leastsquare_constraint':
-            slope,off =  _find_slope(self.alpha,self.cl,x0=alpha0,window=window,method='leastsquare')
-        elif method=='optim':
+        if method == "max":
+            slope, off = _find_slope(self.alpha, self.cl, xi=alpha0, window=window, method="max")
+        elif method == "leastsquare":
+            slope, off = _find_slope(self.alpha, self.cl, xi=alpha0, window=window, method="leastsquare")
+        elif method == "leastsquare_constraint":
+            slope, off = _find_slope(self.alpha, self.cl, x0=alpha0, window=window, method="leastsquare")
+        elif method == "optim":
             # Selecting range of values within window
             idx = np.where((self.alpha >= window[0]) & (self.alpha <= window[1]) & ~np.isnan(self.cl))[0]
             cl, alpha = self.cl[idx], self.alpha[idx]
             # Selecting within the min and max of this window to improve accuracy
-            imin=np.where(cl==np.min(cl))[0][-1]
-            idx = np.arange(imin,np.argmax(cl)+1)
+            imin = np.where(cl == np.min(cl))[0][-1]
+            idx = np.arange(imin, np.argmax(cl) + 1)
             window = [alpha[imin], alpha[np.argmax(cl)]]
             cl, alpha = cl[idx], alpha[idx]
             # Performing minimization of slope
-            slope,off =  _find_slope(alpha,cl,x0=alpha0,window=None,method='optim')
+            slope, off = _find_slope(alpha, cl, x0=alpha0, window=None, method="optim")
 
         else:
-            raise Exception('Method unknown for lift slope determination: {}'.format(method))
+            raise Exception("Method unknown for lift slope determination: {}".format(method))
 
         # --- Safety checks
-        if len(self.cl)>10:
+        if len(self.cl) > 10:
             # Looking at slope around alpha 0 to see if we are too far off
-            slope_FD,off_FD =  _find_slope(self.alpha,self.cl,xi=alpha0,window=window,method='finitediff_1c')
-            if abs(slope-slope_FD)/slope_FD*100>20:
-                #raise Exception('Warning: More than 20% error between estimated slope ({:.4f}) and the slope around alpha0 ({:.4f}). The window for the slope search ([{} {}]) is likely wrong.'.format(slope,slope_FD,window[0],window[-1]))
-                print('Warning: More than 20% error between estimated slope ({:.4f}) and the slope around alpha0 ({:.4f}). The window for the slope search ([{} {}]) is likely wrong.'.format(slope,slope_FD,window[0],window[-1]))
-#         print('slope ',slope,' Alpha range: {:.3f} {:.3f} - nLin {}  nMin {}  nMax {}'.format(alpha[iStart],alpha[iEnd],len(alpha[iStart:iEnd+1]),nMin,len(alpha)))
+            slope_FD, off_FD = _find_slope(self.alpha, self.cl, xi=alpha0, window=window, method="finitediff_1c")
+            if abs(slope - slope_FD) / slope_FD * 100 > 50:
+                logger.debug(
+                    "Warning Polar.py: More than 50% error between estimated slope ({:.4f}) and the slope around alpha0 ({:.4f}). The window for the slope search in the lift coefficient ([{} {}]) is likely wrong.".format(
+                        slope, slope_FD, window[0], window[-1]
+                    )
+                )
+        #         print('slope ',slope,' Alpha range: {:.3f} {:.3f} - nLin {}  nMin {}  nMax {}'.format(alpha[iStart],alpha[iEnd],len(alpha[iStart:iEnd+1]),nMin,len(alpha)))
 
-        return myret(slope,off)
+        return myret(slope, off)
 
-    def cl_fully_separated(self): 
+    def cl_fully_separated(self):
         alpha0 = self.alpha0()
-        cla,_, = self.cl_linear_slope(method='max')
-        if cla==0:
-            cl_fs    = self.cl # when f_st ==1
-            f_st     = self.cl*0 
-        else:
-            cl_ratio = self.cl / ( cla*(self.alpha-alpha0))
-            cl_ratio[ np.where(cl_ratio<0)]=0
-            f_st = ( 2 *np.sqrt(cl_ratio)-1)**2
-            f_st[np.where(f_st<1e-15)] = 0
+        (
+            cla,
+            _,
+        ) = self.cl_linear_slope(method="max")
+        if cla == 0:
+            cl_fs = self.cl  # when f_st ==1
+            f_st = self.cl * 0
+        else:
+            cl_ratio = self.cl / (cla * (self.alpha - alpha0))
+            cl_ratio[np.where(cl_ratio < 0)] = 0
+            f_st = (2 * np.sqrt(cl_ratio) - 1) ** 2
+            f_st[np.where(f_st < 1e-15)] = 0
             # Initialize to linear region (in fact only at singularity, where f_st=1)
-            cl_fs    = self.cl/2.0 # when f_st ==1
+            cl_fs = self.cl / 2.0  # when f_st ==1
             # Region where f_st<1, merge
-            I=np.where(f_st<1)
-            cl_fs[I] =(self.cl[I] - cla* (self.alpha[I]-alpha0)*f_st[I])/(1.-f_st[I])
+            I = np.where(f_st < 1)
+            cl_fs[I] = (self.cl[I] - cla * (self.alpha[I] - alpha0) * f_st[I]) / (1.0 - f_st[I])
             # Outside region, use steady data
-            iHig=np.ma.argmin( np.ma.MaskedArray(f_st,self.alpha<alpha0) );
-            iLow=np.ma.argmin( np.ma.MaskedArray(f_st,self.alpha>alpha0) );
-            cl_fs[0:iLow+1]  = self.cl[0:iLow+1]
-            cl_fs[iHig+1:-1] = self.cl[iHig+1:-1]
-
-        # Ensuring everything is in harmony 
-        cl_inv = cla*(self.alpha - alpha0)
-        f_st=(self.cl-cl_fs)/(cl_inv-cl_fs);
-        f_st[np.where(f_st<1e-15)] = 0
+            iHig = np.ma.argmin(np.ma.MaskedArray(f_st, self.alpha < alpha0))
+            iLow = np.ma.argmin(np.ma.MaskedArray(f_st, self.alpha > alpha0))
+            cl_fs[0 : iLow + 1] = self.cl[0 : iLow + 1]
+            cl_fs[iHig + 1 : -1] = self.cl[iHig + 1 : -1]
+
+        # Ensuring everything is in harmony
+        cl_inv = cla * (self.alpha - alpha0)
+        f_st = (self.cl - cl_fs) / (cl_inv - cl_fs + 1e-10)
+        f_st[np.where(f_st < 1e-15)] = 0
         # Storing
-        self.f_st  = f_st
+        self.f_st = f_st
         self.cl_fs = cl_fs
-        return cl_fs,f_st
+        return cl_fs, f_st
 
-    def dynaStallOye_DiscreteStep(self,alpha_t,tau,fs_prev,dt):
+    def dynaStallOye_DiscreteStep(self, alpha_t, tau, fs_prev, dt):
         # compute aerodynamical force from aerodynamic data
         # interpolation from data
-        f_st  = self.f_st_interp  (alpha_t) 
-        Clinv = self.cl_inv_interp(alpha_t) 
-        Clfs  = self.cl_fs_interp (alpha_t) 
+        f_st = self.f_st_interp(alpha_t)
+        Clinv = self.cl_inv_interp(alpha_t)
+        Clfs = self.cl_fs_interp(alpha_t)
         # dynamic stall model
-        fs = f_st + (fs_prev-f_st)*np.exp(-dt/tau)
-        Cl = fs*Clinv+(1-fs)*Clfs               
-        return Cl,fs
-
-    def toAeroDyn(self, filenameOut=None, templateFile=None, Re=1.0, comment=None):
-        from welib.weio.fast_input_file import FASTInputFile
-        cleanComments=comment is not None
-        # Read a template file for AeroDyn polars
-        if templateFile is None:
-            MyDir=os.path.dirname(__file__)
-            templateFile = os.path.join(MyDir,'../../data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat')
-            cleanComments=True
-
-        ADpol = FASTInputFile(templateFile)
-
-        # Compute unsteady parameters
-        (alpha0,alpha1,alpha2,cnSlope,cn1,cn2,cd0,cm0)=self.unsteadyParams()
-
-        # --- Updating the AD polar file 
-        # Setting unsteady parameters
-        ADpol['Re'] = Re # TODO UNKNOWN
-        if np.isnan(alpha0):
-            ADpol['alpha0'] = 0
-        else:
-            ADpol['alpha0'] = np.around(alpha0, 4)
-        ADpol['alpha1']    = np.around(alpha1, 4) # TODO approximate
-        ADpol['alpha2']    = np.around(alpha2, 4) # TODO approximate
-        ADpol['C_nalpha']  = np.around(cnSlope ,4)
-        ADpol['Cn1']       = np.around(cn1, 4)    # TODO verify
-        ADpol['Cn2']       = np.around(cn2, 4)
-        ADpol['Cd0']       = np.around(cd0, 4)
-        ADpol['Cm0']       = np.around(cm0, 4)
-
-        # Setting polar 
-        PolarTable = np.column_stack((self.alpha,self.cl,self.cd,self.cm))
-        ADpol['NumAlf'] = self.cl.shape[0]
-        ADpol['AFCoeff'] = np.around(PolarTable, 5)
-
-        # --- Comment
-        # Find lines that are comments
-        I=[]
-        for i in [1,2,3]:
-            if ADpol.data[i]['value'].startswith('!'):
-                if not ADpol.data[i]['value'].startswith('! ---'):
-                    I.append(i)
-	# remove comment from template
-        if cleanComments:
-            for i in I:
-                ADpol.data[i]['value'] = '!'
-        if comment is not None:
-            splits = comment.split('\n')
-            for i,com in zip(I,splits):
-                ADpol.data[i]['value'] = '! '+com
-
-        if filenameOut is not None:
-            ADpol.write(filenameOut)
-        return ADpol
-
-
-
-def loadPolarFile(filename, fformat='auto', to_radians=False):
-    if not os.path.exists(filename):
-        raise Exception('File not found:',filename)
-    try: 
-        import welib.weio as weio
-    except:
-        print('[WARN] Module `weio` not present, only delimited file format supported ')
-        fformat='delimited'
-    if fformat=='delimited':
-        try:
-            M=np.loadtxt(filename,comments=['#','!'])
-        except:
-            # Trying an AD15 file
-            M=pd.read_csv(filename, skiprows = 53, header=None, delim_whitespace=True, names=['Alpha','Cl','Cd','Cm']).values
-        Re    = np.nan
-    elif fformat=='auto':
-        try:
-            M = weio.CSVFile(filename).toDataFrame().values
-        except:
-            df = weio.read(filename).toDataFrame()
-            if type(df) is dict:
-                M=df[list(df.keys())[0]].values
-            else:
-                M=df.values
-    else:
-        raise NotImplementedError('Format not implemented: {}'.format(fformat))
-
-    if M.shape[1]<4:
-        raise Exception('Only supporting polars with 4 columns: alpha cl cd cm')
-    if to_radians:
-        M[:,0]=M[:,0]*np.pi/180
-    alpha = M[:,0]
-    cl    = M[:,1]
-    cd    = M[:,2]
-    cm    = M[:,3]
-    Re    = np.nan
-    return alpha, cl, cd, cm, Re
+        fs = f_st + (fs_prev - f_st) * np.exp(-dt / tau)
+        Cl = fs * Clinv + (1 - fs) * Clfs
+        return Cl, fs
 
 
 def blend(pol1, pol2, weight):
     """Blend this polar with another one with the specified weighting
 
     Parameters
     ----------
@@ -994,673 +859,536 @@
     pol2:  (class Polar or array) second polar
     weight: (float)  blending parameter between 0 (first polar) and 1 (second polar)
 
     Returns
     -------
     polar : (class Polar or array) a blended Polar
     """
-    bReturnObject=False
-    if hasattr(pol1,'cl'):
-        bReturnObject=True
-        alpha1=pol1.alpha
-        M1    = np.zeros((len(alpha1),4))
-        M1[:,0]=pol1.alpha
-        M1[:,1]=pol1.cl
-        M1[:,2]=pol1.cd
-        M1[:,3]=pol1.cm
+    bReturnObject = False
+    if hasattr(pol1, "cl"):
+        bReturnObject = True
+        alpha1 = pol1.alpha
+        M1 = np.zeros((len(alpha1), 4))
+        M1[:, 0] = pol1.alpha
+        M1[:, 1] = pol1.cl
+        M1[:, 2] = pol1.cd
+        M1[:, 3] = pol1.cm
     else:
-        alpha1 = pol1[:,0]
-        M1     = pol1
-    if hasattr(pol2,'cl'):
-        bReturnObject=True
-        alpha2=pol2.alpha
-        M2    = np.zeros((len(alpha2),4))
-        M2[:,0]=pol2.alpha
-        M2[:,1]=pol2.cl
-        M2[:,2]=pol2.cd
-        M2[:,3]=pol2.cm
+        alpha1 = pol1[:, 0]
+        M1 = pol1
+    if hasattr(pol2, "cl"):
+        bReturnObject = True
+        alpha2 = pol2.alpha
+        M2 = np.zeros((len(alpha2), 4))
+        M2[:, 0] = pol2.alpha
+        M2[:, 1] = pol2.cl
+        M2[:, 2] = pol2.cd
+        M2[:, 3] = pol2.cm
     else:
-        alpha2 = pol2[:,0]
-        M2     = pol2
+        alpha2 = pol2[:, 0]
+        M2 = pol2
     # Define range of alpha, merged values and truncate if one set beyond the other range
     alpha = np.union1d(alpha1, alpha2)
     min_alpha = max(alpha1.min(), alpha2.min())
     max_alpha = min(alpha1.max(), alpha2.max())
     alpha = alpha[np.logical_and(alpha >= min_alpha, alpha <= max_alpha)]
     # alpha = np.array([a for a in alpha if a >= min_alpha and a <= max_alpha])
 
     # Creating new output matrix to store polar
-    M= np.zeros((len(alpha),M1.shape[1]))
-    M[:,0] = alpha
+    M = np.zeros((len(alpha), M1.shape[1]))
+    M[:, 0] = alpha
 
     # interpolate to new alpha and linearly blend
-    for j in np.arange(1,M.shape[1]):
-        v1 = np.interp(alpha, alpha1, M1[:,j])
-        v2 = np.interp(alpha, alpha2, M2[:,j])
-        M[:,j] = (1-weight)*v1 + weight*v2
-    if hasattr(pol1,'Re'):
-        Re = pol1.Re + weight*(pol2.Re-pol1.Re)
+    for j in np.arange(1, M.shape[1]):
+        v1 = np.interp(alpha, alpha1, M1[:, j])
+        v2 = np.interp(alpha, alpha2, M2[:, j])
+        M[:, j] = (1 - weight) * v1 + weight * v2
+    if hasattr(pol1, "Re"):
+        Re = pol1.Re + weight * (pol2.Re - pol1.Re)
     else:
         Re = np.nan
 
     if bReturnObject:
-        return type(pol1)(Re, M[:,0], M[:,1], M[:,2], M[:,3])
+        return type(pol1)(Re, M[:, 0], M[:, 1], M[:, 2], M[:, 3])
     else:
         return M
 
 
 def thicknessinterp_from_one_set(thickness, polarList, polarThickness):
-    """ Returns a set of interpolated polars from one set of polars at known thicknesses and a list of thickness
+    """Returns a set of interpolated polars from one set of polars at known thicknesses and a list of thickness
     The nearest polar is used when the thickness is beyond the range of values of the input polars.
     """
-    thickness      = np.asarray(thickness)
+    thickness = np.asarray(thickness)
     polarThickness = np.asarray(polarThickness)
-    polarList     = np.asarray(polarList)
-    tmax_in  = np.max(thickness)
+    polarList = np.asarray(polarList)
+    tmax_in = np.max(thickness)
     tmax_pol = np.max(polarThickness)
-    if (tmax_in>1.2 and tmax_pol<=1.2) or (tmax_in<=1.2 and tmax_pol>1.2):
-        raise Exception('Thicknesses of polars and input thickness need to be both in percent ([0-120]) or in fraction ([0-1.2])')
+    if (tmax_in > 1.2 and tmax_pol <= 1.2) or (tmax_in <= 1.2 and tmax_pol > 1.2):
+        raise Exception(
+            "Thicknesses of polars and input thickness need to be both in percent ([0-120]) or in fraction ([0-1.2])"
+        )
 
-    # sorting thickness 
-    Isort          = np.argsort(polarThickness)
+    # sorting thickness
+    Isort = np.argsort(polarThickness)
     polarThickness = polarThickness[Isort]
-    polarList      = polarList[Isort]
-    
+    polarList = polarList[Isort]
+
     polars = []
-    for it,t in enumerate(thickness):
-        ihigh =  len(polarThickness)-1
-        for ip,tp in enumerate(polarThickness):
-            if tp>t:
-                ihigh=ip
+    for it, t in enumerate(thickness):
+        ihigh = len(polarThickness) - 1
+        for ip, tp in enumerate(polarThickness):
+            if tp > t:
+                ihigh = ip
                 break
-        ilow=0
-        for ip,tp in reversed(list(enumerate(polarThickness))):
-            if tp<t:
-                ilow=ip
+        ilow = 0
+        for ip, tp in reversed(list(enumerate(polarThickness))):
+            if tp < t:
+                ilow = ip
                 break
-        
-        if ihigh==ilow:
+
+        if ihigh == ilow:
             polars.append(polarList[ihigh])
-            print('[WARN] Using nearest polar for section {},   t={} , t_near={}'.format(it,t,polarThickness[ihigh]))
+            print("[WARN] Using nearest polar for section {},   t={} , t_near={}".format(it, t, polarThickness[ihigh]))
         else:
-            if (polarThickness[ilow]>t) or (polarThickness[ihigh]<t): 
-                raise Exception('Implementation Error')
-            weight=(t-polarThickness[ilow])/(polarThickness[ihigh]-polarThickness[ilow])
-            #print(polarThickness[ilow],'<',t,'<',polarThickness[ihigh],'Weight',weight)
-            pol=blend(polarList[ilow],polarList[ihigh],weight)
+            if (polarThickness[ilow] > t) or (polarThickness[ihigh] < t):
+                raise Exception("Implementation Error")
+            weight = (t - polarThickness[ilow]) / (polarThickness[ihigh] - polarThickness[ilow])
+            # print(polarThickness[ilow],'<',t,'<',polarThickness[ihigh],'Weight',weight)
+            pol = blend(polarList[ilow], polarList[ihigh], weight)
             polars.append(pol)
             # import matplotlib.pyplot as plt
             # fig=plt.figure()
             # plt.plot(polarList[ilow][: ,0],polarList[ilow][: ,2],'b',label='thick'+str(polarThickness[ilow]))
             # plt.plot(pol[:,0],pol[:,2],'k--',label='thick'+str(t))
             # plt.plot(polarList[ihigh][:,0],polarList[ihigh][:,2],'r',label='thick'+str(polarThickness[ihigh]))
             # plt.legend()
             # plt.show()
     return polars
 
 
-def _alpha_window_in_bounds(alpha,window):
-    """ Ensures that the window of alpha values is within the bounds of alpha
+def _alpha_window_in_bounds(alpha, window):
+    """Ensures that the window of alpha values is within the bounds of alpha
     Example: alpha in [-30,30], window=[-20,20] => window=[-20,20]
     Example: alpha in [-10,10], window=[-20,20] => window=[-10,10]
     Example: alpha in [-30,30], window=[-40,10] => window=[-40,10]
     """
-    IBef=np.where(alpha<=window[0])[0]
-    if len(IBef)>0:
-        im=IBef[-1]
+    IBef = np.where(alpha <= window[0])[0]
+    if len(IBef) > 0:
+        im = IBef[-1]
     else:
-        im=0
-    IAft=np.where(alpha>=window[1])[0]
-    if len(IAft)>0:
-        ip=IAft[0]
+        im = 0
+    IAft = np.where(alpha >= window[1])[0]
+    if len(IAft) > 0:
+        ip = IAft[0]
     else:
-        ip=len(alpha)-1
-    window=[alpha[im], alpha[ip]]
+        ip = len(alpha) - 1
+    window = [alpha[im], alpha[ip]]
     return window
 
-def _find_alpha0(alpha,coeff,window):
-    """ Finds the point where coeff(alpha)==0 using interpolation.
+
+def _find_alpha0(alpha, coeff, window):
+    """Finds the point where coeff(alpha)==0 using interpolation.
     The search is narrowed to a window that can be specified by the user. The default window is yet enough for cases that make physical sense.
     The angle alpha0 is found by looking at a zero up crossing in this window, and interpolation is used to find the exact location.
     """
     # Constant case or only one value
-    if np.all(coeff == coeff[0]) or len(coeff)==1:
-        if coeff[0]==0:
+    if np.all(coeff == coeff[0]) or len(coeff) == 1:
+        if coeff[0] == 0:
             return 0
         else:
             return np.nan
     # Ensuring window is within our alpha values
-    window = _alpha_window_in_bounds(alpha,window)
-    
+    window = _alpha_window_in_bounds(alpha, window)
+
     # Finding zero up-crossing within window
-    iwindow=np.where((alpha>=window[0]) & (alpha<=window[1]))
+    iwindow = np.where((alpha >= window[0]) & (alpha <= window[1]))
     alpha = alpha[iwindow]
-    coeff  = coeff[iwindow]
-    alpha_zc,i_zc = _zero_crossings(x=alpha,y=coeff,direction='up')
-    if len(alpha_zc)>1:
-        print('WARN: Cannot find alpha0, {} zero crossings of Coeff in the range of alpha values: [{} {}] '.format(len(alpha_zc),window[0],window[1]))
-        print('>>> Using second zero')
-        alpha_zc=alpha_zc[1:]
-        #raise Exception('Cannot find alpha0, {} zero crossings of Coeff in the range of alpha values: [{} {}] '.format(len(alpha_zc),window[0],window[1]))
-    elif len(alpha_zc)==0:
-        raise Exception('Cannot find alpha0, no zero crossing of Coeff in the range of alpha values: [{} {}] '.format(window[0],window[1]))
+    coeff = coeff[iwindow]
+    alpha_zc, i_zc = _zero_crossings(x=alpha, y=coeff, direction="up")
 
-    alpha0=alpha_zc[0]
+    if len(alpha_zc) > 1:
+        logger.debug(
+            "Cannot find alpha0, {} zero crossings of Coeff in the range of alpha values: [{} {}] ".format(
+                len(alpha_zc), window[0], window[1]
+            )
+        )
+    elif len(alpha_zc) == 0:
+        logger.debug(
+            "Cannot find alpha0, no zero crossing of Coeff in the range of alpha values: [{} {}] ".format(
+                window[0], window[1]
+            )
+        )
+
+    alpha0 = alpha_zc[0]
     return alpha0
 
 
 def _find_TSE_region(alpha, coeff, slope, alpha0, deviation):
-    """ Find the Trailing Edge Separation points, when the coefficient separates from its linear region
+    """Find the Trailing Edge Separation points, when the coefficient separates from its linear region
     These points are defined as the points where the difference is equal to +/- `deviation`
     Typically deviation is about 0.05 (absolute value)
     The linear region is defined as coeff_lin = slope (alpha-alpha0)
 
     returns:
        a_TSE: values of alpha at the TSE point (upper and lower)
-    
+
     """
     # How off are we from the linear region
-    DeltaLin = slope*(alpha - alpha0)  - coeff
+    DeltaLin = slope * (alpha - alpha0) - coeff
 
     # Upper and lower regions
-    bUpp = alpha>=alpha0
-    bLow = alpha<=alpha0
+    bUpp = alpha >= alpha0
+    bLow = alpha <= alpha0
 
     # Finding the point where the delta is equal to `deviation`
-    a_TSEUpp     = np.interp(  deviation, DeltaLin[bUpp], alpha[bUpp])
-    a_TSELow     = np.interp(- deviation, DeltaLin[bLow], alpha[bLow])
+    a_TSEUpp = np.interp(deviation, DeltaLin[bUpp], alpha[bUpp])
+    a_TSELow = np.interp(-deviation, DeltaLin[bLow], alpha[bLow])
     return a_TSELow, a_TSEUpp
 
 
-
-
-def _find_max_points(alpha, coeff, alpha0, method='inflections'):
-    """ Find upper and lower max points in `coeff` vector.
+def _find_max_points(alpha, coeff, alpha0, method="inflections"):
+    """Find upper and lower max points in `coeff` vector.
     if `method` is "inflection":
-       These point are detected from slope changes of `coeff`, positive of negative inflections 
+       These point are detected from slope changes of `coeff`, positive of negative inflections
        The upper stall point is the first point after alpha0 with a "hat" inflection
        The lower stall point is the first point below alpha0 with a "v" inflection
     """
-    if method=='inflections':
+    if method == "inflections":
         dC = np.diff(coeff)
-        IHatInflections = np.where(np.logical_and.reduce((dC[1:]<0, dC[0:-1]>0, alpha[1:-1]>alpha0)))[0]
-        IVeeInflections = np.where(np.logical_and.reduce((dC[1:]>0, dC[0:-1]<0, alpha[1:-1]<alpha0)))[0]
-        if len(IHatInflections)<=0: 
-            raise Exception('Not able to detect upper stall point of curve')
-        if len(IVeeInflections)<=0: 
-            raise Exception('Not able to detect lower stall point of curve')
-        a_MaxUpp = alpha[IHatInflections[0]+1]
-        c_MaxUpp = coeff[IHatInflections[0]+1]
-        a_MaxLow = alpha[IVeeInflections[-1]+1]
-        c_MaxLow = coeff[IVeeInflections[-1]+1]
+        IHatInflections = np.where(np.logical_and.reduce((dC[1:] < 0, dC[0:-1] > 0, alpha[1:-1] > alpha0)))[0]
+        IVeeInflections = np.where(np.logical_and.reduce((dC[1:] > 0, dC[0:-1] < 0, alpha[1:-1] < alpha0)))[0]
+        if len(IHatInflections) <= 0:
+            raise Exception("Not able to detect upper stall point of curve")
+        if len(IVeeInflections) <= 0:
+            raise Exception("Not able to detect lower stall point of curve")
+        a_MaxUpp = alpha[IHatInflections[0] + 1]
+        c_MaxUpp = coeff[IHatInflections[0] + 1]
+        a_MaxLow = alpha[IVeeInflections[-1] + 1]
+        c_MaxLow = coeff[IVeeInflections[-1] + 1]
     else:
         raise NotImplementedError()
-    return (a_MaxUpp,c_MaxUpp,a_MaxLow,c_MaxLow)
-
-
-
-
-# --------------------------------------------------------------------------------}
-# --- Low-level functions 
-# --------------------------------------------------------------------------------{
-def fn_fullsep(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl):
-    """ Function that is zero when f=0 from the Kirchhoff theory """
-    cl_linear = cl_lin(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl)
-    return cl_linear - 0.25* dclda*(alpha-alpha0)
-
-def cl_lin(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl):
-    """ Linear Cl """
-    if alpha > alpha_sl_neg and alpha < alpha_sl_pos :
-        cl = dclda*(alpha-alpha0)
-    else:
-        cl=np.interp(alpha, valpha, vCl)
-    return cl
-
-def cl_fullsep(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl, alpha_fs_l, alpha_fs_u):
-    """ fully separated lift coefficient"""
-    cl_linear = cl_lin(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl)
-    if alpha > alpha_sl_neg and alpha < alpha_sl_pos :
-        cl = cl_linear*0.5
-    else:
-        fp = f_point(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl, alpha_fs_l, alpha_fs_u)
-        cl=(cl_linear- dclda*(alpha-alpha0)*fp)/(1-fp)
-    return cl
-
-def f_point(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl, alpha_fs_l, alpha_fs_u):
-    """ sepration funciton """
-    if dclda==0:
-        return 0
-    if alpha < alpha_fs_l or alpha > alpha_fs_u:
-        return 0
-    else:
-        cl_linear = cl_lin(alpha, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, valpha, vCl)
-        xx=cl_linear/(dclda*(alpha-alpha0) + np.sign(cl_linear)*1e-15)
-        return (2*np.sqrt(xx)-1)**2
-
-
-def polar_params(alpha, cl, cd, cm):
-    """
-    - alpha in radians
-    """
-    #  Treat zero-lift sections separately
-    zero_offset=1e-15
-    x1 = -7*np.pi/180
-    x2 = 7*np.pi/180
-    y1 = np.interp(x1, alpha, cl)
-    y2 = np.interp(x2, alpha, cl)
-
-    if (y1<zero_offset)and(y2<zero_offset):
-       alpha0        = 0.
-       Cd0          = np.interp(alpha0, alpha, cd)
-       Cm0          = np.interp(alpha0, alpha, cm)
-       dclda        = 0.
-       alpha_fs_u   = pi
-       alpha_fs_l   = -pi
-       alpha_sl_neg = 0.
-       alpha_sl_pos = 0.
-    else:
-        alpha0 = _find_alpha0(alpha, cl, [np.radians(-5), np.radians(20)])
-
-        # Find positive angle of attack stall limit alpha_sl_pos
-        alpha_sl_pos=20.*np.pi/180
-        move_up=True
-        maxclp=0.
-        nobs=50
-        while move_up :
-            dalpha=(alpha_sl_pos-alpha0)/nobs
-            y2=np.interp(alpha_sl_pos, alpha, cl)
-            dclda=y2/(alpha_sl_pos-alpha0)
-            if  dclda>maxclp:
-                alpha_maxclp=alpha_sl_pos
-                maxclp=dclda
-            relerr=0.
-            for k in np.arange(nobs):
-                x1 = alpha0+(k+1)*dalpha
-                y1 = np.interp(x1, alpha, cl)
-                y2 = dclda*(x1-alpha0)
-                relerr=relerr+(y1-y2)/y2
-            relerr=relerr/nobs
-            move_up= relerr>1e-2
-            if move_up:
-                alpha_sl_pos=alpha_sl_pos-dalpha
-        alpha_sl_pos=max(alpha_maxclp, alpha_sl_pos)
-
-        # Find negative angle of attack stall limit alpha_sl_neg
-        alpha_sl_neg=-20*np.pi/180
-        move_down=True
-        maxclp=0.
-        while move_down:
-            dalpha=(alpha0-alpha_sl_neg)/nobs
-            y1=np.interp(alpha_sl_neg, alpha, cl)
-            dclda=y1/(alpha_sl_neg-alpha0)
-            if  dclda>maxclp:
-                alpha_maxclp=alpha_sl_neg
-                maxclp=dclda
-            relerr=0.
-            for k in np.arange(nobs):
-                x1=alpha_sl_neg+(k+1)*dalpha
-                y1 = np.interp(x1, alpha, cl)
-                y2=dclda*(x1-alpha0)
-                relerr=relerr+(y1-y2)/y2
-            relerr=relerr/nobs
-            move_down=relerr>1e-2
-            if move_down:
-                alpha_sl_neg=alpha_sl_neg+dalpha
-        alpha_sl_neg=min(alpha_maxclp, alpha_sl_neg)
-
-        # Compute the final alpha and dclda (linear lift coefficient slope) values
-        y1=np.interp(alpha_sl_neg, alpha, cl)
-        y2=np.interp(alpha_sl_pos, alpha, cl)
-        alpha0=(y1*alpha_sl_pos-y2*alpha_sl_neg)/(y1-y2)
-        dclda =(y1-y2)/(alpha_sl_neg-alpha_sl_pos)
-
-        # Find Cd0 and Cm0
-        Cd0          = np.interp(alpha0, alpha, cd)
-        Cm0          = np.interp(alpha0, alpha, cm)
-        # Find upper surface fully stalled angle of attack alpha_fs_u (Upper limit of the Kirchhoff flat plate solution)
-        y1=-1.
-        y2=-1.
-        delta = np.pi/180
-        x2=alpha_sl_pos + delta
-        while  y1*y2>0. and x2+delta<np.pi:
-            x1=x2
-            x2=x1+np.pi/180
-            y1=fn_fullsep(x1, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl)
-            y2=fn_fullsep(x2, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl)
-        if y1*y2<0:
-            alpha_fs_u=(0.-y2)/(y1-y2)*x1+(0.-y1)/(y2-y1)*x2
-        else:
-            alpha_fs_u=np.pi
-        # Find lower surface fully stalled angle of attack alpha_fs_l (lower limit of the Kirchhoff flat plate solution)
-        y1=-1.
-        y2=-1.
-        x2=alpha_sl_neg-delta
-        while y1*y2>0. and x2-delta>-np.pi:
-            x1=x2
-            x2=x1-delta
-            y1=fn_fullsep(x1, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl)
-            y2=fn_fullsep(x2, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl)
-        if y1*y2<0:
-            alpha_fs_l=(0.-y2)/(y1-y2)*x1+(0.-y1)/(y2-y1)*x2
-        else:
-            alpha_fs_l=-np.pi
-
-        # --- Compute values at all angle of attack
-        Cl_fully_sep = np.zeros(alpha.shape)
-        f_st         = np.zeros(alpha.shape)
-        Cl_linear    = np.zeros(alpha.shape)
-        for i,al in enumerate(alpha):
-            Cl_fully_sep[i] = cl_fullsep(al, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl, alpha_fs_l, alpha_fs_u)
-            f_st        [i] = f_point   (al, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl, alpha_fs_l, alpha_fs_u)
-            Cl_linear   [i] = cl_lin    (al, dclda, alpha0, alpha_sl_neg, alpha_sl_pos, alpha, cl)
-
-    p=dict()
-    p['alpha0'] = alpha0
-    p['Cd0'] = Cd0
-    p['Cm0'] = Cm0
-    p['dclda'] = dclda
-    p['alpha_fs_l'] = alpha_fs_l
-    p['alpha_fs_u'] = alpha_fs_u
-    p['alpha_sl_neg'] = alpha_sl_neg
-    p['alpha_sl_pos'] = alpha_sl_pos
-
-    return p, Cl_linear, Cl_fully_sep, f_st
+    return (a_MaxUpp, c_MaxUpp, a_MaxLow, c_MaxLow)
 
 
 # --------------------------------------------------------------------------------}
 # --- Generic curve handling functions
 # --------------------------------------------------------------------------------{
-def _find_slope(x,y,xi=None,x0=None,window=None,method='max',opts=None):
-    """ Find the slope of a curve at x=xi based on a given method.
-    INPUTS: 
-    x: array of x values 
-    y: array of y values 
+def _find_slope(x, y, xi=None, x0=None, window=None, method="max", opts=None):
+    """Find the slope of a curve at x=xi based on a given method.
+    INPUTS:
+    x: array of x values
+    y: array of y values
     xi: point where the slope is to be computed
-    x0: point where y(x0)=0 
+    x0: point where y(x0)=0
         if provided the constraint y(x0)=0 is added.
-    window: 
-        If a `window` is provided the search is restrained to this region of x values. 
+    window:
+        If a `window` is provided the search is restrained to this region of x values.
         Typical windows for airfoils are: window=[alpha0,Clmax], or window=[-5,5]+alpha0
         If window is None,  the whole extent is used (window=[min(x),max(x)])
 
     The methods available are:
         'max'    : returns the maximum slope within the window. Needs `xi`
-        'leastsquare': use leastsquare (or polyfit), to fit the curve within the window 
+        'leastsquare': use leastsquare (or polyfit), to fit the curve within the window
         'finitediff_1c': first order centered finite difference. Needs `xi`
         'optim': find the slope by looking at all possible slope values, and try to find an optimal where the length of linear region is maximized.
 
     returns:
         (a,x0): such that the slope is a(x-x0)
                 (x0=-b/a where y=ax+b)
     """
-
     if window is not None:
-        x_=x
-        y_=y
-        x_ = np.linspace(x[0], x[-1], max(721,len(x))) # using 0.5deg resolution at least
-        y_ = np.interp(x_, x, y)
-        I = np.where(np.logical_and(x_>=window[0],x_<=window[1]))
-        x = x_[I]
-        y = y_[I]
-
-
-    if len(y)<=1:
-        raise Exception('Cannot find slope, two points needed ({} after window selection)'.format(len(y)))
+        I = np.where(np.logical_and(x >= window[0], x <= window[1]))
+        x = x[I]
+        y = y[I]
+
+    if len(y) <= 0:
+        raise Exception("Cannot find slope, no data in y (after window selection)")
+
+    if len(y) < 4 and method == "optim":
+        method = "leastsquare"
+        # print('[WARN] Not enought data to find slope with optim method, using leastsquare')
 
-
-    if len(y)<4 and method=='optim':
-        method='leastsquare'
-        #print('[WARN] Not enought data to find slope with optim method, using leastsquare')
-
-
-    if method=='max':
+    if method == "max":
         if xi is not None:
-            I=np.nonzero(x-xi)
-            yi = np.interp(xi,x,y)
-            a  = max((y[I]-yi)/(x[I]-xi)) 
-            x0 = xi - yi/a
+            I = np.nonzero(x - xi)
+            yi = np.interp(xi, x, y)
+            a = max((y[I] - yi) / (x[I] - xi))
+            x0 = xi - yi / a
         else:
-            raise Exception('For now xi needs to be set to find a slope with the max method')
+            raise Exception("For now xi needs to be set to find a slope with the max method")
 
-    elif method=='finitediff_1c':
+    elif method == "finitediff_1c":
         # First order centered finite difference
         if xi is not None:
             # First point strictly before xi
-            im = np.where(x<xi)[0][-1]
-            dx=(x[im+1]-x[im-1])
-            if np.abs(dx)>1e-7:
-                a = (y[im+1]-y[im-1])/dx
-                yi = np.interp(xi,x,y)
-                x0 = xi - yi/a
-            else:
-                a=np.inf
-                x0 = xi
-            #print('a',a)
-            #print('x0',x0)
-            #print('yi',yi)
-            dx=(x[im+1]-x[im])
-            if np.abs(dx)>1e-7:
-                a = (y[im+1]-y[im])/dx
-                yi = np.interp(xi,x,y)
-                x0 = xi - yi/a
+            im = np.where(x < xi)[0][-1]
+            dx = x[im + 1] - x[im - 1]
+            if np.abs(dx) > 1e-7:
+                a = (y[im + 1] - y[im - 1]) / dx
+                yi = np.interp(xi, x, y)
+                x0 = xi - yi / a
             else:
-                a=np.inf
+                a = np.inf
                 x0 = xi
-            #print('a',a)
-            #print('x0',x0)
-            #print('yi',yi)
         else:
-            raise Exception('For now xi needs to be set to find a slope with the finite diff method')
+            raise Exception("For now xi needs to be set to find a slope with the finite diff method")
 
-    elif method=='leastsquare':
+    elif method == "leastsquare":
         if x0 is not None:
             try:
-                a = np.linalg.lstsq((x-x0).reshape((-1,1)),y.reshape((-1,1)),rcond = None)[0][0][0]
+                a = np.linalg.lstsq((x - x0).reshape((-1, 1)), y.reshape((-1, 1)), rcond=None)[0][0][0]
             except:
-                a = np.linalg.lstsq((x-x0).reshape((-1,1)),y.reshape((-1,1)))[0][0][0]
+                a = np.linalg.lstsq((x - x0).reshape((-1, 1)), y.reshape((-1, 1)))[0][0][0]
         else:
-            p      = np.polyfit(x, y, 1)
-            a  =  p[0]
-            x0 = -p[1]/a
-    elif method=='optim':
+            p = np.polyfit(x, y, 1)
+            a = p[0]
+            x0 = -p[1] / a
+    elif method == "optim":
         if opts is None:
-            nMin=max(3, int(len(x)/2))
+            nMin = max(3, int(len(x) / 2))
         else:
-            nMin = opts['nMin']
-
-        a,x0,iStart,iEnd = _find_linear_region(x,y,nMin,x0)
+            nMin = opts["nMin"]
 
+        a, x0, iStart, iEnd = _find_linear_region(x, y, nMin, x0)
 
     else:
         raise NotImplementedError()
     return a, x0
 
-def _find_linear_region(x,y,nMin,x0=None):
-    """ Find a linear region by computing all possible slopes for all possible extent.
-        The objective function tries to minimize the error with the linear slope
-        and maximize the length of the linear region.
-        nMin is the mimum number of points to be present in the region
-        If x0 is provided, the function a*(x-x0) is fitted
-
-        returns: 
-            slope :
-            offset:
-            iStart: index of start of linear region
-            iEnd  : index of end of linear region
+
+def _find_linear_region(x, y, nMin, x0=None):
+    """Find a linear region by computing all possible slopes for all possible extent.
+    The objective function tries to minimize the error with the linear slope
+    and maximize the length of the linear region.
+    nMin is the mimum number of points to be present in the region
+    If x0 is provided, the function a*(x-x0) is fitted
+
+    returns:
+        slope :
+        offset:
+        iStart: index of start of linear region
+        iEnd  : index of end of linear region
     """
     if x0 is not None:
-        x = x.reshape((-1,1))-x0
-        y = y.reshape((-1,1))
-    n=len(x)-nMin+1
-    err = np.zeros((n,n))*np.nan
-    slp = np.zeros((n,n))*np.nan
-    off = np.zeros((n,n))*np.nan
-    spn = np.zeros((n,n))*np.nan
+        x = x.reshape((-1, 1)) - x0
+        y = y.reshape((-1, 1))
+    n = len(x) - nMin + 1
+    err = np.zeros((n, n)) * np.nan
+    slp = np.zeros((n, n)) * np.nan
+    off = np.zeros((n, n)) * np.nan
+    spn = np.zeros((n, n)) * np.nan
     for iStart in range(n):
-        for j in range(iStart,n):
-            iEnd=j+nMin
+        for j in range(iStart, n):
+            iEnd = j + nMin
             if x0 is not None:
-                sl=np.linalg.lstsq(x[iStart:iEnd],y[iStart:iEnd],rcond=None)[0][0]
-                slp[iStart,j]= sl
-                off[iStart,j]= x0
+                sl = np.linalg.lstsq(x[iStart:iEnd], y[iStart:iEnd], rcond=None)[0][0]
+                slp[iStart, j] = sl
+                off[iStart, j] = x0
                 y_lin = x[iStart:iEnd] * sl
             else:
-                coefs = np.polyfit(x[iStart:iEnd],y[iStart:iEnd],1)
-                slp[iStart,j]= coefs[0]
-                off[iStart,j]= -coefs[1]/coefs[0]
+                coefs = np.polyfit(x[iStart:iEnd], y[iStart:iEnd], 1)
+                slp[iStart, j] = coefs[0]
+                off[iStart, j] = -coefs[1] / coefs[0]
                 y_lin = x[iStart:iEnd] * coefs[0] + coefs[1]
-            err[iStart,j]= np.mean((y[iStart:iEnd]-y_lin)**2)
-            spn[iStart,j]= iEnd-iStart
-    spn=1/(spn-nMin+1)
-    err=(err)/(np.nanmax(err)) 
-    obj = np.multiply(spn,err) 
-    obj=err
-    (iStart,j) = np.unravel_index(np.nanargmin(obj), obj.shape)
-    iEnd=j+nMin-1 # note -1 since we return the index here
-    return slp[iStart,j],off[iStart,j],iStart,iEnd
+            err[iStart, j] = np.mean((y[iStart:iEnd] - y_lin) ** 2)
+            spn[iStart, j] = iEnd - iStart
+    spn = 1 / (spn - nMin + 1)
+    err = (err) / (np.nanmax(err))
+    obj = np.multiply(spn, err)
+    obj = err
+    (iStart, j) = np.unravel_index(np.nanargmin(obj), obj.shape)
+    iEnd = j + nMin - 1  # note -1 since we return the index here
+    return slp[iStart, j], off[iStart, j], iStart, iEnd
 
-def _zero_crossings(y,x=None,direction=None):
 
-    """
-      Find zero-crossing points in a discrete vector, using linear interpolation.
-      direction: 'up' or 'down', to select only up-crossings or down-crossings
-      Returns: 
-          x values xzc such that y(yzc)==0
-          indexes izc, such that the zero is between y[izc] (excluded) and y[izc+1] (included)
-      if direction is not provided, also returns:
-              sign, equal to 1 for up crossing
+def _zero_crossings(y, x=None, direction=None):
 
-    NOTE: keep in harmony with welib.tools.signals_analysis
     """
-    y=np.asarray(y)
+    Find zero-crossing points in a discrete vector, using linear interpolation.
+    direction: 'up' or 'down', to select only up-crossings or down-crossings
+    Returns:
+        x values xzc such that y(yzc)==0
+        indexes izc, such that the zero is between y[izc] (excluded) and y[izc+1] (included)
+    if direction is not provided, also returns:
+            sign, equal to 1 for up crossing
+    """
+    y = np.asarray(y)
     if x is None:
-        x=np.arange(len(y))
+        x = np.arange(len(y))
 
-    deltas = x[1:] - x[0:-1]
-    if np.any(deltas == 0.0):
-        I=np.where(deltas==0)[0]
-        print('[WARN] Some x values are repeated at index {}. Removing them.'.format(I))
-        x=np.delete(x,I)
-        y=np.delete(x,I)
-    if np.any(deltas<0):
-        raise Exception('x values need to be in ascending order')
+    if np.any((x[1:] - x[0:-1]) <= 0.0):
+        raise Exception("x values need to be in ascending order")
 
     # Indices before zero-crossing
-    iBef = np.where(y[1:]*y[0:-1] < 0.0)[0]
-    
+    iBef = np.where(y[1:] * y[0:-1] < 0.0)[0]
+
     # Find the zero crossing by linear interpolation
-    xzc = x[iBef] - y[iBef] * (x[iBef+1] - x[iBef]) / (y[iBef+1] - y[iBef])
-    
+    xzc = x[iBef] - y[iBef] * (x[iBef + 1] - x[iBef]) / (y[iBef + 1] - y[iBef])
+
     # Selecting points that are exactly 0 and where neighbor change sign
     iZero = np.where(y == 0.0)[0]
-    iZero = iZero[np.where((iZero > 0) & (iZero < x.size-1))]
-    iZero = iZero[np.where(y[iZero-1]*y[iZero+1] < 0.0)]
+    iZero = iZero[np.where((iZero > 0) & (iZero < x.size - 1))]
+    iZero = iZero[np.where(y[iZero - 1] * y[iZero + 1] < 0.0)]
 
-    # Concatenate 
-    xzc  = np.concatenate((xzc, x[iZero]))
+    # Concatenate
+    xzc = np.concatenate((xzc, x[iZero]))
     iBef = np.concatenate((iBef, iZero))
 
     # Sort
     iSort = np.argsort(xzc)
     xzc, iBef = xzc[iSort], iBef[iSort]
 
     # Return up-crossing, down crossing or both
-    sign = np.sign(y[iBef+1]-y[iBef])
-    if direction == 'up':
-        I= np.where(sign==1)[0]
-        return xzc[I],iBef[I]
-    elif direction == 'down':
-        I= np.where(sign==-1)[0]
-        return xzc[I],iBef[I]
+    sign = np.sign(y[iBef + 1] - y[iBef])
+    if direction == "up":
+        I = np.where(sign == 1)[0]
+        return xzc[I], iBef[I]
+    elif direction == "down":
+        I = np.where(sign == -1)[0]
+        return xzc[I], iBef[I]
     elif direction is not None:
-        raise Exception('Direction should be either `up` or `down`')
+        raise Exception("Direction should be either `up` or `down`")
     return xzc, iBef, sign
 
 
-def _intersections(x1,y1,x2,y2):
+def _intersections(x1, y1, x2, y2):
     """
-   INTERSECTIONS Intersections of curves.
-   Computes the (x,y) locations where two curves intersect.  The curves
-   can be broken with NaNs or have vertical segments.
-
-   Written by: Sukhbinder, https://github.com/sukhbinder/intersection
-   License: MIT
-   usage:
-       x,y=intersection(x1,y1,x2,y2)
-
-    Example:
-    a, b = 1, 2
-    phi = np.linspace(3, 10, 100)
-    x1 = a*phi - b*np.sin(phi)
-    y1 = a - b*np.cos(phi)
-
-    x2=phi
-    y2=np.sin(phi)+2
-    x,y=intersection(x1,y1,x2,y2)
-
-    plt.plot(x1,y1,c='r')
-    plt.plot(x2,y2,c='g')
-    plt.plot(x,y,'*k')
-    plt.show()
+    INTERSECTIONS Intersections of curves.
+    Computes the (x,y) locations where two curves intersect.  The curves
+    can be broken with NaNs or have vertical segments.
+
+    Written by: Sukhbinder, https://github.com/sukhbinder/intersection
+    License: MIT
+    usage:
+        x,y=intersection(x1,y1,x2,y2)
+
+     Example:
+     a, b = 1, 2
+     phi = np.linspace(3, 10, 100)
+     x1 = a*phi - b*np.sin(phi)
+     y1 = a - b*np.cos(phi)
+
+     x2=phi
+     y2=np.sin(phi)+2
+     x,y=intersection(x1,y1,x2,y2)
+
+     plt.plot(x1,y1,c='r')
+     plt.plot(x2,y2,c='g')
+     plt.plot(x,y,'*k')
+     plt.show()
 
     """
-    def _rect_inter_inner(x1,x2):
-        n1=x1.shape[0]-1
-        n2=x2.shape[0]-1
-        X1=np.c_[x1[:-1],x1[1:]]
-        X2=np.c_[x2[:-1],x2[1:]]
-        S1=np.tile(X1.min(axis=1),(n2,1)).T
-        S2=np.tile(X2.max(axis=1),(n1,1))
-        S3=np.tile(X1.max(axis=1),(n2,1)).T
-        S4=np.tile(X2.min(axis=1),(n1,1))
-        return S1,S2,S3,S4
-
-    def _rectangle_intersection_(x1,y1,x2,y2):
-        S1,S2,S3,S4=_rect_inter_inner(x1,x2)
-        S5,S6,S7,S8=_rect_inter_inner(y1,y2)
-
-        C1=np.less_equal(S1,S2)
-        C2=np.greater_equal(S3,S4)
-        C3=np.less_equal(S5,S6)
-        C4=np.greater_equal(S7,S8)
-
-        ii,jj=np.nonzero(C1 & C2 & C3 & C4)
-        return ii,jj
-    ii,jj=_rectangle_intersection_(x1,y1,x2,y2)
-    n=len(ii)
-
-    dxy1=np.diff(np.c_[x1,y1],axis=0)
-    dxy2=np.diff(np.c_[x2,y2],axis=0)
-
-    T=np.zeros((4,n))
-    AA=np.zeros((4,4,n))
-    AA[0:2,2,:]=-1
-    AA[2:4,3,:]=-1
-    AA[0::2,0,:]=dxy1[ii,:].T
-    AA[1::2,1,:]=dxy2[jj,:].T
-
-    BB=np.zeros((4,n))
-    BB[0,:]=-x1[ii].ravel()
-    BB[1,:]=-x2[jj].ravel()
-    BB[2,:]=-y1[ii].ravel()
-    BB[3,:]=-y2[jj].ravel()
+
+    def _rect_inter_inner(x1, x2):
+        n1 = x1.shape[0] - 1
+        n2 = x2.shape[0] - 1
+        X1 = np.c_[x1[:-1], x1[1:]]
+        X2 = np.c_[x2[:-1], x2[1:]]
+        S1 = np.tile(X1.min(axis=1), (n2, 1)).T
+        S2 = np.tile(X2.max(axis=1), (n1, 1))
+        S3 = np.tile(X1.max(axis=1), (n2, 1)).T
+        S4 = np.tile(X2.min(axis=1), (n1, 1))
+        return S1, S2, S3, S4
+
+    def _rectangle_intersection_(x1, y1, x2, y2):
+        S1, S2, S3, S4 = _rect_inter_inner(x1, x2)
+        S5, S6, S7, S8 = _rect_inter_inner(y1, y2)
+
+        C1 = np.less_equal(S1, S2)
+        C2 = np.greater_equal(S3, S4)
+        C3 = np.less_equal(S5, S6)
+        C4 = np.greater_equal(S7, S8)
+
+        ii, jj = np.nonzero(C1 & C2 & C3 & C4)
+        return ii, jj
+
+    ii, jj = _rectangle_intersection_(x1, y1, x2, y2)
+    n = len(ii)
+
+    dxy1 = np.diff(np.c_[x1, y1], axis=0)
+    dxy2 = np.diff(np.c_[x2, y2], axis=0)
+
+    T = np.zeros((4, n))
+    AA = np.zeros((4, 4, n))
+    AA[0:2, 2, :] = -1
+    AA[2:4, 3, :] = -1
+    AA[0::2, 0, :] = dxy1[ii, :].T
+    AA[1::2, 1, :] = dxy2[jj, :].T
+
+    BB = np.zeros((4, n))
+    BB[0, :] = -x1[ii].ravel()
+    BB[1, :] = -x2[jj].ravel()
+    BB[2, :] = -y1[ii].ravel()
+    BB[3, :] = -y2[jj].ravel()
 
     for i in range(n):
         try:
-            T[:,i]=np.linalg.solve(AA[:,:,i],BB[:,i])
+            T[:, i] = np.linalg.solve(AA[:, :, i], BB[:, i])
         except:
-            T[:,i]=np.NaN
+            T[:, i] = np.NaN
 
+    in_range = (T[0, :] >= 0) & (T[1, :] >= 0) & (T[0, :] <= 1) & (T[1, :] <= 1)
 
-    in_range= (T[0,:] >=0) & (T[1,:] >=0) & (T[0,:] <=1) & (T[1,:] <=1)
-
-    xy0=T[2:,in_range]
-    xy0=xy0.T
-    return xy0[:,0],xy0[:,1]
-
-
-if __name__ == '__main__':
-    pass
+    xy0 = T[2:, in_range]
+    xy0 = xy0.T
+    return xy0[:, 0], xy0[:, 1]
 
 
+def smooth_heaviside(x, k=1, rng=(-np.inf, np.inf), method="exp"):
+    """
+    Smooth approximation of Heaviside function where the step occurs between rng[0] and rng[1]:
+       if rng[0]<rng[1]: then  f(<rng[0])=0, f(>=rng[1])=1
+       if rng[0]>rng[1]: then  f(<rng[1])=1, f(>=rng[0])=0
+    exp:
+       rng=(-inf,inf):  H(x)=[1 + exp(-2kx)            ]^-1
+       rng=(-1,1):      H(x)=[1 + exp(4kx/(x^2-1)      ]^-1
+       rng=(0,1):       H(x)=[1 + exp(k(2x-1)/(x(x-1)) ]^-1
+    INPUTS:
+        x  : scalar or vector of real x values \in ]-infty; infty[
+        k  : float >=1, the higher k the "steeper" the heaviside function
+        rng: tuple of min and max value such that f(<=min)=0  and f(>=max)=1.
+             Reversing the range makes the Heaviside function from 1 to 0 instead of 0 to 1
+        method: smooth approximation used (e.g. exp or tan)
+    NOTE: an epsilon is introduced in the denominator to avoid overflow of the exponentail
+    """
+    if k < 1:
+        raise Exception("k needs to be >=1")
+    eps = 1e-2
+    mn, mx = rng
+    x = np.asarray(x)
+    H = np.zeros(x.shape)
+    if mn < mx:
+        H[x <= mn] = 0
+        H[x >= mx] = 1
+        b = np.logical_and(x > mn, x < mx)
+    else:
+        H[x <= mx] = 1
+        H[x >= mn] = 0
+        b = np.logical_and(x < mn, x > mx)
+    x = x[b]
+    if method == "exp":
+        if np.abs(mn) == np.inf and np.abs(mx) == np.inf:
+            # Infinite support
+            x[k * x > 100] = 100.0 / k
+            x[k * x < -100] = -100.0 / k
+            if mn < mx:
+                H[b] = 1 / (1 + np.exp(-k * x))
+            else:
+                H[b] = 1 / (1 + np.exp(k * x))
+        elif np.abs(mn) != np.inf and np.abs(mx) != np.inf:
+            n = 4.0
+            # Compact support
+            s = 2.0 / (mx - mn) * (x - (mn + mx) / 2.0)  # transform compact support into ]-1,1[
+            x = -n * s / (s ** 2 - 1.0)  # then transform   ]-1,1[  into ]-inf,inf[
+            x[k * x > 100] = 100.0 / k
+            x[k * x < -100] = -100.0 / k
+            H[b] = 1.0 / (1 + np.exp(-k * x))
+        else:
+            raise NotImplementedError("Heaviside with only one bound infinite")
+    else:
+        # TODO tan approx
+        raise NotImplementedError()
+    return H
 
 
+if __name__ == "__main__":
+    pass
```

### Comparing `welib-0.0.2/welib/airfoils/data/63-235.csv` & `welib-1.0.0/welib/airfoils/data/63-235.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/data/DU21_A17.csv` & `welib-1.0.0/welib/airfoils/data/DU21_A17.csv`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/data/FFA-W3-241-Re12M.dat` & `welib-1.0.0/welib/airfoils/data/FFA-W3-241-Re12M.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/examples/createADPolarFile.py` & `welib-1.0.0/welib/airfoils/examples/createADPolarFile.py`

 * *Files 16% similar despite different names*

```diff
@@ -3,30 +3,32 @@
  - The various parameters (e.g. unsteady parameters) are computed and updated
  - The AD file is written
 """
 import numpy as np
 import os
 
 from welib.airfoils.Polar import Polar
-import welib.weio as weio
+from welib.weio.fast_input_file import FASTInputFile
+from welib.weio.csv_file import CSVFile
 
-MyDir=os.path.dirname(__file__)
+# Get current directory so this script can be called from any location
+scriptDir=os.path.dirname(__file__)
 
 
 def main_ReWriteADFile():
     """ 
     Example 1: 
       - open an existing AeroDyn polar file
       - rewrite it (unsteady parameters are recomputed)
     """
-    AD_polarFile_in = os.path.join(MyDir,'../../../data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat')
+    AD_polarFile_in = os.path.join(scriptDir,'../../../data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat')
     AD_polarFile_out = '_Polar_out.dat.ignore'
 
     # Open an existing AeroDyn polar file
-    polar = Polar(AD_polarFile_in)
+    polar = Polar(AD_polarFile_in, fformat='ADPolar')
     # Rewrite it (unsteady parameters are recomputed)
     # NOTE: you can provide templateFile=AD_polarFile_in to the function below
     #       to ensure that the file will look the same
     comment = 'Cylinder at Re=6Million\nUpdated unsteady parameters' # Optional comment
     Re      = 6 # Reynolds number in Million (Optional)
     ADpol = polar.toAeroDyn(AD_polarFile_out, Re=6, comment=comment)
 
@@ -35,38 +37,38 @@
 
 def main_WriteADPolar():
     """ 
     Example 2: 
       - Open a tabulated file with alpha,Cl,Cd,Cm 
       - Write an AeroDyn file from it (unsteady parameters are computed)
     """
-    polarFile_in     = os.path.join(MyDir,'../data/DU21_A17.csv')
+    polarFile_in     = os.path.join(scriptDir,'../data/DU21_A17.csv')
     polarFile_AD_out = '_Polar_out.dat.ignore'
 
     # Open a tabulated file with alpha,Cl,Cd,Cm 
-    polar = Polar(polarFile_in)
+    polar = Polar(polarFile_in, fformat='delimited')
     # Write an AeroDyn file from it (unsteady parameters are computed)
     # NOTE: you can provide templateFile='ADTemplate.dat' to the function below
     #       to ensure that the AD file will look the same as the template.
     ADpol = polar.toAeroDyn(polarFile_AD_out)
 
     return ADpol, polar
 
 def main_WriteADPolarLowLevel():
     """
     Example 3: Same as Example 2, but with low level interface.
     """
     # --- Reading an existing AD file, just as a template, we'll replace things in it
-    templateADFile = os.path.join(MyDir,'../../../data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat')
-    ADpol = weio.read(templateADFile)
+    templateADFile = os.path.join(scriptDir,'../../../data/NREL5MW/5MW_Baseline/Airfoils/Cylinder1.dat')
+    ADpol = FASTInputFile(templateADFile)
 
     # --- Creating a Polar object from Cl-Cd data
-    polarFile = os.path.join(MyDir,'../data/DU21_A17.csv')
-    p=weio.read(polarFile).toDataFrame().values
-    polar= Polar(np.nan, p[:,0],p[:,1],p[:,2],p[:,3])
+    polarFile = os.path.join(scriptDir,'../data/DU21_A17.csv')
+    p=CSVFile(polarFile).toDataFrame().values
+    polar= Polar(alpha=p[:,0],cl=p[:,1],cd=p[:,2],cm=p[:,3])
     (alpha0,alpha1,alpha2,cnSlope,cn1,cn2,cd0,cm0)=polar.unsteadyParams()
 
     # --- Updating the AD polar file 
     # Setting unsteady parameters
     ADpol['Re'] = 1.0000 # TODO UNKNOWN
     if np.isnan(alpha0):
         ADpol['alpha0'] = 0
```

### Comparing `welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh.py` & `welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh.py`

 * *Files 2% similar despite different names*

```diff
@@ -12,15 +12,15 @@
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 def prescribed_oscillations():
     radians=True
     #FFA-W3-241 airfoil Dyna Stall
 #     P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True,to_radians=radians)
-    P=Polar.fromfile(os.path.join(MyDir,'../data/DU21_A17.csv'),compute_params=True,to_radians=radians)
+    P=Polar(os.path.join(MyDir,'../data/DU21_A17.csv'), compute_params=True, radians=radians)
 
     if radians:
         deg_scale=np.pi/180
     else:
         deg_scale=1
 
     K_omega    = 0.1    # reduced frequency k=omega*c/(2U0)
@@ -48,15 +48,15 @@
     Cl_oye   = np.zeros((len(valpha_mean),len(vt)))
     valpha_t = np.zeros((len(valpha_mean),len(vt)))
 
     # Loop on alpham and time 
     for ia,alpham in enumerate(valpha_mean):
         valpha_t[ia,:]   = (alpham+DeltaAlpha*np.sin(omega*vt))*deg_scale
         valpha_dot_t     = (2*omega*np.cos(omega*vt) )*deg_scale
-        fs_prev = P.f_st_interp(alpham*deg_scale)# init with steady value
+        fs_prev = P.fs_interp(alpham*deg_scale)# init with steady value
 
         # Oye's Parameters and Inputs
         p_oye = dynstall_oye_param_from_polar(P, tau=tau_oye)
         u_oye=dict()
         u_oye['alpha']    = lambda t: np.interp(t, vt, valpha_t[ia,:])
 
         # MHH Parameters and Inputs
@@ -108,15 +108,15 @@
         #print(dynstall_mh_steady(0,u,p))
         #print(Cl_mh[ia,-1])
         #print(P.cl_interp(alpham*deg_scale))
     from welib.tools.colors import fColrs
 
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(8.4,5.8)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-    ax.plot(P.alpha/deg_scale  , P.f_st ,     label='f_st')
+    ax.plot(P.alpha/deg_scale  , P.fs  ,     label='f_s')
     ax.plot(P.alpha/deg_scale  , P.cl  , 'k-',label='Cl static', linewidth=2)
     ax.plot(P.alpha/deg_scale  , P.cl_fs  ,'k--',  label='Cl fully separated')
     ax.plot(P.alpha/deg_scale  , P.cl_inv ,'k-.',  label='Cl inviscid')
     iStart=np.argmin(np.abs(vt-(vt[-1]-T)))-1
     for ia,alpham in enumerate(valpha_mean):
         if ia==0:
             lbl1='Cl dynamic (Oye)'
@@ -129,15 +129,15 @@
         ax.plot(valpha_t[ia,iStart:]/deg_scale, Cl_mhh[ia,iStart:] ,'-', color=col  , label=lbl2)
     ax.tick_params(direction='in')
     ax.set_xlabel('Alpha [deg]')
     ax.set_ylabel('Cl [-]')
     ax.set_xlim(XLIM)
     ax.set_ylim(YLIM)
     ax.legend()
-    ax.set_title('MGH dynamic stall model')
+    ax.set_title('Airfoils - MGH dynamic stall model')
 
 if __name__ == '__main__':
     prescribed_oscillations()
     plt.show()
 if __name__ == '__test__':
     prescribed_oscillations()
 if __name__=="__export__":
```

### Comparing `welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh_riso_1792.py` & `welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh_riso_1792.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 # --------------------------------------------------------------------------------{
 def prescribed_oscillations_ris_r_1792():
     """
         See Riso-R-1792 report, p23-26 Figure 4.1 4.2
     """
     radians=True
     #FFA-W3-241 airfoil Dyna Stall
-    P=Polar.fromfile(os.path.join(MyDir,'../data/DU21_A17.csv'),compute_params=True,to_radians=radians)
+    P=Polar(os.path.join(MyDir,'../data/DU21_A17.csv'), compute_params=True, radians=radians)
 
     if radians:
         deg_scale=np.pi/180
     else:
         deg_scale=1
 
     #print('alpha0:',P._alpha0/deg_scale)
@@ -51,15 +51,15 @@
     Cl_oye   = np.zeros((len(valpha_mean),len(vt)))
     valpha_t = np.zeros((len(valpha_mean),len(vt)))
 
     # Loop on alpham and time 
     for ia,alpham in enumerate(valpha_mean):
         valpha_t[ia,:]   = (alpham+DeltaAlpha*np.sin(omega*vt))*deg_scale
         valpha_dot_t     = (2*omega*np.cos(omega*vt) )*deg_scale 
-        fs_prev = P.f_st_interp(alpham*deg_scale)# init with steady value
+        fs_prev = P.fs_interp(alpham*deg_scale)# init with steady value
 
         # Oye's Parameters and Inputs
         p_oye = dynstall_oye_param_from_polar(P, tau=tau_oye)
         u_oye=dict()
         u_oye['alpha']    = lambda t: np.interp(t, vt, valpha_t[ia,:])
 
         # MHH Parameters and Inputs
```

### Comparing `welib-0.0.2/welib/airfoils/examples/dynamic_stall_mhh_step_change.py` & `welib-1.0.0/welib/airfoils/examples/dynamic_stall_mhh_step_change.py`

 * *Files 2% similar despite different names*

```diff
@@ -17,15 +17,15 @@
     # --- 
     # We use a step from alpha0 to alpha0+2, testing mainly the circulatory response (history)
     # Oye's dynamic stall model will not give a proper response here:
     #  - We are in the linear region, f close to 1, resulting in mainly Cl_inv
     #  - There is no induction build-up (induction history) in the Oye's stall model itself
     #    Fs is continuous and progressive but not Cl since it uses the current alpha. 
     radians=True
-    P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True,to_radians=radians)
+    P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), compute_params=True, radians=radians)
     if radians:
         deg_scale=np.pi/180
     else:
         deg_scale=1
     U0      = 10
     chord   = 0.1591
     alpha1  = P._alpha0 
@@ -54,16 +54,16 @@
     u['alpha']     = lambda t: alpha1 if t<=0 else alpha2 
     u['omega']     = lambda t: 0
     u['alpha_34']  = u['alpha']
 
     # Steady values
     Cl_st1 = P.cl_interp(alpha1)
     Cl_st2 = P.cl_interp(alpha2)
-    fs1    = P.f_st_interp(alpha1)        # init with steady value
-    fs2    = P.f_st_interp(alpha2)        # init with steady value
+    fs1    = P.fs_interp(alpha1)        # init with steady value
+    fs2    = P.fs_interp(alpha2)        # init with steady value
     y0_oye = [0.] # <<<<<<<<<<<<<<<<<<<<<<<<< do not init to fs1
 
     Cl_oye  = np.zeros(len(vt))
 
 
     # --- MHH
     p['alpha0_in_x1x2']=True
```

### Comparing `welib-0.0.2/welib/airfoils/examples/dynamic_stall_oye.py` & `welib-1.0.0/welib/airfoils/examples/dynamic_stall_oye.py`

 * *Files 11% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 from welib.airfoils.Polar import * 
 
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 def prescribed_oscillations():
     #FFA-W3-241 airfoil Dyna Stall
-    P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True)
+    P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), compute_params=True)
 
     # Parameters
     omega       = 12.57
     T           = 2*np.pi/omega
     tau         = 0.08
     valpha_mean = [5,10,15,20,25,30,35]
     t_max       = 1.3*T                  # simulation length
@@ -29,20 +29,20 @@
     Cl       = np.zeros((len(valpha_mean),len(vt)))
     Cl_num   = np.zeros((len(valpha_mean),len(vt)))
     valpha_t = np.zeros((len(valpha_mean),len(vt)))
 
     # Loop on alpham and time 
     for ia,alpham in enumerate(valpha_mean):
         valpha_t[ia,:]=alpham+2*np.sin(omega*vt)
-        fs_prev = P.f_st_interp(alpham)# init with steady value
+        fs_prev = P.fs_interp(alpham)# init with steady value
 
         def dyna_stall_oye(t,fs):
             """ d(fs)/dt = 1/tau (fs_st - fs) """
             alpha_t = np.interp(t, vt, valpha_t[ia,:])
-            f_st    = P.f_st_interp  (alpha_t)
+            f_st    = P.fs_interp  (alpha_t)
             return 1/tau *( f_st - fs)
 
         # Integration using solve_ivp
         sol = solve_ivp(dyna_stall_oye, t_span=[0, t_max], y0=[fs_prev], t_eval=vt)
         for it,fs in enumerate(sol.y[0,:]):
             alpha_t = valpha_t[ia,it]
             Clinv   = P.cl_inv_interp(alpha_t)
@@ -63,15 +63,15 @@
             lbl=''
         ax.plot(valpha_t[ia,:], Cl_num[ia,:], 'k-'   , label=lbl)
         #ax.plot(valpha_t[ia,:], Cl[ia,:], 'k--'   , label=lbl)
     ax.set_xlabel('Alpha [deg]')
     ax.set_ylabel('Cl [-]')
     ax.set_xlim(XLIM)
     ax.set_ylim([0,2.2])
-    ax.set_title('Oye dynamic stall model')
+    ax.set_title('Airfoils - Oye dynamic stall model')
 
 if __name__ == '__main__':
     prescribed_oscillations()
     plt.show()
 if __name__ == '__test__':
     prescribed_oscillations()
 if __name__=="__export__":
```

### Comparing `welib-0.0.2/welib/airfoils/matlab/KarmanTrefftzGeometry` & `welib-1.0.0/welib/airfoils/matlab/KarmanTrefftzGeometry`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/KarmanTrefftzGeometry.f90` & `welib-1.0.0/welib/airfoils/matlab/KarmanTrefftzGeometry.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/MainProfileCoordinatesExamples.m` & `welib-1.0.0/welib/airfoils/matlab/MainProfileCoordinatesExamples.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/MainForcedOscillations.m` & `welib-1.0.0/welib/airfoils/matlab/__tests__/MainForcedOscillations.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/MainPolars.m` & `welib-1.0.0/welib/airfoils/matlab/__tests__/MainPolars.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/MainPolarsFullySep.m` & `welib-1.0.0/welib/airfoils/matlab/__tests__/MainPolarsFullySep.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/data/DTU_10MW_RWT_pc.dat` & `welib-1.0.0/welib/airfoils/matlab/__tests__/data/DTU_10MW_RWT_pc.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/data/FFA-W3-241-Re12e6.dat` & `welib-1.0.0/welib/airfoils/matlab/__tests__/data/FFA-W3-241-Re12e6.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/__tests__/data/tjaere11_ds.dat` & `welib-1.0.0/welib/airfoils/matlab/__tests__/data/tjaere11_ds.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3211.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3211.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3241.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3241.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3301.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3301.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3360.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3360.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3400fb.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3400fb.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/ffaw3480.dat` & `welib-1.0.0/welib/airfoils/matlab/data/ffaw3480.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/geom-cylinder.dat` & `welib-1.0.0/welib/airfoils/matlab/data/geom-cylinder.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/geom-ffaw3241.dat` & `welib-1.0.0/welib/airfoils/matlab/data/geom-ffaw3241.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/data/geom-karman-trefftz_-0.1_0.0_5.dat` & `welib-1.0.0/welib/airfoils/matlab/data/geom-karman-trefftz_-0.1_0.0_5.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fAlpha0.m` & `welib-1.0.0/welib/airfoils/matlab/fAlpha0.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fDynaStallOye.m` & `welib-1.0.0/welib/airfoils/matlab/fDynaStallOye.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fInitPolar.m` & `welib-1.0.0/welib/airfoils/matlab/fInitPolar.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fLoadFromPressure.m` & `welib-1.0.0/welib/airfoils/matlab/fLoadFromPressure.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fLoadFromTau.m` & `welib-1.0.0/welib/airfoils/matlab/fLoadFromTau.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fPlotAirfoilForces.m` & `welib-1.0.0/welib/airfoils/matlab/fPlotAirfoilForces.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fPolarExtendViterna.m` & `welib-1.0.0/welib/airfoils/matlab/fPolarExtendViterna.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fPolarFullySeparated.m` & `welib-1.0.0/welib/airfoils/matlab/fPolarFullySeparated.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fPressureIntegration.m` & `welib-1.0.0/welib/airfoils/matlab/fPressureIntegration.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fProfileCoordinates.m` & `welib-1.0.0/welib/airfoils/matlab/fProfileCoordinates.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fProfileKarmanTrefftz.m` & `welib-1.0.0/welib/airfoils/matlab/fProfileKarmanTrefftz.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fProfileStandardize.m` & `welib-1.0.0/welib/airfoils/matlab/fProfileStandardize.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/fProfileVanDeVooren.m` & `welib-1.0.0/welib/airfoils/matlab/fProfileVanDeVooren.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/naca4gen.m` & `welib-1.0.0/welib/airfoils/matlab/naca4gen.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/naca5gen.m` & `welib-1.0.0/welib/airfoils/matlab/naca5gen.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/struct2str.m` & `welib-1.0.0/welib/airfoils/matlab/struct2str.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/matlab/textlegend.m` & `welib-1.0.0/welib/airfoils/matlab/textlegend.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/airfoils/tests/test_dynamic_stall.py` & `welib-1.0.0/welib/airfoils/tests/test_dynamic_stall.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,28 +13,28 @@
 # --------------------------------------------------------------------------------{
 class TestDynamicStall(unittest.TestCase):
     def assertNaN(self,x):
         self.assertTrue(np.isnan(x))
 
     def test_oye(self):
         #FFA-W3-241 airfoil Dyna Stall
-        P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True)
+        P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), compute_params=True)
 
         omega       = 12.57
         T           = 2*np.pi/omega
         tau         = 0.08
         alpham      = 20
         dt          = 0.01                   # time step
         # 
-        fs_prev = P.f_st_interp(alpham) # init with steady value
+        fs_prev = P.fs_interp(alpham) # init with steady value
         Cl0 = P.cl_interp(alpham) # init with steady value
         Cl_new,fs_prev_new = P.dynaStallOye_DiscreteStep(alpham,tau,fs_prev,dt)
 
         # Testing that value at t=0 is equal to the steady state cl
-        self.assertEqual(Cl_new,Cl0)
+        np.testing.assert_almost_equal(Cl_new, Cl0, decimal=4)
         self.assertEqual(fs_prev_new,fs_prev)
 
         # An increase of alpha from the steady value should have dCl/dt>0
         Cl_new,fs_prev_new = P.dynaStallOye_DiscreteStep(alpham+1,tau,fs_prev,dt)
         self.assertEqual( (Cl_new-Cl0)>0 ,True)
         self.assertEqual( (fs_prev_new-fs_prev)<0 ,True)
 
@@ -44,15 +44,15 @@
         self.assertEqual( (fs_prev_new-fs_prev)>0 ,True)
 
 
     def test_convergence(self):
         # Starting from a wrong set point, the Cl value should converge to the steady Cl value
         # Script params, reading polar
         radians=True
-        P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True,to_radians=radians)
+        P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), compute_params=True, radians=radians)
         U0, chord = 10, 0.1591
         alpha_st  = 3 * P._alpha0 
         tau_t     = np.linspace(0,40,30)
         vt        = chord * tau_t / (2*U0)
            
         # Oye's Parameters
         p_oye = dynstall_oye_param_from_polar(P, tau_chord=chord/U0)
@@ -80,15 +80,15 @@
         ## Integration using solve_ivp
         sol_oye = solve_ivp(lambda t,x: dynstall_oye_dxdt(t,x,u,p_oye), t_span=[0, max(vt)], y0=y0_oye, t_eval=vt)
         for it,t in enumerate(vt):
             Cl_oye[it] = dynstall_oye_output(vt[it],sol_oye.y[0,it],u,p_oye)
 
         ## Steady values
         Cl_st  = P.cl_interp(alpha_st)
-        fs_st  = P.f_st_interp(alpha_st) 
+        fs_st  = P.fs_interp(alpha_st) 
 
         ## --- Test that the last value is the steady state one
         np.testing.assert_almost_equal(Cl_mhh[-1], Cl_st, decimal=3)
         np.testing.assert_almost_equal(Cl_oye[-1], Cl_st, decimal=3)
         np.testing.assert_almost_equal(sol_oye.y[0,-1], fs_st, decimal=3)
 
         # --- Plot, keep me
@@ -106,15 +106,15 @@
         #y0_mhh = dynstall_mhh_steady(0,u,p_mhh)
 
 
     def test_mhh_wagner_step(self):
         # Step from alpha0 to alpha0+2, testing the circulatory response (history), 
         # The Cl result is compared to Wagner's function
         radians=True # <<<
-        P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True,to_radians=radians)
+        P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), compute_params=True, radians=radians)
 
         U0, chord = 10, 0.1591
         alpha1  = P._alpha0 
         alpha2  = alpha1+2*np.pi/180
         tau_t   = np.linspace(0,30,100)
         vt      = chord * tau_t / (2*U0)
```

### Comparing `welib-0.0.2/welib/airfoils/tests/test_polar_interp.py` & `welib-1.0.0/welib/airfoils/tests/test_polar_interp.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,16 +7,16 @@
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 class TestPolarInterp(unittest.TestCase):
 
     def test_interp(self):
         # --- Interpolation of self is self
-        P1=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
-        P2=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
+        P1=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
+        P2=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
         P3= blend(P1,P2,0.5)
         np.testing.assert_equal(P3.alpha,P1.alpha)
         np.testing.assert_equal(P3.cl,P1.cl)
         np.testing.assert_equal(P3.cd,P1.cd)
         np.testing.assert_equal(P3.cm,P1.cm)
         P2.cl=P2.cl+0.3
         P2.cd=P2.cd+0.3
```

### Comparing `welib-0.0.2/welib/airfoils/tests/test_polar_manip.py` & `welib-1.0.0/welib/airfoils/tests/test_polar_manip.py`

 * *Files 21% similar despite different names*

```diff
@@ -8,16 +8,16 @@
 # ---  
 # --------------------------------------------------------------------------------{
 class TestPolarManip(unittest.TestCase):
     def assertNaN(self,x):
         self.assertTrue(np.isnan(x))
 
     def test_read(self):
-        P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
+        P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
         self.assertEqual(P.alpha[-1],180)
         self.assertEqual(P.cl[-1],0)
 
-        P=Polar.fromfile(os.path.join(MyDir,'../data/Cylinder.dat'))
+        P=Polar(os.path.join(MyDir,'../data/Cylinder.dat'))
         self.assertEqual(P.cl.size,3)
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/airfoils/tests/test_polar_params.py` & `welib-1.0.0/welib/airfoils/tests/test_polar_params.py`

 * *Files 8% similar despite different names*

```diff
@@ -5,118 +5,138 @@
 from welib.airfoils.Polar import * 
 
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 class TestPolarParams(unittest.TestCase):
     def setUp(self):
-        self.P235 = Polar.fromfile(os.path.join(MyDir,'../data/63-235.csv'))
-        self.PFFA = Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
-        self.PCyl = Polar.fromfile(os.path.join(MyDir,'../data/Cylinder.csv'))
+        self.P235 = Polar(os.path.join(MyDir,'../data/63-235.csv'))
+        self.PFFA = Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
+        self.PCyl = Polar(os.path.join(MyDir,'../data/Cylinder.csv'))
+        self.PFFA_rad = Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'), radians=True)
 
     def assertNaN(self,x):
         self.assertTrue(np.isnan(x))
 
     def test_alpha0(self):
         # --- Polar with one Cl value
         # non zero cl, alpha0 is nan
-        self.assertNaN  (Polar([],[100],[0.1],[],[]).alpha0())
+        self.assertNaN  (Polar(None,[100],[0.1],[],[]).alpha0())
         # cl value is 0, alpha0 is arbitrarily 0
-        self.assertEqual(Polar([],[100],[0.0],[],[]).alpha0(), 0)
+        self.assertEqual(Polar(None,[100],[0.0],[],[]).alpha0(), 0)
 
         # --- Polar with one zero crossing
-        P=Polar([],[-10,10],[-0.1,0.1],[],[])
+        P=Polar(None,[-10,10],[-0.1,0.1],[],[])
         # Alpha0 is found as long as the window holds it
         self.assertEqual(P.alpha0(window=[-50,50]),0.0)
         self.assertEqual(P.alpha0(window=[-10,10]),0.0)
         self.assertEqual(P.alpha0(window=[ -2, 2]),0.0)
         # Error when window outside, no crossing found
         self.assertRaises(Exception,P.alpha0, window=[-100,-50])
 
         # --- Polar with many zero crossing
-        P=Polar([],[-10,-5,0,5,10],[-0.1,0.1,-0.1,0.1,0.2],[],[])
+        P=Polar(None,[-10,-5,0,5,10],[-0.1,0.1,-0.1,0.1,0.2],[],[])
         self.assertEqual(P.alpha0(window=[-10,-5]), -7.5)
         # Error when several zero crossing are found
         #self.assertRaises(Exception,P.alpha0, window=[-10,10])
         print('\n\n>>>>> TODO alpha0 with no zero crossing was commented!!\n\n')
 
         # --- Polar with constant values 
         # non zero cl, alpha0 is nan
-        self.assertNaN  (Polar([],[-10,10],[0.1,0.1],[],[]).alpha0())
+        self.assertNaN  (Polar(None,[-10,10],[0.1,0.1],[],[]).alpha0())
         # cl is 0, alpha0 is arbitrarily 0
-        self.assertEqual(Polar([],[-10,10],[0.0,0.0],[],[]).alpha0(), 0)
+        self.assertEqual(Polar(None,[-10,10],[0.0,0.0],[],[]).alpha0(), 0)
 
         # --- Real Polars
         np.testing.assert_almost_equal(self.P235.alpha0(),-1.26, decimal=2)
         np.testing.assert_almost_equal(self.PFFA.alpha0(),-2.68, decimal=2)
         np.testing.assert_almost_equal(self.PCyl.alpha0(),0.00, decimal=2)
  
 
     def test_slope(self):
+        alpha0 = 10
         # --- Polar with two points
-        P=Polar([],[-1,1],[-1,1],[],[])
+        P=Polar(None,np.array([-1,1])+alpha0,[-1,1],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0, alpha0)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0,alpha0)
         # --- Polar three points lin
-        P=Polar([],[-1,0,1],[-1,0,1],[],[])
+        P=Polar(None,np.array([-1,0,1])+alpha0,[-1,0,1],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0,alpha0)
         # --- Polar three points cst
-        P=Polar([],[-1,0,1],[1,1,1],[],[])
+        P=Polar(None,np.array([-1,0,2])+alpha0,[1,1,1],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,0.0)
+        np.testing.assert_almost_equal(a0,np.nan) # for constant Cl/=0, we return nan
         # --- Polar with sine shape
-        P=Polar([],[-3,-2,-1,0,1,2,3],[-1,-2,-1,0,1,0,0],[],[])
+        P=Polar(None,[-3,-2,-1,0,1,2,3],[-1,-2,-1,0,1,0,0],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0,0.0)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0,0.0)
         # --- Polar sine with plateaux 
-        P=Polar([],[-3,-2,-1,0,1,2,3],[-1,-2,-2,-1,0,1,1],[],[],radians=False)
+        P=Polar(None,[-3,-2,-1,0,1,2,3],[-1,-2,-2,-1,0,1,1],[],[],radians=False)
         P.alpha0()
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.0)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,1.0)
         # --- Polar sine-line  -  Difficult to evaluate
-        P=Polar([],[-3,-2,-1,0,1,2,3],[-1,-2.1,-2,-1.1,0,1.1,1.2],[],[])
+        P=Polar(None,[-3,-2,-1,0,1,2,3],[-1,-2.1,-2,-1.1,0,1.1,1.2],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.0,decimal=1)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,1.0,decimal=1)
         # --- Polar with a kink - Difficult
-        P=Polar([],[-3,-2,-1,0,1,2,3],[-1,-2,-2,-2,0,1,1],[],[])
+        P=Polar(None,[-3,-2,-1,0,1,2,3],[-1,-2,-2,-2,0,1,1],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,1.5,decimal=1)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,2.0)
         # --- Polar step function
-        P=Polar([],[-3,-2,-1,0,1,2,3],[-.5,-.5,-.5,-.5,.5,.5,.5],[],[])
+        P=Polar(None,np.array([-3,-2,-1,0,1,2,3])+alpha0,[-.5,-.5,-.5,-.5,.5,.5,.5],[],[])
         sl,a0=P.cl_linear_slope(method='optim')
+        np.testing.assert_almost_equal(a0,10.5)
         np.testing.assert_almost_equal(sl,1.0)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,1.0)
+        np.testing.assert_almost_equal(a0,10.5)
         # --- Sine
         alpha = np.linspace(-50,50,100) 
         Cl = np.sin(alpha*np.pi/180.)*180/np.pi
-        P=Polar([],alpha,Cl,[],[])
+        P=Polar(None,alpha,Cl,[],[])
         sl,a0=P.cl_linear_slope(window=[-10,10])
         np.testing.assert_almost_equal(sl,1.0, decimal=2)
         sl,a0=P.cl_linear_slope(window=[-10,10],method='max')
         np.testing.assert_almost_equal(sl,1.0, decimal=2)
         # --- Real Polars
         P=self.PFFA
-        sl,a0=P.cl_linear_slope(radians=True, method='optim')
+        sl,a0=P.cl_linear_slope(method='optim', radians=True) # Requesting radians outputs
         np.testing.assert_almost_equal(sl,7.091, decimal=3)
+        np.testing.assert_almost_equal(a0,-0.04682, decimal=3)
         sl,a0=P.cl_linear_slope(method='optim')
         np.testing.assert_almost_equal(sl,0.123, decimal=3)
+        np.testing.assert_almost_equal(a0,-2.683, decimal=3)
         sl,a0=P.cl_linear_slope(method='max')
         np.testing.assert_almost_equal(sl,0.13, decimal=3)
+        # --- Real Polars, with alpha already in radians
+        P=self.PFFA_rad
+        sl,a0=P.cl_linear_slope(method='optim')
+        np.testing.assert_almost_equal(sl,7.091, decimal=3) # This polar is already in radians
+        np.testing.assert_almost_equal(a0,-0.04682, decimal=3)
+        sl,a0=P.cl_linear_slope(method='optim', radians=True)
+        np.testing.assert_almost_equal(sl,7.091, decimal=3) # This polar is already in radians
+        np.testing.assert_almost_equal(a0,-0.04682, decimal=3)
         # --- Cylinder
         P=self.PCyl
         sl,a0=P.cl_linear_slope(method='optim')
         self.assertEqual(sl,0.0)
         # --- Real Polars
         P=self.P235
         sl,a0=P.cl_linear_slope(method='optim')
@@ -192,15 +212,15 @@
         np.testing.assert_almost_equal(f_st[63],1.0)
         #np.testing.assert_almost_equal(f_st[63],1.0023744)
         # Close to singularity, should be not far from cl/2
         np.testing.assert_almost_equal(cl_fs[64],P.cl[64]/2*1.004,decimal=4)
         np.testing.assert_almost_equal(cl_fs[62],P.cl[62]/2*0.998,decimal=4)
     
         # TODO TODO TODO Ensure harmony between f_st if computed with slope that is not max
-        #P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True)
+        #P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'),compute_params=True)
         #cl_fs,f_st0=P.cl_fully_separated()
         #f_st=(P.cl-cl_fs)/(P.cl_inv-cl_fs);
 
         #import matplotlib.pyplot as plt
         #fig=plt.figure()
         #ax = fig.add_subplot(111)
         #ax.plot(P.alpha  , f_st0 )
@@ -215,22 +235,22 @@
         #ax.plot(P.alpha,f_st,label='f_st')
         #plt.xlim([-50,50])
         #plt.ylim([-3,3])
         #plt.legend()
         #plt.show()
         #print(f_st)
 # 
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/Cylinder.dat'))
+#         P=Polar(os.path.join(MyDir,'../data/Cylinder.dat'))
 #         sl,offset=P.cl_linear_slope()
 # 
 #         plt.show()
 
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/63-235.csv'))
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/Cylinder.csv'))
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/AD_3-63-224_mod.csv'))
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/AD_4-63-218_mod.csv'))
-#         P=Polar.fromfile(os.path.join(MyDir,'../data/AD_5_63-214_mod.csv'))
+#         P=Polar(os.path.join(MyDir,'../data/FFA-W3-241-Re12M.dat'))
+#         P=Polar(os.path.join(MyDir,'../data/63-235.csv'))
+#         P=Polar(os.path.join(MyDir,'../data/Cylinder.csv'))
+#         P=Polar(os.path.join(MyDir,'../data/AD_3-63-224_mod.csv'))
+#         P=Polar(os.path.join(MyDir,'../data/AD_4-63-218_mod.csv'))
+#         P=Polar(os.path.join(MyDir,'../data/AD_5_63-214_mod.csv'))
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/airfoils/tests/test_run_Examples.py` & `welib-1.0.0/welib/hydro/tests/test_run_Examples.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,20 +14,23 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
-        import matplotlib.pyplot as plt
+        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z0-9_]*.py'))
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/beams/examples/Ex1_BeamModes.py` & `welib-1.0.0/welib/beams/examples/Ex1_BeamModes.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/examples/Ex2_BeamModesAllBC.py` & `welib-1.0.0/welib/beams/examples/Ex2_BeamModesAllBC.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/examples/___TestBeamDynUniform.py` & `welib-1.0.0/welib/beams/examples/___TestBeamDynUniform.py`

 * *Files 1% similar despite different names*

```diff
@@ -11,15 +11,15 @@
 EI = 1037.13E9
 m  = 9517.14
 freq,x,U,V,K = UniformBeamBendingModes('unloaded-free-free',EI,m,A=1,L=L, nModes=8)
 print(freq)
 
 
 # --- Open lin File
-linFile = 'FF.lin.txt'
+linFile = '___FF.lin.txt'
 lin = FASTLinearizationFile(linFile)
 
 # --- Perform eigenvalue analysis
 fd, zeta, Q, f0 = eigA(lin['A'])
 b=np.logical_and(f0>0.1, f0<180)
 f0   = f0[b]
 zeta = zeta[b]
```

### Comparing `welib-0.0.2/welib/beams/matlab/examples/Main_Modes.m` & `welib-1.0.0/welib/beams/matlab/examples/Main_Modes.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/matlab/examples/Main_Modes_For_FAST.m` & `welib-1.0.0/welib/beams/matlab/examples/Main_Modes_For_FAST.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/matlab/fInputParser.m` & `welib-1.0.0/welib/beams/matlab/fInputParser.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/matlab/fUniformBeamTheory.m` & `welib-1.0.0/welib/beams/matlab/fUniformBeamTheory.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/matlab/fUniformBeamTheoryLongi.m` & `welib-1.0.0/welib/beams/matlab/fUniformBeamTheoryLongi.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/matlab/fUniformBeamTheoryTorsion.m` & `welib-1.0.0/welib/beams/matlab/fUniformBeamTheoryTorsion.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/tests/test_theory.py` & `welib-1.0.0/welib/beams/tests/test_theory.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/beams/theory.py` & `welib-1.0.0/welib/beams/theory.py`

 * *Files 14% similar despite different names*

```diff
@@ -169,15 +169,40 @@
             ModesV[i,:] = ModesV[i,:] * fact
             ModesK[i,:] = ModesK[i,:] * fact
     else:
         raise Exception('Norm not implemented or incorrect: `%s`'%norm)
 
     return freq,x,ModesU,ModesV,ModesK
 
+def UniformBeamGuyanModes(EI, rho, A, L, x=None, norm='tip', nModes=2):
+    #from welib.FEM.frame3d import N3, N4
+    if x is None or len(x)==0:
+        x = np.linspace(0,L,101)
+    if np.amax(x) != L:
+        raise Exception('Max of x should be equal to L')
 
+    x0 = x/L
+    freq = np.nan # TODO use EI and m
+    U1 = 3*x0**2 - 2*x0**3      # N3
+    U2 = L*x0**2*(x0-1)         # N4
+    V1 = 1/L*(6*x0 - 6*x0**2)
+    K1 = 1/L**2 *(6 - 12*x0)
+    V2 = 3*x0**2 -2*x0
+    K2 = 1/L*(6*x0 -2 )
+    ModesU = np.zeros((nModes,len(x0)))
+    ModesV = np.zeros((nModes,len(x0)))
+    ModesK = np.zeros((nModes,len(x0)))
+    ModesU[0,:] = U1
+    ModesU[1,:] = U2
+    ModesV[0,:] = V1
+    ModesV[1,:] = V2
+    ModesK[0,:] = K1
+    ModesK[1,:] = K2
+
+    return freq,x,ModesU,ModesV,ModesK
     
 # --------------------------------------------------------------------------------}
 # --- Longitudinal modes 
 # --------------------------------------------------------------------------------{
 def UniformBeamLongiModes(Type,E,rho,A,L,x=None,nModes=4,norm='tip_norm'):
     """
     Returns longitudinals modes for a uniform beam
```

### Comparing `welib-0.0.2/welib/ctrl/_BodePlot.py` & `welib-1.0.0/welib/ctrl/_BodePlot.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ctrl/_secord-matlab.py` & `welib-1.0.0/welib/ctrl/_secord-matlab.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ctrl/_secord_transfer.py` & `welib-1.0.0/welib/ctrl/_secord_transfer.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/dyninflow/DynamicInflow.py` & `welib-1.0.0/welib/dyninflow/DynamicInflow.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,39 +9,45 @@
 from scipy.integrate import solve_ivp
 import matplotlib.pyplot as plt
 
 def tau1_oye(a_bar, R, U0):
     """ """
     return  1.1/( 1-1.3*min(a_bar,0.5) ) * R/U0
 
-def tau1_dbemt(a_bar, R, Un0_disk):
-    # We need to extrapolate the radius and disk velocity to the i+1 timestep
-    # We will grab the i+1 version of vind,s and the disk averaged induction by using the
-    # the already updated states of the BEMT module.
-    #bjj: I believe u(1) is at t, which seems inconsistant with this comment
-    U0n_disk = min(U0n_disk,0.1)
-    return min( 1.1/( 1-1.3*min(a_disk,0.5) ) * R/Un0_disk , 100) # plateau 100s
+def tau1_dbemt(a_bar, R, U0n_disk):
+    U0n_disk = max(U0n_disk,0.1)
+    return min( 1.1/( 1-1.3*min(a_bar,0.5) ) * R/U0n_disk , 100) # plateau 100s
 
 def tau2_oye(r_bar, tau1):
     return (0.39-0.26*r_bar**2)*tau1
 
 def dynflow_oye_dxdt(t, x, u, tau1, tau2, k=0.6):
     """ 
     Continuous version of Oye's dynamic inflow model. Two states:
         x[0]: Vred:      Vint = Vred + k*Vqs
         x[1]: Vdyn
     See Reference [2]
     """
     x_qs     = u['Vqs'](t)
+    return dynflow_oye_dxdt_simple(x, x_qs, tau1, tau2, k)
+
+def dynflow_oye_dxdt_simple(x, x_qs, tau1, tau2, k=0.6):
+    """ Time derivative of states for continous formulation """
     xred = x[0]
     xdyn = x[1]
     xred_dot =               - 1/tau1*xred + (1-k)/tau1*x_qs
     xdyn_dot  = -1/tau2*xdyn + 1/tau2*xred +     k/tau2*x_qs
     return [xred_dot, xdyn_dot]
 
+def dynflow_oye_steady_simple(x_qs, k):
+    x    = np.zeros(2)
+    x[0] = x_qs * (1-k)   # Vred   # Vint=Vred + kVqs
+    x[1] = x_qs           # Vdyn
+    return x
+
 def dynflow_oye_steady(t, u, p):
     Vqs  = u['Vqs'](t)
     x    = np.zeros(2)
     x[0] = Vqs * (1-p['k'])   # Vred   # Vint=Vred + kVqs
     x[1] = Vqs                # Vdyn
     return x
```

### Comparing `welib-0.0.2/welib/dyninflow/examples/Ex1_StepUp.py` & `welib-1.0.0/welib/dyninflow/examples/Ex1_StepUp.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/FASTLin.py` & `welib-1.0.0/welib/fast/FASTLin.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,45 +1,76 @@
+""" 
+Tools to handle a set of linearization files
+
+"""
+
 import numpy as np
 import pickle
 import glob
 import os
+import re
 from welib.weio.fast_linearization_file import FASTLinearizationFile
 import pandas as pd
 
 
 class FASTLinPeriodicOP(object):
     """ Class for a set of *.lin files, all assumed to be for the same periodic operating point
     e.g. 
        ws05mps.1.lin
               [...]
        ws05mps.36.lin
 
     """
-    def __init__(self,prefix,nLin=None):
-        if nLin is None:
-            linfiles= glob.glob(prefix + '.*.lin') # TODO we want a more rigorous regexp
-            self.nLinTimes = len(linfiles)
-        else:
-            self.nLinTimes = nLin
-        #print(prefix, self.nLinTimes)
-
-        self.prefix   = prefix
-        self.Data     = []
-        self.vAzim    = []
+    def __init__(self, prefix=None, nLin=None, linFiles=None):
+
+        # --- Init data
+        self.linFiles  = []
+        self.prefix    = None
+        self.Data      = []     # List of linFile as returned by weio
+        self.vAzim     = []
+        self.vWS       = []
+        self.vPitch    = []
+        self.vRotSpeed = []
+
+        # --- Figure out linFiles
+        def glob_re(pattern_glob, pattern_re):
+            """ 
+            glob_re(r'base.([0-9]*).py', 'base.*.py') 
+            """
+            files = glob.glob(pattern_glob)
+            files = [s.replace('\\','/') for s in files]
+            return list(filter(re.compile(pattern_re).match, files))
+        if linFiles is None:
+            if nLin is None:
+                prefix = prefix.replace('\\','/')
+                linFiles = glob_re(prefix + '.*.lin', prefix + r'.([0-9]*).lin',)
+                self.nLinTimes = len(linFiles)
+            else:
+                self.nLinTimes = nLin
+
+            linFiles = [prefix+'.'+str(i+1)+'.lin' for i in np.arange(self.nLinTimes)]
+            if len(linFiles)==0:
+                raise Exception('No Lin Files found with prefix: {}'.format(prefix))
+        else:
+            self.nLinTimes = len(linFiles)
+            prefix = None # TODO
+
+        self.linFiles  = linFiles
+        self.prefix    = prefix
+        self.Data      = []     # List of linFile as returned by weio
+        self.vAzim     = []
         self.vWS       = []
         self.vPitch    = []
         self.vRotSpeed = []
-        self.vBu = []
-        for i in np.arange(self.nLinTimes):
-            linfilename= prefix+'.'+str(i+1)+'.lin'
-            print(linfilename)
-            if not os.path.exists(linfilename):
-                print('Linearization file missing: ',linfilename)
-            linfile=FASTLinearizationFile(linfilename)
-            df=linfile.toDataFrame()
+        for i, linFilename in enumerate(linFiles):
+            print(linFilename)
+            if not os.path.exists(linFilename):
+                print('Linearization file missing: ',linFilename)
+            linfile = FASTLinearizationFile(linFilename)
+            df      = linfile.toDataFrame()
             self.Data.append(linfile)
             #self.A=lin['A']
             #B=linfile['B']
             #u=linfile['u']
             #self.C=lin['C']
             #self.D=lin['D']
             if linfile['WindSpeed'] is not None:
@@ -48,32 +79,56 @@
                 try:
                     self.vWS.append(df['u']['WS_[m/s]'][0])
                 except:
                     print('Wind speed not found in input, assuming 0m/s')
                     self.vWS.append(0)
             self.vRotSpeed.append(linfile['RotSpeed'])
             self.vAzim.append(linfile['Azimuth'])
-            self.vPitch.append(df['u']['B1pitch_[rad]'][0]*180/np.pi)
+            if 'u' in df.keys():
+                self.vPitch.append(df['u']['B1pitch_[rad]'][0]*180/np.pi)
+            else:
+                self.vPitch.append(np.nan)
 
         self.WS       = np.mean(self.vWS)
         self.Pitch    = np.mean(self.vPitch)
         self.RotSpeed = np.mean(self.vRotSpeed)
 
         self.x = df['x']
-        self.y = df['y']
-        self.u = df['u']
+        self.y = None
+        self.u = None
+        if 'y' in df.keys():
+            self.y = df['y']
+        if 'u' in df.keys():
+            self.u = df['u']
         try:
             self.EDdescr = linfile['EDDOF']
         except:
             self.EDdescr = None
 
 
+    def __repr__(self):
+        s ='<FASTLinPeriodicOP object>\n'
+        s+='Attributes:\n'
+        s+=' - prefix   : {}\n'.format(self.prefix)
+        s+=' - WS       : {}\n'.format(self.WS)
+        s+=' - Pitch    : {}\n'.format(self.Pitch)
+        s+=' - RotSpeed : {}\n'.format(self.RotSpeed)
+        s+=' - vAzim    : {}\n'.format(self.vAzim)
+        s+=' - vWS      : {}\n'.format(self.vWS)
+        s+=' - vPitch   : {}\n'.format(self.vPitch)
+        s+=' - vRotSpeed: {}\n'.format(self.vRotSpeed)
+        s+=' - linFiles : {}\n'.format(self.linFiles)
+        s+=' - Data     : list of lin files, size {}\n'.format(len(self.Data))
+        return s
 
 class FASTLin(object):
-    """ Class for linearization data for different operating points (typically Campbell) """
+    """ Class to handle linearization data at different operating points 
+        Typically Campbell, or average over many conditions.
+        Can be used for one lin file as well.
+    """
     def __init__(self, linfiles=None, folder='./', prefix='', nLin=None):
         """ 
         Init with a list of linfiles, or a folder and prefix
         """
         linfiles = [] if linfiles is None else linfiles
 
         if not isinstance(linfiles, list):
@@ -83,31 +138,50 @@
             extsOK =[e.lower()=='.lin' for e in exts]
             if not all(extsOK):
                 raise Exception('Not all inputs have the .lin extension. Provide a list of .lin files, or a folder and a prefix')
         else:
             linfiles= list(glob.glob(folder + prefix + '*.*.lin')) # TODO we want a more rigorous regexp
             linfiles.sort()
 
-        Sim_Prefix=np.unique(['.'.join(f.split('.')[:-2]) for f in linfiles])
-        nSim      = len(Sim_Prefix)
+        simPrefix=np.unique(['.'.join(f.split('.')[:-2]) for f in linfiles])
+        nSim      = len(simPrefix)
+        self.simPrefix = simPrefix
         # --- Read period operating points
         print('Reading linearizations for {} operating points'.format(nSim))
-        self.OP_Data=[FASTLinPeriodicOP(pref,nLin=nLin) for pref in Sim_Prefix]
+        self.OP_Data=[FASTLinPeriodicOP(pref, nLin=nLin) for pref in simPrefix]
+
         # --- Sort by wind speed
         Isort = np.argsort(self.WS)
         self.OP_Data  = [self.OP_Data[i] for i in Isort]
 
         if self.MaxNLinTimes>1:
             IBad = [i for i in np.arange(nSim) if self.nLinTimes[i]<self.MaxNLinTimes and self.OP_Data[i].WS>0]
             if len(IBad)>0: 
                 print('>>> The following simulations have insufficient number of data points:')
                 for i in IBad:
                     print(self.OP_Data[i].prefix, self.OP_Data[i].nLinTimes)
             self.OP_Data = [self.OP_Data[i] for i in np.arange(nSim) if i not in IBad]
 
+    def __repr__(self):
+        s ='<FASTLin object>\n'
+        s+='Attributes:\n'
+        s+=' - OP_Data     : list of FASTLinPeriodicOP (size {})\n'.format(len(self.OP_Data))
+        s+=' * nOP         : {}\n'.format(self.nOP)
+        s+=' * MaxNLinTimes: {}\n'.format(self.MaxNLinTimes)
+        s+=' * WS          : {}\n'.format(self.WS)
+        s+=' * nLinTimes   : {}\n'.format(self.nLinTimes)
+        s+=' * xdescr, udescr, ydescr\n'
+        s+=' * xop_mean, uop_mean, yop_mean\n'
+        s+=' - simPrefix   : {}\n'.format(self.simPrefix)
+        s+='Methods:\n'
+        s+=' - stats(matName, WS=None)\n'
+        s+=' - average(WS=None)\n'
+        s+=' - exportState(self, stateFile, stateDict)\n'
+        return s
+
     @property
     def WS(self):
         return np.array([sim.WS for sim in self.OP_Data])
 
     @property
     def nLinTimes(self):
         return np.array([sim.nLinTimes for sim in self.OP_Data])
@@ -121,45 +195,69 @@
         return len(self.OP_Data)
 
     @property
     def xdescr(self):
         return self.OP_Data[0].x.columns.values
     @property
     def ydescr(self):
-        return self.OP_Data[0].y.columns.values
+        if self.hasY:
+            return self.OP_Data[0].y.columns.values
+        else:
+            return []
     @property
     def EDdescr(self):
         return self.OP_Data[0].EDdescr
     @property
     def udescr(self):
-        return self.OP_Data[0].u.columns.values
+        if self.hasU:
+            return self.OP_Data[0].u.columns.values
+        else:
+            return []
     @property
     def xop_mean(self):
-        return np.mean(np.abs(np.array([op.x.values for op in self.OP_Data])),axis=0)
+        return np.mean(np.array([op.x.values for op in self.OP_Data]),axis=0)
     @property
     def uop_mean(self):
-        return np.mean(np.abs(np.array([op.u.values for op in self.OP_Data])),axis=0)
+        if self.hasU:
+            return np.mean(np.array([op.u.values for op in self.OP_Data]),axis=0)
+        else:
+            raise Exception('Linear model has no inputs')
+     
     @property
-    def uop_mean(self):
-        return np.mean(np.abs(np.array([op.u.values for op in self.OP_Data])),axis=0)
+    def yop_mean(self):
+        if hasY:
+            return np.mean(np.array([op.y.values for op in self.OP_Data]),axis=0)
+        else:
+            raise Exception('Linear model has no outputs')
 
     @property
-    def yop_mean(self):
-        return np.mean(np.abs(np.array([op.y.values for op in self.OP_Data])),axis=0)
+    def hasU(self): return 'u' in self.OP_Data[0].Data[0].keys()
+    @property
+    def hasY(self): return 'y' in self.OP_Data[0].Data[0].keys()
+    @property
+    def hasB(self): return 'B' in self.OP_Data[0].Data[0].keys()
+    @property
+    def hasC(self): return 'C' in self.OP_Data[0].Data[0].keys()
+    @property
+    def hasD(self): return 'D' in self.OP_Data[0].Data[0].keys()
+
 
-    def stats(self,matName,WS=None):
+    def stats(self, matName, WS=None):
+        """ 
+        Compute statistics (mean and std) on a given matrix (A, B, C, D, M)
+        
+        """
         if WS is None:
             WS = self.WS
             nOP=self.nOP
         else:
             nOP=len(WS)
-        print('Returning stats for WS:',WS)
         M_mean=[]
 
-        shape= self.OP_Data[0].Data[0][matName].shape
+        shape = self.OP_Data[0].Data[0][matName].shape
 
         M_all       = np.zeros( (nOP, self.MaxNLinTimes, shape[0],shape[1]))
         M_mean_perWS= np.zeros( (nOP, shape[0],shape[1]))
         M_std_perWS = np.zeros( (nOP, shape[0],shape[1]))
 
         # loop on operating points (e.g. WS)
         ii=0
@@ -168,30 +266,62 @@
                 # Loop on linearization times (e.g. Azimuth)
                 for iTimes in np.arange(self.MaxNLinTimes):
                     if op.nLinTimes==1:
                         M_all[ii,iTimes,:,:]=op.Data[0][matName]
                     else:
                         M_all[ii,iTimes,:,:]=op.Data[iTimes][matName]
 
-                M_mean_perWS[ii,:,:] = np.mean(M_all[ii,:,:,:],axis=0)
+                M_mean_perWS[ii,:,:] = np.mean(M_all[ii,:,:,:],axis=0) # TODO what if MaxNLinTimes is not the same for all OP
                 M_std_perWS [ii,:,:]  = np.std(M_all[ii,:,:,:],axis=0)
                 ii+=1
 
         M_mean    = np.mean( M_mean_perWS, axis=0 )
         M_stdWS   = np.std ( M_mean_perWS, axis=0 ) # How much elements vary with wind speed
         M_stdAzim = np.mean( M_std_perWS , axis=0)  # How much elements vary due to azimuth
 
         return M_mean, M_mean_perWS, M_stdAzim, M_stdWS, M_all
 
 
+    def averageOP(self, WS=None):
+        """ return average operating point values for a given wind speed vector"""
+        if WS is None:
+            WS = self.WS
+        xop = np.zeros(len(self.xdescr))
+        uop = np.zeros(len(self.udescr))
+        yop = np.zeros(len(self.ydescr))
+        for iop, op in enumerate(self.OP_Data):
+            if self.WS[iop] in WS:
+                xop+=op.x.values.flatten()
+                if self.hasU:
+                    uop+=op.u.values.flatten()
+                if self.hasY:
+                    yop+=op.y.values.flatten()
+        xop /= len(WS)
+        if self.hasU:
+            uop /= len(WS)
+        else:
+            uop=None
+        if self.hasY:
+            yop /= len(WS)
+        else:
+            yop=None
+        return xop, uop, yop
+
     def average(self, WS=None):
         A_mean = self.stats('A',WS=WS)[0]
-        B_mean = self.stats('B',WS=WS)[0]
-        C_mean = self.stats('C',WS=WS)[0]
-        D_mean = self.stats('D',WS=WS)[0]
+
+        B_mean = None
+        C_mean = None
+        D_mean = None
+        if self.hasB:
+            B_mean = self.stats('B',WS=WS)[0]
+        if self.hasC:
+            C_mean = self.stats('C',WS=WS)[0]
+        if self.hasD:
+            D_mean = self.stats('D',WS=WS)[0]
         #self.M_mean = self.stats('M',WS=WS)[0]
         return A_mean, B_mean, C_mean, D_mean
 
     def average_subset(self, sX_sel=None, sU_sel=None, sY_sel=None, sE_sel=None, WS=None, exportFile=None, baseDict=None):
         """ 
         Average state spaces based on WS, then extract a subset based on sensor names
         """
@@ -239,20 +369,27 @@
         outDict['D']=Dr
         if sE_sel is not None:
             Mr = M[np.ix_(IDOFE,IDOFE)]
             Mr = pd.DataFrame(data = Mr, index=sED_sel, columns=sED_sel)
             outDict['M']=Mr
 
         if exportFile is not None:
-            import pickle
-            with open(exportFile,'wb') as f:
-                pickle.dump(outDict,f)
+            self.exportState(exportFile, outDict)
 
         if sE_sel is not None:
             return Ar, Br, Cr, Dr, Mr
         else:
             return Ar, Br, Cr, Dr
 
+    def exportState(self, stateFile, stateDict):
+        #if any(['A','B','C','D'])
+
+        import pickle
+        with open(exportFile,'wb') as f:
+            pickle.dump(stateDict,f)
+
     def save(self,filename):
         with open(filename,'wb') as f:
             pickle.dump(self,f)
 
+
+
```

### Comparing `welib-0.0.2/welib/fast/beamdyn.py` & `welib-1.0.0/welib/fast/beamdyn.py`

 * *Files 1% similar despite different names*

```diff
@@ -290,18 +290,19 @@
     #M=np.column_stack((zref, x_off, y_off))
     #np.savetxt(BDBldFileOut.replace('.dat','offsets.txt'), M, delimiter=',',header='z_[m], xoff_[m], yoff_[m]')
 
     # --- Writing BeamDyn main file based on template file
     if BDMainTemplate is not None and BDMainFileOut is not None:
         BD=FASTInputFile(BDMainTemplate)
         #print(BD.keys())
-        BD.data[1]['value']=Label
+        BD.comment=Label
         BD['MemberGeom'] = np.column_stack((x_O,y_O,z_O,twist))
         BD['kp_total']   = len(x_O)
         BD['BldFile']    = '"'+os.path.basename(BDBldFileOut)+'"' 
+        # TODO TODO 
         BD.data[BD.getID('kp_total')+1]['value']= '1 {}'.format(len(x_O))
 
         print('Writing BeamDyn file:',BDMainFileOut)
         BD.write(BDMainFileOut)
 
 
     # ---
@@ -329,15 +330,15 @@
 #         fig,axes = plt.subplots(2, 1, sharex=True, figsize=(6.4,4.8)) # (6.4,4.8)
 #         ax=axes[0,0]
 
         axes[0,0].text(0.5, 1.01, 'Mean line x', horizontalalignment='center', verticalalignment='bottom', transform = axes[0,0].transAxes)
         axes[0,1].text(0.5, 1.01, 'Mean line y', horizontalalignment='center', verticalalignment='bottom', transform = axes[0,1].transAxes)
         axes[0,0].plot(z_O, x_O   , '-' , label = 'BD smooth)')
         axes[0,0].plot(z_O, x_O_h2, '--', label = 'H2 c2def', ms=3, color='k')
-        axes[0,0].plot(z_O, x_off_g, ':', label = r'"$\Delta$" to c2def', color=colrs[6])
+        axes[0,0].plot(z_O, x_off_g, ':', label = r'"Delta" to c2def', color=colrs[6])
         axes[0,1].plot(z_O, y_O   , '-' , label = 'BD y (smooth)')
         axes[0,1].plot(z_O, y_O_h2, '--' , label = 'H2 "y"', ms=3, color='k')
         axes[0,1].plot(z_O, y_off_g , ':', label = 'y_off', color=colrs[6])
         if 'Relative_thickness_[%]' and 'Chord_[m]' in c2def.columns.values:
             c = c2def['Chord_[m]']
             t = c2def['Relative_thickness_[%]'] *c/100
             axes[0,0].plot(z_O, x_O_h2+c/2*np.sin(twist*np.pi/180), '-', color=[0.5,0.5,0.5] )
@@ -391,30 +392,30 @@
         # --- Positions rel to mean line
         axes[2,0].text(0.5, 1.01, r'Pos. wrt. meanline, x', horizontalalignment='center', verticalalignment='bottom', transform = axes[2,0].transAxes)
         axes[2,1].text(0.5, 1.01, r'Pos. wrt. meanline, y', horizontalalignment='center', verticalalignment='bottom', transform = axes[2,1].transAxes)
         axes[2,0].plot(z_O              , x_O-x_O     , '-' , label = 'BD meanline')
         axes[2,0].plot(z_O              , vx_G        , 'd' , ms=6, color=None, markeredgecolor=colrs[1], markerfacecolor="None", label = 'G (COG)') 
         axes[2,0].plot(z_O              , vx_S        , 's' , ms=6, color=None, markeredgecolor=colrs[2], markerfacecolor="None", label = 'S (shear center)') 
         axes[2,0].plot(z_O              , vx_C        , 'o' , ms=6, color=None, markeredgecolor=colrs[3], markerfacecolor="None", label = 'C (elastic center)') 
-        axes[2,0].plot(z_O              , x_off_g     , ':', label = r'"$\Delta$" to c2def', color=colrs[6])
+        axes[2,0].plot(z_O              , x_off_g     , ':', label = r'"Delta" to c2def', color=colrs[6])
 #         axes[1,0].plot(hwc['r_[m]'], x_O_h2 + hwc['y_cg_[m]'], 'o' , ms=1, color=colrs[1] , label='HAWC2')
 #         axes[1,0].plot(hwc['r_[m]'], x_O_h2 + hwc['y_sh_[m]'], 'o' , ms=1, color=colrs[2] )
 #         axes[1,0].plot(hwc['r_[m]'], x_O_h2 + hwc['y_e_[m]'] , 'd' , ms=1, color=colrs[3] )
         axes[2,1].plot(z_O              , y_O -y_O    , '-' , label = 'BD meanline')
         axes[2,1].plot(z_O              , vy_G        , 'd' , ms=6, color=None, markeredgecolor=colrs[1], markerfacecolor="None", label = 'G (COG)') 
         axes[2,1].plot(z_O              , vy_S        , 's' , ms=6, color=None, markeredgecolor=colrs[2], markerfacecolor="None", label = 'S (shear center)') 
         axes[2,1].plot(z_O              , vy_C        , 'o' , ms=6, color=None, markeredgecolor=colrs[3], markerfacecolor="None", label = 'C (elastic center)') 
-        axes[2,1].plot(z_O              , y_off_g     , ':', label = r'"$\Delta$" to c2def', color=colrs[6])
+        axes[2,1].plot(z_O              , y_off_g     , ':', label = r'"Delta" to c2def', color=colrs[6])
 #         axes[1,1].plot(hwc['r_[m]'], y_O_h2 - hwc['x_cg_[m]'], 'o' , ms=1, color=colrs[1] )
 #         axes[1,1].plot(hwc['r_[m]'], y_O_h2 - hwc['x_sh_[m]'], 's' , ms=1, color=colrs[2] )
 #         axes[1,1].plot(hwc['r_[m]'], y_O_h2 - hwc['x_e_[m]'] , 'd' , ms=1, color=colrs[3] )
         axes[2,0].set_xlabel('z [m]')
         axes[2,1].set_xlabel('z [m]')
-        axes[2,0].set_ylabel(r'$\Delta x$ [m]')
-        axes[2,1].set_ylabel(r'$\Delta y$ [m]')
+        axes[2,0].set_ylabel(r'Delta x [m]')
+        axes[2,1].set_ylabel(r'Delta y [m]')
         axes[2,0].legend(loc='upper right', fontsize=8)
 # 
         # --- Plot Stiffness
 #         ax=fig.add_subplot(111)
         ax=axes[3,0]
         ax.text(0.5, 1.01, 'Stiffnesses', horizontalalignment='center', verticalalignment='bottom', transform = ax.transAxes)
         ax.plot(z_O,EdgStiff,'-' , color=colrs[0], label='Edge Stiffness (K_44)')
@@ -586,15 +587,14 @@
         K):
     """
     NOTE: all angles are in radians
     
     """
     import scipy.linalg
     # --- BeamDyn to Hawc2 Structural data
-#     import pdb; pdb.set_trace()
     # Hawc2 = BeamDyn
     x_cg    = -y_G
     y_cg    = x_G
     x_e     = -y_C
     y_e     = x_C
     pitch   = theta_p*180/np.pi # [deg] NOTE: could use theta_p, theta_i or theta_s
     if np.all(np.abs(m)<1e-16):
@@ -696,15 +696,14 @@
     """ 
     NOTE: all angles are in radians
     """
     # --- BeamDyn to Hawc2 Structural data
     if A is None: A = np.ones(x_G.shape)
     if E is None: E = EA/A
     if G is None: G = E/2/(1+0.3) # Young modulus
-#     import pdb; pdb.set_trace()
     # Hawc2 = BeamDyn
     x_cg    = -y_G
     y_cg    = x_G
     x_sh    = -y_S
     y_sh    = x_S
     x_e     = -y_C
     y_e     = x_C
```

### Comparing `welib-0.0.2/welib/fast/campbell.py` & `welib-1.0.0/welib/fast/campbell.py`

 * *Files 0% similar despite different names*

```diff
@@ -10,15 +10,18 @@
 
 import os, glob
 import pandas as pd
 import numpy as np
 try:
     import pyFAST.linearization.mbc.mbc3 as mbc
 except ImportError:
-    import weis.control.mbc.mbc3 as mbc
+    try:
+        import weis.control.mbc.mbc3 as mbc
+    except:
+        pass
 
 
 def postproCampbell(out_or_fstfiles, BladeLen=None, TowerLen=None, verbose=True):
     """ 
     Postprocess linearization files to extract Campbell diagram (linearization at different Operating points)
     - Run MBC
     - Postprocess to put into "CampbellData" matlab form
```

### Comparing `welib-0.0.2/welib/fast/case_gen.py` & `welib-1.0.0/welib/fast/case_gen.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,25 +1,23 @@
-from __future__ import division, print_function
 import os
 import collections
 import glob
 import pandas as pd
 import numpy as np
 import shutil 
 import stat
 import re
 
 # --- Misc fast libraries
 import welib.weio.fast_input_file as fi
 import welib.fast.runner as runner
 import welib.fast.postpro as postpro
-#import pyFAST.input_output.fast_input_file as fi
-#import pyFAST.case_generation.runner as runner
-#import pyFAST.input_output.postpro as postpro
-
+from welib.weio.fast_wind_file import FASTWndFile
+from welib.weio.rosco_performance_file import ROSCOPerformanceFile
+from welib.weio.csv_file import CSVFile
 
 # --------------------------------------------------------------------------------}
 # --- Template replace 
 # --------------------------------------------------------------------------------{
 def handleRemoveReadonlyWin(func, path, exc_info):
     """
     Error handler for ``shutil.rmtree``.
@@ -74,15 +72,15 @@
             isRecursive = not isAFlatDir(s)
             if isRecursive:
                 copyTree(s, d)
             else:
                 forceMergeFlatDir(s, d)
 
 
-def templateReplaceGeneral(PARAMS, templateDir=None, outputDir=None, main_file=None, removeAllowed=False, removeRefSubFiles=False, oneSimPerDir=False):
+def templateReplaceGeneral(PARAMS, templateDir=None, outputDir=None, main_file=None, removeAllowed=False, removeRefSubFiles=False, oneSimPerDir=False, dryRun=False):
     """ Generate inputs files by replacing different parameters from a template file.
     The generated files are placed in the output directory `outputDir` 
     The files are read and written using the library `weio`. 
     The template file is read and its content can be changed like a dictionary.
     Each item of `PARAMS` correspond to a set of parameters that will be replaced
     in the template file to generate one input file.
 
@@ -148,14 +146,18 @@
             templatefilename_full         = os.path.join(workDir,templatefilename)
             TemplateFiles.append(templatefilename_full)
             if FileKey=='Root':
                 # Root files, we start from strID
                 ext = os.path.splitext(templatefilename)[-1]
                 newfilename_full = os.path.join(wd,strID+ext)
                 newfilename      = strID+ext
+                if dryRun:
+                    newfilename = os.path.join(workDir, newfilename)
+                    obj=type('DummyClass', (object,), {'filename':newfilename})
+                    return newfilename, {'Root':obj}
             else:
                 newfilename, newfilename_full = rebaseFileName(templatefilename, workDir, strID)
             #print('--------------------------------------------------------------')
             #print('TemplateFile    :', templatefilename)
             #print('TemplateFileFull:', templatefilename_full)
             #print('NewFile         :', newfilename)
             #print('NewFileFull     :', newfilename_full)
@@ -166,16 +168,20 @@
         # --- Changing parameters in that file
         NewFileKey_or_Key, ChildrenKeys = splitAddress(ParamKey)
         if len(ChildrenKeys)==0:
             # A simple parameter is changed 
             Key    = NewFileKey_or_Key
             #print('Setting', FileKey, '|',Key, 'to',ParamValue)
             if Key=='OutList':
-                OutList=f[Key]
-                f[Key]=addToOutlist(OutList, ParamValue)
+                if len(ParamValue)>0:
+                    if len(ParamValue[0])==0:
+                        f[Key] = ParamValue # We replace
+                    else:
+                        OutList=f[Key]
+                        f[Key] = addToOutlist(OutList, ParamValue) # we insert
             else:
                 f[Key] = ParamValue
         else:
             # Parameters needs to be changed in subfiles (children)
             NewFileKey                = NewFileKey_or_Key
             ChildrenKey            = '|'.join(ChildrenKeys)
             child_templatefilename = f[NewFileKey].strip('"') # old filename that will be used as a template
@@ -223,39 +229,49 @@
     # --- Creating outputDir - Copying template folder to outputDir if necessary
     # Copying template folder to workDir
     for wd in list(set(workDirS)):
         if removeAllowed:
             removeFASTOuputs(wd)
         if os.path.exists(wd) and removeAllowed:
             shutil.rmtree(wd, ignore_errors=False, onerror=handleRemoveReadonlyWin)
-        copyTree(templateDir, wd)
-        if removeAllowed:
-            removeFASTOuputs(wd)
+        templateDir = os.path.normpath(templateDir)
+        wd          = os.path.normpath(wd)
+        # NOTE: need some special handling if path are the sames
+        if templateDir!=wd:
+            copyTree(templateDir, wd)
+            if removeAllowed:
+                removeFASTOuputs(wd)
 
 
     TemplateFiles=[]
     files=[]
+    nTot=len(PARAMS)
     for ip,(wd,p) in enumerate(zip(workDirS,PARAMS)):
+        if np.mod(ip+1,1000)==0:
+            print('File {:d}/{:d}'.format(ip,nTot))
         if '__index__' not in p.keys():
             p['__index__']=ip
 
         main_file_base = os.path.basename(main_file)
         strID          = get_strID(p)
         # --- Setting up files for this simulation
         Files=dict()
         for k,v in p.items():
             if k =='__index__' or k=='__name__':
                 continue
             new_mainFile, Files = replaceRecurse(main_file_base, '', k, v, Files, strID, wd, TemplateFiles)
+            if dryRun:
+                break
 
         # --- Writting files
         for k,f in Files.items():
             if k=='Root':
                 files.append(f.filename)
-            f.write()
+            if not dryRun:
+                f.write()
 
     # --- Remove extra files at the end
     if removeRefSubFiles:
         TemplateFiles, nCounts = np.unique(TemplateFiles, return_counts=True)
         if not oneSimPerDir:
             # we can only detele template files that were used by ALL simulations
             TemplateFiles=[t for nc,t in zip(nCounts, TemplateFiles) if nc==len(PARAMS)]
@@ -263,27 +279,48 @@
             try:
                 os.remove(tf)
             except:
                 print('[FAIL] Removing '+tf)
                 pass
     return files
 
-def templateReplace(PARAMS, templateDir, outputDir=None, main_file=None, removeAllowed=False, removeRefSubFiles=False, oneSimPerDir=False):
-    """ Replace parameters in a fast folder using a list of dictionaries where the keys are for instance:
+# def templateReplace(PARAMS, *args, **kwargs):
+def templateReplace(PARAMS, templateDir, outputDir=None, main_file=None, removeAllowed=False, removeRefSubFiles=False, oneSimPerDir=False, dryRun=False):
+    """ 
+    see templateReplaceGeneral
+
+    Replace parameters in a fast folder using a list of dictionaries where the keys are for instance:
         'DT', 'EDFile|GBRatio', 'ServoFile|GenEff'
     """
     # --- For backward compatibility, remove "FAST|" from the keys
     for p in PARAMS:
         old_keys=[ k for k,_ in p.items() if k.find('FAST|')==0]
         for k_old in old_keys:
             k_new=k_old.replace('FAST|','')
             p[k_new] = p.pop(k_old)
     
+#     return templateReplaceGeneral(PARAMS, *args, **kwargs)
     return templateReplaceGeneral(PARAMS, templateDir, outputDir=outputDir, main_file=main_file, 
-            removeAllowed=removeAllowed, removeRefSubFiles=removeRefSubFiles, oneSimPerDir=oneSimPerDir)
+            removeAllowed=removeAllowed, removeRefSubFiles=removeRefSubFiles, oneSimPerDir=oneSimPerDir, dryRun=dryRun)
+
+
+def addToOutlist(OutList, Signals):
+    if not isinstance(Signals,list):
+        raise Exception('Signals must be a list')
+    if len(Signals)==0:
+        return
+    for s in Signals:
+        if len(s)>0:
+            ss=s.split()[0].strip().strip('"').strip('\'')
+            AlreadyIn = any([o.find(ss)==1 for o in OutList ])
+            if not AlreadyIn:
+                OutList.append(s)
+    if len(OutList[0])>0:
+        OutList=['']+OutList # ensuring first element has zero length (fast_input_file limitation for now) 
+    return OutList
 
 def removeFASTOuputs(workDir):
     # Cleaning folder
     for f in glob.glob(os.path.join(workDir,'*.out')):
         os.remove(f)
     for f in glob.glob(os.path.join(workDir,'*.outb')):
         os.remove(f)
@@ -296,14 +333,15 @@
 # --- Tools for template replacement 
 # --------------------------------------------------------------------------------{
 def paramsSteadyAero(p=None):
     p = dict() if p is None else p
     p['AeroFile|AFAeroMod']=1 # remove dynamic effects dynamic
     p['AeroFile|WakeMod']=1 # remove dynamic inflow dynamic
     p['AeroFile|TwrPotent']=0 # remove tower shadow
+    p['AeroFile|TwrAero']=False # remove tower shadow
     return p
 
 def paramsNoGen(p=None):
     p = dict() if p is None else p
     p['EDFile|GenDOF' ]  = 'False'
     return p
 
@@ -344,15 +382,15 @@
     p['EDFile|PtfmSwDOF'] = 'False'
     p['EDFile|PtfmHvDOF'] = 'False'
     p['EDFile|PtfmRDOF']  = 'False'
     p['EDFile|PtfmPDOF']  = 'False'
     p['EDFile|PtfmYDOF']  = 'False'
     return p
 
-def paramsWS_RPM_Pitch(WS, RPM, Pitch, baseDict=None, flatInputs=False):
+def paramsWS_RPM_Pitch(WS, RPM, Pitch, baseDict=None, flatInputs=False, tMax_OneRotation=True, nPerRot=60, dtMax=0.2):
     """ 
     Generate OpenFAST "parameters" (list of dictionaries with "address")
     chaing the inputs in ElastoDyn, InflowWind for different wind speed, RPM and Pitch
     """
     # --- Ensuring everythin is an iterator
     def iterify(x):
         if not isinstance(x, collections.Iterable): x = [x]
@@ -378,23 +416,33 @@
     PARAMS=[]
     i=0
     for ws,rpm,pitch in zip(WS_flat,RPM_flat,Pitch_flat):
         if baseDict is None:
             p=dict()
         else:
             p = baseDict.copy()
+        if tMax_OneRotation:
+            # Ensure that tMax is large enough to cover one full rotation
+            omega = rpm/60*2*np.pi
+            T = 2*np.pi/omega
+            dt = min(dtMax, T/nPerRot)
+            p['DT']     = dt
+            p['TMax']   = T+3*dt # small buffer
+            p['DT_Out'] = 'default'
+
         p['EDFile|RotSpeed']       = rpm
         p['InflowFile|HWindSpeed'] = ws
         p['InflowFile|WindType']   = 1 # Setting steady wind
         p['EDFile|BlPitch(1)']     = pitch
         p['EDFile|BlPitch(2)']     = pitch
         p['EDFile|BlPitch(3)']     = pitch
 
         p['__index__']  = i
-        p['__name__']   = '{:03d}_ws{:04.1f}_pt{:04.2f}_om{:04.2f}'.format(p['__index__'],p['InflowFile|HWindSpeed'],p['EDFile|BlPitch(1)'],p['EDFile|RotSpeed'])
+        #p['__name__']   = '{:03d}_ws{:04.1f}_pt{:04.2f}_om{:04.2f}'.format(p['__index__'],p['InflowFile|HWindSpeed'],p['EDFile|BlPitch(1)'],p['EDFile|RotSpeed'])
+        p['__name__']   = 'ws{:04.1f}_pt{:04.2f}_om{:04.2f}'.format(p['InflowFile|HWindSpeed'],p['EDFile|BlPitch(1)'],p['EDFile|RotSpeed'])
         i=i+1
         PARAMS.append(p)
     return PARAMS
 
 def paramsLinearTrim(p=None):
     p = dict() if p is None else p
 
@@ -441,17 +489,15 @@
 
     return p
 
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 def createStepWind(filename,WSstep=1,WSmin=3,WSmax=25,tstep=100,dt=0.5,tmin=0,tmax=999):
-    import welib.weio
-    import welib.weio.fast_wind_file
-    f = welib.weio.fast_wind_file.FASTWndFile()
+    f = FASTWndFile()
     Steps= np.arange(WSmin,WSmax+WSstep,WSstep)
     print(Steps)
     nCol = len(f.colNames)
     nRow = len(Steps)*2
     M = np.zeros((nRow,nCol));
     M[0,0] = tmin
     M[0,1] = WSmin
@@ -478,22 +524,31 @@
 # createStepWind('test.wnd',tstep=200,WSmin=5,WSmax=7,WSstep=2)
 
 
 
 # --------------------------------------------------------------------------------}
 # --- Tools for typical wind turbine study 
 # --------------------------------------------------------------------------------{
-def CPCT_LambdaPitch(refdir,main_fastfile,Lambda=None,Pitch=np.linspace(-10,40,5),WS=None,Omega=None, # operating conditions
-          TMax=20,bStiff=True,bNoGen=True,bSteadyAero=True, # simulation options
-          reRun=True, 
-          fastExe=None,showOutputs=True,nCores=4): # execution options
+def CPCT_LambdaPitch(refdir, main_fastfile, Lambda=None, Pitch=np.linspace(-10,40,5), WS=None, Omega=None, # operating conditions
+          TMax=20, bStiff=True, bNoGen=True, bSteadyAero=True, # simulation options
+          reRun=True, skipWrite = False, # Set options to False to speed up execution when reruning this function
+          workDir=None,
+          exportBase=None, exportFmt='rosco', plot=False,  # IO
+          fastExe=None, showOutputs=True, nCores=4): # execution options
     """ Computes CP and CT as function of tip speed ratio (lambda) and pitch.
     There are two main ways to define the inputs:
       - Option 1: provide Lambda and Pitch (deg)
       - Option 2: provide WS (m/s), Omega (in rpm) and Pitch (deg), in which case len(WS)==len(Omega)
+    INPUTS:
+      - refdir: reference directory containing all the necessary input files for openFAST, will be copied
+                to workDir
+      - main_fastfile: main .fst file used as a template (with the subfiles referenced from it)
+      - fastEXE : path to fast executable used to run the simulations
+      - exportBase: basename to be used to export data to CSV format (TODO other formats)
+      - plot: plot and return figure
     """
 
     WS_default=5 # If user does not provide a wind speed vector, wind speed used
 
     # if the user provided a full path to the main file, we scrap the directory. TODO, should be cleaner
     if len(os.path.dirname(main_fastfile))>0:
         main_fastfile=os.path.basename(main_fastfile)
@@ -509,77 +564,112 @@
             WS = np.ones(Omega.shape)*WS_default
         elif (WS is not None):
             if len(WS)!=len(Omega):
                 raise Exception('When providing Omega and WS, both vectors should have the same dimension')
         else:
             WS = np.ones(Omega.shape)*WS_default
     else:
-        Omega = WS_default * Lambda/R*60/(2*np.pi) # TODO, use more realistic combinations of WS and Omega
+        Omega = WS_default * Lambda/R*60/(2*np.pi) #[rpm] TODO, use more realistic combinations of WS and Omega
         WS    = np.ones(Omega.shape)*WS_default
 
 
     # --- Defining flat vectors of operating conditions
     WS_flat    = []
     RPM_flat   = []
     Pitch_flat = []
     for pitch in Pitch:
         for (rpm,ws) in zip(Omega,WS):
             WS_flat.append(ws)
             RPM_flat.append(rpm)
             Pitch_flat.append(pitch)
     # --- Setting up default options
-    baseDict={'TMax': TMax, 'DT': 0.01, 'DT_Out': 0.1} # NOTE: Tmax should be at least 2pi/Omega
+    baseDict={'TMax': TMax, 'DT': 0.01, 'DT_Out': 0.1, 'OutFileFmt':2} # NOTE: Tmax should be at least 2pi/Omega
+    baseDict['AeroFile|OutList'] = ['', '"RtAeroCp"', '"RtAeroCt"','"RtVAvgxh"']
+    baseDict['EDFile|OutList']   = ['', '"Azimuth"' ,'"RotSpeed"', '"BldPitch1"']
+    baseDict['InflowFile|PLexp'] = 0   
+    baseDict['InflowFile|RefHt'] = 90  # Arbitrary
+    baseDict['InflowFile|NWindVel']   =1
+    baseDict['InflowFile|WindVxiList']=0
+    baseDict['InflowFile|WindVyiList']=0
+    baseDict['InflowFile|WindVziList']=90 # should be same as RefHt
+    baseDict['InflowFile|OutList']    = ['', '"Wind1VelX"']
+
     baseDict = paramsNoController(baseDict)
     if bStiff:
         baseDict = paramsStiff(baseDict)
     if bNoGen:
         baseDict = paramsNoGen(baseDict)
     if bSteadyAero:
         baseDict = paramsSteadyAero(baseDict)
 
     # --- Creating set of parameters to be changed
-    # TODO: verify that RtAeroCp and RtAeroCt are present in AeroDyn outlist
-    PARAMS = paramsWS_RPM_Pitch(WS_flat,RPM_flat,Pitch_flat,baseDict=baseDict, flatInputs=True)
+    PARAMS = paramsWS_RPM_Pitch(WS_flat, RPM_flat, Pitch_flat, baseDict=baseDict, flatInputs=True, tMax_OneRotation=True)
 
     # --- Generating all files in a workDir
-    workDir = refdir.strip('/').strip('\\')+'_CPLambdaPitch'
-    print('>>> Generating inputs files in {}'.format(workDir))
+    if workDir is None:
+        workDir = refdir.strip('/').strip('\\')+'_CPLambdaPitch'
+    print('>>> Generating {} inputs files in {}'.format(len(PARAMS), workDir))
     RemoveAllowed=reRun # If the user want to rerun, we can remove, otherwise we keep existing simulations
-    fastFiles=templateReplace(PARAMS, refdir, outputDir=workDir,removeRefSubFiles=True,removeAllowed=RemoveAllowed,main_file=main_fastfile)
+    fastFiles=templateReplace(PARAMS, refdir, outputDir=workDir,removeRefSubFiles=True,removeAllowed=RemoveAllowed,main_file=main_fastfile, dryRun=skipWrite)
+
+    # --- Creating a batch script just in case
+    batchFile = os.path.join(workDir,'_RUN_ALL.bat')
+    runner.writeBatch(batchFile, fastFiles, fastExe=fastExe, nBatches=nCores)
+    print('>>> Batch script created (if preferred):', batchFile)
 
     # --- Running fast simulations
     print('>>> Running {} simulations...'.format(len(fastFiles)))
     runner.run_fastfiles(fastFiles, showOutputs=showOutputs, fastExe=fastExe, nCores=nCores, reRun=reRun)
 
     # --- Postpro - Computing averages at the end of the simluation
     print('>>> Postprocessing...')
     outFiles = [os.path.splitext(f)[0]+'.outb' for f in fastFiles]
     # outFiles = glob.glob(os.path.join(workDir,'*.outb'))
     ColKeepStats  = ['RotSpeed_[rpm]','BldPitch1_[deg]','RtAeroCp_[-]','RtAeroCt_[-]','Wind1VelX_[m/s]']
-    result = postpro.averagePostPro(outFiles,avgMethod='periods',avgParam=1,ColKeep=ColKeepStats,ColSort='RotSpeed_[rpm]')
-    # print(result)        
+    ColSort='RotSpeed_[rpm]'
+    try:
+        result = postpro.averagePostPro(outFiles, avgMethod='periods', avgParam=1, ColKeep=ColKeepStats, ColSort=ColSort )
+    except:
+        result = postpro.averagePostPro(outFiles, avgMethod='constantwindow', avgParam=None, ColKeep=ColKeepStats, ColSort=ColSort)
 
     # --- Adding lambda, sorting and keeping only few columns
-    result['lambda_[-]'] = result['RotSpeed_[rpm]']*R*2*np.pi/60/result['Wind1VelX_[m/s]']
-    result.sort_values(['lambda_[-]','BldPitch1_[deg]'],ascending=[True,True],inplace=True)
-    ColKeepFinal=['lambda_[-]','BldPitch1_[deg]','RtAeroCp_[-]','RtAeroCt_[-]']
-    result=result[ColKeepFinal]
-    print('>>> Done')
+    result['lambda_[-]'] = result['RotSpeed_[rpm]']* R*2*np.pi/60/result['Wind1VelX_[m/s]']
+    result.sort_values(['lambda_[-]','BldPitch1_[deg]'], ascending=[True,True], inplace=True)
+    ColKeepFinal = ['lambda_[-]','BldPitch1_[deg]','RtAeroCp_[-]','RtAeroCt_[-]']
+    result = result[ColKeepFinal]
 
-    #  --- Converting to a matrices
+    #  --- Converting to matrices
     CP = result['RtAeroCp_[-]'].values
     CT = result['RtAeroCt_[-]'].values
-    MCP =CP.reshape((len(Lambda),len(Pitch)))
-    MCT =CT.reshape((len(Lambda),len(Pitch)))
-    LAMBDA, PITCH = np.meshgrid(Lambda, Pitch)
-    #  --- CP max
-    i,j = np.unravel_index(MCP.argmax(), MCP.shape)
-    MaxVal={'CP_max':MCP[i,j],'lambda_opt':LAMBDA[j,i],'pitch_opt':PITCH[j,i]}
+    MCP = CP.reshape((len(Lambda),len(Pitch)))
+    MCT = CT.reshape((len(Lambda),len(Pitch)))
+
+    # --- Create a ROSCO PerformanceFile for convenience
+    turbname    = os.path.basename(exportBase)
+    rs = ROSCOPerformanceFile(pitch=Pitch, tsr=Lambda, CP=MCP, CT=MCT, name=turbname)
+
+    if exportBase is not None:
+        if exportFmt.lower()=='rosco':
+            # Write a ROSCO performance file
+            aeroMapFile = exportBase+'_CPCTCQ.txt'
+            rs.write(aeroMapFile)
+        elif exportFmt.lower()=='csv':
+            # Write individual CSV files
+            np.savetxt(exportBase+'_Lambda.csv',Lambda,delimiter = ',')
+            np.savetxt(exportBase+'_Pitch.csv' ,Pitch ,delimiter = ',')
+            np.savetxt(exportBase+'_CP.csv'    ,MCP    ,delimiter = ',')
+            np.savetxt(exportBase+'_CT.csv'    ,MCT    ,delimiter = ',')
+        else:
+            raise NotImplementedError(exportFmt)
 
-    return  MCP,MCT,Lambda,Pitch,MaxVal,result
+    fig = None
+    if plot is True:
+        # --- Plotting matrix of CP values
+        fig = rs.plotCP3D()
+    return  rs, result, fig
 
 
 if __name__=='__main__':
     # --- Test of templateReplace
     PARAMS                          = {}
     PARAMS['TMax']             = 10
     PARAMS['__name__']             =  'MyName'
```

### Comparing `welib-0.0.2/welib/fast/examples/Example_CPLambdaPitch.py` & `welib-1.0.0/welib/fast/examples/Example_CPLambdaPitch.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_ExcelFile.py` & `welib-1.0.0/welib/fast/examples/Example_ExcelFile.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_ExtractInertia.py` & `welib-1.0.0/welib/fast/examples/Example_ExtractInertia.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_Hawc2ToBeamDyn.py` & `welib-1.0.0/welib/fast/examples/Example_Hawc2ToBeamDyn.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_HydroDyn_PrescribedMotion.py` & `welib-1.0.0/welib/fast/examples/Example_HydroDyn_PrescribedMotion.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_Parametric.py` & `welib-1.0.0/welib/fast/examples/Example_Parametric.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_PointMesh.py` & `welib-1.0.0/welib/fast/examples/Example_PointMesh.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_PowerCurve_Parametric.py` & `welib-1.0.0/welib/fast/examples/Example_PowerCurve_Parametric.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_RadialInterp.py` & `welib-1.0.0/welib/fast/examples/Example_RadialInterp.py`

 * *Files 11% similar despite different names*

```diff
@@ -20,30 +20,42 @@
     # --- Read an openfast output file
     outFile = os.path.join(MyDir,'../../../data/example_files/fastout_allnodes.outb')
     df = io.fast_output_file.FASTOutputFile(outFile).toDataFrame()
 
     # --- Define output radial stations
     # Option 1 - Get all these locations automatically (recommended)
     fstFile = os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst') # must correspond to the one used to generate outputs
-    r_AD, r_ED, r_BD, IR_AD, IR_ED, IR_BD, R, r_hub, fst = postpro.FASTRadialOutputs(fstFile, df.columns.values)
+    d = postpro.FASTSpanwiseOutputs(fstFile, df.columns.values)
+    r_AD      = d['r_AD']
+    r_ED_bld  = d['r_ED_bld']
+    r_ED_twr  = d['r_ED_twr']
+    r_BD      = d['r_BD']
+    IR_AD     = d['IR_AD']
+    IR_ED_bld = d['IR_ED_bld']
+    IR_ED_twr = d['IR_ED_twr']
+    IR_BD     = d['IR_BD']
+    TwrLen    = d['TwrLen']
+    R         = d['R']
+    r_hub     = d['r_hub']
+    fst       = d['fst']
 
     # Option 2 - Get ouputs locations for each module
     #r_ED_gag, IR_ED = ED_BldGag(fstFile)
     #r_AD_gag, IR_AD = AD_BldGag(fstFile)
 
     # Option 3 - Define them manually..
     #r_AD = [0.,30.,60.]  
     #r_ED = [0.,30.,60.] 
 
     # --- Interpolate Cl and TDx at desired radial position
     # NOTE: format need to be adjusted if you use AllOuts, or outputs at few nodes
     r    = 60         # Radial location where outputs are to be interpolated
     Cl_interp  = postpro.radialInterpTS(df, r, 'Cl_[-]', r_AD,  bldFmt='AB{:d}', ndFmt='N{:03d}')
-    TDx_interp = postpro.radialInterpTS(df, r, 'TDx_[m]', r_ED, bldFmt='B{:d}' , ndFmt='N{:03d}')
-    #TDx_interp = postpro.radialInterpTS(df, r, 'TDx_[m]', r_ED, bldFmt='B{:d}' , ndFmt='N{d}')
+    TDx_interp = postpro.radialInterpTS(df, r, 'TDx_[m]', r_ED_bld, bldFmt='B{:d}' , ndFmt='N{:03d}')
+    #TDx_interp = postpro.radialInterpTS(df, r, 'TDx_[m]', r_ED_bld, bldFmt='B{:d}' , ndFmt='N{d}')
 
     # --- Plot
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     ax.plot(df['Time_[s]'].values, df['AB1N017Cl_[-]'].values, label='Section before (r={}m)'.format(r_AD[16]))
     ax.plot(df['Time_[s]'].values, Cl_interp.values          , label='Interpolated (r={}m)'.format(r))
     ax.plot(df['Time_[s]'].values, df['AB1N018Cl_[-]'].values, label='Section after (r={}m)'.format(r_AD[17]))
```

### Comparing `welib-0.0.2/welib/fast/examples/Example_RadialPostPro.py` & `welib-1.0.0/welib/fast/examples/Example_RadialPostPro.py`

 * *Files 12% similar despite different names*

```diff
@@ -22,18 +22,19 @@
     outFile = os.path.join(MyDir,'../../../data/example_files/fastout_allnodes.outb')
     df = io.fast_output_file.FASTOutputFile(outFile).toDataFrame()
 
     # --- Step2 : Average data and extrat the radial stations
     # Averaging here is done over 1 period (avgParam=1, avgMethod='periods')
     # To get the output radial stations, a .fst file is needed
     fstFile = os.path.join(MyDir,'../../../data/NREL5MW/Main_Onshore.fst')
-    dfRad_ED, dfRad_AD, dfRad_BD = postpro.spanwisePostPro(FST_In=fstFile, avgMethod='periods', avgParam=1, df=df)
+    out = postpro.spanwisePostPro(FST_In=fstFile, avgMethod='periods', avgParam=1, df=df)
+    dfRad_ED=out['ED_bld']; dfRad_AD = out['AD']; dfRad_BD = out['BD']
 
     # --- Step1&2 at once (when .outb and .fst are next to each other in same folder, with same name)
-    # dfRad_ED, dfRad_AD, dfRad_BD, df = postpro.spanwisePostPro(FST_In=fstFile, avgMethod='periods', avgParam=1, out_ext='.outb')
+    # out = postpro.spanwisePostPro(FST_In=fstFile, avgMethod='periods', avgParam=1, out_ext='.outb')
 
     # --- (Optional, compute time series average)
     # Averaging here is done over the last 100s (avgParam=100, avgMethod='constantwindow')
     #dfAvg = postpro.averageDF(df, avgMethod='constantwindow' ,avgParam=100) 
 
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
```

### Comparing `welib-0.0.2/welib/fast/examples/Example_Remap.py` & `welib-1.0.0/welib/fast/examples/Example_Remap.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/Example_SubDyn_Modes.py` & `welib-1.0.0/welib/fast/examples/Example_SubDyn_Modes.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/ParametricExcel.xlsx` & `welib-1.0.0/welib/fast/examples/ParametricExcel.xlsx`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/examples/README.md` & `welib-1.0.0/welib/fast/examples/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/fast_mesh - Copy.py` & `welib-1.0.0/welib/fast/fast_mesh - Copy.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/fast_mesh.py` & `welib-1.0.0/welib/fast/fast_mesh.py`

 * *Files 11% similar despite different names*

```diff
@@ -33,17 +33,17 @@
         Apply a rigid body motion to the mesh:
         u         : translation     of reference point
         u_dot     : translation vel of reference point
         u_ddot    : translation acc of reference point
         R_b2g     : rotation matrix from body 2 global
         omega     : rotational vel of body
         omega_dot : rotational acc of body
-        RefPoint: Define the reference point where the Rigid Body Motion is to be applied, very important parameter
+        RefPoint: Define the reference point (on the undisplaced mesh) where the Rigid Body Motion is to be applied, very important parameter
         """
-        from welib.yams.rotations import BodyXYZ_A, smallRot_OF, smallRot_A
+        from welib.yams.rotations import rotMat
         # --- Default arguments
         if RefPoint is None:
             RefPoint = self.RefPoint
             if RefPoint is None: 
                 raise Exception('Provide a reference point for rigid body motion')
 
         if qd is None:
@@ -57,56 +57,96 @@
             theta     = np.array([q[3]   , q[4]   , q[5]])
             omega     = np.array([qd[3]  , qd[4]  , qd[5]]) # NOTE  , small angle approx here
             omega_dot = np.array([qdd[3] , qdd[4] , qdd[5]]) # NOTE , small angle approx here
 
 
         if R_b2g is None:
 #             R_b2g = BodyXYZ_A(theta[0], theta[1], theta[2])# matrix body 2 global, order XYZ
-            if rot_type=='smallRot_OF':
-                R_b2g = smallRot_OF(theta[0], theta[1], theta[2]).T # TO MATCH OPENFAST !!!
-            elif rot_type=='smallRot':
-                R_b2g = smallRot_A(theta[0], theta[1], theta[2])
-            else:
-                raise Exception('Rotation type not supported: {}'.format(rot_type))
+            R_b2g = rotMat(theta, rot_type)
+            #if rot_type=='smallRot_OF':
+            #    R_b2g = smallRot_OF(theta[0], theta[1], theta[2]).T # TO MATCH OPENFAST !!!
+            #elif rot_type=='smallRot':
+            #    R_b2g = smallRot_A(theta[0], theta[1], theta[2])
+            #else:
+            #    raise Exception('Rotation type not supported: {}'.format(rot_type))
         # --- Sanitation    
         u         = np.asarray(u)
         u_dot     = np.asarray(u_dot)
         u_ddot    = np.asarray(u_ddot)
         theta     = np.asarray(theta)
         omega     = np.asarray(omega)
         omega_dot = np.asarray(omega_dot)
         # --- Motion
         r_AB0  = (self.Position[:,:] - RefPoint)
         r_AB   = (R_b2g.dot(r_AB0.T)).T
         om_x_r = (np.cross(omega, r_AB))
         self.TranslationDisp[:,:] = u + (r_AB - r_AB0)
         self.TranslationVel [:,:] = u_dot  + om_x_r
         self.TranslationAcc [:,:] = u_ddot + np.cross(omega_dot, r_AB) + np.cross(omega, om_x_r)
-        self.Orientation [:,:,:]  = R_b2g.T
+        self.Orientation [:,:,:]  = R_b2g.T # TODO TODO TODO Shouldn't we also have RefOrientation here?
         self.RotationVel [:,:]    = omega
         self.RotationAcc [:,:]    = omega_dot
 
+    def perturbNode(self, iNode, q):
+        from welib.yams.rotations import BodyXYZ_A, smallRot_OF, smallRot_A
+        u         = np.array([q[0]   , q[1]   , q[2]])
+        theta     = np.array([q[3]   , q[4]   , q[5]])
+        R_b2g = smallRot_OF(theta[0], theta[1], theta[2]).T # TO MATCH OPENFAST !!!
+        # --- Motion
+        self.TranslationDisp[iNode,:] += u 
+        self.Orientation  [iNode,:,:]  = R_b2g.T # TODO?
+
     def mapLoadsToPoint(self, P):
         """ Map Force and Moment fields to a given point"""
         P = np.asarray(P)
         F = np.zeros(3)
         M = np.zeros(3)
         r_PP0 = self.Position[:,:] + self.TranslationDisp[:,:] - P
         dM = np.cross(r_PP0, self.Force[:,:])
         F = np.sum(self.Force[:,:], axis=0) 
         M = np.sum(self.Moment+dM , axis=0) 
         return F, M
 
     def transferMotion2IdenticalMesh(self, target):
-        target.TranslationDisp = self.TranslationDisp
-        target.TranslationVel  = self.TranslationVel 
-        target.TranslationAcc  = self.TranslationAcc 
-        target.Orientation     = self.Orientation    
-        target.RotationVel     = self.RotationVel    
-        target.RotationAcc     = self.RotationAcc    
+        target.TranslationDisp = self.TranslationDisp.copy()
+        target.TranslationVel  = self.TranslationVel .copy()
+        target.TranslationAcc  = self.TranslationAcc .copy()
+        target.Orientation     = self.Orientation    .copy()
+        target.RotationVel     = self.RotationVel    .copy()
+        target.RotationAcc     = self.RotationAcc    .copy()
+
+    def backupValues(self):
+        """ Backup mesh motion values, useful at an operating point """
+        self.TranslationDisp_0 = self.TranslationDisp.copy()
+        self.TranslationVel_0  = self.TranslationVel .copy()
+        self.TranslationAcc_0  = self.TranslationAcc .copy()
+        self.Orientation_0     = self.Orientation    .copy()
+        self.RotationVel_0     = self.RotationVel    .copy()
+        self.RotationAcc_0     = self.RotationAcc    .copy()
+
+    def restoreValues(self):
+        """ Resstore stored values by backupValues() """
+        self.TranslationDisp = self.TranslationDisp_0.copy()
+        self.TranslationVel  = self.TranslationVel_0.copy()
+        self.TranslationAcc  = self.TranslationAcc_0.copy()
+        self.Orientation     = self.Orientation_0.copy()
+        self.RotationVel     = self.RotationVel_0.copy()
+        self.RotationAcc     = self.RotationAcc_0.copy()
+
+    def packLoads(self, FthenM=True):
+        if FthenM:
+            # Force for all nodes + Moment for all nodes
+            M = np.vstack((self.Force,self.Moment))
+        else:
+            # Force+Moment for each node
+            M=np.zeros((self.nNodes*2, 3))
+            for i in range(self.nNodes):
+                M[i*3+0: i*3+3] = self.Force[i,:]
+                M[i*3+3: i*3+6] = self.Moment[i,:]
+        return M.flatten()
 
     # --------------------------------------------------------------------------------}
     # --- IO  
     # --------------------------------------------------------------------------------{
     def toConnectedObject(self, diameters=5):
         from welib.FEM.graph import ConnectedObject
         if self.Connectivity is None:
```

### Comparing `welib-0.0.2/welib/fast/fastfarm.py` & `welib-1.0.0/welib/fast/fastfarm.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,23 +1,16 @@
 import os
 import glob
 import numpy as np
 import pandas as pd
-try:
-    import welib.weio as weio
-    from welib.weio.fast_input_file import FASTInputFile
-    from welib.weio.fast_output_file import FASTOutputFile
-    from welib.weio.turbsim_file import TurbSimFile
-except:
-    try:
-	    from weio.fast_input_file import FASTInputFile
-	    from weio.fast_output_file import FASTOutputFile
-	    from weio.turbsim_file import TurbSimFile
-    except:
-        raise Exception('Python package `weio` not found, please install it from https://github.com/ebranlard/weio ')
+
+import welib.weio as weio
+from welib.weio.fast_input_file import FASTInputFile
+from welib.weio.fast_output_file import FASTOutputFile
+from welib.weio.turbsim_file import TurbSimFile
 
 from . import fastlib
 
 # --------------------------------------------------------------------------------}
 # --- Small helper functions
 # --------------------------------------------------------------------------------{
 def insertTN(s,i,nWT=1000):
@@ -143,115 +136,188 @@
     # --- Export coordinates only
     M=np.column_stack((XWT.ravel(),YWT.ravel(),ZWT.ravel()))
     np.savetxt('Farm_Coordinates.csv', M, delimiter=',',header='X_[m], Y_[m], Z_[m]')
     print(M)
 
     return XWT, YWT, ZWT
 
-def fastFarmTurbSimExtent(TurbSimFilename, HubHeight, D, xWT, yWT, Cmeander=1.9, Chord_max=3, extent_X=1.2, extent_Y=1.2):
+
+def fastFarmTurbSimExtent(TurbSimFilename, hubHeight, D, xWT, yWT, Cmeander=1.9, chord_max=3, extent_X=1.1, extent_YZ=1.1, meanUAtHubHeight=False):
     """ 
     Determines "Ambient Wind" box parametesr for FastFarm, based on a TurbSimFile ('bts')
+
+    Implements the guidelines listed here:
+        https://openfast.readthedocs.io/en/dev/source/user/fast.farm/ModelGuidance.html
+
+    INPUTS:
+     - TurbSimFilename: name of the BTS file used in the FAST.Farm simulation
+     - hubHeight      : Hub height [m]
+     - D              : turbine diameter [m]
+     - xWT            : vector of x positions of the wind turbines (e.g. [0,300,600])
+     - yWT            : vector of y positions of the wind turbines (e.g. [0,0,0])
+     - Cmeander       : parameter for meandering used in FAST.Farm [-]
+     - chord_max      : maximum chord of the wind turbine blade. Used to determine the high resolution 
+     - extent_X       : x-extent of high res box in diamter around turbine location
+     - extent_YZ      : y-extent of high res box in diamter around turbine location
+
     """
     # --- TurbSim data
-    ts      = TurbSimFile(TurbSimFilename)
-    #iy,iz   = ts.closestPoint(y=0,z=HubHeight)
-    #iy,iz   = ts.closestPoint(y=0,z=HubHeight)
-    zMid, uMid =  ts.midValues()
-    #print('uMid',uMid)
-    #meanU   = ts['u'][0,:,iy,iz].mean()
-    meanU   = uMid
-    dY_High = ts['y'][1]-ts['y'][0]
-    dZ_High = ts['z'][1]-ts['z'][0]
-    Z0_Low  = ts['z'][0]
-    Z0_High = ts['z'][0] # we start at lowest to include tower
-    Width   = ts['y'][-1]-ts['y'][0]
-    Height  = ts['z'][-1]-ts['z'][0]
-    dT_High = ts['dt']
-    #effSimLength = ts['t'][-1]-ts['t'][0] + Width/meanU
-    effSimLength = ts['t'][-1]-ts['t'][0]
+    ts = TurbSimFile(TurbSimFilename)
 
-    # Desired resolution, rule of thumbs
-    dX_High_desired = Chord_max             
-    dX_Low_desired  = Cmeander*D*meanU/150.0
-    dt_des          = Cmeander*D/(10.0*meanU)
+    if meanUAtHubHeight:
+        # Use Hub Height to determine convection velocity
+        iy,iz   = ts.closestPoint(y=0,z=hubHeight)
+        meanU   = ts['u'][0,:,iy,iz].mean()
+    else:
+        # Use middle of the box to determine convection velocity
+        zMid, meanU =  ts.midValues()
+
+    return fastFarmBoxExtent(ts.y, ts.z, ts.t, meanU, hubHeight, D, xWT, yWT, Cmeander=Cmeander, chord_max=chord_max, extent_X=extent_X, extent_YZ=extent_YZ) 
+
+def fastFarmBoxExtent(yBox, zBox, tBox, meanU, hubHeight, D, xWT, yWT, 
+        Cmeander=1.9, chord_max=3, extent_X=1.1, extent_YZ=1.1, 
+        extent_wake=8, LES=False):
+    """ 
+    Determines "Ambient Wind" box parametesr for FastFarm, based on turbulence box parameters
+    INPUTS:
+     - yBox  : y vector of grid points of the box
+     - zBox  : z vector of grid points of the box
+     - tBox  : time vector of the box
+     - meanU : mean velocity used to convect the box
+     - hubHeight      : Hub height [m]
+     - D              : turbine diameter [m]
+     - xWT            : vector of x positions of the wind turbines (e.g. [0,300,600])
+     - yWT            : vector of y positions of the wind turbines (e.g. [0,0,0])
+     - Cmeander       : parameter for meandering used in FAST.Farm [-]
+     - chord_max      : maximum chord of the wind turbine blade. Used to determine the high resolution 
+     - extent_X       : x-extent of high-res box (in diameter) around turbine location
+     - extent_YZ      : y-extent of high-res box (in diameter) around turbine location
+     - extent_wake    : extent of low-res box (in diameter) to add beyond the "last" wind turbine
+     - LES: False for TurbSim box, true for LES. Perform additional checks for LES.
+    """
+    if LES:
+        raise NotImplementedError()
+    # --- Box resolution and extents
+    dY_Box      = yBox[1]-yBox[0]
+    dZ_Box      = zBox[1]-zBox[0]
+    dT_Box      = tBox[1]-tBox[0]
+    dX_Box      = dT_Box * meanU
+    Z0_Box      = zBox[0]
+    LY_Box      = yBox[-1]-yBox[0]
+    LZ_Box      = zBox[-1]-zBox[0]
+    LT_Box      = tBox[-1]-tBox[0]    
+    LX_Box      = LT_Box * meanU
 
-    # --- High domain
-    ZMax_High = HubHeight+extent_Y*D/2.0
-    # high-box extent in x and y [D]
-    Xdist_High = extent_X*D
-    Ydist_High = extent_Y*D
-    Zdist_High = ZMax_High-Z0_High # we include the tower
-    X0_rel     = Xdist_High/2.0
-    Y0_rel     = Ydist_High/2.0
-    Length     = effSimLength*meanU
-    nx         = int(round(effSimLength/dT_High))
-    dx_TS      = Length/(nx-1)
-    #print('dx_TS',dx_TS)
-    dX_High    = round(dX_High_desired/dx_TS)*dx_TS
-    #print('dX_High_desired',dX_High_desired, dX_High)
+    # --- Desired resolution, rules of thumb
+    dX_High_desired = chord_max
+    dX_Low_desired  = Cmeander*D*meanU/150.0
+    dY_Low_desired  = dX_Low_desired
+    dZ_Low_desired  = dX_Low_desired
+    dT_Low_desired  = Cmeander*D/(10.0*meanU)
+
+    # --- Suitable resolution for high res
+    dX_High = int(dX_High_desired/dX_Box)*dX_Box
+    if dX_High==0: raise Exception('The x-resolution of the box ({}) is too large and cannot satisfy the requirements for the high-res domain of dX~{} (based on chord_max). Reduce DX (or DT) of the box.'.format(dX_Box, dX_High_desired))
+    dY_High = dY_Box  # TODO? 
+    dZ_High = dZ_Box  # TODO? 
+    dT_High = dT_Box  # TODO? 
+
+    # --- Suitable resolution for Low res
+    dT_Low = int(dT_Low_desired/dT_Box )*dT_Box
+    dX_Low = int(dX_Low_desired/dX_High)*dX_High
+    dY_Low = int(dY_Low_desired/dY_High)*dY_High
+    dZ_Low = int(dZ_Low_desired/dZ_High)*dZ_High
+    if dT_Low==0: raise Exception('The time-resolution of the box ({}) is too large and cannot satisfy the requirements for the low-res domain of dT~{} (based on D & U). Reduce the DT of the box.'.format(dT_Box, dT_Low_desired))
+    if dX_Low==0: raise Exception('The X-resolution of the box ({}) is too large and cannot satisfy the requirements for the low-res domain of dX~{} (based on D & U). Reduce the DX of the box.'.format(dX_Box, dX_Low_desired))
+    if dY_Low==0: raise Exception('The Y-resolution of the box ({}) is too large and cannot satisfy the requirements for the low-res domain of dY~{} (based on D & U). Reduce the DY of the box.'.format(dY_Box, dY_Low_desired))
+    if dZ_Low==0: raise Exception('The Z-resolution of the box ({}) is too large and cannot satisfy the requirements for the low-res domain of dZ~{} (based on D & U). Reduce the DZ of the box.'.format(dZ_Box, dZ_Low_desired))
+
+    # --- Low-res domain
+    # NOTE: more work is needed to make sure the domain encompass the turbines
+    #       Also, we need to know the main flow direction to add a buffere with extent_wake
+    # Origin
+    nD_Before = extent_X/2 # Diameters before the first turbine to start the domain
+    X0_Low = np.floor( (min(xWT)-nD_Before*D-dX_Low)) # Starting on integer value for esthetics. With a dX_Low margin.
+    Y0_Low = np.floor( -LY_Box/2                    ) # Starting on integer value for esthetics
+    Z0_Low = zBox[0] # we start at lowest to include tower
+    if LES:
+        if Y0_Low > min(yWT)-3*D:
+            Y0_Low = np.floor(min(yWT)-3*D) 
+    # Extent NOTE: this assumes main flow about x. Might need to be changed
     
-    nX_High = int(round(Xdist_High/dX_High)+1)
-    nY_High = int(round(Ydist_High/dY_High)+1)
-    nZ_High = int(round(Zdist_High/dZ_High)+1)
-
-    # --- High extent per turbine
-    nTurbs = len(xWT)
-    X0_des = np.asarray(xWT)-X0_rel
-    Y0_des = np.asarray(yWT)-Y0_rel
-    X0_High = np.around(np.round(X0_des/dX_High)*dX_High,3)
-    Y0_High = np.around(np.round(Y0_des/dY_High)*dY_High,3)
-
-    # --- Low domain
-    dT_Low = round(dt_des/dT_High)*dT_High
-    dx_des = dX_Low_desired
-    dy_des = dX_Low_desired
-    dz_des = dX_Low_desired
-    X0_Low = round( (min(xWT)-2*D)/dX_High) *dX_High
-    Y0_Low = round( -Width/2      /dY_High) *dY_High
-    dX_Low = round( dx_des        /dX_High)*dX_High
-    dY_Low = round( dy_des        /dY_High)*dY_High
-    dZ_Low = round( dz_des        /dZ_High)*dZ_High
-    Xdist  = max(xWT)+8.0*D-X0_Low  # Maximum extent
-    Ydist  = Width
-    Zdist  = Height
-    #print('dX_Low',dX_Low, dX_Low/dx_TS, dX_High/dx_TS)
-
-    nX_Low = int(Xdist/dX_Low)+1; 
-    nY_Low = int(Ydist/dY_Low)+1;
-    nZ_Low = int(Zdist/dZ_Low)+1;
-
-    if (nX_Low*dX_Low>Xdist):
-        nX_Low=nX_Low-1 
-    if (nY_Low*dY_Low>Ydist):
-        nY_Low=nY_Low-1 
-    if (nZ_Low*dZ_Low>Zdist):
-        nZ_Low=nZ_Low-1 
+    XMax_Low = max(xWT) + extent_wake*D
+    LX_Low = XMax_Low-X0_Low
+    LY_Low = LY_Box 
+    LZ_Low = LZ_Box 
+    # Number of points
+    nX_Low = int(np.ceil(LX_Low/dX_Low))
+    nY_Low = int(np.ceil(LY_Low/dY_Low))
+    nZ_Low = int(np.ceil(LZ_Low/dZ_Low))
+    # Make sure we don't exceed box in Y and Z
+    if (nY_Low*dY_Low>LY_Box): nY_Low=nY_Low-1 
+    if (nZ_Low*dZ_Low>LZ_Box): nZ_Low=nZ_Low-1 
+
+    # --- High-res domain extent and number of points
+    ZMax_High = hubHeight+extent_YZ*D/2
+    Z0_High   = zBox[0] # we start at lowest to include tower
+    LX_High =  extent_X*D        
+    LY_High =  min(LY_Box, extent_YZ*D      ) # Bounding to not exceed the box dimension
+    LZ_High =  min(LZ_Box, ZMax_High-Z0_High) # Bounding to not exceed the box dimension
+    nX_High = int(np.ceil(LX_High/dX_High))
+    nY_High = int(np.ceil(LY_High/dY_High))
+    nZ_High = int(np.ceil(LZ_High/dZ_High))
+    # Make sure we don't exceed box in Y and Z
+    if (nY_High*dY_High>LY_Box): nY_High=nY_High-1 
+    if (nZ_High*dZ_High>LZ_Box): nZ_High=nZ_High-1 
+
+    # --- High-res location per turbine 
+    X0_desired = np.asarray(xWT)-LX_High/2 # high-res is centered on turbine location
+    Y0_desired = np.asarray(yWT)-LY_High/2 # high-res is centered on turbine location
+    X0_High    = X0_Low + np.floor((X0_desired-X0_Low)/dX_High)*dX_High
+    Y0_High    = Y0_Low + np.floor((Y0_desired-Y0_Low)/dY_High)*dY_High
 
     d = dict()
-    d['DT']      = np.around(dT_Low ,3)
-    d['DT_High'] = np.around(dT_High,3)
-    d['NX_Low']  = int(nX_Low)
-    d['NY_Low']  = int(nY_Low)
-    d['NZ_Low']  = int(nZ_Low)
-    d['X0_Low']  = np.around(X0_Low,3)
-    d['Y0_Low']  = np.around(Y0_Low,3)
-    d['Z0_Low']  = np.around(Z0_Low,3)
-    d['dX_Low']  = np.around(dX_Low,3)
-    d['dY_Low']  = np.around(dY_Low,3)
-    d['dZ_Low']  = np.around(dZ_Low,3)
-    d['NX_High'] = int(nX_High)
-    d['NY_High'] = int(nY_High)
-    d['NZ_High'] = int(nZ_High)
+    d['DT_Low']  = np.around(dT_Low ,4)
+    d['DT_High'] = np.around(dT_High,4)
+    d['NX_Low']  = nX_Low
+    d['NY_Low']  = nY_Low
+    d['NZ_Low']  = nZ_Low
+    d['X0_Low']  = np.around(X0_Low,4)
+    d['Y0_Low']  = np.around(Y0_Low,4)
+    d['Z0_Low']  = np.around(Z0_Low,4)
+    d['dX_Low']  = np.around(dX_Low,4)
+    d['dY_Low']  = np.around(dY_Low,4)
+    d['dZ_Low']  = np.around(dZ_Low,4)
+    d['NX_High'] = nX_High
+    d['NY_High'] = nY_High
+    d['NZ_High'] = nZ_High
     # --- High extent info for turbine outputs
-    d['dX_High'] = np.around(dX_High,3)
-    d['dY_High'] = np.around(dY_High,3)
-    d['dZ_High'] = np.around(dZ_High,3)
-    d['X0_High'] = X0_High
-    d['Y0_High'] = Y0_High
-    d['Z0_High'] = np.around(Z0_High,3)
+    d['dX_High'] = np.around(dX_High,4)
+    d['dY_High'] = np.around(dY_High,4)
+    d['dZ_High'] = np.around(dZ_High,4)
+    d['X0_High'] = np.around(X0_High,4)
+    d['Y0_High'] = np.around(Y0_High,4)
+    d['Z0_High'] = np.around(Z0_High,4)
+    # --- Misc
+    d['dX_des_High'] = dX_High_desired
+    d['dX_des_Low']  = dX_Low_desired
+    d['DT_des']      = dT_Low_desired
+    d['U_mean']      = meanU
+
+    # --- Sanity check: check that the high res is at "almost" an integer location
+    X_rel = (np.array(d['X0_High'])-d['X0_Low'])/d['dX_High']
+    Y_rel = (np.array(d['Y0_High'])-d['Y0_Low'])/d['dY_High']
+    dX = X_rel - np.round(X_rel) # Should be close to zero
+    dY = Y_rel - np.round(Y_rel) # Should be close to zero
+    if any(abs(dX)>1e-3):
+        print('Deltas:',dX)
+        raise Exception('Some X0_High are not on an integer multiple of the high-res grid')
+    if any(abs(dY)>1e-3):
+        print('Deltas:',dY)
+        raise Exception('Some Y0_High are not on an integer multiple of the high-res grid')
 
     return d
 
 def writeFastFarm(outputFile, templateFile, xWT, yWT, zWT, FFTS=None, OutListT1=None):
     """ Write FastFarm input file based on a template, a TurbSimFile and the Layout
     
     outputFile: .fstf file to be written
@@ -260,20 +326,21 @@
     FFTS: FastFarm TurbSim parameters as returned by fastFarmTurbSimExtent
     """
     # --- Read template fast farm file
     fst=FASTInputFile(templateFile)
     # --- Replace box extent values
     if FFTS is not None:
         fst['Mod_AmbWind'] = 2
-        for k in ['DT', 'DT_High', 'NX_Low', 'NY_Low', 'NZ_Low', 'X0_Low', 'Y0_Low', 'Z0_Low', 'dX_Low', 'dY_Low', 'dZ_Low', 'NX_High', 'NY_High', 'NZ_High']:
+        ModVars = ['DT_Low', 'DT_High', 'NX_Low', 'NY_Low', 'NZ_Low', 'X0_Low', 'Y0_Low', 'Z0_Low', 'dX_Low', 'dY_Low', 'dZ_Low', 'NX_High', 'NY_High', 'NZ_High']
+        for k in ModVars:
             if isinstance(FFTS[k],int):
                 fst[k] = FFTS[k] 
             else:
                 fst[k] = np.around(FFTS[k],3)
-        fst['WrDisDT'] = FFTS['DT']
+        fst['WrDisDT'] = FFTS['DT_Low']
 
     # --- Set turbine names, position, and box extent
     nWT = len(xWT)
     fst['NumTurbines'] = nWT
     if FFTS is not None:
         nCol= 10
     else:
@@ -309,90 +376,159 @@
             OutList+=['"'+s.replace('T1','T{:d}'.format(iWT+1))+'"' for iWT in np.arange(nWTOut) ]
         else:
             OutList+='"'+s+'"'
     fst['OutList']=OutList
     fst.write(fastFarmFile)
 
 
-def plotFastFarmSetup(fastFarmFile):
+def plotFastFarmSetup(fastFarmFile, grid=True, fig=None, D=None, plane='XY', hubHeight=None):
     """ """
     import matplotlib.pyplot as plt
+
+    def col(i): 
+        Colrs=plt.rcParams['axes.prop_cycle'].by_key()['color']
+        return Colrs[ np.mod(i,len(Colrs)) ]
+    def boundingBox(x, y):
+        """ return x and y coordinates to form a box marked by the min and max of x and y"""
+        x_bound = [x[0],x[-1],x[-1],x[0] ,x[0]]
+        y_bound = [y[0],y[0] ,y[-1],y[-1],y[0]]
+        return x_bound, y_bound
+
+
+    # --- Read FAST.Farm input file
     fst=FASTInputFile(fastFarmFile)
 
-    fig = plt.figure(figsize=(13.5,10))
-    ax  = fig.add_subplot(111,aspect="equal")
+    if fig is None:
+        fig = plt.figure(figsize=(13.5,8))
+        ax  = fig.add_subplot(111,aspect="equal")
 
     WT=fst['WindTurbines']
-    x       = WT[:,0].astype(float)
-    y       = WT[:,1].astype(float)
+    xWT = WT[:,0].astype(float)
+    yWT = WT[:,1].astype(float)
+    zWT = yWT*0 
+    if hubHeight is not None:
+        zWT += hubHeight
+
+    if plane == 'XY':
+        pass
+    elif plane == 'XZ':
+        yWT = zWT
+    elif plane == 'YZ':
+        xWT = yWT
+        yWT = zWT
+    else:
+        raise Exception("Plane should be 'XY' 'XZ' or 'YZ'")
 
     if fst['Mod_AmbWind'] == 2:
-        xmax_low = fst['X0_Low']+fst['DX_Low']*fst['NX_Low']
-        ymax_low = fst['Y0_Low']+fst['DY_Low']*fst['NY_Low']
-        # low-res box
-        ax.plot([fst['X0_Low'],xmax_low,xmax_low,fst['X0_Low'],fst['X0_Low']],
-                [fst['Y0_Low'],fst['Y0_Low'],ymax_low,ymax_low,fst['Y0_Low']],'--k',lw=2,label='Low')
+        x_low = fst['X0_Low'] + np.arange(fst['NX_Low']+1)*fst['DX_Low']
+        y_low = fst['Y0_Low'] + np.arange(fst['NY_Low']+1)*fst['DY_Low']
+        z_low = fst['Z0_Low'] + np.arange(fst['NZ_Low']+1)*fst['DZ_Low']
+        if plane == 'XZ':
+            y_low = z_low
+        elif plane == 'YZ':
+            x_low = y_low
+            y_low = z_low
+        # Plot low-res box
+        x_bound_low, y_bound_low =  boundingBox(x_low, y_low)
+        ax.plot(x_bound_low, y_bound_low ,'--k',lw=2,label='Low-res')
+        # Plot Low res grid lines
+        if grid:
+            ax.vlines(x_low, ymin=y_low[0], ymax=y_low[-1], ls='-', lw=0.3, color=(0.3,0.3,0.3))
+            ax.hlines(y_low, xmin=x_low[0], xmax=x_low[-1], ls='-', lw=0.3, color=(0.3,0.3,0.3))
+
         X0_High = WT[:,4].astype(float)
         Y0_High = WT[:,5].astype(float)
+        Z0_High = WT[:,6].astype(float)
         dX_High = WT[:,7].astype(float)[0]
         dY_High = WT[:,8].astype(float)[0]
+        dZ_High = WT[:,9].astype(float)[0]
         nX_High = fst['NX_High']
         nY_High = fst['NY_High']
+        nZ_High = fst['NZ_High']
+
         # high-res boxes
-        for wt in range(len(x)):
-            xmax_high = X0_High[wt]+dX_High*nX_High
-            ymax_high = Y0_High[wt]+dY_High*nY_High
-            ax.plot([X0_High[wt],xmax_high,xmax_high,X0_High[wt],X0_High[wt]],
-                    [Y0_High[wt],Y0_High[wt],ymax_high,ymax_high,Y0_High[wt]],
-                    '-',
-                    label="HighT{0}".format(wt+1))
-            ax.plot(x[wt],y[wt],'x',ms=8,mew=2,label="WT{0}".format(wt+1))
-    else:
-        for wt in range(len(x)):
-            ax.plot(x[wt],y[wt],'x',ms=8,mew=2,label="WT{0}".format(wt+1))
-        # 
-    plt.legend(bbox_to_anchor=(1.05,1.015),frameon=False)
-    ax.set_xlabel("x-location [m]")
-    ax.set_ylabel("y-location [m]")
+        for wt in range(len(xWT)):
+            x_high = X0_High[wt] + np.arange(nX_High+1)*dX_High
+            y_high = Y0_High[wt] + np.arange(nY_High+1)*dY_High
+            z_high = Z0_High[wt] + np.arange(nZ_High+1)*dZ_High
+            if plane == 'XZ':
+                y_high = z_high
+            elif plane == 'YZ':
+                x_high = y_high
+                y_high = z_high
+
+            x_bound_high, y_bound_high =  boundingBox(x_high, y_high)
+            ax.plot(x_bound_high, y_bound_high, '-', lw=2, c=col(wt))
+            # Plot High res grid lines
+            if grid:
+                ax.vlines(x_high, ymin=y_high[0], ymax=y_high[-1], ls='--', lw=0.4, color=col(wt))
+                ax.hlines(y_high, xmin=x_high[0], xmax=x_high[-1], ls='--', lw=0.4, color=col(wt))
+
+    # Plot turbines
+    for wt in range(len(xWT)):
+        ax.plot(xWT[wt], yWT[wt], 'x', ms=8, mew=2, c=col(wt),label="WT{}".format(wt+1))
+        if plane=='XY' and D is not None:
+            ax.plot([xWT[wt],xWT[wt]], [yWT[wt]-D/2,yWT[wt]+D/2], '-', lw=2, c=col(wt))
+        elif plane=='XZ' and D is not None and hubHeight is not None:
+            ax.plot([xWT[wt],xWT[wt]], [yWT[wt]-D/2,yWT[wt]+D/2], '-', lw=2, c=col(wt))
+        elif plane=='YZ' and D is not None and hubHeight is not None:
+            theta = np.linspace(0,2*np.pi, 40)
+            x = xWT[wt] + D/2*np.cos(theta)
+            y = yWT[wt] + D/2*np.sin(theta)
+            ax.plot(x, y, '-', lw=2, c=col(wt))
+
+    #plt.legend(bbox_to_anchor=(1.05,1.015),frameon=False)
+    ax.legend()
+    if plane=='XY':
+        ax.set_xlabel("x [m]")
+        ax.set_ylabel("y [m]")
+    elif plane=='XZ':
+        ax.set_xlabel("x [m]")
+        ax.set_ylabel("z [m]")
+    elif plane=='YZ':
+        ax.set_xlabel("y [m]")
+        ax.set_ylabel("z [m]")
     fig.tight_layout
     # fig.savefig('FFarmLayout.pdf',bbox_to_inches='tight',dpi=500)
 
+    return fig
+
 # --------------------------------------------------------------------------------}
 # --- Tools for postpro 
 # --------------------------------------------------------------------------------{
 
 def spanwiseColFastFarm(Cols, nWT=9, nD=9):
     """ Return column info, available columns and indices that contain AD spanwise data"""
     FFSpanMap=dict()
     for i in np.arange(nWT):
-        FFSpanMap['^CtT{:d}N(\d*)_\[-\]'.format(i+1)]='CtT{:d}_[-]'.format(i+1)
+        FFSpanMap[r'^CtT{:d}N(\d*)_\[-\]'.format(i+1)]='CtT{:d}_[-]'.format(i+1)
     for i in np.arange(nWT):
         for k in np.arange(nD):
-            FFSpanMap['^WkDfVxT{:d}N(\d*)D{:d}_\[m/s\]'.format(i+1,k+1) ]='WkDfVxT{:d}D{:d}_[m/s]'.format(i+1, k+1)  
+            FFSpanMap[r'^WkDfVxT{:d}N(\d*)D{:d}_\[m/s\]'.format(i+1,k+1) ]='WkDfVxT{:d}D{:d}_[m/s]'.format(i+1, k+1)  
     for i in np.arange(nWT):
         for k in np.arange(nD):
-            FFSpanMap['^WkDfVrT{:d}N(\d*)D{:d}_\[m/s\]'.format(i+1,k+1) ]='WkDfVrT{:d}D{:d}_[m/s]'.format(i+1, k+1)  
+            FFSpanMap[r'^WkDfVrT{:d}N(\d*)D{:d}_\[m/s\]'.format(i+1,k+1) ]='WkDfVrT{:d}D{:d}_[m/s]'.format(i+1, k+1)  
 
     return fastlib.find_matching_columns(Cols, FFSpanMap)
 
 def diameterwiseColFastFarm(Cols, nWT=9):
     """ Return column info, available columns and indices that contain AD spanwise data"""
     FFDiamMap=dict()
     for i in np.arange(nWT):
         for x in ['X','Y','Z']:
-            FFDiamMap['^WkAxs{}T{:d}D(\d*)_\[-\]'.format(x,i+1)]   ='WkAxs{}T{:d}_[-]'.format(x,i+1) 
+            FFDiamMap[r'^WkAxs{}T{:d}D(\d*)_\[-\]'.format(x,i+1)]   ='WkAxs{}T{:d}_[-]'.format(x,i+1) 
     for i in np.arange(nWT):
         for x in ['X','Y','Z']:
-            FFDiamMap['^WkPos{}T{:d}D(\d*)_\[m\]'.format(x,i+1)]   ='WkPos{}T{:d}_[m]'.format(x,i+1)
+            FFDiamMap[r'^WkPos{}T{:d}D(\d*)_\[m\]'.format(x,i+1)]   ='WkPos{}T{:d}_[m]'.format(x,i+1)
     for i in np.arange(nWT):
         for x in ['X','Y','Z']:
-            FFDiamMap['^WkVel{}T{:d}D(\d*)_\[m/s\]'.format(x,i+1)] ='WkVel{}T{:d}_[m/s]'.format(x,i+1) 
+            FFDiamMap[r'^WkVel{}T{:d}D(\d*)_\[m/s\]'.format(x,i+1)] ='WkVel{}T{:d}_[m/s]'.format(x,i+1) 
     for i in np.arange(nWT):
         for x in ['X','Y','Z']:
-            FFDiamMap['^WkDiam{}T{:d}D(\d*)_\[m\]'.format(x,i+1)]  ='WkDiam{}T{:d}_[m]'.format(x,i+1)
+            FFDiamMap[r'^WkDiam{}T{:d}D(\d*)_\[m\]'.format(x,i+1)]  ='WkDiam{}T{:d}_[m]'.format(x,i+1)
     return fastlib.find_matching_columns(Cols, FFDiamMap)
 
 def SensorsFARMRadial(nWT=3,nD=10,nR=30,signals=None):
     """ Returns a list of FASTFarm sensors that are used for the radial distribution
     of quantities (e.g. Ct, Wake Deficits).
     If `signals` is provided, the output is the list of sensors within the list `signals`.
     """
@@ -441,19 +577,19 @@
     # --- Opening ouputfile
     if df is None:
         df=FASTOutputFile(fastfarm_out).toDataFrame()
 
     # --- Opening input file and extracting inportant variables
     if fastfarm_input is None:
         # We don't have an input file, guess numbers of turbine, diameters, Nodes...
-        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, 'T(\d+)')
+        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, r'T(\d+)')
         nWT = np.array(sIdx).astype(int).max()
-        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, 'D(\d+)')
+        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, r'D(\d+)')
         nD = np.array(sIdx).astype(int).max()
-        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, 'N(\d+)')
+        cols, sIdx = fastlib.find_matching_pattern(df.columns.values, r'N(\d+)')
         nr = np.array(sIdx).astype(int).max()
         vr=None
         vD=None
         D=0
     else:
         main=FASTInputFile(fastfarm_input)
         iOut    = main['OutRadii']
```

### Comparing `welib-0.0.2/welib/fast/fastlib_legacy.py` & `welib-1.0.0/welib/fast/fastlib_legacy.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 # --- For cmd.py
-from __future__ import division, print_function
 import os
 import subprocess
 import multiprocessing
 
 import collections
 import glob
 import pandas as pd
```

### Comparing `welib-0.0.2/welib/fast/hydrodyn.py` & `welib-1.0.0/welib/fast/hydrodyn.py`

 * *Files 12% similar despite different names*

```diff
@@ -194,36 +194,120 @@
         y['Morison'] = yMor
         self.u = u 
         self.y = y 
         return u, y
 
     
     def calcOutput(self, t, x=None, xd=None, xo=None, u=None, y=None, optsM=None):
+        """ 
+        optsM: Morison options
+        """
+
         yMor = self.morison.calcOutput(t, x=x, xd=xd, xo=xo, u=u['Morison'], y=y['Morison'], opts=optsM)
         y['Morison'] = yMor
 
         return y
 
 
+    def linearize(self, q0=None, qd0=None, qdd0=None, dq=None, dqd=None, dqdd=None, 
+            RefPointMotion=None, RefPointMapping=None,
+            RefPointMappingMotion='translate',
+            optsM=None, saveFile=None,
+            around=None
+            ):
+        """ 
+        """
+        from welib.system.linearization import numerical_jacobian
+        uMesh = self.u['Morison']['Mesh']
+
+        if optsM is None:
+            optsM={}
+
+        FthenM=True
+
+        # --- Define a function that returns outputs
+        def fh(q,p=None):
+            iNode = p['MotionNode']
+            # Set uMesh to operating point values
+            uMesh.restoreValues()
+            # Perturb
+            uMesh.perturbNode(iNode, q)
+            #print('Translation\n',uMesh.TranslationDisp)
+            #print('Rotation\n',uMesh.Orientation)
+            # Calculate hydrodynamic loads at every nodes 
+            self.calcOutput(t=0, u=self.u, y=self.y, optsM=p)
+            # Pack loads
+            fh = self.y['Morison']['Mesh'].packLoads(FthenM=FthenM)
+            return fh
+
+        # --- Operating point and perturbation sizes
+        if q0 is None:
+            q0  = np.zeros(6)
+        if dq is None:
+            dq   = [0.01]*3 + [0.01]*3
+
+        # --- Save operating point value
+        uMesh.rigidBodyMotion(q=q0, qd=qd0, qdd=qdd0, RefPoint=RefPointMotion)
+        uMesh.backupValues()
+
+        # --- Linearization
+        optsM['MotionNode']=0
+        f0 = fh(q0, optsM)
+        K=[]
+        nNodes = uMesh.nNodes 
+
+        su=[]
+        for i in range(1,nNodes+1):
+            su+=['HDMorisonTxN{}_[m]'.format(i), 'HDMorisonTyN{}_[m]'.format(i), 'HDMorisonTzN{}_[m]'.format(i), 'HDMorisonRxN{}_[rad]'.format(i), 'HDMorisonRyN{}_[rad]'.format(i), 'HDMorisonRzN{}_[rad]'.format(i)]
+        sy = []
+        if FthenM:
+            for i in range(1,nNodes+1):
+                sy+=['HDMorisonLoadsFxN{}_[N]'.format(i) , 'HDMorisonLoadsFyN{}_[N]'.format(i), 'HDMorisonLoadsFzN{}_[N]'.format(i)]
+            for i in range(1,nNodes+1):
+                sy+=['HDMorisonLoadsMxN{}_[Nm]'.format(i), 'HDMorisonLoadsMyN{}_[Nm]'.format(i), 'HDMorisonLoadsMzN{}_[Nm]'.format(i)]
+        else:
+            for i in range(1,nNodes+1):
+                sy+=['HDMorisonLoadsFxN{}_[N]'.format(i) , 'HDMorisonLoadsFyN{}_[N]'.format(i), 'HDMorisonLoadsFzN{}_[N]'.format(i)]
+                sy+=['HDMorisonLoadsMxN{}_[Nm]'.format(i), 'HDMorisonLoadsMyN{}_[Nm]'.format(i), 'HDMorisonLoadsMzN{}_[Nm]'.format(i)]
+
+        D=np.zeros((6*nNodes,6*nNodes)) 
+        for iNode in range(uMesh.nNodes):
+            if np.mod(iNode,10)==0:
+                print('{:5d}/{:5d}'.format(iNode,nNodes))
+
+            optsM['MotionNode']=iNode
+            dfNode = numerical_jacobian(fh, (q0,), 0, dq  , optsM)
+            #print('')
+            #print('K for node{}\n'.format(iNode+1),dfNode)
+            D[:,iNode*6:iNode*6+6] = dfNode
+
+        D= pd.DataFrame(columns=su, index=sy, data=D)
+        return D
+
 
     def linearize_RigidMotion2Loads(self, q0=None, qd0=None, qdd0=None, dq=None, dqd=None, dqdd=None, 
             RefPointMotion=None, RefPointMapping=None,
-            moveWithOP=True,
+            RefPointMappingMotion='translate',
             optsM=None, saveFile=None,
             around=None
             ):
         """ 
         Linearize the outputs force at the reference point with respect to
            motions of the reference point (assuming rigid body motion of the structure)
            Return: M=df/dqdd C=df/dqd K=df/dq 
 
         -q0, qd0, qdd0: 6-array of rigid DOFs positions, velocities and accelerations at platform ref 
         -dq, dqd, dqdd: 6-array of perturbations around q0, qd0 and qdd0
 
-        - RefPoint: point used to defined rigid body motion, important parameter
+        - RefPointMotion: point used to defined rigid body motion, important parameter
+        - RefPointMapping: point used to defined rigid body mapping
+        - RefPointMappingMotion: how does the reference point move with q
+              'translate': the reference point for mapping translate with q
+              'none':      the reference point for mapping does not move
+              'follow_point': the reference point for mapping follow the whole motion (translation and rotation)
 
         -optsM: options for Morison Calculation
 
         NOTE: only Morison for now
         """
         from welib.system.linearization import numerical_jacobian
         print('Computing HydroDyn linearized model, about: ({:.3f} {:.3f} {:.3f} {:.3f} {:.3f} {:.3f})'.format(*q0))
@@ -231,28 +315,48 @@
         if RefPointMotion is None:
             RefPointMotion = uMesh.RefPoint
 
         if RefPointMapping is None:
             # TODO add options to map to a point in body coordinates (including rotations)
             RefPointMapping=np.array([0,0,0])
         print('- RefPoint for Motion : ',RefPointMotion)
-        print('- RefPoint for Mapping: ',RefPointMapping)
+        if RefPointMappingMotion=='translate':
+            print('- RefPoint for Mapping: ',RefPointMapping, '+ (q0, q1, q2) (followed in translation only)')
+
+        elif RefPointMappingMotion=='none':
+            print('- RefPoint for Mapping: ',RefPointMapping, '(fixed, not translating with q)')
+
+        elif RefPointMappingMotion=='follow_point':
+            from welib.yams.kinematics import rigidBodyMotion2Points_q6
+            print('- RefPoint for Mapping: ',RefPointMapping, '(followed in translation and rotation)')
+
+        else:
+            raise Exception()
 
         # --- Define a function that returns outputs
         def fh(q,qd,qdd,p=None):
             # Rigid body motion of the mesh
-            self.u['Morison']['Mesh'].rigidBodyMotion(q=q, qd=qd, qdd=qdd, RefPoint=RefPointMotion)
+            uMesh.rigidBodyMotion(q=q, qd=qd, qdd=qdd, RefPoint=RefPointMotion)
             # Calculate hydrodynamic loads at every nodes 
             self.calcOutput(t=0, u=self.u, y=self.y, optsM=p)
             # Compute integral loads (force&moment) at the reference point (translated but not rotated)
             fh=np.zeros(6)
-            if moveWithOP:
+            if RefPointMappingMotion=='translate':
                 MappingPoint = RefPointMapping + np.array([q[0],q[1],q[2]])
-            else:
+
+            elif RefPointMappingMotion=='follow_point':
+                qM,_,_, _ = rigidBodyMotion2Points_q6(RefPointMotion, RefPointMapping, q, rot='smallRot_OF')
+                MappingPoint=(RefPointMapping[0]+qM[0], RefPointMapping[1]+qM[1], RefPointMapping[2]+qM[2])
+
+            elif RefPointMappingMotion=='none':
                 MappingPoint = RefPointMapping
+
+            else:
+                raise Exception()
+            #print('Mapping Point: ', MappingPoint, q)
             fh[:3], fh[3:] = self.y['Morison']['Mesh'].mapLoadsToPoint(MappingPoint)
             return fh
 
         # --- Operating point and perturbation sizes
         if q0 is None:
             q0  = np.zeros(6)
         if qd0 is None:
```

### Comparing `welib-0.0.2/welib/fast/hydrodyn_driver.py` & `welib-1.0.0/welib/fast/hydrodyn_driver.py`

 * *Files 14% similar despite different names*

```diff
@@ -10,15 +10,15 @@
 from welib.weio.fast_output_file import writeDataFrame
 from welib.fast.hydrodyn import HydroDyn
 from welib.fast.fast_mesh import MeshStorage
 from welib.tools.clean_exceptions import *
 from welib.tools.tictoc import Timer
 
 
-def hydroSimLinFromOpenFAST(fstFilename, tMax=None, optsM=None, plot=True, json=True, out=True, png=True, verbose=False, base=None, MCKF=None, q0=None, fig=None):
+def hydroSimLinFromOpenFAST(fstFilename, tMax=None, optsM=None, plot=True, json=True, out=True, png=True, verbose=False, base=None, MCKF=None, q0=None, fig=None, motionRef='PRP', zRef=None):
     """ 
     """
     if base is None:
         base=fstFilename.replace('.fst','')
     if q0 is None:
         q0=np.zeros(6)
 
@@ -34,20 +34,33 @@
     if tMax is not None:
         dfOF=dfOF[dfOF['Time_[s]']<=tMax]
     if F0 is None:
         F0=np.zeros(6) # TODO mean value?
 
     # --- Relevant columns from OpenFAST outputs
     time  = dfOF['Time_[s]'].values
-    if 'PRPSurge_[m]' in dfOF.columns:
-        qCol   = ['PRPSurge_[m]'    ,'PRPSway_[m]'    ,'PRPHeave_[m]'   ,'PRPRoll_[rad]'    ,'PRPPitch_[rad]'   ,'PRPYaw_[rad]'     ]
-        qdCol  = ['PRPTVxi_[m/s]'   ,'PRPTVyi_[m/s]'  ,'PRPTVzi_[m/s]'  ,'PRPRVxi_[rad/s]'  ,'PRPRVyi_[rad/s]'  ,'PRPRVzi_[rad/s]'  ]
-        qddCol = ['PRPTAxi_[m/s^2]','PRPTAyi_[m/s^2]','PRPTAzi_[m/s^2]','PRPRAxi_[rad/s^2]','PRPRAyi_[rad/s^2]','PRPRAzi_[rad/s^2]']
+    if motionRef=='PRP':
+        # q is HDRefPoint
+        RefPoint=(0,0,0)
+        if 'PRPSurge_[m]' in dfOF.columns:
+            qCol   = ['PRPSurge_[m]'    ,'PRPSway_[m]'    ,'PRPHeave_[m]'   ,'PRPRoll_[rad]'    ,'PRPPitch_[rad]'   ,'PRPYaw_[rad]'     ]
+            qdCol  = ['PRPTVxi_[m/s]'   ,'PRPTVyi_[m/s]'  ,'PRPTVzi_[m/s]'  ,'PRPRVxi_[rad/s]'  ,'PRPRVyi_[rad/s]'  ,'PRPRVzi_[rad/s]'  ]
+            qddCol = ['PRPTAxi_[m/s^2]','PRPTAyi_[m/s^2]','PRPTAzi_[m/s^2]','PRPRAxi_[rad/s^2]','PRPRAyi_[rad/s^2]','PRPRAzi_[rad/s^2]']
+        else:
+            raise NotImplementedError()
+    elif motionRef=='EDRP':
+        # q is EDRefPoint
+        qCol   = ['Q_Sg_[m]'      ,'Q_Sw_[m]'      ,'Q_Hv_[m]'      ,'Q_R_[rad]'      ,'Q_P_[rad]'      ,'Q_Y_[rad]']
+        qdCol  = ['QD_Sg_[m/s]'   ,'QD_Sw_[m/s]'   ,'QD_Hv_[m/s]'   ,'QD_R_[rad/s]'   ,'QD_P_[rad/s]'   ,'QD_Y_[rad/s]']
+        qddCol = ['QD2_Sg_[m/s^2]','QD2_Sw_[m/s^2]','QD2_Hv_[m/s^2]','QD2_R_[rad/s^2]','QD2_P_[rad/s^2]','QD2_Y_[rad/s^2]']
+        if zRef is None:
+            raise Exception('When motionRef is not PRP, zRef needs to be provided') 
+        RefPoint=(0,0,zRef)
     else:
-        raise NotImplementedError()
+        raise NotImplementedError(motionRef)
 
     # --- Prepare time stepping
     fh = np.zeros((len(time), 6))
 
     # --- Time integration
     with Timer('Time integration'):
         for it, t in enumerate(time):
@@ -113,14 +126,15 @@
 
 def hydroSimFromOpenFAST(fstFilename, tMax=None, optsM=None, plot=True, json=True, out=True, png=True, verbose=False, base=None, fig=None, motionRef='PRP', zRef=None):
     """ 
     Compute hydrodynamics loads on a structure under rigid body motion based on an OpenFAST simulation
     fstFilename: OpenFAST or HydroDyn driver input file
     tMax: maximum time in time vector (to reduce the simulation length)
     """
+
     if base is None:
         base=fstFilename.replace('.fst','')
 
     # --- Initialize a python HydroDyn instance
     hd = HydroDyn(fstFilename)
     #hd.writeSummary(hdFilename.replace('.dat','.HD_python.sum'))
     umesh = hd.u['Morison']['Mesh']
@@ -132,51 +146,72 @@
     if tMax is not None:
         dfOF=dfOF[dfOF['Time_[s]']<=tMax]
 
 
     # --- Relevant columns from OpenFAST outputs
     time  = dfOF['Time_[s]'].values
     if motionRef=='PRP':
+        # q is HDRefPoint
         RefPoint=(0,0,0)
         if 'PRPSurge_[m]' in dfOF.columns:
             qCol   = ['PRPSurge_[m]'    ,'PRPSway_[m]'    ,'PRPHeave_[m]'   ,'PRPRoll_[rad]'    ,'PRPPitch_[rad]'   ,'PRPYaw_[rad]'     ]
             qdCol  = ['PRPTVxi_[m/s]'   ,'PRPTVyi_[m/s]'  ,'PRPTVzi_[m/s]'  ,'PRPRVxi_[rad/s]'  ,'PRPRVyi_[rad/s]'  ,'PRPRVzi_[rad/s]'  ]
             qddCol = [ 'PRPTAxi_[m/s^2]','PRPTAyi_[m/s^2]','PRPTAzi_[m/s^2]','PRPRAxi_[rad/s^2]','PRPRAyi_[rad/s^2]','PRPRAzi_[rad/s^2]']
         else:
             raise NotImplementedError()
     else:
+        from welib.yams.rotations import BodyXYZ_A, smallRot_OF, smallRot_A
+        from welib.yams.kinematics import rigidBodyMotion2Points_q6
+        # q is EDRefPoint
         qCol   = ['Q_Sg_[m]'      ,'Q_Sw_[m]'      ,'Q_Hv_[m]'      ,'Q_R_[rad]'      ,'Q_P_[rad]'      ,'Q_Y_[rad]']
         qdCol  = ['QD_Sg_[m/s]'   ,'QD_Sw_[m/s]'   ,'QD_Hv_[m/s]'   ,'QD_R_[rad/s]'   ,'QD_P_[rad/s]'   ,'QD_Y_[rad/s]']
         qddCol = ['QD2_Sg_[m/s^2]','QD2_Sw_[m/s^2]','QD2_Hv_[m/s^2]','QD2_R_[rad/s^2]','QD2_P_[rad/s^2]','QD2_Y_[rad/s^2]']
         if zRef is None:
             raise Exception('When motionRef is not PRP, zRef needs to be provided')
-        RefPoint=(0,0,zRef)
+        RefPoint    = np.array([0,0,zRef])
+        SourcePoint = np.array([0,0,0])
+        s_B0_b =SourcePoint-RefPoint # From RefPoint to "0" in body coordinates
 
     # --- Prepare time stepping
     fh = np.zeros((len(time), 6))
     msy = MeshStorage(ymesh, time) # Store mesh at each time step
 
     # --- Time integration
     with Timer('Time integration'):
         for it, t in enumerate(time):
-            # Reference point motion
+            # Reference point motion (ED or HD!)
             q  = dfOF[qCol].iloc[it].values
             qd = dfOF[qdCol].iloc[it].values
             qdd = dfOF[qddCol].iloc[it].values
             omega = (qd[3],qd[4],qd[5]) # ...
 
             # Rigid body motion of the mesh
             #umesh.rigidBodyMotion(u=(q[0],q[1],q[2]), theta=(q[3],q[4],q[5]), u_dot=(qd[0],qd[1],qd[2]), omega=omega, u_ddot=(qdd[0],qdd[1],qdd[2]), omega_dot = (qdd[3],qdd[4],qdd[5])  )
             umesh.rigidBodyMotion(q=q, qd=qd, qdd=qdd, RefPoint=RefPoint)
             # Calculate hydrodynamic loads at every nodes 
             hd.y=hd.calcOutput(t, u=hd.u, y=hd.y, optsM=optsM)
             # Store mesh
             msy.store(ymesh, it)
             # Compute integral loads (force&moment) at the reference point (translated but not rotated)
-            fh[it, :3], fh[it, 3:] = ymesh.mapLoadsToPoint((q[0],q[1],q[2]))
+            # Note: HydroF*I are translated, but not rotated
+            if motionRef=='PRP':
+                # q is HDRefPoint
+                fh[it, :3], fh[it, 3:] = ymesh.mapLoadsToPoint((q[0],q[1],q[2]))
+            elif motionRef=='EDRP':
+                # q is EDRefPoint
+                # --- Method 1
+                R_b2g  = smallRot_OF(q[3], q[4], q[5]).T
+                r_B0_g = R_b2g.dot(s_B0_b)
+                u0 = (r_B0_g-s_B0_b) # Displacement of PRP from its initial position
+                fh[it, :3], fh[it, 3:] = ymesh.mapLoadsToPoint((q[0]+u0[0],q[1]+u0[1],q[2]+u0[2]))
+                # --- Method 2 (identical)
+                #qS,_,_ = rigidBodyMotion2Points_q6(RefPoint, SourcePoint, q, rot='smallRot_OF')
+                #fh[it, :3], fh[it, 3:] = ymesh.mapLoadsToPoint((qS[0],qS[1],qS[2]))
+            else:
+                raise Exception()
             if verbose:
                 print('f_Hydro {:12.4f} {:16.3f}{:16.3f}{:16.3f}{:16.3f}{:16.3f}{:16.3f}'.format(t, *fh[it,:]))
 
     # --- Creating a dataframe for convenience
     lCols = ['HydroFxi_[N]','HydroFyi_[N]','HydroFzi_[N]','HydroMxi_[N-m]','HydroMyi_[N-m]','HydroMzi_[N-m]']
     dfPH = pd.DataFrame(data=np.column_stack((time,fh)), columns=['Time_[s]']+lCols)
```

### Comparing `welib-0.0.2/welib/fast/hydrodyn_morison.py` & `welib-1.0.0/welib/fast/hydrodyn_morison.py`

 * *Files 0% similar despite different names*

```diff
@@ -162,15 +162,15 @@
                         An = An + sgn* member['k']*np.pi*(member['RMG'][MemberEndIndx])**2     # area-weighted normal vector
                         Vn = Vn + sgn* member['k']*      (member['RMG'][MemberEndIndx])**3     # r^3-weighted normal vector used for mass
                         I_n=I_n + sgn* member['k']*np.pi*(member['RMG'][MemberEndIndx])**4     # r^4-weighted normal vector used for moments of inertia
                         if tMG == -999.0:
                             # All member nodes at this joint will have the same MG thickness and density, so only do this once
                             tMG =    member['tMG'][MemberEndIndx      ]
                             MGdens = member['MGdensity'][MemberEndIndx]
-                #Vn *= 2*np.pi/3   # Semisphere volume is Vn = 2/3 pi \sum (r_MG^3 k)   # TODO TODO TODO uncomment when OpenFAST fixed
+                Vn *= 2*np.pi/3   # Semisphere volume is Vn = 2/3 pi \sum (r_MG^3 k)   # TODO TODO TODO uncomment when OpenFAST fixed
                 p['An_End'][:,i] = An_drag 
                 Amag_drag =  An_drag.dot(An_drag)
                 Amag      =  An.dot(An)
                 if Amag_drag == 0:
                     p['DragConst_End'][i] =  0
                 else:
                     p['DragConst_End'][i] = n.data['JAxCd']*p['WtrDens'] / ( 4.* Amag_drag )
```

### Comparing `welib-0.0.2/welib/fast/hydrodyn_waves.py` & `welib-1.0.0/welib/fast/hydrodyn_waves.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/linearization.py` & `welib-1.0.0/welib/fast/linearization.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,11 @@
+""" 
+Tools for Campbell diagrams and MBC
 
+"""
 import os
 import pandas as pd
 import numpy as np
 from pandas import ExcelFile
 
 try:
     from . import fastlib
```

### Comparing `welib-0.0.2/welib/fast/linmodel.py` & `welib-1.0.0/welib/tools/eva.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,270 +1,331 @@
-##
+""" 
+Eigenvalue analyses (EVA) tools for:
+    - arbitrary systems:  system matrix (A)
+    - and mechnical systems: mass (M), stiffness (K) and damping (C) matrices
+
+Some definitions:
+
+    - zeta: damping ratio 
+
+    - delta/log_dec: logarithmic decrement
+
+    - xi: approximation of logarithmic decrement: xi = 2 pi zeta
+
+    - omega0  : natural frequency
+
+    - omega_d : damped frequency  omega_d = omega_0 sqrt(1-zeta^2)
+
+
+"""
+import pandas as pd    
 import numpy as np
-import copy
-import os
-import welib.weio as weio
-
-# --------------------------------------------------------------------------------}
-# --- Creating a TNSB model from a FAST model
-# --------------------------------------------------------------------------------{
-class FASTLinModel():
-    def __init__(self,ED_or_FST_file, StateFile=None, nShapes_twr=1, nShapes_bld=0, DEBUG=False):
-
-        # --- Input data from fst and ED file
-        ext=os.path.splitext(ED_or_FST_file)[1]
-        if ext.lower()=='.fst':
-            FST=weio.read(ED_or_FST_file)
-            rootdir = os.path.dirname(ED_or_FST_file)
-            EDfile = os.path.join(rootdir,FST['EDFile'].strip('"')).replace('\\','/')
-        else:
-            EDfile=ED_or_FST_file
-        self.ED= weio.read(EDfile)
-
-        # --- Loading linear model
-        if StateFile is not None:
-            self.A,self.B,self.C,self.D,self.M = loadLinStateMatModel(StateFile)
-        else:
-            raise NotImplementedError()
-        self.sX = self.A.columns
-
-        self.nGear = self.ED['GBRatio']
-        self.theta_tilt=-self.ED['ShftTilt']*np.pi/180 # NOTE: tilt has wrong orientation in FAST
-        # --- Initial conditions
-        omega_init = self.ED['RotSpeed']*2*np.pi/60 # rad/s
-        psi_init   = self.ED['Azimuth']*np.pi/180 # rad
-        FA_init    = self.ED['TTDspFA']
-        iPsi     = list(self.sX).index('psi_rot_[rad]')
-        nDOFMech = int(len(self.A)/2)
-        q_init   = np.zeros(2*nDOFMech) # x2, state space
-
-        if nShapes_twr>0:
-            q_init[0] = FA_init
-
-        q_init[iPsi]          = psi_init
-        q_init[nDOFMech+iPsi] = omega_init
-
-        self.q_init = q_init
-
-    def __repr__(self):
-        def pretty_PrintMat(M,fmt='{:11.3e}',fmt_int='    {:4d}   ',sindent='   '):
-            s=sindent
-            for iline,line in enumerate(M):
-                s+=''.join([(fmt.format(v) if int(v)!=v else fmt_int.format(int(v))) for v in line ])
-                s+='\n'+sindent
-            return s
-        s=''
-        s+='<FASTLinModel object>\n'
-        s+='Attributes:\n'
-        s+=' - A: State-State Matrix  \n'
-        s+=pretty_PrintMat(self.A.values)+'\n'
-        s+=' - B: State-Input Matrix  \n'
-        s+=pretty_PrintMat(self.B.values)+'\n'
-        s+=' - q_init: Initial conditions (state) \n'
-        s+=str(self.q_init)+'\n'
-        return s
-
-# --------------------------------------------------------------------------------}
-# --- Helper functions 
-# --------------------------------------------------------------------------------{
-def unit(s):
-    iu=s.rfind('[')
-    if iu>1:
-        return s[iu+1:].replace(']','')
+from scipy import linalg
+
+def polyeig(*A, sort=False, normQ=None):
+    """
+    Solve the polynomial eigenvalue problem:
+        (A0 + e A1 +...+  e**p Ap)x = 0
+
+    Return the eigenvectors [x_i] and eigenvalues [e_i] that are solutions.
+
+    Usage:
+        X,e = polyeig(A0,A1,..,Ap)
+
+    Most common usage, to solve a second order system: (K + C e + M e**2) x =0
+        X,e = polyeig(K,C,M)
+
+    """
+    if len(A)<=0:
+        raise Exception('Provide at least one matrix')
+    for Ai in A:
+        if Ai.shape[0] != Ai.shape[1]:
+            raise Exception('Matrices must be square')
+        if Ai.shape != A[0].shape:
+            raise Exception('All matrices must have the same shapes');
+
+    n = A[0].shape[0]
+    l = len(A)-1 
+    # Assemble matrices for generalized problem
+    C = np.block([
+        [np.zeros((n*(l-1),n)), np.eye(n*(l-1))],
+        [-np.column_stack( A[0:-1])]
+        ])
+    D = np.block([
+        [np.eye(n*(l-1)), np.zeros((n*(l-1), n))],
+        [np.zeros((n, n*(l-1))), A[-1]          ]
+        ]);
+    # Solve generalized eigenvalue problem
+    e, X = linalg.eig(C, D);
+    if np.all(np.isreal(e)):
+        e=np.real(e)
+    X=X[:n,:]
+
+    # Sort eigen values
+    if sort:
+        I = np.argsort(e)
+        X = X[:,I]
+        e = e[I]
+
+    # Scaling each mode by max
+    if normQ=='byMax':
+        X /= np.tile(np.max(np.abs(X),axis=0), (n,1))
+
+    return X, e
+
+
+def eig(K, M=None, freq_out=False, sort=True, normQ=None, discardIm=False, massScaling=True):
+    """ performs eigenvalue analysis and return same values as matlab 
+
+    returns:
+       Q     : matrix of column eigenvectors
+       Lambda: matrix where diagonal values are eigenvalues
+              frequency = np.sqrt(np.diag(Lambda))/(2*np.pi)
+         or
+    frequencies (if freq_out is True)
+    """
+    if M is not None:
+        D,Q = linalg.eig(K,M)
+        # --- rescaling using mass matrix to be consistent with Matlab
+        # TODO, this can be made smarter
+        # TODO this should be a normQ
+        if massScaling:
+            for j in range(M.shape[1]):
+                q_j = Q[:,j]
+                modalmass_j = np.dot(q_j.T,M).dot(q_j)
+                Q[:,j]= Q[:,j]/np.sqrt(modalmass_j)
+        Lambda=np.dot(Q.T,K).dot(Q)
     else:
-        return ''
-def no_unit(s):
-    s=s.replace('_[',' [')
-    iu=s.rfind(' [')
-    if iu>1:
-        return s[:iu]
+        D,Q = linalg.eig(K)
+        Lambda = np.diag(D)
+
+    # --- Sort
+    lambdaDiag=np.diag(Lambda)
+    if sort:
+        I = np.argsort(lambdaDiag)
+        Q          = Q[:,I]
+        lambdaDiag = lambdaDiag[I]
+    if freq_out:
+        Lambda = np.sqrt(lambdaDiag)/(2*np.pi) # frequencies [Hz]
     else:
-        return s
+        Lambda = np.diag(lambdaDiag) # enforcing purely diagonal
+
+    # --- Renormalize modes if users wants to
+    if normQ == 'byMax':
+        for j in range(Q.shape[1]):
+            q_j = Q[:,j]
+            iMax = np.argmax(np.abs(q_j))
+            scale = q_j[iMax] # not using abs to normalize to "1" and not "+/-1"
+            Q[:,j]= Q[:,j]/scale
+
+    # --- Sanitization, ensure real values
+    if discardIm:
+        Q_im    = np.imag(Q)
+        Q       = np.real(Q)
+        imm     = np.mean(np.abs(Q_im),axis = 0)
+        bb = imm>0
+        if sum(bb)>0:
+            W=list(np.where(bb)[0])
+            print('[WARN] Found {:d} complex eigenvectors at positions {}/{}'.format(sum(bb),W,Q.shape[0]))
+        Lambda = np.real(Lambda)
+
+    return Q,Lambda
 
-def matToSIunits(Mat, name='', verbose=False):
-    """ 
-    Scale a matrix (pandas dataframe) such that is has standard units
 
+def eigA(A, nq=None, nq1=None, fullEV=False, normQ=None, sort=True):
     """
-    # TODO columns
-    for irow,row in enumerate(Mat.index.values):
-        # Scaling based on units
-        u  = unit(row).lower()
-        nu = no_unit(row)
-        if u in['deg','deg/s','deg/s^2']:
-            if verbose:
-                print('Mat {} - scaling deg2rad   for row {}'.format(name,row))
-            Mat.iloc[irow,:] /=180/np.pi # deg 2 rad
-            Mat.index.values[irow]=Mat.index.values[irow].replace('rad','deg')
-        elif u=='rpm':
-            if verbose:
-                print('Mat {} - scaling rpm2rad/s for row {}'.format(name,row))
-            Mat.iloc[irow,:] /=60/(2*np.pi) # rpm 2 rad/s
-            Mat.index.values[irow]=nu+'_[rad/s]'
-        elif u=='knm':
-            if verbose:
-                print('Mat {} - scaling kNm to Nm for row {}'.format(name,row))
-            Mat.iloc[irow,:] /=1000 # to Nm
-            Mat.index.values[irow]=nu+'_[Nm]'
-    return Mat
-
-
-def subMat(df, rows=None, cols=None, check=True):
-    """ Extract relevant part from a dataframe, perform a safety check """
-    if rows is None:
-        rows=df.index
-    if cols is None:
-        cols=df.columns
-    if check:
-        missingRows = [l for l in rows if l not in df.index]
-        missingCols = [c for c in cols  if c not in df.columns]
-        if len(missingRows)>0:
-            raise Exception('The following rows are missing from outputs: {}'.format(missingRows))
-        if len(missingCols)>0:
-            raise Exception('The following columns are missing from inputs: {}'.format(missingCols))
-    return df[cols].loc[rows].copy()
-
-def matLabelNoUnit(df):
-    """ remove unit from index and columns of matrix"""
-    rows = [no_unit(row) for row in df.index.values]
-    cols = [no_unit(col) for col in df.columns.values]
-    df.index =  rows
-    df.columns = cols
-    return df
-
-def matLabelReplace(df, s1, s2):
-    """ remove unit from index and columns of matrix"""
-    rows = [row.replace(s1,s2) for row in df.index.values]
-    cols = [col.replace(s1,s2) for col in df.columns.values]
-    df.index =  rows
-    df.columns = cols
-    return df
-
-
-def matSimpleStateLabels(df, inplace=False):
-    RenameMap={
-    'PtfmSurge_[m]'       : 'x',
-    'PtfmSway_[m]'        : 'y',
-    'PtfmHeave_[m]'       : 'z',
-    'PtfmRoll_[rad]'      : 'phi_x',
-    'PtfmPitch_[rad]'     : 'phi_y',
-    'PtfmYaw_[rad]'       : 'phi_z',
-    'psi_rot_[rad]'       : 'psi',
-    'qt1FA_[m]'           : 'q_FA1',
-    'd_PtfmSurge_[m/s]'   : 'dx',
-    'd_PtfmSway_[m/s]'    : 'dy',
-    'd_PtfmHeave_[m/s]'   : 'dz',
-    'd_PtfmRoll_[rad/s]'  : 'dphi_x',
-    'd_PtfmPitch_[rad/s]' : 'dphi_y',
-    'd_PtfmYaw_[rad/s]'   : 'dphi_z',
-    'd_psi_rot_[rad/s]'   : 'dpsi',
-    'd_qt1FA_[m/s]'       : 'dq_FA1',
-    }
-    return df.rename(columns=RenameMap, index=RenameMap, inplace=inplace)
+    Perform eigenvalue analysis on a "state" matrix A
+    where states are assumed to be ordered as {q, q_dot, q1}
+    This order is only relevant for returning the eigenvectors.
+
+    INPUTS:
+     - A : square state matrix
+     - nq: number of second order states, optional, relevant if fullEV is False
+     - nq1: number of first order states, optional, relevant if fullEV is False
+     - fullEV: if True, the entire eigenvectors are returned, otherwise, 
+                only the part associated with q and q1 are returned
+     - normQ: 'byMax': normalize by maximum
+              None: do not normalize
+    OUPUTS:
+     - freq_d: damped frequencies [Hz]
+     - zeta  : damping ratios [-]
+     - Q     : column eigenvectors
+     - freq_0: natural frequencies [Hz]
+    """
+    n,m = A.shape
+
+    if m!=n:
+        raise Exception('Matrix needs to be squared')
+    if nq is None:
+        if nq1 is None:
+            nq1=0
+        nq = int((n-nq1)/2)
+    else:
+        nq1 = n-2*nq
+    if n!=2*nq+nq1 or nq1<0:
+        raise Exception('Number of 1st and second order dofs should match the matrix shape (n= 2*nq + nq1')
+    Q, Lambda = eig(A, sort=False)
+    v = np.diag(Lambda)
+
+    if not fullEV:
+        Q=np.delete(Q, slice(nq,2*nq), axis=0)
+
+    # Selecting eigenvalues with positive imaginary part (frequency)
+    Ipos = np.imag(v)>0
+    Q = Q[:,Ipos]
+    v = v[Ipos]
+
+    # Frequencies and damping based on compled eigenvalues
+    omega_0 = np.abs(v)              # natural cylic frequency [rad/s]
+    freq_d  = np.imag(v)/(2*np.pi)   # damped frequency [Hz]
+    zeta    = - np.real(v)/omega_0   # damping ratio
+    freq_0  = omega_0/(2*np.pi)      # natural frequency [Hz]
+
+    # Sorting
+    if sort:
+        I = np.argsort(freq_0)
+        freq_d = freq_d[I]
+        freq_0 = freq_0[I]
+        zeta   = zeta[I]
+        Q      = Q[:,I]
+
+    # Normalize Q
+    if normQ=='byMax':
+        for j in range(Q.shape[1]):
+            q_j = Q[:,j]
+            scale = np.max(np.abs(q_j))
+            Q[:,j]= Q[:,j]/scale
+    return freq_d, zeta, Q, freq_0 
+
 
 
-def loadLinStateMatModel(StateFile, ScaleUnits=True, Adapt=True, ExtraZeros=False, nameMap={'SvDGenTq_[kNm]':'Qgen_[kNm]'}, ):
+def eigMK(M, K, sort=True, normQ=None, discardIm=False, freq_out=True, massScaling=True):
     """ 
-    Load a pickle file contains A,B,C,D matrices either as sequence or dictionary.
-    Specific treatments are possible:
-       - ScaleUnits: convert to SI units deg->rad, rpm-> rad/s, kN->N
-       - Adapt: 
-       - Adapt: 
-       - nameMap: rename columns and indices
+    Eigenvalue analysis of a mechanical system
+    M, K: mass, and stiffness matrices respectively
 
-    If a "model" is given specific treatments can be done
-    
+    Should be equivalent to calling eig(K, M) in Matlab (NOTE: argument swap)
+    except that frequencies are returned instead of "Lambda"
+
+    OUTPUTS:
+      Q, freq_0 if freq_out
+      Q, Lambda otherwise
     """
-    import pickle
-    # --- Subfunctions
-    def load(filename):
-        with open(filename,'rb') as f:
-            dat=pickle.load(f)
-        return dat
-
-    # --- Load model
-    dat = load(StateFile)
-    if isinstance(dat,dict):
-        A=dat['A']
-        B=dat['B']
-        C=dat['C']
-        D=dat['D']
-        M=None
-        model =dat['model']
-    else:
-        model='TNSB'
-        if len(dat)==4:
-            M=None
-            (A,B,C,D) = dat
-        else:
-            (A,B,C,D,M) = dat
-
-    # --- Renaming
-    for S,Mat in zip(['A','B','C','D'],[A,B,C,D]):
-        for irow,row in enumerate(Mat.index.values):
-            # Changing names
-            if row=='SvDGenTq_[kNm]':
-                Mat.index.values[irow]='Qgen_[kNm]'
-                row='Qgen_[kNm]'
-
-
-
-    # --- Scale units
-    if ScaleUnits:
-        # Changing rows
-        for S,Mat in zip(['A','B','C','D'],[A,B,C,D]):
-            Mat = matToSIunits(Mat, name=S, verbose=True)
-    # --- ColMap
-    if nameMap is not None:
-        for S,Mat in zip(['A','B','C','D'],[A,B,C,D]):
-            Mat.rename(nameMap, axis='columns', inplace=True)
-            Mat.rename(nameMap, axis='index', inplace=True)
-
-    # --- Numerics, 0
-    for S,Mat in zip(['A','B','C','D'],[A,B,C,D]):
-        Mat[np.abs(Mat)<1e-14]=0
-
-
-    if model=='FNS' and A.shape[0]==6:
-        pass
-        #print(C)
-        #print(D)
-    elif model=='F1NS' and A.shape[0]==4:
-        pass
-    elif model=='F010000NS' and A.shape[0]==4:
-        pass
-    elif model=='F010010NS' and A.shape[0]==6:
-        pass
-    elif model=='F011010NS' and A.shape[0]==6:
-        pass
-
-    elif model=='FN' and A.shape[0]==4:
-        pass
-
-        
-    elif model=='TNSB' and A.shape[0]==4:
-        if Adapt==True:
-            A.iloc[3,:]=0 # No state influence of ddpsi ! <<<< Important
-            A.iloc[2,1]=0 # No psi influence of  ddqt
-            A.iloc[2,3]=0 # No psi_dot influence of ddqt
-            if ExtraZeros:
-                B.iloc[0,:]=0 # No thrust influence on dqt
-                B.iloc[1,:]=0 # No thrust influence on dpsi
-            B.iloc[:,2]=0 # no pitch influence on states ! <<<< Important since value may only be valid around a given pitch
-            if ExtraZeros:
-                B.iloc[2,1]=0 # No Qgen influence on qtdot
-                B.iloc[3,0]=0 # No thrust influence on psi
-                D.iloc[0,1]=0  # No Qgen influence on IMU
-            D.iloc[0,2]=0  # No pitch influences on IMU
+    return eig(K, M, sort=sort, normQ=normQ, discardIm=discardIm, freq_out=freq_out, massScaling=massScaling)
+
+
+def eigMCK(M, C, K, method='full_matrix', sort=True, normQ=None): 
+    """
+    Eigenvalue analysis of a mechanical system
+    M, C, K: mass, damping, and stiffness matrices respectively
+
+    NOTE: full_matrix, state_space and state_space_gen should return the same
+          when damping is present
+    """
+    if np.linalg.norm(C)<1e-14:
+        if method.lower() not in ['state_space', 'state_space_gen']:
+            # No damping
+            Q, freq_0 =  eigMK(M, K, sort=sort, freq_out=True, normQ=normQ)
+            freq_d = freq_0
+            zeta   = freq_0*0
+            return freq_d, zeta, Q, freq_0
+
+
+    n = M.shape[0] # Number of DOFs
+
+    if method.lower()=='diag_beta':
+        ## using K, M and damping assuming diagonal beta matrix (Rayleigh Damping)
+        Q, Lambda   = eig(K,M, sort=False) # provide scaled EV, important, no sorting here!
+        freq_0      = np.sqrt(np.diag(Lambda))/(2*np.pi)
+        betaMat     = np.dot(Q,C).dot(Q.T)
+        xi          = (np.diag(betaMat)*np.pi/(2*np.pi*freq_0))
+        xi[xi>2*np.pi] = np.NAN
+        zeta        = xi/(2*np.pi)
+        freq_d      = freq_0*np.sqrt(1-zeta**2)
+
+    elif method.lower()=='full_matrix':
+        ## Method 2 - Damping based on K, M and full D matrix
+        Q,v = polyeig(K,C,M, sort=sort, normQ=normQ)
+        #omega0 = np.abs(e)
+        zeta = - np.real(v) / np.abs(v)
+        freq_d = np.imag(v) / (2*np.pi)
+        # Keeping only positive frequencies
+        bValid = freq_d > 1e-08
+        freq_d = freq_d[bValid]
+        zeta   = zeta[bValid]
+        Q      = Q[:,bValid]
+        # logdec2 = 2*pi*dampratio_sorted./sqrt(1-dampratio_sorted.^2);
+
+    elif method.lower()=='state_space':
+        # See welib.system.statespace.StateMatrix
+        Minv = np.linalg.inv(M)
+        I = np.eye(n)
+        Z = np.zeros((n, n))
+        A = np.block([[np.zeros((n, n)), np.eye(n)],
+                      [ -Minv@K        , -Minv@C  ]])
+        return eigA(A, normQ=normQ, sort=sort)
+
+    elif method.lower()=='state_space_gen':
+        I = np.eye(n)
+        Z = np.zeros((n, n))
+        A = np.block([[Z, I],
+                      [-K, -C]])
+        B = np.block([[I, Z],
+                      [Z, M]])
+        # solve the generalized eigenvalue problem
+        D, Q = linalg.eig(A, B)
+        # Keeping every other states (assuming pairs..)
+        v = D[::2]
+        Q = Q[:n, ::2]
+
+        # calculate natural frequencies and damping
+        omega_0 = np.abs(v)              # natural cyclic frequency [rad/s]
+        freq_d  = np.imag(v)/(2*np.pi)   # damped frequency [Hz]
+        zeta    = - np.real(v)/omega_0   # damping ratio
 
-            C.iloc[3,:]=0 # No states influence pitch
-            C.iloc[2,3]=0 # No influence of psi on Qgen !<<< Important
     else:
-        raise NotImplementedError('Model {} shape {}'.format(model,A.shape))
+        raise NotImplementedError()
 
-    # ---
-    try:
-        D['Qgen_[Nm]']['Qgen_[Nm]']=1
-    except:
-        pass
+    # Sorting
+    if sort:
+        I = np.argsort(freq_d)
+        freq_d = freq_d[I]
+        zeta   = zeta[I]
+        Q      = Q[:,I]
+    # Undamped frequency 
+    freq_0 = freq_d / np.sqrt(1 - zeta**2)
+    #xi = 2 * np.pi * zeta # pseudo log-dec
+    return freq_d, zeta, Q, freq_0
+
+
+if __name__=='__main__':
+    np.set_printoptions(linewidth=300, precision=4)
+    nDOF   = 2
+    M      = np.zeros((nDOF,nDOF))
+    K      = np.zeros((nDOF,nDOF))
+    C      = np.zeros((nDOF,nDOF))
+    M[0,0] = 430000;
+    M[1,1] = 42000000;
+    C[0,0] = 7255;
+    C[1,1] = M[1,1]*0.001;
+    K[0,0] = 2700000.;
+    K[1,1] = 200000000.;
+
+    freq_d, zeta, Q, freq, xi = eigMCK(M,C,K)
+    print(freq_d)
+    print(Q)
+
+
+    #M = diag([3,0,0,0], [0, 1,0,0], [0,0,3,0],[0,0,0, 1])
+    M = np.diag([3,1,3,1])
+    C = np.array([[0.4 , 0 , -0.3 , 0] , [0 , 0  , 0 , 0] , [-0.3 , 0 , 0.5 , -0.2 ] , [ 0 , 0 , -0.2 , 0.2]])
+    K = np.array([[-7  , 2 , 4    , 0] , [2 , -4 , 2 , 0] , [4    , 2 , -9  , 3    ] , [ 0 , 0 , 3    , -3]])
+
+    X,e = polyeig(K,C,M)
+    print('X:\n',X)
+    print('e:\n',e)
+    # Test taht first eigenvector and valur satisfy eigenvalue problem:
+    s = e[0];
+    x = X[:,0];
+    res = (M*s**2 + C*s + K).dot(x) # residuals
+    assert(np.all(np.abs(res)<1e-12))
 
-    return A,B,C,D,M
```

### Comparing `welib-0.0.2/welib/fast/postpro.py` & `welib-1.0.0/welib/fast/postpro.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,122 +1,139 @@
 # --- For cmd.py
-from __future__ import division, print_function
 import os
 import pandas as pd
 import numpy as np
 import re
 
 # --- fast libraries
 import welib.weio as weio
 from welib.weio.fast_input_file import FASTInputFile
 from welib.weio.fast_output_file import FASTOutputFile
 from welib.weio.fast_input_deck import FASTInputDeck
-# from pyFAST.input_output.fast_input_file import FASTInputFile
-# from pyFAST.input_output.fast_output_file import FASTOutputFile
-# from pyFAST.input_output.fast_input_deck import FASTInputDeck
+
+from welib.fast.subdyn import SubDyn
+
 
 # --------------------------------------------------------------------------------}
 # --- Tools for IO 
 # --------------------------------------------------------------------------------{
+def getEDClass(class_or_filename):
+    """
+    Return ElastoDyn instance of FileCl
+    INPUT: either
+       - an instance of FileCl, as returned by reading the file, ED = weio.read(ED_filename)
+       - a filepath to a ElastoDyn input file
+       - a filepath to a main OpenFAST input file
+    """
+    if hasattr(class_or_filename,'startswith'): # if string
+        ED = FASTInputFile(class_or_filename)
+        if 'EDFile' in ED.keys(): # User provided a .fst file...
+            parentDir=os.path.dirname(class_or_filename)
+            EDfilename = os.path.join(parentDir, ED['EDFile'].replace('"',''))
+            ED = FASTInputFile(EDfilename)
+    else:
+        ED = class_or_filename
+    return ED
+
 def ED_BldStations(ED):
     """ Returns ElastoDyn Blade Station positions, useful to know where the outputs are.
     INPUTS:
        - ED: either:
            - a filename of a ElastoDyn input file
            - an instance of FileCl, as returned by reading the file, ED = weio.read(ED_filename)
 
     OUTUPTS:
         - bld_fract: fraction of the blade length were stations are defined
         - r_nodes: spanwise position from the rotor apex of the Blade stations
     """
-    if hasattr(ED,'startswith'): # if string
-        ED = FASTInputFile(ED)
+    ED = getEDClass(ED)
 
     nBldNodes    = ED['BldNodes']
     bld_fract    = np.arange(1./nBldNodes/2., 1, 1./nBldNodes)
     r_nodes      = bld_fract*(ED['TipRad']-ED['HubRad']) + ED['HubRad']
     return bld_fract, r_nodes
 
-def ED_TwrStations(ED):
+def ED_TwrStations(ED, addBase=True):
     """ Returns ElastoDyn Tower Station positions, useful to know where the outputs are.
     INPUTS:
        - ED: either:
            - a filename of a ElastoDyn input file
            - an instance of FileCl, as returned by reading the file, ED = weio.read(ED_filename)
 
     OUTPUTS:
         - r_fract: fraction of the towet length were stations are defined
         - h_nodes: height from the *ground* of the stations  (not from the Tower base)
     """
-    if hasattr(ED,'startswith'): # if string
-        ED = FASTInputFile(ED)
+    ED = getEDClass(ED)
 
     nTwrNodes = ED['TwrNodes']
     twr_fract    = np.arange(1./nTwrNodes/2., 1, 1./nTwrNodes)
-    h_nodes      = twr_fract*(ED['TowerHt']-ED['TowerBsHt']) + ED['TowerBsHt']
+    h_nodes      = twr_fract*(ED['TowerHt']-ED['TowerBsHt'])
+    if addBase:
+        h_nodes      += ED['TowerBsHt']
     return twr_fract, h_nodes
 
 def ED_BldGag(ED):
     """ Returns the radial position of ElastoDyn blade gages 
     INPUTS:
        - ED: either:
            - a filename of a ElastoDyn input file
            - an instance of FileCl, as returned by reading the file, ED = weio.read(ED_filename)
     OUTPUTS:
        - r_gag: The radial positions of the gages, given from the rotor apex
     """
-    if hasattr(ED,'startswith'): # if string
-        ED = FASTInputFile(ED)
+    ED = getEDClass(ED)
     _,r_nodes= ED_BldStations(ED)
     
     #     if ED.hasNodal:
     #         return r_nodes, None
     nOuts = ED['NBlGages']
     if nOuts<=0:
         return np.array([]), np.array([])
     if type(ED['BldGagNd']) is list:
         Inodes = np.asarray(ED['BldGagNd'])
     else:
         Inodes = np.array([ED['BldGagNd']])
     r_gag = r_nodes[ Inodes[:nOuts] -1]
     return r_gag, Inodes
 
-def ED_TwrGag(ED):
+def ED_TwrGag(ED, addBase=True):
     """ Returns the heights of ElastoDyn blade gages 
     INPUTS:
        - ED: either:
            - a filename of a ElastoDyn input file
            - an instance of FileCl, as returned by reading the file, ED = weio.read(ED_filename)
+       - addBase: if True, TowerBsHt is added to h_gag
     OUTPUTS:
        - h_gag: The heights of the gages, given from the ground height (tower base + TowerBsHt)
     """
-    if hasattr(ED,'startswith'): # if string
-        ED = FASTInputFile(ED)
-    _,h_nodes= ED_TwrStations(ED)
+    ED = getEDClass(ED)
+
+    _,h_nodes= ED_TwrStations(ED, addBase=addBase)
     nOuts = ED['NTwGages']
     if nOuts<=0:
-        return np.array([])
+        return np.array([]), None
     if type(ED['TwrGagNd']) is list:
         Inodes = np.asarray(ED['TwrGagNd'])
     else:
         Inodes = np.array([ED['TwrGagNd']])
     h_gag = h_nodes[ Inodes[:nOuts] -1]
-    return h_gag
+    return h_gag, Inodes
 
 
 def AD14_BldGag(AD):
     """ Returns the radial position of AeroDyn 14 blade gages (based on "print" in column 6)
     INPUTS:
        - AD: either:
            - a filename of a AeroDyn input file
            - an instance of FileCl, as returned by reading the file, AD = weio.read(AD_filename)
     OUTPUTS:
        - r_gag: The radial positions of the gages, given from the blade root
     """
-    if hasattr(ED,'startswith'): # if string
+    if hasattr(AD,'startswith'): # if string
         AD = FASTInputFile(AD)
 
     Nodes=AD['BldAeroNodes']  
     if Nodes.shape[1]==6:
        doPrint= np.array([ n.lower().find('p')==0  for n in Nodes[:,5]])
     else:
        doPrint=np.array([ True  for n in Nodes[:,0]])
@@ -153,39 +170,70 @@
     if chordOut:
         chord_gag = AD_bld['BldAeroNodes'][INodes-1,5]
         return r_gag,chord_gag
     else:
         return r_gag
 
 def BD_BldStations(BD, BDBld):
-    """ Returns BeamDyn Blade Station positions, useful to know where the outputs are.
+    """ Returns BeamDyn Blade Quadrature Points positions:
+        - Defines where BeamDyn outputs are provided.
+        - Used by BeamDyn for the Input Mesh  u%DistrLoad
+                          and the Output Mesh y%BldMotion
+    NOTE: This should match the quadrature points in the summary file of BeamDyn for a straight beam
+          This will NOT match the "Initial Nodes" reported  in the summary file.
     INPUTS:
        - BD: either:
-           - a filename of a ElastoDyn input file
+           - a filename of a BeamDyn input file
            - an instance of FileCl, as returned by reading the file, BD = weio.read(BD_filename)
-    OUTUPTS:
+       - BDBld: same as BD but for the BeamDyn blade file
+    OUTPUTS:
         - r_nodes: spanwise position from the balde root of the Blade stations
     """
+    GAUSS_QUADRATURE = 1
+    TRAP_QUADRATURE  = 2
     if hasattr(BD,'startswith'): # if string
         BD = FASTInputFile(BD)
-    if hasattr(BD,'startswith'): # if string
+    if hasattr(BDBld,'startswith'): # if string
         BDBld = FASTInputFile(BDBld)
         #  BD['BldFile'].replace('"',''))
 
+
+    # --- Extract relevant info from BD files
     z_kp = BD['MemberGeom'][:,2]
     R    = z_kp[-1]-z_kp[0]
-    r    = BDBld['BeamProperties']['span']*R
+
+    nStations      = BDBld['station_total']
+    rStations      = BDBld['BeamProperties']['span']*R
     quad = BD['quadrature']
-    ref  = BD['refine']
-    if 'default' in str(ref).lower():
-        ref = 1
-    dr   = np.diff(r)/ref
-    rmid = np.concatenate( [r[:-1]+dr*(iref+1) for iref in np.arange(ref-1)  ])
-    r    = np.concatenate( (r, rmid))
-    r    = np.unique(np.sort(r))
+
+    refine         = BD['refine']
+    nodes_per_elem = BD['order_elem'] + 1
+    if 'default' in str(refine).lower():
+        refine = 1
+
+    # --- Distribution of points
+    if quad==GAUSS_QUADRATURE:
+        # See BD_GaussPointWeight
+        #  Number of Gauss points
+        nqp = nodes_per_elem #- 1
+        # qp_indx_offset = 1 ! we skip the first node on the input mesh (AD needs values at the end points, but BD doesn't use them)
+        x, _ = np.polynomial.legendre.leggauss(nqp)
+        r= R*(1+x)/2
+
+    elif quad==TRAP_QUADRATURE:
+        # See BD_TrapezoidalPointWeight
+        nqp = (nStations - 1)*refine + 1
+        # qp_indx_offset = 0
+        # BldMotionNodeLoc = BD_MESH_QP ! we want to output y%BldMotion at the blade input property stations, and this will be a short-cut       
+        dr   = np.diff(rStations)/refine
+        rmid = np.concatenate( [rStations[:-1]+dr*(iref+1) for iref in np.arange(refine-1)  ])
+        r    = np.concatenate( (rStations, rmid))
+        r    = np.unique(np.sort(r))
+    else:
+        raise NotImplementedError('Only Gauss and Trap quadrature implemented')
     return r
 
 def BD_BldGag(BD):
     """ Returns the radial position of BeamDyn blade gages 
     INPUTS:
        - BD: either:
            - a filename of a BeamDyn input file
@@ -205,14 +253,26 @@
         Inodes = np.asarray(BD['OutNd'])
     else:
         Inodes = np.array([BD['OutNd']])
     r_gag = r_nodes[ Inodes[:nOuts] -1]
     return r_gag, Inodes, r_nodes
 
 # 
+def SD_MembersNodes(SD):
+    sd = SubDyn(SD)
+    return sd.pointsMN
+
+def SD_MembersJoints(SD):
+    sd = SubDyn(SD)
+    return sd.pointsMJ
+
+def SD_MembersGages(SD):
+    sd = SubDyn(SD)
+    return sd.pointsMNout
+
 # 
 # 1, 7, 14, 21, 30, 36, 43, 52, 58 BldGagNd List of blade nodes that have strain gages [1 to BldNodes] (-) [unused if NBlGages=0]
 
 # --------------------------------------------------------------------------------}
 # --- Helper functions for radial data  
 # --------------------------------------------------------------------------------{
 def _HarmonizeSpanwiseData(Name, Columns, vr, R, IR=None) :
@@ -267,15 +327,15 @@
         dfRad['Node_[#]']=IR[:nrMax]
     dfRad['i_[#]']=ids+1
     if not bFakeVr:
         dfRad['r_[m]'] = r
 
     return dfRad,  nrMax, ValidRow
 
-def insert_radial_columns(df, vr=None, R=None, IR=None):
+def insert_spanwise_columns(df, vr=None, R=None, IR=None, sspan='r', sspan_bar='r/R'):
     """
     Add some columns to the radial data
     df: dataframe
     """
     if df is None:
         return df
     if df.shape[1]==0:
@@ -288,21 +348,21 @@
         df.insert(0, 'i/n_[-]', vr_bar)
     else:
         vr_bar=vr/R
         if (nrMax)<=len(vr_bar):
             vr_bar=vr_bar[:nrMax]
         elif (nrMax)>len(vr_bar):
             raise Exception('Inconsitent length between radial stations ({:d}) and max index present in output chanels ({:d})'.format(len(vr_bar),nrMax))
-        df.insert(0, 'r/R_[-]', vr_bar)
+        df.insert(0, sspan_bar+'_[-]', vr_bar)
 
     if IR is not None:
         df['Node_[#]']=IR[:nrMax]
     df['i_[#]']=ids+1
     if vr is not None:
-        df['r_[m]'] = vr[:nrMax]
+        df[sspan+'_[m]'] = vr[:nrMax]
     return df
 
 def find_matching_columns(Cols, PatternMap):
     ColsInfo=[]
     nrMax=0
     for colpattern,colmap in PatternMap.items():
         # Extracting columns matching pattern
@@ -539,14 +599,43 @@
         EDSpanMap[r'^Spn(\d)FLy'+sB+r'_\[kN\]'   ]=SB+'FLy_[kN]'
         EDSpanMap[r'^Spn(\d)FLz'+sB+r'_\[kN\]'   ]=SB+'FLz_[kN]'
         EDSpanMap[r'^Spn(\d)MLy'+sB+r'_\[kN-m\]' ]=SB+'MLx_[kN-m]'
         EDSpanMap[r'^Spn(\d)MLx'+sB+r'_\[kN-m\]' ]=SB+'MLy_[kN-m]'  
         EDSpanMap[r'^Spn(\d)MLz'+sB+r'_\[kN-m\]' ]=SB+'MLz_[kN-m]'
     return find_matching_columns(Cols, EDSpanMap)
 
+def spanwiseColEDTwr(Cols):
+    """ Return column info, available columns and indices that contain ED spanwise data"""
+    EDSpanMap=dict()
+    # All Outs
+    EDSpanMap[r'^TwHt(\d*)ALxt_\[m/s^2\]'] = 'ALxt_[m/s^2]'
+    EDSpanMap[r'^TwHt(\d*)ALyt_\[m/s^2\]'] = 'ALyt_[m/s^2]'
+    EDSpanMap[r'^TwHt(\d*)ALzt_\[m/s^2\]'] = 'ALzt_[m/s^2]' 
+    EDSpanMap[r'^TwHt(\d*)TDxt_\[m\]'    ] = 'TDxt_[m]'
+    EDSpanMap[r'^TwHt(\d*)TDyt_\[m\]'    ] = 'TDyt_[m]'
+    EDSpanMap[r'^TwHt(\d*)TDzt_\[m\]'    ] = 'TDzt_[m]' 
+    EDSpanMap[r'^TwHt(\d*)RDxt_\[deg\]'  ] = 'RDxt_[deg]'
+    EDSpanMap[r'^TwHt(\d*)RDyt_\[deg\]'  ] = 'RDyt_[deg]'
+    EDSpanMap[r'^TwHt(\d*)RDzt_\[deg\]'  ] = 'RDzt_[deg]' 
+    EDSpanMap[r'^TwHt(\d*)TPxi_\[m\]'    ] = 'TPxi_[m]'
+    EDSpanMap[r'^TwHt(\d*)TPyi_\[m\]'    ] = 'TPyi_[m]'
+    EDSpanMap[r'^TwHt(\d*)TPzi_\[m\]'    ] = 'TPzi_[m]' 
+    EDSpanMap[r'^TwHt(\d*)RPxi_\[deg\]'  ] = 'RPxi_[deg]'
+    EDSpanMap[r'^TwHt(\d*)RPyi_\[deg\]'  ] = 'RPyi_[deg]'
+    EDSpanMap[r'^TwHt(\d*)RPzi_\[deg\]'  ] = 'RPzi_[deg]' 
+    EDSpanMap[r'^TwHt(\d*)FLxt_\[kN\]'   ] = 'FLxt_[kN]'
+    EDSpanMap[r'^TwHt(\d*)FLyt_\[kN\]'   ] = 'FLyt_[kN]'
+    EDSpanMap[r'^TwHt(\d*)FLzt_\[kN\]'   ] = 'FLzt_[kN]' 
+    EDSpanMap[r'^TwHt(\d*)MLxt_\[kN-m\]' ] = 'MLxt_[kN-m]'
+    EDSpanMap[r'^TwHt(\d*)MLyt_\[kN-m\]' ] = 'MLyt_[kN-m]'
+    EDSpanMap[r'^TwHt(\d*)MLzt_\[kN-m\]' ] = 'MLzt_[kN-m]'
+    return find_matching_columns(Cols, EDSpanMap)
+
+
+
 def spanwiseColAD(Cols):
     """ Return column info, available columns and indices that contain AD spanwise data"""
     ADSpanMap=dict()
     for sB in ['B1','B2','B3']:
         ADSpanMap['^[A]*'+sB+r'N(\d*)Alpha_\[deg\]']=sB+'Alpha_[deg]'
         ADSpanMap['^[A]*'+sB+r'N(\d*)AOA_\[deg\]'  ]=sB+'Alpha_[deg]' # DBGOuts
         ADSpanMap['^[A]*'+sB+r'N(\d*)AxInd_\[-\]'  ]=sB+'AxInd_[-]'  
@@ -647,38 +736,57 @@
             pass
     return dfRad
 
 
 
 def spanwisePostPro(FST_In=None,avgMethod='constantwindow',avgParam=5,out_ext='.outb',df=None):
     """
-    Postprocess FAST radial data. Average the time series, return a dataframe nr x nColumns
+    Postprocess FAST radial data. 
+    if avgMethod is not None: Average the time series, return a dataframe nr x nColumns
 
     INPUTS:
         - FST_IN: Fast .fst input file
         - avgMethod='periods', avgParam=2:  average over 2 last periods, Needs Azimuth sensors!!!
         - avgMethod='constantwindow', avgParam=5:  average over 5s of simulation
         - postprofile: outputfile to write radial data
     """
     # --- Opens Fast output  and performs averaging
     if df is None:
-        df = FASTOutputFile(FST_In.replace('.fst',out_ext).replace('.dvr',out_ext)).toDataFrame()
+        filename =FST_In.replace('.fst',out_ext).replace('.dvr',out_ext)
+        df = FASTOutputFile(filename).toDataFrame()
         returnDF=True
     else:
+        filename=''
         returnDF=False
     # NOTE: spanwise script doest not support duplicate columns
     df = df.loc[:,~df.columns.duplicated()]
-    dfAvg = averageDF(df,avgMethod=avgMethod ,avgParam=avgParam) # NOTE: average 5 last seconds
+    if avgMethod is not None:
+        dfAvg = averageDF(df,avgMethod=avgMethod ,avgParam=avgParam, filename=filename) # NOTE: average 5 last seconds
+    else:
+        dfAvg=df
 
     # --- Extract info (e.g. radial positions) from Fast input file
     # We don't have a .fst input file, so we'll rely on some default values for "r"
     rho         = 1.225
     chord       = None
     # --- Extract radial positions of output channels
-    r_AD, r_ED, r_BD, IR_AD, IR_ED, IR_BD, R, r_hub, fst = FASTRadialOutputs(FST_In, OutputCols=df.columns.values)
+    d = FASTSpanwiseOutputs(FST_In, OutputCols=df.columns.values)
+    r_AD      = d['r_AD']
+    r_ED_bld  = d['r_ED_bld']
+    r_ED_twr  = d['r_ED_twr']
+    r_BD      = d['r_BD']
+    IR_AD     = d['IR_AD']
+    IR_ED_bld = d['IR_ED_bld']
+    IR_ED_twr = d['IR_ED_twr']
+    IR_BD     = d['IR_BD']
+    TwrLen    = d['TwrLen']
+    R         = d['R']
+    r_hub     = d['r_hub']
+    fst       = d['fst']
+
     if R is None: 
         R=1
     try:
         chord  = fst.AD.Bld1['BldAeroNodes'][:,5] # Full span
     except:
         pass
     try:
@@ -690,51 +798,81 @@
             pass
     #print('r_AD:', r_AD)
     #print('r_ED:', r_ED)
     #print('r_BD:', r_BD)
     #print('I_AD:', IR_AD)
     #print('I_ED:', IR_ED)
     #print('I_BD:', IR_BD)
+    out = {}
+    if returnDF:
+        out['df']    = df
+        out['dfAvg'] = dfAvg
     # --- Extract radial data and export to csv if needed
-    dfRad_AD    = None
-    dfRad_ED    = None
-    dfRad_BD    = None
     Cols=dfAvg.columns.values
     # --- AD
     ColsInfoAD, nrMaxAD = spanwiseColAD(Cols)
     dfRad_AD            = extract_spanwise_data(ColsInfoAD, nrMaxAD, df=None, ts=dfAvg.iloc[0])
     dfRad_AD            = insert_extra_columns_AD(dfRad_AD, dfAvg.iloc[0], vr=r_AD, rho=rho, R=R, nB=3, chord=chord)
-    dfRad_AD            = insert_radial_columns(dfRad_AD, r_AD, R=R, IR=IR_AD)
-    # --- ED
+    dfRad_AD            = insert_spanwise_columns(dfRad_AD, r_AD, R=R, IR=IR_AD)
+    out['AD'] = dfRad_AD
+    # --- ED Bld
     ColsInfoED, nrMaxED = spanwiseColED(Cols)
     dfRad_ED            = extract_spanwise_data(ColsInfoED, nrMaxED, df=None, ts=dfAvg.iloc[0])
-    dfRad_ED            = insert_radial_columns(dfRad_ED, r_ED, R=R, IR=IR_ED)
+    dfRad_ED            = insert_spanwise_columns(dfRad_ED, r_ED_bld, R=R, IR=IR_ED_bld)
+    out['ED_bld'] = dfRad_ED
+    # --- ED Twr
+    ColsInfoED, nrMaxEDt = spanwiseColEDTwr(Cols)
+    dfRad_EDt           = extract_spanwise_data(ColsInfoED, nrMaxEDt, df=None, ts=dfAvg.iloc[0])
+    dfRad_EDt2          = insert_spanwise_columns(dfRad_EDt, r_ED_twr, R=TwrLen, IR=IR_ED_twr, sspan='H',sspan_bar='H/L')
+    # TODO we could insert TwrBs and TwrTp quantities here...
+    out['ED_twr'] = dfRad_EDt
     # --- BD
     ColsInfoBD, nrMaxBD = spanwiseColBD(Cols)
     dfRad_BD            = extract_spanwise_data(ColsInfoBD, nrMaxBD, df=None, ts=dfAvg.iloc[0])
-    dfRad_BD            = insert_radial_columns(dfRad_BD, r_BD, R=R, IR=IR_BD)
-    if returnDF:
-        return dfRad_ED , dfRad_AD, dfRad_BD, df
+    dfRad_BD            = insert_spanwise_columns(dfRad_BD, r_BD, R=R, IR=IR_BD)
+    out['BD'] = dfRad_BD
+    # --- SubDyn
+    if fst.SD is not None:
+        sd = SubDyn(fst.SD)
+        MN = sd.pointsMN
+        MNout, MJout = sd.memberPostPro(dfAvg)
+        out['SD_MembersOut'] = MNout
+        out['SD_JointsOut'] = MJout
     else:
-        return dfRad_ED , dfRad_AD, dfRad_BD
+        out['SD_MembersOut'] = None
+        out['SD_JointsOut'] = None
 
+    # Combine all into a dictionary
+    return out
 
 
 def spanwisePostProRows(df, FST_In=None):
     """ 
     Returns a 3D matrix: n x nSpan x nColumn where df is of size n x mColumn
 
     NOTE: this is really not optimal. Spanwise columns should be extracted only once..
     """
     # --- Extract info (e.g. radial positions) from Fast input file
     # We don't have a .fst input file, so we'll rely on some default values for "r"
     rho         = 1.225
     chord       = None
     # --- Extract radial positions of output channels
-    r_AD, r_ED, r_BD, IR_AD, IR_ED, IR_BD, R, r_hub, fst = FASTRadialOutputs(FST_In, OutputCols=df.columns.values)
+    d = FASTSpanwiseOutputs(FST_In, OutputCols=df.columns.values)
+    r_AD      = d['r_AD']
+    r_ED_bld  = d['r_ED_bld']
+    r_ED_twr  = d['r_ED_twr']
+    r_BD      = d['r_BD']
+    IR_AD     = d['IR_AD']
+    IR_ED_bld = d['IR_ED_bld']
+    IR_ED_twr = d['IR_ED_twr']
+    IR_BD     = d['IR_BD']
+    TwrLen    = d['TwrLen']
+    R         = d['R']
+    r_hub     = d['r_hub']
+    fst       = d['fst']
     #print('r_AD:', r_AD)
     #print('r_ED:', r_ED)
     #print('r_BD:', r_BD)
     if R is None: 
         R=1
     try:
         chord  = fst.AD.Bld1['BldAeroNodes'][:,5] # Full span
@@ -765,54 +903,58 @@
         ColsInfoED, nrMaxED = spanwiseColED(Cols)
     if r_BD is not None:
         ColsInfoBD, nrMaxBD = spanwiseColBD(Cols)
     for i,val in enumerate(v):
         if r_AD is not None:
             dfRad_AD = extract_spanwise_data(ColsInfoAD, nrMaxAD, df=None, ts=df.iloc[i])
             dfRad_AD = insert_extra_columns_AD(dfRad_AD, df.iloc[i], vr=r_AD, rho=rho, R=R, nB=3, chord=chord)
-            dfRad_AD = insert_radial_columns(dfRad_AD, r_AD, R=R, IR=IR_AD)
+            dfRad_AD = insert_spanwise_columns(dfRad_AD, r_AD, R=R, IR=IR_AD)
             if i==0:
                 M_AD = np.zeros((len(v), len(dfRad_AD), len(dfRad_AD.columns)))
                 Col_AD=dfRad_AD.columns.values
             M_AD[i, :, : ] = dfRad_AD.values
         if r_ED is not None and len(r_ED)>0:
             dfRad_ED = extract_spanwise_data(ColsInfoED, nrMaxED, df=None, ts=df.iloc[i])
-            dfRad_ED = insert_radial_columns(dfRad_ED, r_ED, R=R, IR=IR_ED)
+            dfRad_ED = insert_spanwise_columns(dfRad_ED, r_ED, R=R, IR=IR_ED)
             if i==0:
                 M_ED = np.zeros((len(v), len(dfRad_ED), len(dfRad_ED.columns)))
                 Col_ED=dfRad_ED.columns.values
             M_ED[i, :, : ] = dfRad_ED.values
         if r_BD is not None and len(r_BD)>0:
             dfRad_BD = extract_spanwise_data(ColsInfoBD, nrMaxBD, df=None, ts=df.iloc[i])
-            dfRad_BD = insert_radial_columns(dfRad_BD, r_BD, R=R, IR=IR_BD)
+            dfRad_BD = insert_spanwise_columns(dfRad_BD, r_BD, R=R, IR=IR_BD)
             if i==0:
                 M_BD = np.zeros((len(v), len(dfRad_BD), len(dfRad_BD.columns)))
                 Col_BD=dfRad_BD.columns.values
             M_BD[i, :, : ] = dfRad_BD.values
     return M_AD, Col_AD, M_ED, Col_ED, M_BD, Col_BD
 
 
-def FASTRadialOutputs(FST_In, OutputCols=None):
-    """ Returns radial positions where FAST has outputs
+def FASTSpanwiseOutputs(FST_In, OutputCols=None, verbose=False):
+    """ Returns spanwise positions where OpenFAST has outputs
     INPUTS:
-       FST_In: fast input file (.fst)
+      - FST_In: fast input file (.fst)
     OUTPUTS:
-       r_AD: radial positions of FAST Outputs from the rotor center
+       dictionary with fields:
+         - r_AD: radial positions of FAST Outputs from the rotor center
     """
     R           = None
+    TwrLen      = None
     r_hub =0
     r_AD        = None 
-    r_ED        = None
+    r_ED_bld    = None
+    r_ED_twr    = None
     r_BD        = None
-    IR_ED       = None
+    IR_ED_bld   = None
+    IR_ED_twr   = None
     IR_AD       = None
     IR_BD       = None
     fst=None
     if FST_In is not None:
-        fst = FASTInputDeck(FST_In, readlist=['AD','ADbld','ED','BD','BDbld'])
+        fst = FASTInputDeck(FST_In, readlist=['AD','ADbld','ED','BD','BDbld','SD'])
         # NOTE: all this below should be in FASTInputDeck
         if fst.version == 'F7':
             # --- FAST7
             if  not hasattr(fst,'AD'):
                 raise Exception('The AeroDyn file couldn''t be found or read, from main file: '+FST_In)
             r_AD,IR_AD = AD14_BldGag(fst.AD)
             R   = fst.fst['TipRad']
@@ -829,38 +971,44 @@
                 # AeroDyn driver...
                 if 'HubRad(1)' in fst.fst.keys():
                     r_hub       = fst.fst['HubRad(1)']
                 else:
                     r_hub       = fst.fst['BldHubRad_bl(1_1)']
 
             elif  not hasattr(fst,'ED'):
-                print('[WARN] The Elastodyn file couldn''t be found or read, from main file: '+FST_In)
+                if verbose:
+                    print('[WARN] The Elastodyn file couldn''t be found or read, from main file: '+FST_In)
                 #raise Exception('The Elastodyn file couldn''t be found or read, from main file: '+FST_In)
             else:
                 R           = fst.ED['TipRad']
                 r_hub       = fst.ED['HubRad']
                 if fst.ED.hasNodal:
-                    _, r_ED = ED_BldStations(fst.ED)
-                    IR_ED =None
+                    _, r_ED_bld = ED_BldStations(fst.ED)
+                    IR_ED_bld =None
                 else:
-                    r_ED, IR_ED = ED_BldGag(fst.ED)
+                    r_ED_bld, IR_ED_bld = ED_BldGag(fst.ED)
+
+                # No nodal output for elastodyn tower yet
+                TwrLen = fst.ED['TowerHt'] -fst.ED['TowerBsHt']
+                r_ED_twr, IR_ED_twr = ED_TwrGag(fst.ED)
 
             # --- BeamDyn
             if  fst.BD is not None:
                 if R is None:
                     R = r_BD_All[-1] # just in case ED file missing
                 if fst.BD.hasNodal:
                     r_BD = BD_BldStations(fst.BD, fst.BDbld)
                 else:
                     r_BD, IR_BD, r_BD_All = BD_BldGag(fst.BD)
                 r_BD= r_BD+r_hub
 
             # --- AeroDyn
             if  fst.AD is None:
-                print('[WARN] The AeroDyn file couldn''t be found or read, from main file: '+FST_In)
+                if verbose:
+                    print('[WARN] The AeroDyn file couldn''t be found or read, from main file: '+FST_In)
                 #raise Exception('The AeroDyn file couldn''t be found or read, from main file: '+FST_In)
             else:
                 if fst.ADversion == 'AD15':
                     if  fst.AD.Bld1 is None:
                         raise Exception('The AeroDyn blade file couldn''t be found or read, from main file: '+FST_In)
                     
                     if 'B1N001Cl_[-]' in OutputCols or np.any(np.char.find(list(OutputCols),'AB1N')==0):
@@ -877,15 +1025,21 @@
                         R = fst.AD.Bld1['BldAeroNodes'][-1,0]
 
                 elif fst.ADversion == 'AD14':
                     r_AD,IR_AD = AD14_BldGag(fst.AD)
 
                 else:
                     raise Exception('AeroDyn version unknown')
-    return r_AD, r_ED, r_BD, IR_AD, IR_ED, IR_BD, R, r_hub, fst
+    # Put everything into a dictionary for convenience
+    outs = {'r_AD':r_AD, 'IR_AD':IR_AD, 'r_ED_bld':r_ED_bld, 'IR_ED_bld':IR_ED_bld, 'r_ED_twr':r_ED_twr, 'IR_ED_twr':IR_ED_twr, 'r_BD':r_BD, 'IR_BD':IR_BD}
+    outs['R']     = R
+    outs['TwrLen']= TwrLen
+    outs['r_hub'] = r_hub
+    outs['fst']   = fst
+    return outs # r_AD, r_ED, r_BD, IR_AD, IR_ED, IR_BD, R, r_hub, fst
 
 
 
 def addToOutlist(OutList, Signals):
     if not isinstance(Signals,list):
         raise Exception('Signals must be a list')
     for s in Signals:
@@ -897,24 +1051,29 @@
 
 
 
 # --------------------------------------------------------------------------------}
 # --- Generic df 
 # --------------------------------------------------------------------------------{
 def remap_df(df, ColMap, bColKeepNewOnly=False, inPlace=False, dataDict=None, verbose=False):
-    """ Add/rename columns of a dataframe, potentially perform operations between columns
+    """ 
+    NOTE: see welib.tools.pandalib
+
+    Add/rename columns of a dataframe, potentially perform operations between columns
 
-    dataDict: dicitonary of data to be made available as "variable" in the column mapping
+    dataDict: dictionary of data to be made available as "variable" in the column mapping
+         'key' (new) : value (old)
 
     Example:
 
         ColumnMap={
           'WS_[m/s]'         : '{Wind1VelX_[m/s]}'             , # create a new column from existing one
           'RtTSR_[-]'        : '{RtTSR_[-]} * 2  +  {RtAeroCt_[-]}'    , # change value of column
           'RotSpeed_[rad/s]' : '{RotSpeed_[rpm]} * 2*np.pi/60 ', # new column [rpm] -> [rad/s]
+          'q_p' :  ['Q_P_[rad]', '{PtfmSurge_[deg]}*np.pi/180']  # List of possible matches
         }
         # Read
         df = weio.read('FASTOutBin.outb').toDataFrame()
         # Change columns based on formulae, potentially adding new columns
         df = fastlib.remap_df(df, ColumnMap, inplace=True)
 
     """
@@ -928,41 +1087,55 @@
         df=df.copy()
     ColMapMiss=[]
     ColNew=[]
     RenameMap=dict()
     # Loop for expressions
     for k0,v in ColMap.items():
         k=k0.strip()
-        v=v.strip()
-        if v.find('{')>=0:
-            search_results = re.finditer(r'\{.*?\}', v)
-            expr=v
-            if verbose:
-                print('Attempt to insert column {:15s} with expr {}'.format(k,v))
-            # For more advanced operations, we use an eval
-            bFail=False
-            for item in search_results:
-                col=item.group(0)[1:-1]
-                if col not in df.columns:
-                    ColMapMiss.append(col)
-                    bFail=True
-                expr=expr.replace(item.group(0),'df[\''+col+'\']')
-            #print(k0, '=', expr)
-            if not bFail:
-                df[k]=eval(expr)
-                ColNew.append(k)
-            else:
-                print('[WARN] Column not present in dataframe, cannot evaluate: ',expr)
+        if type(v) is not list:
+            values = [v]
         else:
-            #print(k0,'=',v)
-            if v not in df.columns:
-                ColMapMiss.append(v)
-                print('[WARN] Column not present in dataframe: ',v)
+            values = v
+        Found = False
+        for v in values:
+            v=v.strip()
+            if Found:
+                break # We avoid replacing twice
+            if v.find('{')>=0:
+                # --- This is an advanced substitution using formulae
+                search_results = re.finditer(r'\{.*?\}', v)
+                expr=v
+                if verbose:
+                    print('Attempt to insert column {:15s} with expr {}'.format(k,v))
+                # For more advanced operations, we use an eval
+                bFail=False
+                for item in search_results:
+                    col=item.group(0)[1:-1]
+                    if col not in df.columns:
+                        ColMapMiss.append(col)
+                        bFail=True
+                    expr=expr.replace(item.group(0),'df[\''+col+'\']')
+                #print(k0, '=', expr)
+                if not bFail:
+                    df[k]=eval(expr)
+                    ColNew.append(k)
+                else:
+                    print('[WARN] Column not present in dataframe, cannot evaluate: ',expr)
             else:
-                RenameMap[k]=v
+                #print(k0,'=',v)
+                if v not in df.columns:
+                    ColMapMiss.append(v)
+                    if verbose:
+                        print('[WARN] Column not present in dataframe: ',v)
+                else:
+                    if k in RenameMap.keys():
+                        print('[WARN] Not renaming {} with {} as the key is already present'.format(k,v))
+                    else:
+                        RenameMap[k]=v
+                        Found=True
 
     # Applying renaming only now so that expressions may be applied in any order
     for k,v in RenameMap.items():
         if verbose:
             print('Renaming column {:15s} > {}'.format(v,k))
         k=k.strip()
         iCol = list(df.columns).index(v)
@@ -1031,17 +1204,17 @@
     elif direction == 'down':
         I= np.where(sign==-1)[0]
         return xzc[I],iBef[I]
     elif direction is not None:
         raise Exception('Direction should be either `up` or `down`')
     return xzc, iBef, sign
 
-def find_matching_pattern(List, pattern, sort=False, integers=True):
+def find_matching_pattern(List, pattern, sort=False, integers=True, n=1):
     r""" Return elements of a list of strings that match a pattern
-        and return the first matching group
+        and return the n first matching group
 
     Example:
 
         find_matching_pattern(['Misc','TxN1_[m]', 'TxN20_[m]'], 'TxN(\d+)_\[m\]')
         returns: Matches = 1,20
     """
     reg_pattern=re.compile(pattern)
@@ -1076,15 +1249,15 @@
 def extractSpanTS(df, pattern):
     r"""
     Extract spanwise time series of a given "type" (e.g. Cl for each radial node)
     Return a dataframe of size nt x nr 
 
     NOTE: time is not inserted in the output dataframe 
 
-    To find "r" use FASTRadialOutputs, it is different for AeroDyn/ElastoDyn/BeamDyn/
+    To find "r" use FASTSpanwiseOutputs, it is different for AeroDyn/ElastoDyn/BeamDyn/
     There is no guarantee that the number of columns matching pattern will exactly
     corresponds to the number of radial stations. That's the responsability of the 
     OpenFAST user.
 
     INPUTS:
      - df : a dataframe of size nt x nColumns
      - pattern: Pattern used to find "radial" columns amongst the dataframe columns
@@ -1245,23 +1418,26 @@
     dfPsi= bin_mean_DF(df, psiBin, colPsi)
     if np.any(dfPsi['Counts']<1):
         print('[WARN] some bins have no data! Increase the bin size.')
 
     return dfPsi
 
 
-def averageDF(df,avgMethod='periods',avgParam=None,ColMap=None,ColKeep=None,ColSort=None,stats=['mean']):
+def averageDF(df,avgMethod='periods',avgParam=None,ColMap=None,ColKeep=None,ColSort=None,stats=['mean'], filename=''):
     """
     See average PostPro for documentation, same interface, just does it for one dataframe
     """
     def renameCol(x):
         for k,v in ColMap.items():
             if x==v:
                 return k
         return x
+    # Sanity 
+    if len(filename)>0:
+        filename=' (File: {})'.format(filename)
     # Before doing the colomn map we store the time
     time = df['Time_[s]'].values
     timenoNA = time[~np.isnan(time)]
     # Column mapping
     if ColMap is not None:
         ColMapMiss = [v for _,v in ColMap.items() if v not in df.columns.values]
         if len(ColMapMiss)>0:
@@ -1273,43 +1449,43 @@
         if avgParam is None:
             tStart=timenoNA[0]
         else:
             tStart =tEnd-avgParam
     elif avgMethod.lower()=='periods':
         # --- Using azimuth to find periods
         if 'Azimuth_[deg]' not in df.columns:
-            raise Exception('The sensor `Azimuth_[deg]` does not appear to be in the output file. You cannot use the averaging method by `periods`, use `constantwindow` instead.')
+            raise Exception('The sensor `Azimuth_[deg]` does not appear to be in the dataframe{}. You cannot use the averaging method by `periods`, use `constantwindow` instead.'.format(filename))
         # NOTE: potentially we could average over each period and then average
         psi=df['Azimuth_[deg]'].values
-        _,iBef = _zero_crossings(psi-psi[-10],direction='up')
+        _,iBef = _zero_crossings(psi-psi[-2],direction='up')
         if len(iBef)==0:
             _,iBef = _zero_crossings(psi-180,direction='up')
         if len(iBef)==0:
-            print('[WARN] Not able to find a zero crossing!')
+            print('[WARN] Not able to find a zero crossing!{}'.format(filename))
             tEnd = time[-1]
             iBef=[0]
         else:
             tEnd = time[iBef[-1]]
 
         if avgParam is None:
             tStart=time[iBef[0]]
         else:
             avgParam=int(avgParam) 
             if len(iBef)-1<avgParam:
-                print('[WARN] Not enough periods found ({}) compared to number requested to average ({})!'.format(len(iBef)-1,avgParam))
+                print('[WARN] Not enough periods found ({}) compared to number requested to average ({})!{}'.format(len(iBef)-1,avgParam, filename))
                 avgParam=len(iBef)-1
             if avgParam==0:
                 tStart = time[0]
                 tEnd   = time[-1]
             else:
                 tStart=time[iBef[-1-avgParam]]
     elif avgMethod.lower()=='periods_omega':
         # --- Using average omega to find periods
         if 'RotSpeed_[rpm]' not in df.columns:
-            raise Exception('The sensor `RotSpeed_[rpm]` does not appear to be in the output file. You cannot use the averaging method by `periods_omega`, use `periods` or `constantwindow` instead.')
+            raise Exception('The sensor `RotSpeed_[rpm]` does not appear to be in the dataframe{}. You cannot use the averaging method by `periods_omega`, use `periods` or `constantwindow` instead.'.format(filename))
         Omega=df['RotSpeed_[rpm]'].mean()/60*2*np.pi
         Period = 2*np.pi/Omega 
         if avgParam is None:
             nRotations=np.floor(tEnd/Period)
         else:
             nRotations=avgParam
         tStart =tEnd-Period*nRotations
@@ -1319,15 +1495,15 @@
     if ColKeep is not None:
         ColKeepSafe = [c for c in ColKeep if c in df.columns.values]
         ColKeepMiss = [c for c in ColKeep if c not in df.columns.values]
         if len(ColKeepMiss)>0:
             print('[WARN] Signals missing and omitted for ColKeep:\n       '+'\n       '.join(ColKeepMiss))
         df=df[ColKeepSafe]
     if tStart<time[0]:
-        print('[WARN] Simulation time ({}) too short compared to required averaging window ({})!'.format(tEnd-time[0],tStart-tEnd))
+        print('[WARN] Simulation time ({}) too short compared to required averaging window ({})!{}'.format(tEnd-time[0],tStart-tEnd,filename))
     IWindow    = np.where((time>=tStart) & (time<=tEnd) & (~np.isnan(time)))[0]
     iEnd   = IWindow[-1]
     iStart = IWindow[0]
     ## Absolute and relative differences at window extremities
     DeltaValuesAbs=(df.iloc[iEnd]-df.iloc[iStart]).abs()
 #         DeltaValuesRel=(df.iloc[iEnd]-df.iloc[iStart]).abs()/df.iloc[iEnd]
     DeltaValuesRel=(df.iloc[IWindow].max()-df.iloc[IWindow].min())/df.iloc[IWindow].mean()
@@ -1342,18 +1518,23 @@
         MeanValues = pd.DataFrame(df.iloc[IWindow].mean()).transpose()
     else:
         raise NotImplementedError()
     return MeanValues
 
 
 
-def averagePostPro(outFiles,avgMethod='periods',avgParam=None,ColMap=None,ColKeep=None,ColSort=None,stats=['mean']):
+def averagePostPro(outFiles_or_DFs,avgMethod='periods',avgParam=None,
+        ColMap=None,ColKeep=None,ColSort=None,stats=['mean'],
+        skipIfWrongCol=False):
     """ Opens a list of FAST output files, perform average of its signals and return a panda dataframe
     For now, the scripts only computes the mean within a time window which may be a constant or a time that is a function of the rotational speed (see `avgMethod`).
     The script only computes the mean for now. Other stats will be added
+    INPUTS:
+
+     outFiles_or_DFs: list of fst filenames or dataframes
 
     `ColMap` :  dictionary where the key is the new column name, and v the old column name.
                 Default: None, output is not sorted
                 NOTE: the mapping is done before sorting and `ColKeep` is applied
                 ColMap = {'WS':Wind1VelX_[m/s], 'RPM': 'RotSpeed_[rpm]'}
     `ColKeep` : List of strings corresponding to the signals to analyse. 
                 Default: None, all columns are analysed
@@ -1366,58 +1547,80 @@
     `avgParam`: based on `avgMethod` it is either
                 - for 'periods_*': the number of revolutions for the window. 
                    Default: None, as many period as possible are used
                 - for 'constantwindow': the number of seconds for the window
                    Default: None, full simulation length is used
     """
     result=None
+    if len(outFiles_or_DFs)==0:
+        raise Exception('No outFiles or DFs provided')
+
     invalidFiles =[]
     # Loop trough files and populate result
-    for i,f in enumerate(outFiles):
-        try:
-            df=weio.read(f).toDataFrame()
-            #df=FASTOutputFile(f).toDataFrame()A # For pyFAST
-        except:
-            invalidFiles.append(f)
-            continue
-        postpro=averageDF(df, avgMethod=avgMethod, avgParam=avgParam, ColMap=ColMap, ColKeep=ColKeep,ColSort=ColSort,stats=stats)
+    for i,f in enumerate(outFiles_or_DFs):
+        if isinstance(f, pd.DataFrame):
+            df = f
+        else:
+            try:
+                df=weio.read(f).toDataFrame()
+                #df=FASTOutputFile(f).toDataFrame()A # For pyFAST
+            except:
+                invalidFiles.append(f)
+                continue
+        postpro=averageDF(df, avgMethod=avgMethod, avgParam=avgParam, ColMap=ColMap, ColKeep=ColKeep,ColSort=ColSort,stats=stats, filename=f)
         MeanValues=postpro # todo
         if result is None:
             # We create a dataframe here, now that we know the colums
             columns = MeanValues.columns
-            result = pd.DataFrame(np.nan, index=np.arange(len(outFiles)), columns=columns)
-        result.iloc[i,:] = MeanValues.copy().values
+            result = pd.DataFrame(np.nan, index=np.arange(len(outFiles_or_DFs)), columns=columns)
+        if MeanValues.shape[1]!=result.shape[1]:
+            columns_ref = result.columns
+            columns_loc = MeanValues.columns
+            if skipIfWrongCol:
+                print('[WARN] File {} has {} columns and not {}. Skipping.'.format(f, MeanValues.shape[1], result.shape[1]))
+            else:
+                try:
+                    MeanValues=MeanValues[columns_ref]
+                    result.iloc[i,:] = MeanValues.copy().values
+                    print('[WARN] File {} has more columns than other files. Truncating.'.format(f, MeanValues.shape[1], result.shape[1]))
+                except:
+                    print('[WARN] File {} is missing some columns compared to other files. Skipping.'.format(f))
+        else:
+            result.iloc[i,:] = MeanValues.copy().values
+
+
+    if len(invalidFiles)==len(outFiles_or_DFs):
+        raise Exception('None of the files can be read (or exist)!. For instance, cannot find: {}'.format(invalidFiles[0]))
+    elif len(invalidFiles)>0:
+        print('[WARN] There were {} missing/invalid files: \n {}'.format(len(invalidFiles),'\n'.join(invalidFiles)))
 
     if ColSort is not None:
+        if not ColSort in result.keys():
+            print('[INFO] Columns present: ', result.keys())
+            raise Exception('[FAIL] Cannot sort results with column `{}`, column not present in dataframe (see above)'.format(ColSort)) 
         # Sorting 
         result.sort_values([ColSort],inplace=True,ascending=True)
         result.reset_index(drop=True,inplace=True) 
 
-    if len(invalidFiles)==len(outFiles):
-        raise Exception('None of the files can be read (or exist)!')
-    elif len(invalidFiles)>0:
-        print('[WARN] There were {} missing/invalid files: {}'.format(len(invalidFiles),invalidFiles))
-
-
     return result 
 
 
 def integrateMoment(r, F):
-    """ 
+    r""" 
     Integrate moment from force and radial station
         M_j =  \int_{r_j}^(r_n) f(r) * (r-r_j) dr  for j=1,nr
     TODO: integrate analytically the "r" part
     """
     M = np.zeros(len(r)-1)
     for ir,_ in enumerate(r[:-1]):
         M[ir] = np.trapz(F[ir:]*(r[ir:]-r[ir]), r[ir:]-r[ir])
     return M
 
 def integrateMomentTS(r, F):
-    """
+    r"""
     Integrate moment from time series of forces at nr radial stations
 
     Compute 
         M_j =  \int_{r_j}^(r_n) f(r) * (r-r_j) dr  for j=1,nr
         M_j =  \int_{r_j}^(r_n) f(r) *r*dr  - r_j * \int_(r_j}^{r_n} f(r) dr
       j are the columns of M
```

### Comparing `welib-0.0.2/welib/fast/runner.py` & `welib-1.0.0/welib/fast/runner.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 # --- For cmd.py
-from __future__ import division, print_function
 import os
 import subprocess
 import multiprocessing
 
 import collections
 import glob
 import pandas as pd
@@ -11,24 +10,22 @@
 import shutil 
 import stat
 import re
 
 # --- Fast libraries
 from welib.weio.fast_input_file import FASTInputFile
 from welib.weio.fast_output_file import FASTOutputFile
-#from pyFAST.input_output.fast_input_file import FASTInputFile
-#from pyFAST.input_output.fast_output_file import FASTOutputFile
 
 FAST_EXE='openfast'
 
 # --------------------------------------------------------------------------------}
 # --- Tools for executing FAST
 # --------------------------------------------------------------------------------{
 # --- START cmd.py
-def run_cmds(inputfiles, exe, parallel=True, showOutputs=True, nCores=None, showCommand=True, verbose=True): 
+def run_cmds(inputfiles, exe, parallel=True, showOutputs=True, nCores=None, showCommand=True, flags=[], verbose=True): 
     """ Run a set of simple commands of the form `exe input_file`
     By default, the commands are run in "parallel" (though the method needs to be improved)
     The stdout and stderr may be displayed on screen (`showOutputs`) or hidden. 
     A better handling is yet required.
     """
     Failed=[]
     def _report(p):
@@ -48,14 +45,16 @@
     ps=[]
     iProcess=0
     if nCores is None:
         nCores=multiprocessing.cpu_count()
     if nCores<0:
         nCores=len(inputfiles)+1
     for i,f in enumerate(inputfiles):
+        if len(flags)>0:
+            f=flags + [f]
         #print('Process {}/{}: {}'.format(i+1,len(inputfiles),f))
         ps.append(run_cmd(f, exe, wait=(not parallel), showOutputs=showOutputs, showCommand=showCommand))
         iProcess += 1
         # waiting once we've filled the number of cores
         # TODO: smarter method with proper queue, here processes are run by chunks
         if parallel:
             if iProcess==nCores:
@@ -80,28 +79,23 @@
         for p in Failed:
             print('      ',p.input_file)
         return False, Failed
 
 def run_cmd(input_file_or_arglist, exe, wait=True, showOutputs=False, showCommand=True):
     """ Run a simple command of the form `exe input_file` or `exe arg1 arg2`  """
     # TODO Better capture STDOUT
+    if not os.path.exists(exe):
+        raise Exception('Executable not found: {}'.format(exe))
     if isinstance(input_file_or_arglist, list):
-        args= [exe] + input_file_or_arglist
         input_file     = ' '.join(input_file_or_arglist)
-        input_file_abs = input_file
+        args= [exe] + input_file_or_arglist
     else:
         input_file=input_file_or_arglist
-    if not os.path.isabs(input_file):
-        input_file_abs=os.path.abspath(input_file)
-    else:
-        input_file_abs=input_file
-    if not os.path.exists(exe):
-        raise Exception('Executable not found: {}'.format(exe))
-    args= [exe,input_file]
-    #args = 'cd '+workDir+' && '+ exe +' '+basename
+        args= [exe,input_file]
+    args = [a.strip() for a in args] # No surounding spaces, could cause issue
     shell=False
     if showOutputs:
         STDOut= None
     else:
         STDOut= open(os.devnull, 'w') 
     if showCommand:
         print('Running: '+' '.join(args))
@@ -112,17 +106,74 @@
         p.returncode=subprocess.call(args , stdout=STDOut, stderr=subprocess.STDOUT, shell=shell)
     else:
         p=subprocess.Popen(args, stdout=STDOut, stderr=subprocess.STDOUT, shell=shell)
     # Storing some info into the process
     p.cmd            = ' '.join(args)
     p.args           = args
     p.input_file     = input_file
-    p.input_file_abs = input_file_abs
     p.exe            = exe
     return p
+
+def runBatch(batchfiles, showOutputs=True, showCommand=True, verbose=True):
+    """ 
+    Run one or several batch files
+    TODO: error handling, status, parallel
+    """
+
+    if showOutputs:
+        STDOut= None
+    else:
+        STDOut= open(os.devnull, 'w') 
+
+    curDir = os.getcwd()
+    print('Current directory', curDir)
+
+    def runOneBatch(batchfile):
+        batchfile = batchfile.strip()
+        batchfile = batchfile.replace('\\','/')
+        batchDir  = os.path.dirname(batchfile)
+        if showCommand:
+            print('>>>> Running batch file:', batchfile)
+            print('           in directory:', batchDir)
+        try:
+            os.chdir(batchDir)
+            returncode=subprocess.call([batchfile], stdout=STDOut, stderr=subprocess.STDOUT, shell=shell)
+        except:
+            os.chdir(curDir)
+            returncode=-10
+        return returncode
+
+    shell=False
+    if isinstance(batchfiles,list):
+        returncodes = []
+        Failed=[]
+        for batchfile in batchfiles:
+            returncode = runOneBatch(batchfile)
+            if returncode!=0:
+                Failed.append(batchfile)
+        if len(Failed)>0:
+            returncode=1
+            print('[FAIL] {}/{} Batch files failed.'.format(len(Failed),len(batchfiles)))
+            print(Failed)
+        else:
+            returncode=0
+            if verbose:
+                print('[ OK ] {} batch filse ran successfully.'.format(len(batchfiles)))
+        # TODO
+    else:
+        returncode = runOneBatch(batchfiles)
+        if returncode==0:
+            if verbose:
+                print('[ OK ] Batch file ran successfully.')
+        else:
+            print('[FAIL] Batch file failed:',batchfiles)
+
+    return returncode
+
+
 # --- END cmd.py
 
 def run_fastfiles(fastfiles, fastExe=None, parallel=True, showOutputs=True, nCores=None, showCommand=True, reRun=True, verbose=True):
     if fastExe is None:
         fastExe=FAST_EXE
     if not reRun:
         # Figure out which files exist
@@ -140,39 +191,114 @@
 
 def run_fast(input_file, fastExe=None, wait=True, showOutputs=False, showCommand=True):
     if fastExe is None:
         fastExe=FAST_EXE
     return run_cmd(input_file, fastExe, wait=wait, showOutputs=showOutputs, showCommand=showCommand)
 
 
-def writeBatch(batchfile, fastfiles, fastExe=None, nBatches=1, pause=False):
-    """ Write batch file, everything is written relative to the batch file"""
+def writeBatch(batchfile, fastfiles, fastExe=None, nBatches=1, pause=False, flags='', flags_after='',
+        run_if_ext_missing=None,
+        discard_if_ext_present=None,
+        dispatch=False,
+        stdOutToFile=False,
+        echo=True):
+    """ Write one or several batch file, all paths are written relative to the batch file directory.
+    The batch file will consist of lines of the form:
+         [CONDITION] EXE [FLAGS] FILENAME [FLAGS_AFTER]
+
+    INPUTS:
+    - batchfile: path of the batch file to be written. 
+                 If several files are requested (using nBatches) _i is inserted before the extension
+    - nBatches: split into nBatches files.
+    - pause: insert a pause statement at the end so that batch file is not closed after execution
+    - flags: flags (string) to be placed between the executable and the filename
+    - flags_after: flags (string) to be placed after the filename
+    - run_if_ext_missing: add a line in the batch file so that the command is only run if
+                          the file `f.EXT` is missing, where .EXT is specified in run_if_ext_missing
+                          If None, the command is always run
+    - discard_if_ext_present: similar to run_if_ext_missing, but this time, the lines are not written to the batch file
+                          The test for existing outputs is done before writing the batch file
+    - dispatch: if True, the input files are dispatched (the first nBatches files are dispathced on the nBatches)
+    - stdOutToFile: if True, the output of the command is redirected to filename.stdout
+
+    example:
+       writeBatch('dir/MyBatch.bat', ['dir/c1.fst','dir/c2.fst'], 'op.exe', flags='-v', run_if_ext_missing='.outb')
+
+       will generate a file with the following content:
+         if not exist c1.outb (../of.exe c1.fst) else (echo "Skipping c1.fst")
+         if not exist c2.outb (../of.exe c2.fst) else (echo "Skipping c2.fst")
+
+
+    """
     if fastExe is None:
         fastExe=FAST_EXE
     fastExe_abs   = os.path.abspath(fastExe)
     batchfile_abs = os.path.abspath(batchfile)
     batchdir      = os.path.dirname(batchfile_abs)
     fastExe_rel   = os.path.relpath(fastExe_abs, batchdir)
+    if len(flags)>0:
+        flags=' '+flags
+    if len(flags_after)>0:
+        flags_after=' '+flags_after
+
+    # Remove commandlines if outputs are already present
+    if discard_if_ext_present:
+        outfiles = [os.path.splitext(f)[0] + discard_if_ext_present for f in fastfiles]
+        nIn=len(fastfiles)
+        fastfiles =[f for f,o in zip(fastfiles,outfiles) if not os.path.exists(o)]
+        nMiss=len(fastfiles)
+        if nIn>nMiss:
+            print('[INFO] WriteBatch: discarding simulations, only {}/{} needed'.format(nMiss, nIn))
+
+
     def writeb(batchfile, fastfiles):
         with open(batchfile,'w') as f:
+            if not echo:
+                if os.name == 'nt':
+                    f.write('@echo off\n')
             for ff in fastfiles:
                 ff_abs = os.path.abspath(ff)
                 ff_rel = os.path.relpath(ff_abs, batchdir)
-                l = fastExe_rel + ' '+ ff_rel
-                f.write("%s\n" % l)
+                cmd = fastExe_rel + flags + ' '+ ff_rel + flags_after
+                if stdOutToFile:
+                    stdout = os.path.splitext(ff_rel)[0]+'.stdout'
+                    cmd += ' > ' +stdout
+                if run_if_ext_missing is not None:
+                    # TODO might be windows only
+                    ff_out = os.path.splitext(ff_rel)[0] + run_if_ext_missing
+                    if os.name == 'nt':
+                        cmd = 'if not exist {} ({}) else (echo Skipping {})'.format(ff_out, cmd, ff_rel)
+                    else:
+                        cmd = 'if [[ ! -f {} ]] ; then {}; else echo Skipping {} ; fi'.format(ff_out, cmd, ff_rel)
+                f.write("{:s}\n".format(cmd))
             if pause:
-                f.write("pause\n") # windows only..
+                f.write("pause\n") # might be windows only..
+
+
 
     if nBatches==1:
         writeb(batchfile, fastfiles)
+        return batchfile
     else:
+
+        if dispatch:
+            # TODO this can probably be done with a one liner
+            fastfiles2=[]
+            for i in range(nBatches):
+                fastfiles2+=fastfiles[i::nBatches]
+            fastfiles = fastfiles2
+
         splits = np.array_split(fastfiles,nBatches)
         base, ext = os.path.splitext(batchfile)
+        batchfiles=[]
         for i in np.arange(nBatches):
-            writeb(base+'_{:d}'.format(i+1) + ext, splits[i])
+            batchfile = base+'_{:d}'.format(i+1) + ext
+            batchfiles.append(batchfile)
+            writeb(batchfile, splits[i])
+        return batchfiles
 
 
 
 
 
 
 def removeFASTOuputs(workDir):
```

### Comparing `welib-0.0.2/welib/fast/subdyn.py` & `welib-1.0.0/welib/fast/subdyn.py`

 * *Files 5% similar despite different names*

```diff
@@ -7,50 +7,61 @@
 
 """
 
 
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
+import copy
+import re
 # Local 
 from welib.weio.fast_input_file import FASTInputFile
-from welib.tools.clean_exceptions import *
 from welib.tools.tictoc import Timer
 
 idGuyanDamp_None     = 0
 idGuyanDamp_Rayleigh = 1
 idGuyanDamp_66       = 2 
 
 class SubDyn:
 
-    def __init__(self, sdFilename=None, sdData=None):
+    def __init__(self, sdFilename_or_data=None):
+        """ 
+        Initialize a SubDyn object either with:
+          - sdFilename: a subdyn input file name
+          - sdData: an instance of FASTInputFile
+        """
 
         self._graph=None
         self.File=None
 
         # Read SubDyn file
-        if sdFilename is not None:
-            self.File = FASTInputFile(sdFilename)
-        if sdData is not None:
-            self.File = sdData
+        if sdFilename_or_data is not None:
+            if hasattr(sdFilename_or_data,'startswith'): # if string
+                self.File = FASTInputFile(sdFilename_or_data)
+            else:
+                self.File = sdFilename_or_data
 
         self.M_tip=None
 
         # Internal
         self._graph=None
+        self._mgraph=None # Member graph
         self._FEM=None
 
     def __repr__(self):
         s='<{} object>:\n'.format(type(self).__name__)
         s+='|properties:\n'
         s+='|- File: (input file data)\n'
+        s+='|* graph: (Nodes/Elements/Members)\n'
+        s+='|* pointsMJ, pointsMN, pointsMNout\n'
         s+='|methods:\n'
+        s+='|- memberPostPro\n'
         s+='|- setTopMass\n'
         s+='|- beamDataFrame, beamFEM, beamModes\n'
-        s+='|- toYAMS\n'
+        s+='|- toYAMSData\n'
         return s
 
     # --------------------------------------------------------------------------------}
     # --- Functions for general FEM model (jacket, flexible floaters)
     # --------------------------------------------------------------------------------{
     def init(self, TP=(0,0,0), gravity = 9.81):
         """
@@ -69,15 +80,14 @@
             mainElementType='frame3d'
         elif FEMMod==2:
             mainElementType='frame3dlin'
         elif FEMMod==3:
             mainElementType='timoshenko'
         else:
             raise NotImplementedError()
-        print('>>> Main Element', FEMMod)
         # Get graph
         graph = self.graph
         #print('>>> graph\n',graph)
         #graph.toJSON('_GRAPH.json')
         # Convert to FEM model
         with Timer('From graph'):
             FEM = femm.FEMModel.from_graph(self.graph, mainElementType=mainElementType, refPoint=TP, gravity=gravity)
@@ -146,56 +156,222 @@
         if TopMass:
             # NOTE: you can use welib.yams.windturbine to compute RNA mass and inertia
             Mtop = 50000  # Top mass [kg]
             M_tip= rigidBodyMassMatrixAtP(m=Mtop, J_G=None, Ref2COG=None)
         else:
             M_tip=None
 
+
+    def getGraph(self, nDiv=1):
+        # See welib.weio.fast_input_file_graph.py to see how SubDyn files are converted to graph 
+        # See welib.fem.graph.py for Graph interface
+        _graph = self.File.toGraph().divideElements(nDiv,
+                    excludeDataKey='Type', excludeDataList=['Cable','Rigid'], method='insert',
+                    keysNotToCopy=['IBC','RBC','addedMassMatrix'] # Very important
+                    )
+
+        if len(_graph.Members)==0:
+            raise Exception('Problem in graph subdivisions, no members found.')
+        # Sanitization
+        #idBC_Fixed    =  0 # Fixed BC
+        #idBC_Internal = 10 # Free/Internal BC
+        #idBC_Leader   = 20 # Leader DOF
+        MapIBC={0:0, 1:20} # 1 in the input file is leader
+        MapRBC={0:10, 1:0} # 1 in the input file is fixed
+        for n in _graph.Nodes:
+            #print(n)
+            if 'IBC' in n.data.keys():
+                IBC = n.data['IBC'].copy()
+                n.data['IBC'] = [MapIBC[i] for i in IBC[:6]]
+            if 'RBC' in n.data.keys():
+                RBC = n.data['RBC'].copy()
+                n.data['RBC'] = [MapRBC[i] for i in RBC[:6]]
+                if any(RBC[:6])==0:
+                    print('RBC        ',RBC)
+                    print('n.data[RBC]',n.data['RBC'] )
+                    print('n          ',n )
+                    raise NotImplementedError('SSI')
+
+        return _graph
+
     @property
     def graph(self):
-        import copy
         if self._graph is None:
-            print('>>> NDIV is ', self.File['NDiv'])
-            self._graph = self.File.toGraph().divideElements(self.File['NDiv'],
-                        excludeDataKey='Type', excludeDataList=['Cable','Rigid'], method='insert',
-                        keysNotToCopy=['IBC','RBC','addedMassMatrix'] # Very important
-                        )
-            # Sanitization
-            #idBC_Fixed    =  0 # Fixed BC
-            #idBC_Internal = 10 # Free/Internal BC
-            #idBC_Leader   = 20 # Leader DOF
-            MapIBC={0:0, 1:20} # 1 in the input file is leader
-            MapRBC={0:10, 1:0} # 1 in the input file is fixed
-            for n in self._graph.Nodes:
-                #print(n)
-                if 'IBC' in n.data.keys():
-                    IBC = n.data['IBC'].copy()
-                    n.data['IBC'] = [MapIBC[i] for i in IBC[:6]]
-                if 'RBC' in n.data.keys():
-                    RBC = n.data['RBC'].copy()
-                    n.data['RBC'] = [MapRBC[i] for i in RBC[:6]]
-                    if any(RBC[:6])==0:
-                        print('RBC        ',RBC)
-                        print('n.data[RBC]',n.data['RBC'] )
-                        print('n          ',n )
-                        raise NotImplementedError('SSI')
-
+            self._graph = self.getGraph(nDiv = self.File['NDiv'])
         return copy.deepcopy(self._graph)
 
+
+    @property
+    def pointsMJ(self):
+        """ return a dataframe with the coordinates of all members and joints
+        The index corresponds to the SubDyn outputs "M_J_XXX"
+        """
+        Joints=[]
+        labels =[]
+        graph = self.graph
+        for ie,M in enumerate(graph.Members): # loop on members
+            Nodes = M.getNodes(graph)
+            for iN,N in enumerate([Nodes[0], Nodes[-1]]):
+                s='M{}J{}'.format(ie+1, iN+1)
+                Joints.append([N.x,N.y,N.z])
+                labels.append(s)
+        df =pd.DataFrame(data=np.asarray(Joints), index=labels, columns=['x','y','z'])
+        return df
+
+    @property
+    def pointsMN(self):
+        """ return a dataframe with the coordinates of all members and nodes
+        The index would correspond to the SubDyn outputs "M_N_XXX *prior* to the user selection"
+        """
+        Nodes=[]
+        labels =[]
+        graph = self.graph
+        for im,M in enumerate(graph.Members): # loop on members
+            nodes = M.getNodes(graph)
+            for iN,N in enumerate(nodes): # Loop on member nodes
+                s='M{}N{}'.format(im+1, iN+1)
+                Nodes.append([N.x,N.y,N.z])
+                labels.append(s)
+        df =pd.DataFrame(data=np.asarray(Nodes), index=labels, columns=['x','y','z'])
+        return df
+
+    @property
+    def pointsMNout(self):
+        """ return a dataframe with the coordinates of members and nodes requested by user
+        The index corresponds to the SubDyn outputs "M_N_XXX selected by the user"
+        """
+        Nodes=[]
+        labels =[]
+        graph = self.graph
+        for im, out in enumerate(self.File['MemberOuts']):
+            mID = out[0] # Member ID
+            iNodes = np.array(out[2:])-1 # Node positions within member (-1 for python indexing)
+            nodes = graph.getMemberNodes(mID)
+            nodes = np.array(nodes)[iNodes]
+            for iN,N in enumerate(nodes): # Loop on selected nodes
+                s='M{}N{}'.format(im+1, iN+1)
+                Nodes.append([N.x,N.y,N.z])
+                labels.append(s)
+        df =pd.DataFrame(data=np.asarray(Nodes), index=labels, columns=['x','y','z'])
+        return df
+
+
+    def memberPostPro(self, dfAvg):
+        """
+        Convert a dataframe of SubDyn/OpenFAST outputs (time-averaged)
+        with columns such as: M_N_* and M_J_* 
+        into a dataframe that is organized by main channel name and nodal coordinates.
+        The scripts taken into account with member ID and node the user requested as outputs channels.
+        Discretization (nDIV) is also taken into account.
+
+        For instance:
+            dfAvg with columns = ['M1N1MKye_[N*m]', 'M1N2MKye_[N*m]', 'M1N1TDxss_[m]']
+        returns:
+            MNout with columns ['x', 'y', 'z', 'MKye_[Nm]', 'TDxss_[m]']
+               and index    ['M1N1', 'M1N2']
+               with x,y,z the undisplaced nodal positions (accounting for discretization)
+
+        INPUTS: 
+          -  dfAvg: a dataframe of time-averaged SubDyn/OpenFAST outputs, for instance obtained as:
+              df    = FASTInputFile(filename).toDataFrame()
+              dfAvg = postpro.averageDF(df, avgMethod=avgMethod ,avgParam=avgParam)
+        OUTPUTS
+          - MNout: dataframe of members outputs (requested by the user)
+          - MJout: dataframe of joints outputs
+        """
+        import welib.fast.postpro as postpro # Import done here to avoid circular dependency
+
+        # --- Get Points where output are requested
+        MJ = self.pointsMJ
+        MNo= self.pointsMNout
+        MJ.columns = ['x_[m]','y_[m]', 'z_[m]']
+        MNo.columns = ['x_[m]','y_[m]', 'z_[m]']
+
+        # --- Requested Member Outputs
+        Map={}
+        Map['^'+r'M(\d*)N(\d*)TDxss_\[m\]']   = 'TDxss_[m]'
+        Map['^'+r'M(\d*)N(\d*)TDyss_\[m\]']   = 'TDyss_[m]'
+        Map['^'+r'M(\d*)N(\d*)TDzss_\[m\]']   = 'TDzss_[m]'
+        Map['^'+r'M(\d*)N(\d*)RDxe_\[rad\]']  = 'RDxe_[deg]' # NOTE rescale needed
+        Map['^'+r'M(\d*)N(\d*)RDye_\[rad\]']  = 'RDye_[deg]' # NOTE rescale needed
+        Map['^'+r'M(\d*)N(\d*)RDze_\[rad\]']  = 'RDze_[deg]' # NOTE rescale needed
+        Map['^'+r'M(\d*)N(\d*)FKxe_\[N\]'] = 'FKxe_[N]'
+        Map['^'+r'M(\d*)N(\d*)FKye_\[N\]'] = 'FKye_[N]'
+        Map['^'+r'M(\d*)N(\d*)FKze_\[N\]'] = 'FKze_[N]'
+        Map['^'+r'M(\d*)N(\d*)MKxe_\[N\*m\]'] = 'MKxe_[Nm]'
+        Map['^'+r'M(\d*)N(\d*)MKye_\[N\*m\]'] = 'MKye_[Nm]'
+        Map['^'+r'M(\d*)N(\d*)MKze_\[N\*m\]'] = 'MKze_[Nm]'
+        ColsInfo, _ = postpro.find_matching_columns(dfAvg.columns, Map)
+        nCols = len(ColsInfo)
+        if nCols>0:
+            newCols=[c['name'] for c in ColsInfo ]
+            ValuesM = pd.DataFrame(index=MNo.index, columns=newCols)
+            for ic,c in enumerate(ColsInfo):
+                Idx, cols, colname = c['Idx'], c['cols'], c['name']
+                labels = [re.match(r'(^M\d*N\d*)', s)[0] for s in cols] 
+                ValuesM.loc[labels,colname] = dfAvg[cols].values.flatten()
+                if 'deg' in colname and 'rad' in cols[0]:
+                    ValuesM[colname] *= 180/np.pi
+            # We remove lines that are all NaN
+            Values = ValuesM.dropna(axis = 0, how = 'all')
+            MNo2 = MNo.loc[Values.index]
+            MNout = pd.concat((MNo2, Values), axis=1)
+        else:
+            MNout = None
+
+        # --- Joint Outputs
+        Map={}
+        Map['^'+r'M(\d*)J(\d*)FKxe_\[N\]']   ='FKxe_[N]'
+        Map['^'+r'M(\d*)J(\d*)FKye_\[N\]']   ='FKye_[N]'
+        Map['^'+r'M(\d*)J(\d*)FKze_\[N\]']   ='FKze_[N]'
+        Map['^'+r'M(\d*)J(\d*)MKxe_\[N\*m\]']='MKxe_[Nm]'
+        Map['^'+r'M(\d*)J(\d*)MKye_\[N\*m\]']='MKye_[Nm]'
+        Map['^'+r'M(\d*)J(\d*)MKze_\[N\*m\]']='MKze_[Nm]'
+        Map['^'+r'M(\d*)J(\d*)FMxe_\[N\]']   ='FMxe_[N]'
+        Map['^'+r'M(\d*)J(\d*)FMye_\[N\]']   ='FMye_[N]'
+        Map['^'+r'M(\d*)J(\d*)FMze_\[N\]']   ='FMze_[N]'
+        Map['^'+r'M(\d*)J(\d*)MMxe_\[N\*m\]']='MMxe_[Nm]'
+        Map['^'+r'M(\d*)J(\d*)MMye_\[N\*m\]']='MMye_[Nm]'
+        Map['^'+r'M(\d*)J(\d*)MMze_\[N\*m\]']='MMze_[Nm]'
+        ColsInfo, _ = postpro.find_matching_columns(dfAvg.columns, Map)
+        nCols = len(ColsInfo)
+        if nCols>0:
+            newCols=[c['name'] for c in ColsInfo ]
+            ValuesJ = pd.DataFrame(index=MJ.index, columns=newCols)
+            for ic,c in enumerate(ColsInfo):
+                Idx, cols, colname = c['Idx'], c['cols'], c['name']
+                labels = [re.match(r'(^M\d*J\d*)', s)[0] for s in cols] 
+                ValuesJ.loc[labels,colname] = dfAvg[cols].values.flatten()
+            # We remove lines that are all NaN
+            Values = ValuesJ.dropna(axis = 0, how = 'all')
+            MJ2 = MJ.loc[Values.index]
+            MJout = pd.concat((MJ2, Values), axis=1)
+        else:
+            MJout = None
+        return MNout, MJout
+
+
+
+
     # --------------------------------------------------------------------------------}
     # --- Functions for beam-like structure (Spar, Monopile)
     # --------------------------------------------------------------------------------{
     def beamDataFrame(self, equispacing=False):
         """ """
         # --- Parameters
         UseSubDynModel=True
         TopMass = False
 
+
         # Convert to "welib.fem.Graph" class to easily handle the model (overkill for a monopile)
-        df = self.graph.sortNodesBy('z').nodalDataFrame()
+        locgraph = self.graph.sortNodesBy('z')
+        # Add nodal properties from propsets (NOTE: Not done anymore by SubDyn because a same node can have different diameters...)
+        for e in locgraph.Elements:
+            locgraph.setElementNodalProp(e, propset=e.propset, propIDs=e.propIDs)
+        df = locgraph.nodalDataFrame()
 
         if equispacing:
             from welib.tools.pandalib import pd_interp1
             # Interpolate dataframe to equispaced values
             xOld  = df['z']    # NOTE: FEM uses "x" as main axis
             nSpan = len(xOld)
             x = np.linspace(np.min(xOld),np.max(xOld), nSpan)
@@ -529,203 +705,204 @@
         for ip, p in enumerate(prop):
             if p.ID == propID:
                 return ip+1
 
     SD_Vars = subdynPartitionVars(model)
 
     # --- Helper functions
-    with open(filename, 'w') as f:
-        s=''
-        s += '#____________________________________________________________________________________________________\n'
-        s += '# RIGID BODY EQUIVALENT DATA\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s0 = 'Mass: {:15.6e} # Total Mass\n'.format(model.M_O[0,0])
-        s += s0.replace('e+','E+').replace('e-','E-')
-        s0 = 'CM_point: [{:15.6e},{:15.6e},{:15.6e},] # Center of mass coordinates (Xcm,Ycm,Zcm)\n'.format(model.center_of_mass[0],model.center_of_mass[1],model.center_of_mass[2])
+    s=''
+    s += '#____________________________________________________________________________________________________\n'
+    s += '# RIGID BODY EQUIVALENT DATA\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s0 = 'Mass: {:15.6e} # Total Mass\n'.format(model.M_O[0,0])
+    s += s0.replace('e+','E+').replace('e-','E-')
+    s0 = 'CM_point: [{:15.6e},{:15.6e},{:15.6e},] # Center of mass coordinates (Xcm,Ycm,Zcm)\n'.format(model.center_of_mass[0],model.center_of_mass[1],model.center_of_mass[2])
+    s += s0.replace('e+','E+').replace('e-','E-')
+    s0 = 'TP_point: [{:15.6e},{:15.6e},{:15.6e},] # Transition piece reference point\n'.format(model.refPoint[0],model.refPoint[1],model.refPoint[2])
+    s += s0.replace('e+','E+').replace('e-','E-')
+    s += yaml_array('MRB',  model.M_O,  comment = 'Rigid Body Equivalent Mass Matrix w.r.t. (0,0,0).')
+    s += yaml_array('M_P' , model.M_ref,comment = 'Rigid Body Equivalent Mass Matrix w.r.t. TP Ref point')
+    s += yaml_array('M_G' , model.M_G,  comment = 'Rigid Body Equivalent Mass Matrix w.r.t. CM (Xcm,Ycm,Zcm).')
+    s += '#____________________________________________________________________________________________________\n'
+    s += '# GUYAN MATRICES at the TP reference point\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += yaml_array('KBBt' , model.KBBt,  comment = '')
+    s += yaml_array('MBBt' , model.MBBt,  comment = '')
+    s += yaml_array('CBBt' , model.CBBt,  comment = '(user Guyan Damping + potential joint damping from CB-reduction)')
+    s += '#____________________________________________________________________________________________________\n'
+    s += '# SYSTEM FREQUENCIES\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += '#Eigenfrequencies [Hz] for full system, with reaction constraints (+ Soil K/M + SoilDyn K0) \n'
+    s += yaml_array('Full_frequencies', model.freq)
+    s += '#Frequencies of Guyan modes [Hz]\n'
+    s += yaml_array('GY_frequencies', model.f_G)
+    s += '#Frequencies of Craig-Bampton modes [Hz]\n'
+    s += yaml_array('CB_frequencies', model.f_CB)
+    s += '#____________________________________________________________________________________________________\n'
+    s += '# Internal FEM representation\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += 'nNodes_I: {:7d} # Number of Nodes: "interface" (I)\n'.format(len(model.interfaceNodes))
+    s += 'nNodes_C: {:7d} # Number of Nodes: "reactions" (C)\n'.format(len(model.reactionNodes))
+    s += 'nNodes_L: {:7d} # Number of Nodes: "internal"  (L)\n'.format(len(model.internalNodes))
+    s += 'nNodes  : {:7d} # Number of Nodes: total   (I+C+L)\n'.format(len(model.Nodes))
+    if more:
+        s += 'nDOFI__ : {:7d} # Number of DOFs: "interface"          (I__)\n'.format(len(SD_Vars['IDI__']))
+        s += 'nDOFI_B : {:7d} # Number of DOFs: "interface" retained (I_B)\n'.format(len(SD_Vars['IDI_B']))
+        s += 'nDOFI_F : {:7d} # Number of DOFs: "interface" fixed    (I_F)\n'.format(len(SD_Vars['IDI_F']))
+        s += 'nDOFC__ : {:7d} # Number of DOFs: "reactions"          (C__)\n'.format(len(SD_Vars['IDC__']))
+        s += 'nDOFC_B : {:7d} # Number of DOFs: "reactions" retained (C_B)\n'.format(len(SD_Vars['IDC_B']))
+        s += 'nDOFC_L : {:7d} # Number of DOFs: "reactions" internal (C_L)\n'.format(len(SD_Vars['IDC_L']))
+        s += 'nDOFC_F : {:7d} # Number of DOFs: "reactions" fixed    (C_F)\n'.format(len(SD_Vars['IDC_F']))
+        s += 'nDOFR__ : {:7d} # Number of DOFs: "intf+react"         (__R)\n'.format(len(SD_Vars['IDR__']))
+        s += 'nDOFL_L : {:7d} # Number of DOFs: "internal"  internal (L_L)\n'.format(len(SD_Vars['IDL_L']))
+    s += 'nDOF__B : {:7d} # Number of DOFs:             retained (__B)\n'.format(SD_Vars['nDOF__B'])
+    s += 'nDOF__L : {:7d} # Number of DOFs:             internal (__L)\n'.format(SD_Vars['nDOF__L'])
+    s += 'nDOF__F : {:7d} # Number of DOFs:             fixed    (__F)\n'.format(SD_Vars['nDOF__F'])
+    s += 'nDOF_red: {:7d} # Number of DOFs: total\n'                     .format(SD_Vars['nDOF___'])
+    s += yaml_array('Nodes_I', nodeID([n.ID for n in model.interfaceNodes]), Fmt='{:7d}', comment='"interface" nodes"');
+    s += yaml_array('Nodes_C', nodeID([n.ID for n in model.reactionNodes ]), Fmt='{:7d}', comment='"reaction" nodes"');
+    s += yaml_array('Nodes_L', nodeID([n.ID for n in model.internalNodes ]), Fmt='{:7d}', comment='"internal" nodes"');
+    if more:
+        s += yaml_array('DOF_I__', np.array(SD_Vars['IDI__'])+1,   Fmt='{:7d}', comment = '"interface"           DOFs"')
+        s += yaml_array('DOF_I_B', np.array(SD_Vars['IDI_B'])+1,   Fmt='{:7d}', comment = '"interface" retained  DOFs')
+        s += yaml_array('DOF_I_F', np.array(SD_Vars['IDI_F'])+1,   Fmt='{:7d}', comment = '"interface" fixed     DOFs')
+        s += yaml_array('DOF_C__', np.array(SD_Vars['IDC__'])+1,   Fmt='{:7d}', comment = '"reaction"            DOFs"')
+        s += yaml_array('DOF_C_B', np.array(SD_Vars['IDC_B'])+1,   Fmt='{:7d}', comment = '"reaction"  retained  DOFs')
+        s += yaml_array('DOF_C_L', np.array(SD_Vars['IDC_L'])+1,   Fmt='{:7d}', comment = '"reaction"  internal  DOFs')
+        s += yaml_array('DOF_C_F', np.array(SD_Vars['IDC_F'])+1,   Fmt='{:7d}', comment = '"reaction"  fixed     DOFs')
+        s += yaml_array('DOF_L_L', np.array(SD_Vars['IDL_L'])+1,   Fmt='{:7d}', comment = '"internal"  internal  DOFs')
+        s += yaml_array('DOF_R_' , np.array(SD_Vars['IDR__'])+1,   Fmt='{:7d}', comment = '"interface&reaction"  DOFs')
+    s += yaml_array('DOF___B', np.array(model.DOFc_Leader  )+1, Fmt='{:7d}',  comment='all         retained  DOFs');
+    s += yaml_array('DOF___F', np.array(model.DOFc_Fixed   )+1, Fmt='{:7d}',  comment='all         fixed     DOFs');
+    s += yaml_array('DOF___L', np.array(model.DOFc_Follower)+1, Fmt='{:7d}',  comment='all         internal  DOFs');
+    s += '\n'
+    s += '#Index map from DOF to nodes\n'
+    s += '#     Node No.,  DOF/Node,   NodalDOF\n'
+    s += 'DOF2Nodes: # {} x 3 (nDOFRed x 3, for each constrained DOF, col1: node index, col2: number of DOF, col3: DOF starting from 1)\n'.format(model.nDOFc)
+    DOFc2Nodes = model.DOFc2Nodes
+    for l in DOFc2Nodes:
+        s +='  - [{:7d},{:7d},{:7d}] # {}\n'.format(l[1]+1, l[2], l[3], l[0]+1 )
+    s += '#     Node_[#]          X_[m]           Y_[m]           Z_[m]       JType_[-]       JDirX_[-]       JDirY_[-]       JDirZ_[-]  JStff_[Nm/rad]\n'
+    s += 'Nodes: # {} x 9\n'.format(len(model.Nodes))
+    for n in model.Nodes:
+        s += '  - [{:7d}.,{:15.3f},{:15.3f},{:15.3f},{:14d}.,   0.000000E+00,   0.000000E+00,   0.000000E+00,   0.000000E+00]\n'.format(nodeID(n.ID), n.x, n.y, n.z, int(n.data['Type']) )
+    s += '#    Elem_[#]    Node_1   Node_2   Prop_1   Prop_2     Type     Length_[m]      Area_[m^2]  Dens._[kg/m^3]        E_[N/m2]        G_[N/m2]       shear_[-]       Ixx_[m^4]       Iyy_[m^4]       Jzz_[m^4]          T0_[N]\n'
+    s += 'Elements: # {} x 16\n'.format(len(model.Elements))
+    for e in model.Elements:
+        I = e.inertias
+        s0='  - [{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:15.3f},{:15.3f},{:15.3f},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e}]\n'.format(
+            elemID(e.ID), nodeID(e.nodeIDs[0]), nodeID(e.nodeIDs[1]), propID(e.propIDs[0], e.propset), propID(e.propIDs[1], e.propset), elemType(e.data['Type']), 
+            e.length, e.area, e.rho, e.E, e.G, e.kappa, I[0], I[1], I[2], e.T0)
         s += s0.replace('e+','E+').replace('e-','E-')
-        s0 = 'TP_point: [{:15.6e},{:15.6e},{:15.6e},] # Transition piece reference point\n'.format(model.refPoint[0],model.refPoint[1],model.refPoint[2])
+    s += '#____________________________________________________________________________________________________\n'
+    s += '#User inputs\n'
+    s += '\n'
+    s += '#Number of properties (NProps):{:6d}\n'.format(len(model.NodePropertySets['Beam']))
+    s += '#Prop No         YoungE         ShearG        MatDens          XsecD          XsecT\n'
+    for ip,p in enumerate(model.NodePropertySets['Beam']):
+        s0='#{:8d}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format(p.ID, p['E'],p['G'],p['rho'],p['D'],p['t'])
+        s +=  s0.replace('e+','E+').replace('e-','E-')
+    s +='\n'
+    s += '#No. of Reaction DOFs:{:6d}\n'.format(len(SD_Vars['IDC__']) )
+    s += '#React. DOF_ID    BC\n'
+    s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Fixed' ) for idof in SD_Vars['IDC_F']])
+    s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Free'  ) for idof in SD_Vars['IDC_L']])
+    s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Leader') for idof in SD_Vars['IDC_B']])
+    s += '\n\n'
+    s += '#No. of Interface DOFs:{:6d}\n'.format(len(SD_Vars['IDI__']))
+    s += '#Interf. DOF_ID    BC\n'
+    s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'    Fixed' ) for idof in SD_Vars['IDI_F']])
+    s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'    Leader') for idof in SD_Vars['IDI_B']])
+    s += '\n\n'
+    CM = []
+    from welib.yams.utils import identifyRigidBodyMM
+    for n in model.Nodes:
+        if 'addedMassMatrix' in n.data:
+            mass, J_G, ref2COG = identifyRigidBodyMM(n.data['addedMassMatrix'])
+            CM.append( (n.ID, mass, J_G, ref2COG) )
+    s += '#Number of concentrated masses (NCMass):{:6d}\n'.format(len(CM))
+    s += '#JointCMas           Mass            JXX            JYY            JZZ            JXY            JXZ            JYZ           MCGX           MCGY           MCGZ\n'
+    for cm in CM:
+        s0 = '# {:9.0f}.{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format( nodeID(cm[0]),  cm[1], cm[2][0,0], cm[2][1,1], cm[2][2,2], cm[2][0,1], cm[2][0,2], cm[2][1,2],cm[3][0],cm[3][1],cm[3][2] )
         s += s0.replace('e+','E+').replace('e-','E-')
-        s += yaml_array('MRB',  model.M_O,  comment = 'Rigid Body Equivalent Mass Matrix w.r.t. (0,0,0).')
-        s += yaml_array('M_P' , model.M_ref,comment = 'Rigid Body Equivalent Mass Matrix w.r.t. TP Ref point')
-        s += yaml_array('M_G' , model.M_G,  comment = 'Rigid Body Equivalent Mass Matrix w.r.t. CM (Xcm,Ycm,Zcm).')
-        s += '#____________________________________________________________________________________________________\n'
-        s += '# GUYAN MATRICES at the TP reference point\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += yaml_array('KBBt' , model.KBBt,  comment = '')
-        s += yaml_array('MBBt' , model.MBBt,  comment = '')
-        s += yaml_array('CBBt' , model.CBBt,  comment = '(user Guyan Damping + potential joint damping from CB-reduction)')
-        s += '#____________________________________________________________________________________________________\n'
-        s += '# SYSTEM FREQUENCIES\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += '#Eigenfrequencies [Hz] for full system, with reaction constraints (+ Soil K/M + SoilDyn K0) \n'
-        s += yaml_array('Full_frequencies', model.freq)
-        s += '#Frequencies of Guyan modes [Hz]\n'
-        s += yaml_array('GY_frequencies', model.f_G)
-        s += '#Frequencies of Craig-Bampton modes [Hz]\n'
-        s += yaml_array('CB_frequencies', model.f_CB)
-        s += '#____________________________________________________________________________________________________\n'
-        s += '# Internal FEM representation\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += 'nNodes_I: {:7d} # Number of Nodes: "interface" (I)\n'.format(len(model.interfaceNodes))
-        s += 'nNodes_C: {:7d} # Number of Nodes: "reactions" (C)\n'.format(len(model.reactionNodes))
-        s += 'nNodes_L: {:7d} # Number of Nodes: "internal"  (L)\n'.format(len(model.internalNodes))
-        s += 'nNodes  : {:7d} # Number of Nodes: total   (I+C+L)\n'.format(len(model.Nodes))
-        if more:
-            s += 'nDOFI__ : {:7d} # Number of DOFs: "interface"          (I__)\n'.format(len(SD_Vars['IDI__']))
-            s += 'nDOFI_B : {:7d} # Number of DOFs: "interface" retained (I_B)\n'.format(len(SD_Vars['IDI_B']))
-            s += 'nDOFI_F : {:7d} # Number of DOFs: "interface" fixed    (I_F)\n'.format(len(SD_Vars['IDI_F']))
-            s += 'nDOFC__ : {:7d} # Number of DOFs: "reactions"          (C__)\n'.format(len(SD_Vars['IDC__']))
-            s += 'nDOFC_B : {:7d} # Number of DOFs: "reactions" retained (C_B)\n'.format(len(SD_Vars['IDC_B']))
-            s += 'nDOFC_L : {:7d} # Number of DOFs: "reactions" internal (C_L)\n'.format(len(SD_Vars['IDC_L']))
-            s += 'nDOFC_F : {:7d} # Number of DOFs: "reactions" fixed    (C_F)\n'.format(len(SD_Vars['IDC_F']))
-            s += 'nDOFR__ : {:7d} # Number of DOFs: "intf+react"         (__R)\n'.format(len(SD_Vars['IDR__']))
-            s += 'nDOFL_L : {:7d} # Number of DOFs: "internal"  internal (L_L)\n'.format(len(SD_Vars['IDL_L']))
-        s += 'nDOF__B : {:7d} # Number of DOFs:             retained (__B)\n'.format(SD_Vars['nDOF__B'])
-        s += 'nDOF__L : {:7d} # Number of DOFs:             internal (__L)\n'.format(SD_Vars['nDOF__L'])
-        s += 'nDOF__F : {:7d} # Number of DOFs:             fixed    (__F)\n'.format(SD_Vars['nDOF__F'])
-        s += 'nDOF_red: {:7d} # Number of DOFs: total\n'                     .format(SD_Vars['nDOF___'])
-        s += yaml_array('Nodes_I', nodeID([n.ID for n in model.interfaceNodes]), Fmt='{:7d}', comment='"interface" nodes"');
-        s += yaml_array('Nodes_C', nodeID([n.ID for n in model.reactionNodes ]), Fmt='{:7d}', comment='"reaction" nodes"');
-        s += yaml_array('Nodes_L', nodeID([n.ID for n in model.internalNodes ]), Fmt='{:7d}', comment='"internal" nodes"');
-        if more:
-            s += yaml_array('DOF_I__', np.array(SD_Vars['IDI__'])+1,   Fmt='{:7d}', comment = '"interface"           DOFs"')
-            s += yaml_array('DOF_I_B', np.array(SD_Vars['IDI_B'])+1,   Fmt='{:7d}', comment = '"interface" retained  DOFs')
-            s += yaml_array('DOF_I_F', np.array(SD_Vars['IDI_F'])+1,   Fmt='{:7d}', comment = '"interface" fixed     DOFs')
-            s += yaml_array('DOF_C__', np.array(SD_Vars['IDC__'])+1,   Fmt='{:7d}', comment = '"reaction"            DOFs"')
-            s += yaml_array('DOF_C_B', np.array(SD_Vars['IDC_B'])+1,   Fmt='{:7d}', comment = '"reaction"  retained  DOFs')
-            s += yaml_array('DOF_C_L', np.array(SD_Vars['IDC_L'])+1,   Fmt='{:7d}', comment = '"reaction"  internal  DOFs')
-            s += yaml_array('DOF_C_F', np.array(SD_Vars['IDC_F'])+1,   Fmt='{:7d}', comment = '"reaction"  fixed     DOFs')
-            s += yaml_array('DOF_L_L', np.array(SD_Vars['IDL_L'])+1,   Fmt='{:7d}', comment = '"internal"  internal  DOFs')
-            s += yaml_array('DOF_R_' , np.array(SD_Vars['IDR__'])+1,   Fmt='{:7d}', comment = '"interface&reaction"  DOFs')
-        s += yaml_array('DOF___B', np.array(model.DOFc_Leader  )+1, Fmt='{:7d}',  comment='all         retained  DOFs');
-        s += yaml_array('DOF___F', np.array(model.DOFc_Fixed   )+1, Fmt='{:7d}',  comment='all         fixed     DOFs');
-        s += yaml_array('DOF___L', np.array(model.DOFc_Follower)+1, Fmt='{:7d}',  comment='all         internal  DOFs');
-        s += '\n'
-        s += '#Index map from DOF to nodes\n'
-        s += '#     Node No.,  DOF/Node,   NodalDOF\n'
-        s += 'DOF2Nodes: # {} x 3 (nDOFRed x 3, for each constrained DOF, col1: node index, col2: number of DOF, col3: DOF starting from 1)\n'.format(model.nDOFc)
-        DOFc2Nodes = model.DOFc2Nodes
-        for l in DOFc2Nodes:
-            s +='  - [{:7d},{:7d},{:7d}] # {}\n'.format(l[1]+1, l[2], l[3], l[0]+1 )
-        s += '#     Node_[#]          X_[m]           Y_[m]           Z_[m]       JType_[-]       JDirX_[-]       JDirY_[-]       JDirZ_[-]  JStff_[Nm/rad]\n'
-        s += 'Nodes: # {} x 9\n'.format(len(model.Nodes))
-        for n in model.Nodes:
-            s += '  - [{:7d}.,{:15.3f},{:15.3f},{:15.3f},{:14d}.,   0.000000E+00,   0.000000E+00,   0.000000E+00,   0.000000E+00]\n'.format(nodeID(n.ID), n.x, n.y, n.z, int(n.data['Type']) )
-        s += '#    Elem_[#]    Node_1   Node_2   Prop_1   Prop_2     Type     Length_[m]      Area_[m^2]  Dens._[kg/m^3]        E_[N/m2]        G_[N/m2]       shear_[-]       Ixx_[m^4]       Iyy_[m^4]       Jzz_[m^4]          T0_[N]\n'
-        s += 'Elements: # {} x 16\n'.format(len(model.Elements))
-        for e in model.Elements:
-            I = e.inertias
-            s0='  - [{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:7d}.,{:15.3f},{:15.3f},{:15.3f},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e},{:15.6e}]\n'.format(
-                elemID(e.ID), nodeID(e.nodeIDs[0]), nodeID(e.nodeIDs[1]), propID(e.propIDs[0], e.propset), propID(e.propIDs[1], e.propset), elemType(e.data['Type']), 
-                e.length, e.area, e.rho, e.E, e.G, e.kappa, I[0], I[1], I[2], e.T0)
-            s += s0.replace('e+','E+').replace('e-','E-')
-        s += '#____________________________________________________________________________________________________\n'
-        s += '#User inputs\n'
-        s += '\n'
-        s += '#Number of properties (NProps):{:6d}\n'.format(len(model.NodePropertySets['Beam']))
-        s += '#Prop No         YoungE         ShearG        MatDens          XsecD          XsecT\n'
-        for ip,p in enumerate(model.NodePropertySets['Beam']):
-            s0='#{:8d}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format(p.ID, p['E'],p['G'],p['rho'],p['D'],p['t'])
-            s +=  s0.replace('e+','E+').replace('e-','E-')
-        s +='\n'
-        s += '#No. of Reaction DOFs:{:6d}\n'.format(len(SD_Vars['IDC__']) )
-        s += '#React. DOF_ID    BC\n'
-        s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Fixed' ) for idof in SD_Vars['IDC_F']])
-        s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Free'  ) for idof in SD_Vars['IDC_L']])
-        s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'     Leader') for idof in SD_Vars['IDC_B']])
-        s += '\n\n'
-        s += '#No. of Interface DOFs:{:6d}\n'.format(len(SD_Vars['IDI__']))
-        s += '#Interf. DOF_ID    BC\n'
-        s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'    Fixed' ) for idof in SD_Vars['IDI_F']])
-        s += '\n'.join(['#{:10d}{:10s}'.format(idof+1,'    Leader') for idof in SD_Vars['IDI_B']])
-        s += '\n\n'
-        CM = []
-        from welib.yams.utils import identifyRigidBodyMM
-        for n in model.Nodes:
-            if 'addedMassMatrix' in n.data:
-                mass, J_G, ref2COG = identifyRigidBodyMM(n.data['addedMassMatrix'])
-                CM.append( (n.ID, mass, J_G, ref2COG) )
-        s += '#Number of concentrated masses (NCMass):{:6d}\n'.format(len(CM))
-        s += '#JointCMas           Mass            JXX            JYY            JZZ            JXY            JXZ            JYZ           MCGX           MCGY           MCGZ\n'
-        for cm in CM:
-            s0 = '# {:9.0f}.{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format( nodeID(cm[0]),  cm[1], cm[2][0,0], cm[2][1,1], cm[2][2,2], cm[2][0,1], cm[2][0,2], cm[2][1,2],cm[3][0],cm[3][1],cm[3][2] )
-            s += s0.replace('e+','E+').replace('e-','E-')
-        s += '\n'
-        #s += '#Number of members    18\n'
-        #s += '#Number of nodes per member:     2\n'
-        #s += '#Member I Joint1_ID Joint2_ID    Prop_I    Prop_J           Mass         Length     Node IDs...\n'
-        #s += '#       77        61        60        11        11   1.045888E+04   2.700000E+00       19    18\n'
-        #s += '#____________________________________________________________________________________________________\n'
-        #s += '#Direction Cosine Matrices for all Members: GLOBAL-2-LOCAL. No. of 3x3 matrices=    18\n'
-        #s += '#Member I        DC(1,1)        DC(1,2)        DC(1,3)        DC(2,1)        DC(2,2)        DC(2,3)        DC(3,1)        DC(3,2)        DC(3,3)\n'
-        #s += '#       77  1.000E+00  0.000E+00  0.000E+00  0.000E+00 -1.000E+00  0.000E+00  0.000E+00  0.000E+00 -1.000E+00\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += '#FEM Eigenvectors ({} x {}) [m or rad], full system with reaction constraints (+ Soil K/M + SoilDyn K0)\n'.format(*model.Q.shape)
-        s += yaml_array('Full_Modes', model.Q)
-        s += '#____________________________________________________________________________________________________\n'
-        s += '#CB Matrices (PhiM,PhiR) (reaction constraints applied)\n'
-        s += yaml_array('PhiM', model.Phi_CB[:,:model.nModesCB] ,comment='(CB modes)')
-        s += yaml_array('PhiR', model.Phi_G,  comment='(Guyan modes)')
-        s += '\n'
-        if more:
-            s += '#____________________________________________________________________________________________________\n'
-            s += '# ADDITIONAL DEBUGGING INFORMATION\n'
-            s += '#____________________________________________________________________________________________________\n'
-            s +=  ''
-            e = model.Elements[0]
-            rho=e.rho
-            A = e.area
-            L = e.length
-            t= rho*A*L
-            s0 = '{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format(model.gravity,e.area, e.length, e.inertias[0], e.inertias[1], e.inertias[2], e.kappa, e.E, e.G, e.rho, t)
-            s0 = s0.replace('e+','E+').replace('e-','E-')
-            s += s0
-            s += yaml_array('KeLocal' +str(), model.Elements[0].Ke(local=True))
-
-            for ie,e in enumerate(model.Elements):
-                s += yaml_array('DC' +str(ie+1), e.DCM.transpose())
-                s += yaml_array('Ke' +str(ie+1), e.Ke())
-                s += yaml_array('Me' +str(ie+1), e.Me())
-                s += yaml_array('FGe'+str(ie+1), e.Fe_g(model.gravity))
-                s += yaml_array('FCe'+str(ie+1), e.Fe_o())
-
-                s += yaml_array('KeLocal' +str(ie+1), e.Ke(local=True))
-                s += yaml_array('MeLocal' +str(ie+1), e.Me(local=True))
-                s += yaml_array('FGeLocal'+str(ie+1), e.Fe_g(model.gravity, local=True))
-                s += yaml_array('FCeLocal'+str(ie+1), e.Fe_o(local=True))
-
-            s += '#____________________________________________________________________________________________________\n'
-            e = model.Elements[0]
-            s += yaml_array('Ke', e.Ke(local=True), comment='First element stiffness matrix'); # TODO not in local
-            s += yaml_array('Me', e.Me(local=True), comment='First element mass matrix');
-            s += yaml_array('FGe', e.Fe_g(model.gravity,local=True), comment='First element gravity vector');
-            s += yaml_array('FCe', e.Fe_o(local=True), comment='First element cable pretension');
-            s += '#____________________________________________________________________________________________________\n'
-            s += '#FULL FEM K and M matrices. TOTAL FEM TDOFs:    {}\n'.format(model.nDOF); # NOTE: wrong in SubDyn, should be nDOFc
-            s += yaml_array('K', model.KK, comment='Stiffness matrix');
-            s += yaml_array('M', model.MM, comment='Mass matrix');
-            s += '#____________________________________________________________________________________________________\n'
-            s += '#Gravity and cable loads applied at each node of the system (before DOF elimination with T matrix)\n'
-            s += yaml_array('FG', model.FF_init, comment=' ');
-            s += '#____________________________________________________________________________________________________\n'
-            s += '#Additional CB Matrices (MBB,MBM,KBB) (constraint applied)\n'
-            s += yaml_array('MBB'    , model.MBB, comment='');
-            s += yaml_array('MBM'    , model.MBM[:,:model.nModesCB], comment='');
-            s += yaml_array('CMMdiag', model.CMM, comment='(2 Zeta OmegaM)');
-            s += yaml_array('KBB'    , model.KBB, comment='');
-            s += yaml_array('KMM'    , np.diag(model.KMM), comment='(diagonal components, OmegaL^2)');
-            s += yaml_array('KMMdiag', np.diag(model.KMM)[:model.nModesCB], comment='(diagonal components, OmegaL^2)');
-            s += yaml_array('PhiL'   , model.Phi_CB, comment='');
-            s += 'PhiLOm2-1: # 18 x 18 \n'
-            s += 'KLL^-1: # 18 x 18 \n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += yaml_array('T_red', model.T_c, Fmt = '{:9.2e}', comment='(Constraint elimination matrix)');
-        s += 'AA: # 16 x 16 (State matrix dXdx)\n'
-        s += 'BB: # 16 x 48 (State matrix dXdu)\n'
-        s += 'CC: # 6 x 16 (State matrix dYdx)\n'
-        s += 'DD: # 6 x 48 (State matrix dYdu)\n'
-        s += '#____________________________________________________________________________________________________\n'
-        s += yaml_array('TI', model.T_refPoint,  Fmt = '{:9.2e}',comment='(TP refpoint Transformation Matrix TI)');
-        f.write(s);
+    s += '\n'
+    #s += '#Number of members    18\n'
+    #s += '#Number of nodes per member:     2\n'
+    #s += '#Member I Joint1_ID Joint2_ID    Prop_I    Prop_J           Mass         Length     Node IDs...\n'
+    #s += '#       77        61        60        11        11   1.045888E+04   2.700000E+00       19    18\n'
+    #s += '#____________________________________________________________________________________________________\n'
+    #s += '#Direction Cosine Matrices for all Members: GLOBAL-2-LOCAL. No. of 3x3 matrices=    18\n'
+    #s += '#Member I        DC(1,1)        DC(1,2)        DC(1,3)        DC(2,1)        DC(2,2)        DC(2,3)        DC(3,1)        DC(3,2)        DC(3,3)\n'
+    #s += '#       77  1.000E+00  0.000E+00  0.000E+00  0.000E+00 -1.000E+00  0.000E+00  0.000E+00  0.000E+00 -1.000E+00\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += '#FEM Eigenvectors ({} x {}) [m or rad], full system with reaction constraints (+ Soil K/M + SoilDyn K0)\n'.format(*model.Q.shape)
+    s += yaml_array('Full_Modes', model.Q)
+    s += '#____________________________________________________________________________________________________\n'
+    s += '#CB Matrices (PhiM,PhiR) (reaction constraints applied)\n'
+    s += yaml_array('PhiM', model.Phi_CB[:,:model.nModesCB] ,comment='(CB modes)')
+    s += yaml_array('PhiR', model.Phi_G,  comment='(Guyan modes)')
+    s += '\n'
+    if more:
+        s += '#____________________________________________________________________________________________________\n'
+        s += '# ADDITIONAL DEBUGGING INFORMATION\n'
+        s += '#____________________________________________________________________________________________________\n'
+        s +=  ''
+        e = model.Elements[0]
+        rho=e.rho
+        A = e.area
+        L = e.length
+        t= rho*A*L
+        s0 = '{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}{:15.6e}\n'.format(model.gravity,e.area, e.length, e.inertias[0], e.inertias[1], e.inertias[2], e.kappa, e.E, e.G, e.rho, t)
+        s0 = s0.replace('e+','E+').replace('e-','E-')
+        s += s0
+        s += yaml_array('KeLocal' +str(), model.Elements[0].Ke(local=True))
+
+        for ie,e in enumerate(model.Elements):
+            s += yaml_array('DC' +str(ie+1), e.DCM.transpose())
+            s += yaml_array('Ke' +str(ie+1), e.Ke())
+            s += yaml_array('Me' +str(ie+1), e.Me())
+            s += yaml_array('FGe'+str(ie+1), e.Fe_g(model.gravity))
+            s += yaml_array('FCe'+str(ie+1), e.Fe_o())
+
+            s += yaml_array('KeLocal' +str(ie+1), e.Ke(local=True))
+            s += yaml_array('MeLocal' +str(ie+1), e.Me(local=True))
+            s += yaml_array('FGeLocal'+str(ie+1), e.Fe_g(model.gravity, local=True))
+            s += yaml_array('FCeLocal'+str(ie+1), e.Fe_o(local=True))
+
+        s += '#____________________________________________________________________________________________________\n'
+        e = model.Elements[0]
+        s += yaml_array('Ke', e.Ke(local=True), comment='First element stiffness matrix'); # TODO not in local
+        s += yaml_array('Me', e.Me(local=True), comment='First element mass matrix');
+        s += yaml_array('FGe', e.Fe_g(model.gravity,local=True), comment='First element gravity vector');
+        s += yaml_array('FCe', e.Fe_o(local=True), comment='First element cable pretension');
+        s += '#____________________________________________________________________________________________________\n'
+        s += '#FULL FEM K and M matrices. TOTAL FEM TDOFs:    {}\n'.format(model.nDOF); # NOTE: wrong in SubDyn, should be nDOFc
+        s += yaml_array('K', model.KK, comment='Stiffness matrix');
+        s += yaml_array('M', model.MM, comment='Mass matrix');
+        s += '#____________________________________________________________________________________________________\n'
+        s += '#Gravity and cable loads applied at each node of the system (before DOF elimination with T matrix)\n'
+        s += yaml_array('FG', model.FF_init, comment=' ');
+        s += '#____________________________________________________________________________________________________\n'
+        s += '#Additional CB Matrices (MBB,MBM,KBB) (constraint applied)\n'
+        s += yaml_array('MBB'    , model.MBB, comment='');
+        s += yaml_array('MBM'    , model.MBM[:,:model.nModesCB], comment='');
+        s += yaml_array('CMMdiag', model.CMM, comment='(2 Zeta OmegaM)');
+        s += yaml_array('KBB'    , model.KBB, comment='');
+        s += yaml_array('KMM'    , np.diag(model.KMM), comment='(diagonal components, OmegaL^2)');
+        s += yaml_array('KMMdiag', np.diag(model.KMM)[:model.nModesCB], comment='(diagonal components, OmegaL^2)');
+        s += yaml_array('PhiL'   , model.Phi_CB, comment='');
+        s += 'PhiLOm2-1: # 18 x 18 \n'
+        s += 'KLL^-1: # 18 x 18 \n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += yaml_array('T_red', model.T_c, Fmt = '{:9.2e}', comment='(Constraint elimination matrix)');
+    s += 'AA: # 16 x 16 (State matrix dXdx)\n'
+    s += 'BB: # 16 x 48 (State matrix dXdu)\n'
+    s += 'CC: # 6 x 16 (State matrix dYdx)\n'
+    s += 'DD: # 6 x 48 (State matrix dYdu)\n'
+    s += '#____________________________________________________________________________________________________\n'
+    s += yaml_array('TI', model.T_refPoint,  Fmt = '{:9.2e}',comment='(TP refpoint Transformation Matrix TI)');
+    if filename is not None:
+        with open(filename, 'w') as f:
+            f.write(s)
```

### Comparing `welib-0.0.2/welib/fast/subdyn_sum.py` & `welib-1.0.0/welib/fast/subdyn_sum.py`

 * *Files 18% similar despite different names*

```diff
@@ -16,32 +16,38 @@
 # --------------------------------------------------------------------------------}
 # ---  
 # --------------------------------------------------------------------------------{
 class SubDynModel(FEMModel):
 
     def fromSummaryFile(self, filename):
         # --- Read summary file
-        import yaml
-        with open(filename, 'r', errors="surrogateescape") as fid:
-            data=yaml.load(fid, Loader=yaml.SafeLoader)
-            for k,v in data.items():
-                if isinstance(v,list):
-                    data[k]=np.array(v)
+        from welib.weio.fast_summary_file import FASTSummaryFile
+        data = FASTSummaryFile(filename) 
+        #import yaml
+        #print('Reading yaml...', end='')
+        #with open(filename, 'r', errors="surrogateescape") as fid:
+        #    data=yaml.load(fid, Loader=yaml.SafeLoader)
+        #print('Done')
         #print(data.keys())
+        #for k,v in data.items():
+        #    if isinstance(v,list):
+        #        data[k]=np.array(v)
         DOF2Nodes = data['DOF2Nodes']
-        self.nDOF = data['nDOF_red']
+        self.nDOF_red = data['nDOF_red']
         PhiM      = data['PhiM']
         PhiR      = data['PhiR']
         Nodes     = data['Nodes']
         Elements  = data['Elements']
-        DOFs= np.arange(self.nDOF)
+        DOFs= np.arange(self.nDOF_red)
         # Reindexing with -1
         DOF_L = data['DOF___L'].ravel()-1 # internal DOFs
         DOF_B = data['DOF___B'].ravel()-1 # internal
         DOF_F = data['DOF___F'].ravel()
+
+        # --- TODO merge with subdynSumToGraph(data) in fast_input_file_graph...
         if DOF2Nodes.shape[1]==3:
             DOF2Nodes=np.column_stack((DOFs,DOF2Nodes))
         else:
             DOF2Nodes[:,0]-=1
         DOF2Nodes[:,1]-=1
         Elements[:,0]-=1
         Elements[:,1]-=1
@@ -69,55 +75,86 @@
         #print(self.maxDimension)
 
         DOF_K = np.concatenate((DOF_B,DOF_L))
         maxDisp = self.maxDimension*0.1
 
         # CB modes
         if PhiM is not None:
-            Phi_CB = np.vstack((np.zeros((len(DOF_B),PhiM.shape[1])),PhiM, np.zeros((len(DOF_F),PhiM.shape[1]))))
-            dispCB, posCB, INodes = self.NodesDisp(DOF_K, Phi_CB, maxDisp=maxDisp)
+            Q_CB = np.vstack((np.zeros((len(DOF_B),PhiM.shape[1])),PhiM, np.zeros((len(DOF_F),PhiM.shape[1]))))
+            dispCB, posCB, INodesCB = self.NodesDisp(DOF_K, Q_CB, maxDisp=maxDisp)
 
         # Guyan modes
-        Phi_Guyan = np.vstack((np.eye(len(DOF_B)),PhiR))
-        dispGy, posGy, INodesGy = self.NodesDisp(DOF_K, Phi_Guyan, maxDisp=maxDisp, sortDim=2)
+        Q_GY = np.vstack((np.eye(len(DOF_B)),PhiR))
+        dispGY, posGY, INodesGY = self.NodesDisp(DOF_K, Q_GY, maxDisp=maxDisp, sortDim=2)
+
+
+        # --- FEM Model
+        self.f_G    = data['GY_frequencies'].flatten()
+        self.f_CB   = data['CB_frequencies'].flatten()
+        if PhiM is not None:
+            self.Phi_CB = data['PhiM'] # Not Extended with BC, might need checking
+            self.Q_CB   = Q_CB         # full
+        self.Phi_G = data['PhiR'] # Not Extended, might need checking
+        self.Q_GY  = Q_GY         # full
+
+        # --- Add modes
+        # TODO this is more or less FEMModel.setModes
+        for iMode in range(dispGY.shape[2]):
+            try:
+                self.addMode(displ=dispGY[:,:,iMode], name='GY{:d}'.format(iMode+1), freq=self.f_G[iMode], group='GY')
+            except:
+                raise 
+        for iMode in range(len(self.f_CB)):
+            self.addMode(displ=dispCB[:,:,iMode], name='CB{:d}'.format(iMode+1), freq=self.f_CB[iMode], group='CB') 
 
-        def toDF(pos,disp):
-            columns=['z_[m]','x_[m]','y_[m]']
-            dataZXY=np.column_stack((pos[:,2],pos[:,0],pos[:,1]))
-            disptot=disp.copy()
-            for ishape in np.arange(disp.shape[2]):
-                disptot[:,:,ishape]= pos + disp[:,:,ishape]
-                sMode='Mode{:d}'.format(ishape+1)
-                columns+=[sMode+'x_[m]',sMode+'y_[m]',sMode+'z_[m]']
-            disptot= np.moveaxis(disptot,2,1).reshape(disptot.shape[0],disptot.shape[1]*disptot.shape[2])
-            disp   = np.moveaxis(disp,2,1).reshape(disp.shape[0],disp.shape[1]*disp.shape[2])
-            data = np.column_stack((dataZXY,disptot))
-            df= pd.DataFrame(data = data ,columns = columns)
-
-            disp[np.isnan(disp)]=0
-            data = np.column_stack((dataZXY,disp))
-            dfDisp= pd.DataFrame(data = data ,columns = columns)
-            # remove zero 
-            df2= df.loc[:, (dfDisp !=0).any(axis=0)]
-            return df
+        # --- Store
+        if PhiM is not None:
+            self.dispCB   = dispCB
+            self.posCB    = posCB
+            self.INodesCB = INodesCB
+            self.dfCB = self.toDF(posCB, dispCB)
+        else:
+            self.dfCB = None
 
-        df=toDF(posGy, dispGy)
+        self.dispGY   = dispGY
+        self.posGY    = posGY
+        self.INodesGY = INodesGY
+        self.dfGY     = self.toDF(posGY, dispGY)
 
         try:
             # Full system matrices
             MM        = data['M']
             KK        = data['K']
             self.setFullMatrices(MM,KK)
         except:
-            print('>>> Full mass and stiffness matrices not included in summary file')
+            print('[INFO] Full mass and stiffness matrices not included in summary file')
             pass
-        self.toDataFrame()
+
+    def toDF(self, pos,disp):
+        columns=['z_[m]','x_[m]','y_[m]']
+        dataZXY=np.column_stack((pos[:,2],pos[:,0],pos[:,1]))
+        disptot=disp.copy()
+        for ishape in np.arange(disp.shape[2]):
+            disptot[:,:,ishape]= pos + disp[:,:,ishape]
+            sMode='Mode{:d}'.format(ishape+1)
+            columns+=[sMode+'x_[m]',sMode+'y_[m]',sMode+'z_[m]']
+        disptot= np.moveaxis(disptot,2,1).reshape(disptot.shape[0],disptot.shape[1]*disptot.shape[2])
+        disp   = np.moveaxis(disp,2,1).reshape(disp.shape[0],disp.shape[1]*disp.shape[2])
+        data = np.column_stack((dataZXY,disptot))
+        df= pd.DataFrame(data = data ,columns = columns)
+
+        disp[np.isnan(disp)]=0
+        data = np.column_stack((dataZXY,disp))
+        dfDisp= pd.DataFrame(data = data ,columns = columns)
+        # remove zero 
+        df2= df.loc[:, (dfDisp !=0).any(axis=0)]
+        return df
 
     def toDataFrame(self):
-        dfs={}
+        return {'GY':self.dfGY,'CB':self.dfCB}
 #         Mr, Kr, Phi_G, Phi_CB, f_CB, f_G = self.CraigBampton(Ileader=DOF_B, Ifollow=DOF_L)
 #         print(data['PhiL'])
 
     def NodesDisp(self, IDOF, UDOF, maxDisp=None, sortDim=None):
         DOF2Nodes = self.DOF2Nodes
         INodes = list(np.sort(np.unique(DOF2Nodes[IDOF,1]))) # NOTE: sorted
         nShapes = UDOF.shape[1]
@@ -148,13 +185,29 @@
             disp   = disp[I,:,:]
             pos    = pos[I,:]
 
         return disp, pos, INodes
 
 
 if __name__=='__main__':
+    from welib.fast.subdyn_sum import SubDynModel
+    filename = 'SybDyn-sum-MC-04JAN23.yaml'
+    filename = '../../data/example_files/FASTSum_Pendulum.SD.sum.yaml'
+
     np.set_printoptions(linewidth=500)
     mdl=SubDynModel()
-    mdl.fromSummaryFile('../../data/example_files/FASTSum_Pendulum.SD.sum.yaml')
-    mdl.toJSON('./_out.json')
-    print(mdl)
+    mdl.fromSummaryFile()
+    mdl.toJSON('_OUT.json')
 
+    # --- Lower level functions
+    #from welib.weio.fast_summary_file import FASTSummaryFile
+    #sds = FASTSummaryFile(filename) 
+    #df = sds.toDataFrame(sortDim=2)
+    #print(df)
+    #sds.toJSON()
+    #sds.toGraph().toJSON('_OUT3.json')
+    #df = sds.toDataFrame(sortDim=None)
+
+    #import matplotlib.pyplot as plt
+    #plt.plot(df['z_[m]'], df['GuyanMode1x_[m]'])
+    #plt.plot(df['z_[m]'], df['GuyanMode5x_[m]'])
+    #plt.show()
```

### Comparing `welib-0.0.2/welib/fast/tests/test_elastodyn.py` & `welib-1.0.0/welib/tools/tests/test_curve_fitting.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,300 +1,369 @@
-# --- Common libraries 
-import os
 import unittest
 import numpy as np
-from welib.fast.elastodyn import *
-from welib.yams.utils import skew
-from welib.yams.flexibility import GMBeam, GKBeam, GKBeamStiffnening
-
-MyDir=os.path.dirname(__file__)
-
-
-class TestED(unittest.TestCase):
-    """ See examples/ for more examples """
-
-    def test_ED_rot_params(self):
-        Gravity = 9.80665
-        EDfilename=os.path.join(MyDir,'../../../data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat')
-        #p = bladeParameters(EDfilename, AdjBlMs=1)  # <<<<<<
-        prot,pbld,phub = rotorParameters(EDfilename)
-
-        # --- ElastoDyn Summary file
-        #  Rotor Mass            (kg)       109389.842
-        #  Rotor Inertia         (kg-m^2) 38677040.613
-        #  Mass                  (kg)        17536.614    17536.614    17536.614
-        #  Second Mass Moment    (kg-m^2) 11752352.265 11752352.265 11752352.265
-        #  First Mass Moment     (kg-m)     362132.653   362132.653   362132.653
-        #  Center of Mass        (m)            20.650       20.650       20.650
-        np.testing.assert_almost_equal(prot['RotMass'],        109389.842 , 3)
-        np.testing.assert_almost_equal(prot['RotIner'],      38677040.613 , 3)
-        np.testing.assert_almost_equal(pbld[0]['BldMass'],      17536.614 , 3)
-        np.testing.assert_almost_equal(pbld[0]['SecondMom'], 11752352.265 , 3)
-        np.testing.assert_almost_equal(pbld[0]['FirstMom'] ,   362132.653 , 3)
-        np.testing.assert_almost_equal(pbld[0]['BldCG'] ,           20.650, 3)
-
-
-
-
-    def test_ED_blade_params_NoBldAdj(self):
-        # 
-        # NOTE:  These parameters were obtained for AdjBlMs=1!!!
-        # Kept to avoid redoing all these tests..
-        Gravity = 9.80665
-        EDfilename=os.path.join(MyDir,'../../../data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat')
-        p = bladeParameters(EDfilename, AdjBlMs=1)  # <<<<<<
-        # Physical quantities / Inertias
-        np.testing.assert_almost_equal(p['BldMass'], 16775.66975907849)
-        np.testing.assert_almost_equal(p['FirstMom'], 346419.0832041095)
-        np.testing.assert_almost_equal(p['SecondMom'], 11242397.13082460)
-        np.testing.assert_almost_equal(p['BldCG'], 20.65008957491178)
-
-        # Shape functions
-        np.testing.assert_almost_equal(p['ShapeF1_full'][1:3], np.array([9.537890879514419e-05 ,  1.496964261332097e-03]))
-        np.testing.assert_almost_equal(p['ShapeF1_full'][-3:-1], np.array([7.907408392607156e-01 , 9.302315172663902e-01]))
-        np.testing.assert_almost_equal(p['ddShapeF1_full'][1:3], np.array([ 1.051074892093353e-04,   2.102754797663044e-04]))
-        np.testing.assert_almost_equal(p['ddShapeF1_full'][-3:-1], np.array([ 4.957076482520056e-04,  -9.910176341969626e-05]))
-
-        # Generalized quantities
-        np.testing.assert_almost_equal(p['MBF'][0,0], 884.8557898849025)
-        np.testing.assert_almost_equal(p['MBF'][1,1], 537.0972116447014)
-        np.testing.assert_almost_equal(p['KBF'],   np.array([[   1.669817537559324e+04 , -1.453663035386739e+03], [  -1.453663035386742e+03  , 8.495748847887896e+04]]))
-        np.testing.assert_almost_equal(p['MBE'][0,0], 1368.695198467347)
-        np.testing.assert_almost_equal(p['KBE'][0,0], 66822.08061735689)
-        np.testing.assert_almost_equal(p['KBFCent'][1,1], 3.144387706952399e+03)
-
-        #---  Twisted shape funciton
-        # x/y, BF1/BF2/BE, node, deriv
-        # - Flap 1
-        # Root, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,0,0],0)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,0,1],0)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,0,2],3.200725883815983e-05)
-        # Tip, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,-1,0], 9.910328208697139e-01)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,-1,1], 3.815332774490886e-02)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,-1,2],-4.940445502016021e-04)
-        # Mid, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,9,0],1.400789659935833e-01)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,9,1],1.260777581991000e-02)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,0,9,2],8.191781538881797e-04)
-        # - Edge 1
-        # Root, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,0,0],                     0)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,0,1],                     0)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,0,2], 4.414743766275156e-05)
-        # Tip, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,-1,0],   0.167501776715005)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,-1,1],  0.003946589036490)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,-1,2],                  0)
-        # Mid, all deriv
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,9,0],5.141515067563961e-02)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,9,1],3.261536229664988e-03)
-        np.testing.assert_almost_equal(p['TwistedSF'][0,2,9,2],6.728816969020595e-05)
-
-        # --- AxRedBld
-        #3, 3, ED['BldNodes']+2))
-        np.testing.assert_almost_equal(p['AxRedBld'][:,0,-1], [2.722873037538838e-02,  4.273914168364583e-02,  8.556785740654360e-04])
-        np.testing.assert_almost_equal(p['AxRedBld'][:,0,0],[0,0,0]) 
-        np.testing.assert_almost_equal(p['AxRedBld'][:,0,9],[1.100604990701515e-03, -1.686447688419782e-03 , 1.552531491358490e-05])
-        np.testing.assert_almost_equal(p['AxRedBld'][:,2,-1],[ 8.556785740654360e-04 , 4.524659962852886e-03 , 2.160759559741185e-02])
-        np.testing.assert_almost_equal(p['AxRedBld'][:,2,-2],[ 7.654290347321518e-04 , 3.949211069010193e-03 , 2.018155508430989e-02])
-        np.testing.assert_almost_equal(p['AxRedBld'][:,2,9],[1.552531491358490e-05 , 2.331092957799932e-05 , 2.931333434244318e-03])
-
-        # --- Frequencies
-        np.testing.assert_almost_equal(p['FreqBF'][0,2],0.723649838650248)
-        np.testing.assert_almost_equal(p['FreqBF'][1,2],2.038385218375959)
-        np.testing.assert_almost_equal(p['FreqBE'][0,:], np.array([1.112056253877955, 1.112056253877955, 1.128488446907760]))
-        np.testing.assert_almost_equal(p['CBE']   [0,0],91.32399596067735)
-
-	
-        # --------------------------------------------------------------------------------}
-        # --- Mass Matrix using GM or not
-        # --------------------------------------------------------------------------------{
-#         nq=2
-#         nNodes=n+2
-#         p['Ut'] = np.zeros((nq, 3, nNodes))
-#         p['Vt'] = np.zeros((nq, 3, nNodes))
-#         p['Kt'] = np.zeros((nq, 3, nNodes))
-#         p['U']  = np.zeros((nq, 3, nNodes))
-#         p['V']  = np.zeros((nq, 3, nNodes))
-#         p['K']  = np.zeros((nq, 3, nNodes))
-#         for j,jj,idir,name in zip(range(0,nq), (0,2), (0,1), ('F1','E1')): # direction is x, x, y
-#             p['Ut'][j][0,:] = p['TwistedSF'][0, jj, :, 0]  # x
-#             p['Ut'][j][1,:] = p['TwistedSF'][1, jj, :, 0]  # y
-#             p['Vt'][j][0,:] = p['TwistedSF'][0, jj, :, 1]  # x
-#             p['Vt'][j][1,:] = p['TwistedSF'][1, jj, :, 1]  # y
-#             p['Kt'][j][0,:] = p['TwistedSF'][0, jj, :, 2]  # x
-#             p['Kt'][j][1,:] = p['TwistedSF'][1, jj, :, 2]  # y
-#             p['U'][j][idir,:]  = p['Shape'+name+'_full']  
-#             p['V'][j][idir,:]  = p['dShape'+name+'_full'] 
-#             p['K'][j][idir,:]  = p['ddShape'+name+'_full']
-
-
-        # --- Calling GM/GK Beam with OpenFAST method
-        inertiaAtBladeRoot=True # TODO for loop around that
-        rh = 0 # Hub Radius # TODO make this an option if from blade root or not
-        s_G0 = np.zeros((3, len(p['s_span'])))
-        s_G0[2,:] = p['s_span'] + rh 
-        MM, IT = GMBeam(s_G0, p['s_span'], p['m_full'], p['Ut'], rot_terms=True, method='OpenFAST', main_axis='z', U_untwisted=p['U'], M1=True) 
-        Gr, Ge, Oe, Oe6 = IT['Gr'], IT['Ge'], IT['Oe'], IT['Oe6']
-
-        KK = GKBeam(p['s_span'], p['EI'], p['K'], bOrth=False, method='OpenFAST')
-
-        KKg_SW = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=0, Omega=0, bSelfWeight=True,  bMtop=False, bRot=False, main_axis='z', method='OpenFAST')
-        #KKg_TM = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=0, Omega=0, bSelfWeight=False, bMtop=True, bRot=False, main_axis='z')
-        KKg_Om = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=0, Omega=1, bSelfWeight=False, bMtop=False, bRot=True, main_axis='z', method='OpenFAST')
-
-        # --- Call bladeDerivedParameters for "manual" calculation
-        p = bladeDerivedParameters(p, inertiaAtBladeRoot=inertiaAtBladeRoot)
-#         print('KK\n',KK[6:,6:])
-#         print('KKe\n',p['Ke'])
-#         print('KKg_SW\n',KKg_SW[6:,6:])
-#         print('KKg_Om\n',KKg_Om[6:,6:])
-#         print('KKg_Om\n',p['Kg_Om'])
-
-        # --- TODO TODO TODO TODOs
-        # - compute general centrifugal stiffening tersm in GM/GKBeam
-        # - Update SID/ *parameters functions to use GM/GK beam
-
-#         print('MM',MM[0,0])
-#         print('Ms',p['BldMass'])
-#         print('J\n',p['J'])
-#         print('J\n',MM[3:6,3:6])
-#         print('mdCM_GM\n',MM[3:6,0:3])
-#         print('mdCM_OF\n',-skew(p['mdCM']))
-#         print('me_GM\n',MM[6:,6:])
-#         print('me_OF\n',p['Me'])
-#         print('Ct_GM\n',MM[0:3,6:])
-#         print('Ct_OF\n',p['Ct'].T)
-#         print('Cr_GM\n',MM[3:6,6:])
-#         print('Cr_OF\n',p['Cr'].T)
-#         print('OeM1_GM\n',IT['Oe6M1'])
-#         print('OeM1_OF\n',p['OeM1'])
-#         for j in np.arange(nq):
-#             print('')
-#             print('Oe6 GM{}\n'.format(j), Oe6[j])
-#             print('Oe6 OF{}\n'.format(j), p['Oe6'][j])
-        #for j in np.arange(nq):
-        #    print('')
-        #    print('mdCM1_GM {}\n'.format(j),IT['mdCM1'][:,j])
-        #    print('mdCM1_OF {}\n'.format(j), p['mdCM1'][:,j])
-        # --- Compare both "manual" and GM/GKBeam approach
-        np.testing.assert_almost_equal(MM[0,0,]           , p['BldMass'])
-        np.testing.assert_almost_equal(MM[3:6,3:6]       ,  p['J'])
-        np.testing.assert_almost_equal(MM[3:6,0:3]       ,  skew(p['mdCM']))
-        np.testing.assert_almost_equal(np.diag(MM[6:,6:]),  np.diag(p['Me']))
-        np.testing.assert_almost_equal(MM[0:3,6:],          p['Ct'].T)
-        np.testing.assert_almost_equal(MM[3:6,6:],          p['Cr'].T)
-        np.testing.assert_almost_equal(IT['Oe6_M1'] , p['Oe_M1'])
-        np.testing.assert_almost_equal(IT['mdCM_M1'], p['mdCM_M1'])
-        np.testing.assert_almost_equal(KK[6:,6:]  , p['Ke'])
-
-
-        # --------------------------------------------------------------------------------}
-        # --- Using inertia at rotor center
-        # --------------------------------------------------------------------------------{
-        # --- Calling GM Beam with OpenFAST method
-        inertiaAtBladeRoot=False
-        rh = p['HubRad'] # Hub Radius # TODO make this an option if from blade root or not
-        s_G0 = np.zeros((3, len(p['s_span'])))
-        s_G0[2,:] = p['s_span'] + rh 
-        MM, IT = GMBeam(s_G0, p['s_span'], p['m_full'], p['Ut'], rot_terms=True, method='OpenFAST', main_axis='z', U_untwisted=p['U'], M1=True) 
-        Gr, Ge, Oe, Oe6 = IT['Gr'], IT['Ge'], IT['Oe'], IT['Oe6']
-        # --- Call bladeDerivedParameters for "manual" calculation
-        p = bladeDerivedParameters(p, inertiaAtBladeRoot=inertiaAtBladeRoot)
-        # --- Compare both "manual" and GMBeam approach
-        np.testing.assert_almost_equal(MM[0,0,]           , p['BldMass'])
-        np.testing.assert_almost_equal(MM[3:6,3:6]       ,  p['J'])
-        np.testing.assert_almost_equal(MM[3:6,0:3]       ,  skew(p['mdCM']))
-        np.testing.assert_almost_equal(np.diag(MM[6:,6:]),  np.diag(p['Me']))
-        np.testing.assert_almost_equal(MM[0:3,6:],          p['Ct'].T)
-        np.testing.assert_almost_equal(MM[3:6,6:],          p['Cr'].T)
-        np.testing.assert_almost_equal(IT['Oe6_M1'], p['Oe_M1'])
-        np.testing.assert_almost_equal(IT['mdCM_M1'], p['mdCM_M1'])
+from welib.tools.curve_fitting import *
+from welib.tools.curve_fitting import sinusoid
+
+class TestFitting(unittest.TestCase):
+
+    # --------------------------------------------------------------------------------}
+    # --- Testing of high level functions  
+    # --------------------------------------------------------------------------------{
+    def test_fit_gaussian(self):
+        mu,sigma,y0=0.5,1.2,10
+        x=np.linspace(0,1,10)
+        y=gaussian_w_offset(x,(mu,sigma,y0))
+        y_fit, pfit, fitter = fit_gaussian(x, y, offset=True)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(mu   ,fitter.model['coeffs']['mu'])
+        np.testing.assert_almost_equal(sigma,fitter.model['coeffs']['sigma'])
+        np.testing.assert_almost_equal(y0   ,fitter.model['coeffs']['y0'])
+
+    def test_fit_gaussian(self):
+        mu,sigma,y0=0.5,1.2,10
+        x=np.linspace(0,1,10)
+        y=gaussian_w_offset(x,(mu,sigma,y0))
+        y_fit, pfit, fitter = fit_gaussian(x, y, offset=True)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(mu   ,fitter.model['coeffs']['mu'])
+        np.testing.assert_almost_equal(sigma,fitter.model['coeffs']['sigma'])
+        np.testing.assert_almost_equal(y0   ,fitter.model['coeffs']['y0'])
+
+    def test_fit_sinusoid(self):
+        A     = 101
+        B     = -200.5
+        omega = 10
+        phi   = np.pi/3
+        x=np.linspace(0,10,300)
+        y=sinusoid(x,(A,omega,phi,B))  #+ np.random.normal(0, 0.1, len(x))
+        y_fit, pfit, fitter = fit_sinusoid(x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(A    ,fitter.model['coeffs']['A'],1)
+        np.testing.assert_almost_equal(B    ,fitter.model['coeffs']['B'])
+        np.testing.assert_almost_equal(omega,fitter.model['coeffs']['omega'])
+        np.testing.assert_almost_equal(phi  ,fitter.model['coeffs']['phi'])
+
+    def test_fit_polynomial(self):
+        x=np.linspace(0,1,10)
+        y=x**2
+        exponents=[0,1,2]
+        y_fit, pfit, fitter = fit_polynomial(x, y, exponents=exponents)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(1 , fitter.model['coeffs']['c'])
+        np.testing.assert_almost_equal(0 , fitter.model['coeffs']['a'])
+
+        y_fit, pfit, fitter = fit_polynomial(x, y, order=3)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(1 , fitter.model['coeffs']['b'])
+        np.testing.assert_almost_equal(0 , fitter.model['coeffs']['a'])
+
+    # --------------------------------------------------------------------------------}
+    # --- Testing of predefined models
+    # --------------------------------------------------------------------------------{
+    def test_gaussian(self):
+        mu,sigma=0.5,1.2
+        x=np.linspace(0,1,10)
+        y=gaussian(x,(mu,sigma))
+        y_fit, pfit, fitter = model_fit('predef: gaussian', x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(mu   ,fitter.model['coeffs']['mu'])
+        np.testing.assert_almost_equal(sigma,fitter.model['coeffs']['sigma'])
+
+    def test_gaussian_w_offset(self):
+        mu,sigma,y0=0.5,1.2,10
+        x=np.linspace(-0,1,10)
+        y=gaussian_w_offset(x,(mu,sigma,y0))
+        y_fit, pfit, fitter = model_fit('predef: gaussian-yoff', x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(mu   ,fitter.model['coeffs']['mu'])
+        np.testing.assert_almost_equal(sigma,fitter.model['coeffs']['sigma'])
+        np.testing.assert_almost_equal(y0   ,fitter.model['coeffs']['y0'])
+
+    def test_powerlaw_alpha(self):
+        u_ref,z_ref,alpha=20,12,0.12
+        x = np.linspace(0,1,10)
+        y=powerlaw_all(x,(alpha,u_ref,z_ref))
+
+        fun_kwargs = {'u_ref':u_ref,'z_ref':z_ref}
+        y_fit, pfit, fitter = model_fit('predef: powerlaw_alpha', x, y, p0=(0.1), **fun_kwargs)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(alpha ,fitter.model['coeffs']['alpha'])
+
+    def test_powerlaw_u_alpha(self):
+        u_ref,z_ref,alpha=10,12,0.12
+        x = np.linspace(0,1,10)
+        y=powerlaw_all(x,(alpha,u_ref,z_ref,alpha))
+
+        fun_kwargs = {'z_ref':z_ref}
+        y_fit, pfit, fitter = model_fit('predef: powerlaw_u_alpha', x, y, **fun_kwargs)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(alpha ,fitter.model['coeffs']['alpha'])
+        np.testing.assert_almost_equal(u_ref ,fitter.model['coeffs']['u_ref'])
+
+#     def test_powerlaw_all(self):
+#         u_ref,z_ref,alpha=10,12,0.12
+#         x = np.linspace(0,1,10)
+#         y=powerlaw_all(x,(alpha,u_ref,z_ref,alpha))
+# 
+#         y_fit, pfit, fitter = model_fit('predef: powerlaw_all', x, y)
+#         np.testing.assert_array_almost_equal(y,y_fit)
+#         np.testing.assert_almost_equal(alpha ,fitter.model['coeffs']['alpha'])
+# # NOTE: cannot test for u_ref or z
+
+    def test_expdecay(self):
+        A,k,B=0.5,1.2,10
+        x=np.linspace(0,1,10)
+        y=expdecay(x,(A,k,B))
+        y_fit, pfit, fitter = model_fit('predef: expdecay', x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(A,fitter.model['coeffs']['A'])
+        np.testing.assert_almost_equal(k,fitter.model['coeffs']['k'])
+        np.testing.assert_almost_equal(B,fitter.model['coeffs']['B'])
+
+    def test_weibull(self):
+        A, k = 10, 2.3,
+        x=np.linspace(0.01,1,10)
+        y=weibull_pdf(x,(A,k))
+        y_fit, pfit, fitter = model_fit('predef: weibull_pdf', x, y)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(A,fitter.model['coeffs']['A'],5)
+        np.testing.assert_almost_equal(k,fitter.model['coeffs']['k'])
+
+    # --------------------------------------------------------------------------------}
+    # --- Testing of Predefined fitters 
+    # --------------------------------------------------------------------------------{
+    def test_secondorder_impulse(self):
+        A, omega0, zeta, B, t0 = 2, 2, 0.01, 100, 10
+        x=np.linspace(0,50,1000)
+        y=secondorder_impulse(x,(A,omega0, zeta, B, t0)) #0* + np.random.normal(0, 0.1, len(x))
+        #y_fit, pfit, fitter = model_fit('predef: secondorder_impulse', x, y)
+        y_fit, pfit, fitter = model_fit('fitter: secondorder_impulse', x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(omega0   ,fitter.model['coeffs']['omega'])
+        np.testing.assert_almost_equal(zeta     ,fitter.model['coeffs']['zeta'])
+
+    def test_secondorder_step(self):
+        A, omega0, zeta, B, t0 = 2, 2, 0.8, 100, 10
+        x=np.linspace(0,50,1000)
+        y=secondorder_step(x,(A,omega0, zeta, B, t0)) #0* + np.random.normal(0, 0.1, len(x))
+        #y_fit, pfit, fitter = model_fit('predef: secondorder_step', x, y)
+        y_fit, pfit, fitter = model_fit('fitter: secondorder_step', x, y)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(omega0   ,fitter.model['coeffs']['omega'])
+        np.testing.assert_almost_equal(zeta     ,fitter.model['coeffs']['zeta'])
+
+    def test_polycont(self):
+        k = 2.0
+        x = np.linspace(0,1,10)
+        y = k * x**3
+        y_fit, pfit, fitter = model_fit('fitter: polynomial_continuous', x, y, order=3)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(k ,fitter.model['coeffs']['a'])
+        np.testing.assert_almost_equal(0 ,fitter.model['coeffs']['b'])
+        np.testing.assert_almost_equal(0 ,fitter.model['coeffs']['c'])
+        np.testing.assert_almost_equal(0 ,fitter.model['coeffs']['d'])
+
+    def test_polydisc(self):
+        exponents=[0,3,5]
+        a,b,c = 2.0, 3.0, 4.0
+        x = np.linspace(0,1,10)
+        y = a + b*x**3 + c*x**5
+        y_fit, pfit, fitter = model_fit('fitter: polynomial_discrete', x, y, exponents=exponents)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(a ,fitter.model['coeffs']['a'])
+        np.testing.assert_almost_equal(b ,fitter.model['coeffs']['b'])
+        np.testing.assert_almost_equal(c ,fitter.model['coeffs']['c'])
+
+    def test_sinusoid(self):
+        A     = 101
+        B     = -200.5
+        omega = 10
+        phi   = np.pi/3
+        x=np.linspace(0,10,300)
+        y=sinusoid(x,(A,omega,phi,B)) # + np.random.normal(0, 0.1, len(x))
+        y_fit, pfit, fitter = model_fit('fitter: sinusoid', x, y, physical=False)
+        #fitter.plot(); import matplotlib.pyplot as plt; plt.show()
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(A    ,fitter.model['coeffs']['A'],1)
+        np.testing.assert_almost_equal(B    ,fitter.model['coeffs']['B'])
+        np.testing.assert_almost_equal(omega,fitter.model['coeffs']['omega'])
+        np.testing.assert_almost_equal(phi  ,fitter.model['coeffs']['phi'])
+
+    def test_gentorque(self):
+        pass # TODO
+#         GBRatio= 27.5647     #; % Gearbox ratio (-)
+#         SpdGenOn  = 14*GBRatio#
+#         RtGnSp = 1207.61    # % Rated generator speed for simple variable-speed generator control (HSS side) (rpm) 
+#         RtTq   = 1790.49    # % Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) (N-m) 
+#         Rgn2K  = 0.0004128  # % Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) (N-m/rpm^2) 
+#         SlPc   = 6          # % Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control (%) 
+# #         x=np.linspace(300,1500,100)
+#         x=np.linspace(300,1000,100)
+#         y=gentorque(x, (RtGnSp, RtTq  , Rgn2K , SlPc , SpdGenOn))
+# 
+#         bounds='RtGnSp=(1200,1300) , RtTq=(1500,1800), Rgn2K=(0.0,0.01) ,SlPc=(0,20) , SpdGenOn=(10,500)'
+#         p0 = [1250, 1700,0.001, 10, 50]
+#         y_fit, pfit, fitter = model_fit('fitter: gentorque', x, y)
+# 
+#         y_fit, pfit, fitter = model_fit('predef: gentorque', x, y, bounds=bounds, p0=p0)
+# #         np.testing.assert_array_almost_equal(y,y_fit)
+#         print(fitter)
+#         import matplotlib.pyplot as plt
+# 
+#         fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+#         fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+#         ax.plot(x, y     ,'o', label='')
+#         ax.plot(x, y_fit ,'-', label='')
+#         ax.plot(x, fitter.model['fitted_function'](x) ,'.', label='')
+#         ax.set_xlabel('')
+#         ax.set_ylabel('')
+#         ax.legend()
+#         ax.tick_params(direction='in')
+#         plt.show()
+
+
+    # --------------------------------------------------------------------------------}
+    # --- Testing of user models
+    # --------------------------------------------------------------------------------{
+    def test_evalpoly(self):
+        exponents=[0,3,5]
+        a,b,c = 2.0, 3.0, 4.0
+        x = np.linspace(0,1,10)
+        y = a + b*x**3 + c*x**5
+        y_fit, pfit, fitter = model_fit('eval: {a} + {b}*x**3 + {c}*x**5', x, y)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(a ,fitter.model['coeffs']['a'])
+        np.testing.assert_almost_equal(b ,fitter.model['coeffs']['b'])
+        np.testing.assert_almost_equal(c ,fitter.model['coeffs']['c'])
+
+    def test_evalpowerlaw(self):
+        u_ref,z_ref,alpha=10,12,0.12
+        x = np.linspace(0,1,10)
+        y=powerlaw_all(x,(alpha,u_ref,z_ref))
+        y_fit, pfit, fitter = model_fit('eval: {u_ref}*(x/{z_ref})**{alpha}', x, y, p0=(8,9,0.1), bounds=(0.001,100))
+        np.testing.assert_array_almost_equal(y,y_fit)
+
+    def test_lowlevelpoly(self):
+        x=np.linspace(0,1,10)
+        y=x**2
+        exponents=[0,1,2]
+        y_fit, pfit, model = fit_polynomial_discrete(x, y, exponents)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(1 , model['coeffs']['c'])
+        np.testing.assert_almost_equal(0 , model['coeffs']['a'])
+
+        y_fit, pfit, model = fit_polynomial_continuous(x, y, 3)
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(1 , model['coeffs']['b'])
+        np.testing.assert_almost_equal(0 , model['coeffs']['a'])
+
+    def test_lowlevelpowerlaw(self):
+        u_ref,z_ref,alpha=10,12,0.12
+        x = np.linspace(0,1,10)
+        y=powerlaw_all(x,(alpha,u_ref,z_ref))
+
+        y_fit, pfit, model = fit_powerlaw_u_alpha(x, y, z_ref=z_ref, p0=(9,0.1))
+        np.testing.assert_array_almost_equal(y,y_fit)
+        np.testing.assert_almost_equal(alpha , model['coeffs']['alpha'])
+        np.testing.assert_almost_equal(u_ref , model['coeffs']['u_ref'])
+
+#     def test_debug(self):
+#         # --- Try Gaussian
+#         x=np.linspace(0,1,10)
+#         y=gaussian(x,(0.5,1.2))
+#         y_fit, pfit, fitter = model_fit('predef: gaussian', x, y) #, p0=(0,1))
+# #         fitter = ModelFitter('eval: {a}*(1.0/{b}+2/0)**{c}', x, y, p0=(8,9,0.1))
+# #         fitter = ModelFitter('eval: {a}/x', x, y, p0=(8,9,0.1))
 # 
+#         # --- Plot 
+#         y_fit=fitter.data['y_fit']
+#         print(fitter)
+# 
+#         import matplotlib.pyplot as plt
+#         fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+#         fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+#         ax.plot(x, y     ,'o', label='')
+#         ax.plot(x, y_fit ,'-', label='')
+#         ax.plot(x, fitter.model['fitted_function'](x) ,'.', label='')
+#         ax.set_xlabel('')
+#         ax.set_ylabel('')
+#         ax.legend()
+#         ax.tick_params(direction='in')
+#         plt.show()
+
+    def test_extract_var(self):
+        var, _ = extract_variables('{a}*x + {b}')
+        self.assertEqual(var,['a','b'])
+
+        var, _ = extract_variables('{BB}*x + {a}*{BB}')
+        self.assertEqual(var,['BB','a'])
+
+        var, _ = extract_variables('{a}*x + {{b}}') #< TODO Won't work
+        #self.assertEqual(var,['a','b'])
+
+    def test_key_tuples(self):
+        self.assertEqual(extract_key_tuples('a=(1,2)'),{'a':(1,2)})
+
+        self.assertEqual(extract_key_tuples('a=(1, 2),b =(inf,0),c= ( -inf , 0.3e+10)'),{'a':(1,2),'b':(inf,0),'c':(-inf,0.3e+10)})
+
+    def test_key_num(self):
+        self.assertEqual(extract_key_num('a=2'),OrderedDict({'a':2}))
+        self.assertEqual(extract_key_num('all=0.1,b =inf, c= -0.3e+10'),OrderedDict({'all':0.1,'b':inf,'c':-0.3e+10}))
+
+    def test_key_misc(self):
+        self.assertEqual(extract_key_miscnum('a=2'),{'a':2})
+
+        #np.testing.assert_almost_equal(d['a'],(2,3))
+        d=extract_key_miscnum('a=(2,3)')
+        self.assertEqual(d['a'],(2,3))
+        d=extract_key_miscnum('a=[2,3]')
+        np.testing.assert_almost_equal(d['a'],[2,3])
+
+        d=extract_key_miscnum('a=[2,3],b=3,c=(0,)')
+        np.testing.assert_almost_equal(d['a'],[2,3])
+        self.assertEqual(d['b'],3)
+        self.assertEqual(d['c'],(0,))
 
 
-    def test_ED_tower_params(self):
-        EDfilename=os.path.join(MyDir,'../../../data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat')
-        RotMass = 107107.00927723547
-        Gravity = 9.80665
-        p = towerParameters(EDfilename, RotMass=RotMass, gravity=Gravity)
-
-        # Physical quantities / Inertias
-        np.testing.assert_almost_equal(p['TwrMass'], 347460.2316000000)
-        np.testing.assert_almost_equal(p['TwrTpMass'], 347107.0092772355)
-
-        # Shape functions nModes x nNodes x nDeriv
-        np.testing.assert_almost_equal(p['TwrFASF'][0,-3:, 0],  [0.871714585606445  ,0.958488717049806  ,1.000000000000000])
-        np.testing.assert_almost_equal(p['TwrSSSF'][1,:4, 1], [0, -0.065390448129370,-0.175841634092733,-0.263419614469624])
-
-        # Generalized quantities
-        np.testing.assert_almost_equal(np.diag(p['MTFA'])/1e6,np.array([4.010392552595473e+05, 2.755960009968935e+07])/1e6-p['TwrTpMass']/1e6)
-        np.testing.assert_almost_equal(np.diag(p['MTSS'])/1e6,np.array([4.008128638209492e+05, 3.558329856444363e+07])/1e6-p['TwrTpMass']/1e6)
-        np.testing.assert_almost_equal(       (p['KTFA'])/1e6, np.array([[1.910902930730452e+06   ,2.908366961340314e+06],[2.908366961340315e+06   ,1.024457413318486e+10]])/1e6)
-        np.testing.assert_almost_equal(       (p['KTSS'])/1e6, np.array([[1.838181636362126e+06  , 5.692201925965283e+06],[  5.692201925965278e+06 ,  1.319779713916086e+10]])/1e6)
-        np.testing.assert_almost_equal(np.diag(p['KTFAGrav']),[ 1.066694734234754e+03 , 1.169976720444022e+06])
-        np.testing.assert_almost_equal(np.diag(p['KTSSGravTT']), [1.491565303636175e-02 , 1.838391204221678e+01])
-
-        np.testing.assert_almost_equal(p['AxRedTFA'][0,0,-3:],[1.158577163756421e-02,1.332102574930896e-02,1.417295499349627e-02])
-
-        # Frequencies
-        np.testing.assert_almost_equal(p['FreqTSS'], np.array([[0.931115438458394 , 0.346445103037537], [3.080181973131150 , 3.074014122773748]]))
-        np.testing.assert_almost_equal(p['CTFA'], np.array([[6.420569660348690e+03  , 2.997894941172623e+03],[9.772015298550068e+03,1.055993187124818e+07]]))
-
-        # --------------------------------------------------------------------------------}
-        # --- Mass Matrix using GM or not
-        # --------------------------------------------------------------------------------{
-        from welib.yams.flexibility import GMBeam, GKBeam
-        # --- Call bladeDerivedParameters for "manual" calculation
-        p = towerDerivedParameters(p)
-
-        # --- Calling GM/GK Beam with OpenFAST method
-        s_G0 = np.zeros((3, len(p['s_span'])))
-        s_G0[2,:] = p['s_span']
-        MM, IT = GMBeam(s_G0, p['s_span'], p['m_full'], p['U'], rot_terms=True, method='OpenFAST', main_axis='z', M1=True) 
-        Gr, Ge, Oe, Oe6 = IT['Gr'], IT['Ge'], IT['Oe'], IT['Oe6']
-
-        KK = GKBeam(p['s_span'], p['EI'], p['K'], bOrth=False, method='OpenFAST')
-        Mtop = p['TwrTpMass']
-        KKg_SW = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=0, Omega=0, bSelfWeight=True,  bMtop=False, bRot=False, main_axis='z')
-        KKg_TM = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=1, Omega=0, bSelfWeight=False, bMtop=True, bRot=False, main_axis='z')
-        #KKg_Om = GKBeamStiffnening(p['s_span'], p['V'], Gravity, p['m_full'], Mtop=0, Omega=1, bSelfWeight=False, bMtop=False, bRot=True, main_axis='z')
-
-        # --- 
-#         print('KKg_SW\n',KKg_SW[6:,6:])
-#         print('KKg_SW\n',p['Kg_SW'])
-#         print('KKg_TM\n',KKg_TM[6:,6:])
-#         print('KKg_TM\n',p['Kg_TM'])
-#         print('Ke\n',KK[6:,6:])
-#         print('Ke\n',p['Ke'])
-
-#         print('MM',MM[0,0])
-#         print('Ms',p['TwrMass'])
-#         print('J\n',p['J'])
-#         print('J\n',MM[3:6,3:6])
-#         print('mdCM_GM\n',MM[3:6,0:3])
-#         print('mdCM_OF\n',p['mdCM'])
-#         print('me_GM\n',MM[6:,6:])
-#         print('me_OF\n',p['Me'])
-#         print('Ct_GM\n',MM[0:3,6:])
-#         print('Ct_OF\n',p['Ct'].T)
-#         print('Cr_GM\n',MM[3:6,6:])
-#         print('Cr_OF\n',p['Cr'].T)
-
-        # --- Compare both "manual" and GMBeam approach
-        np.testing.assert_almost_equal(MM[0,0,]          , p['TwrMass'])
-        np.testing.assert_almost_equal(MM[3:6,3:6]/1e6   , p['J']/1e6)
-        np.testing.assert_almost_equal(MM[3:6,0:3]       , skew(p['mdCM']))
-        np.testing.assert_almost_equal(MM[6:,6:]         , p['Me'])
-        np.testing.assert_almost_equal(MM[0:3,6:],         p['Ct'].T)
-        np.testing.assert_almost_equal(MM[3:6,6:],         p['Cr'].T)
+if __name__ == '__main__':
+    #TestFitting().test_sinusoid()
+    #TestFitting().test_secondorder_step()
+    unittest.main()
 
-        np.testing.assert_almost_equal(KK[6:,6:]/1e6,         p['Ke']/1e6)
 
 
 
+    ## --- Generate file for testing
+    #import welib.system.firstorder as fo
+    #import welib.system.secondorder as so
+    #m      = 250.0              # system mass
+    #k      = 40.0               # spring constant
+    #omega0 = np.sqrt(k/m)
+    #T0     = 2*np.pi/omega0
+    #b      = 1/m                # NOTE: should be 1/m for a mechanical system
+
+    #time = np.linspace(0*T0,10*T0,10001) # time span # Convolution needs enough time steps
+    #t0  = 2*T0     # initial time where input starts (for simple inputs)
+    #A   = 3         # amplitude for all simple inputs
+    #T   = 2*T0   # for hat
+
+    #zeta   = 0.01
+    #x_d1 = so.impulse_response(time, omega0, zeta, b=b, t0=t0, A=A, both=True)
+    #x_s1 = so.step_response   (time, omega0, zeta, b=b, t0=t0, A=A, both=True)
+    #zeta   = 0.7
+    #x_d2 = so.impulse_response(time, omega0, zeta, b=b, t0=t0, A=A, both=True)
+    #x_s2 = so.step_response   (time, omega0, zeta, b=b, t0=t0, A=A, both=True)
 
+    #M=np.column_stack((time,x_d1[0]+100,-x_d1[1],x_d2[0]-1000,x_d2[1], x_s1[0]+100, -x_s1[1], x_s2[0]-20,x_s2[1]))
+    #np.savetxt('../TestFitSystem.csv',M,header='x,soi_z1,soi_z1_d,soi_z2,soi_z2_d,sos_z1,sos_z1_d,sos_z2,sos_z2_d',delimiter=',')
 
-if __name__ == '__main__':
-    unittest.main()
```

### Comparing `welib-0.0.2/welib/fast/tests/test_hydrodyn.py` & `welib-1.0.0/welib/fast/tests/test_hydrodyn.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/tests/test_mesh.py` & `welib-1.0.0/welib/fast/tests/test_mesh.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/fast/tests/test_run_Examples.py` & `welib-1.0.0/welib/vortilib/elements/tests/test_run_Examples.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,20 +14,24 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
-        import matplotlib.pyplot as plt
-        print('\n--------------------------------------------------------------')
+        files = glob.glob(os.path.join(MyDir,'../examples/[_a-zA-Z0-9]*.py'))
         for f in files:
+            print('\n--------------------------------------------------------------')
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+
+        try:
+            import matplotlib.pyplot as plt
+            plt.close('all')
+        except:
+            pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/hydro/_spectral.py` & `welib-1.0.0/welib/hydro/_spectral.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/examples/Ex1_WaveKinematics.py` & `welib-1.0.0/welib/hydro/examples/Ex1_WaveKinematics.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/examples/Ex2_Jonswap_spectrum.py` & `welib-1.0.0/welib/hydro/examples/Ex2_Jonswap_spectrum.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/examples/Ex3_WaveTimeSeries.py` & `welib-1.0.0/welib/hydro/examples/Ex3_WaveTimeSeries.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/examples/Ex4_WaveLoads.py` & `welib-1.0.0/welib/hydro/examples/Ex4_WaveLoads.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/examples/README.md` & `welib-1.0.0/welib/hydro/examples/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/hydrostat.py` & `welib-1.0.0/welib/hydro/hydrostat.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,21 +21,23 @@
      - A_{0}: undisplaced waterplane area of platform (m^2)
      - V_{0}: undisplaced volume of platform (m^3)
     """
     if z1<z2:
         raise Exception('z1 should be above z2')
     if z1<0:
         # Fully submerged
+        ztop = z1
         A0=0
-        h=z1-z2 # submerged height
     else:
-        h  = -z2        # submerged height
+        # Partially submerged
+        ztop = 0 
         A0 = np.pi*R**2 # undisplaced waterplane area of platform (m^2)
 
-    V0 = np.pi*R**2*h         # undisplaced volume of platform (m^3)
-    z_b = h/2         # coordinates of the center of buoyancy of the undisplaced platform (m)
+    h   = ztop-z2      # submerged height
+    z_b = (ztop+z2)/2  # coordinates of the center of buoyancy of the undisplaced platform (m)
+    V0  = np.pi*R**2*h # undisplaced volume of platform (m^3)
 
     K=np.zeros((6,6))
     K[2,2] = rho * g * A0
     K[3,3] = rho * g * A0 * R**2/4 + rho*g*V0*z_b- m_mg * g * z_mg - m_f *g *z_f
     K[4,4] = K[3,3]
     return K
```

### Comparing `welib-0.0.2/welib/hydro/morison.py` & `welib-1.0.0/welib/hydro/morison.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/spectra.py` & `welib-1.0.0/welib/hydro/spectra.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/tests/test_morison.py` & `welib-1.0.0/welib/hydro/tests/test_morison.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/tests/test_run_Examples.py` & `welib-1.0.0/welib/kalman/tests/test_run_Examples.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,20 +14,23 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z0-9_]*.py'))
-        import matplotlib.pyplot as plt
+        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/hydro/tests/test_spectra.py` & `welib-1.0.0/welib/hydro/tests/test_spectra.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/tests/test_wavekin.py` & `welib-1.0.0/welib/hydro/tests/test_wavekin.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/tools.py` & `welib-1.0.0/welib/hydro/tools.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/hydro/wavekin.py` & `welib-1.0.0/welib/hydro/wavekin.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/TN.py` & `welib-1.0.0/welib/kalman/TN.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,14 +1,20 @@
+""" 
+Kalman filter model for "Tower Nacelle Shaft" (based on yams TNSB)"
+
+"""
+
 import numpy as np
 from .kalman import *
 from .kalmanfilter import KalmanFilter
 from .filters import moving_average
+from welib.ws_estimator.tabulated import TabulatedWSEstimator
 from welib.yams.TNSB_FAST import FASTmodel2TNSB
 
-from welib.ws_estimator.tabulated import TabulatedWSEstimator
+
 import welib.fast.fastlib as fastlib
 import welib.weio as weio
 
 DEFAULT_COL_MAP={
   ' ut1    ' : ' TTDspFA_[m]                   ' ,
   ' psi    ' : ' {Azimuth_[deg]} * np.pi/180   ' , # [deg] -> [rad]
   ' ut1dot ' : ' NcIMUTVxs_[m/s]               ' ,
@@ -66,16 +72,16 @@
         if nShapes_twr==1:
             # TODO aerodamping
             WT.DD      = WT.DD*3.5 # increased damping to account for aero damping
         print(WT)
         KF.WT=WT
 
         # --- Creating a wind speed estimator (reads tabulated aerodynamic data)
-        KF.wse = TabulatedWSEstimator(fst_file=FstFile)
-        KF.wse.load_files(base=base,suffix='')
+        KF.wse = TabulatedWSEstimator(fstFile=FstFile)
+        KF.wse.loadFromBasename(basename=base,suffix='')
         print(KF.wse)
         # --- Building continuous and discrete state matrices
         M,C,K = WT.MM, WT.DD, WT.KK
         Xx,Xu,Yx,Yu = BuildSystem_Linear(M,C,K,Ya,Yv,Yq,Fp=Fp,Pp=Pp,Yp=Yp,Yu=Yu,Method='augmented_first_order')
         KF.setMat(Xx,Xu,Yx,Yu)
 
 
@@ -123,63 +129,64 @@
 
     def timeLoop(KF):
         # --- Initial conditions
         x = KF.initFromClean()
         P = KF.P
 
         for it in range(0,KF.nt-1):    
+            t = it*KF.dt
             # --- "Measurements"
-            y  = KF.Y[:,it]
+            y  = KF.Y.iloc[it,:].values
 
             # --- KF predictions
-            u=KF.U_clean[:,it]
+            u=KF.U_clean.iloc[it,:].values
             x,P,_ = KF.estimateTimeStep(u,y,x,P,KF.Q,KF.R)
 
             # --- Estimate thrust and WS - Non generic code
             WS0       = x[KF.iX['WS']]
-            pitch     = y[KF.iY['pitch']]
+            pitch     = y[KF.iY['pitch']]*180/np.pi # deg
             Qaero_hat = x[KF.iX['Qaero']]
             omega     = x[KF.iX['omega']]
-            WS_hat = KF.wse.estimate(Qaero_hat, pitch, omega, WS0, relaxation = 0)
+            WS_hat, _ = KF.wse.estimate(Qaero_hat, pitch, omega, WS0, relaxation = 0)
             Qaero_hat = np.max(Qaero_hat,0)
             Thrust = KF.wse.Thrust(WS_hat, pitch, omega)
             GF = KF.WT.GF_lin(Thrust,x,bFull=True)
 
             x[KF.iX['Thrust']] = GF
             x[KF.iX['WS']]     = WS_hat
             x[KF.iX['psi']]    = np.mod(x[KF.iX['psi']], 2*np.pi)
 
             # --- Store
-            KF.X_hat[:,it+1] = x
-            KF.Y_hat[:,it+1] = np.dot(KF.Yx,x) + np.dot(KF.Yu,u)
+            KF.X_hat.iloc[it+1,:] = x
+            KF.Y_hat.iloc[it+1,:] = np.dot(KF.Yx,x) + np.dot(KF.Yu,u)
 
             if np.mod(it,500) == 0:
                 print('Time step %8.0f t=%10.3f  WS=%4.1f Thrust=%.1f' % (it,KF.time[it],x[7],x[4]))
 
         KF.P = P
 
 
     def moments(KF):
         WT=KF.WT
         z_test = fastlib.ED_TwrGag(WT.ED) - WT.ED['TowerBsHt']
         EI     = np.interp(z_test, WT.Twr.s_span, WT.Twr.EI[0,:])
         kappa  = np.interp(z_test, WT.Twr.s_span, WT.Twr.PhiK[0][0,:])
-        qx    = KF.X_hat[KF.iX['ut1']]
+        qx    = KF.X_hat['ut1']
         KF.M_sim = [qx*EI[i]*kappa[i]/1000 for i in range(len(z_test))]                 # in [kNm]
         KF.M_ref = [KF.df['TwHt{:d}MLyt'.format(i+1)].values for i in range(len(z_test)) ] # in [kNm]
         return KF.M_sim, KF.M_ref
 
     def export(KF,OutputFile):
-        M=np.column_stack([KF.time]+[KF.X_clean[j,:] for j,_ in enumerate(KF.sX)])
-        M=np.column_stack([M]+[KF.X_hat  [j,:] for j,_ in enumerate(KF.sX)])
-        M=np.column_stack([M]+[KF.Y      [j,:] for j,_ in enumerate(KF.sY)])
-        M=np.column_stack([M]+[KF.Y_hat  [j,:] for j,_ in enumerate(KF.sY)])
+        M=np.column_stack([KF.time]+[KF.X_clean[sj] for j,sj in enumerate(KF.sX)])
+        M=np.column_stack([M]+[KF.X_hat  [sj] for j,sj in enumerate(KF.sX)])
+        M=np.column_stack([M]+[KF.Y      [sj] for j,sj in enumerate(KF.sY)])
+        M=np.column_stack([M]+[KF.Y_hat  [sj] for j,sj in enumerate(KF.sY)])
         if len(KF.sS)>0:
-            M=np.column_stack([M]+[KF.S_clean[j,:] for j,_ in enumerate(KF.sS)])
-            M=np.column_stack([M]+[KF.S_hat  [j,:] for j,_ in enumerate(KF.sS)])
+            M=np.column_stack([M]+[KF.S_clean[sj] for j,sj in enumerate(KF.sS)])
+            M=np.column_stack([M]+[KF.S_hat  [sj] for j,sj in enumerate(KF.sS)])
         M=np.column_stack([M]+KF.M_ref)
         M=np.column_stack([M]+KF.M_sim)
         header='time'+','
         header+=','.join(['x_'+s+'_ref' for s in KF.sX])+','
         header+=','.join(['x_'+s+'_est' for s in KF.sX])+','
         header+=','.join(['y_'+s+'_ref' for s in KF.sY])+','
         header+=','.join(['y_'+s+'_est' for s in KF.sY])+','
@@ -246,60 +253,60 @@
         time = KF.time
 
         ##
         fig=plt.figure()
         # fig.set_size_inches(13.8,4.8,forward=True) # default is (6.4,4.8)
         fig.set_size_inches(13.8,8.8,forward=True) # default is (6.4,4.8)
         ax=fig.add_subplot(6,2,1)
-        time_plot(ax,time,X_clean[iX['Qaero'],:]/ 1000, X_hat[iX['Qaero'],:]/ 1000)
+        time_plot(ax,time,X_clean['Qaero']/ 1000, X_hat['Qaero']/ 1000)
         ax.set_ylabel('Aerodynamic Torque [kNm]')
 
         ax=fig.add_subplot(6,2,2)
-        spec_plot(ax,time,X_clean[iX['Qaero'],:]/ 1000, X_hat[iX['Qaero'],:]/ 1000)
+        spec_plot(ax,time,X_clean['Qaero']/ 1000, X_hat['Qaero']/ 1000)
         # ax.set_ylabel('Power Spectral Density (Welch Avg.)') 
 
 
         ax=fig.add_subplot(6,2,3)
         try:
-            time_plot(ax,time,X_clean[iX['WS'],:], X_hat[iX['WS'],:])
+            time_plot(ax,time,X_clean['WS'], X_hat['WS'])
         except:
-            time_plot(ax,time,S_clean[iS['WS'],:], S_hat[iS['WS'],:])
+            time_plot(ax,time,S_clean['WS'], S_hat['WS'])
         ax.set_ylabel('WS [m/s]')
 
         ax=fig.add_subplot(6,2,4)
         try:
-            spec_plot(ax,time,X_clean[iX['WS'],:], X_hat[iX['WS'],:])
+            spec_plot(ax,time,X_clean['WS'], X_hat['WS'])
         except:
-            spec_plot(ax,time,S_clean[iS['WS'],:], S_hat[iS['WS'],:])
+            spec_plot(ax,time,S_clean['WS'], S_hat['WS'])
 
         ax=fig.add_subplot(6,2,5)
-        time_plot(ax,time,X_clean[iX['omega'],:], X_hat[iX['omega'],:])
+        time_plot(ax,time,X_clean['omega'], X_hat['omega'])
         ax.set_ylabel('Omega [RPM]')
 
         ax=fig.add_subplot(6,2,6)
-        spec_plot(ax,time,X_clean[iX['omega'],:], X_hat[iX['omega'],:])
+        spec_plot(ax,time,X_clean['omega'], X_hat['omega'])
 
         ax=fig.add_subplot(6,2,7)
         try:
-            time_plot(ax,time,X_clean[iX['Thrust'],:]/1000, X_hat[iX['Thrust'],:]/1000)
+            time_plot(ax,time,X_clean['Thrust']/1000, X_hat['Thrust']/1000)
         except:
-            time_plot(ax,time,S_clean[iS['Thrust'],:]/1000, S_hat[iS['Thrust'],:]/1000)
+            time_plot(ax,time,S_clean['Thrust']/1000, S_hat['Thrust']/1000)
         ax.set_ylabel('Thrust [kN]')
 
         ax=fig.add_subplot(6,2,8)
         try:
-            spec_plot(ax,time,X_clean[iX['Thrust'],:]/1000, X_hat[iX['Thrust'],:]/1000)
+            spec_plot(ax,time,X_clean['Thrust']/1000, X_hat['Thrust']/1000)
         except:
-            spec_plot(ax,time,S_clean[iS['Thrust'],:]/1000, S_hat[iS['Thrust'],:]/1000)
+            spec_plot(ax,time,S_clean['Thrust']/1000, S_hat['Thrust']/1000)
 
         ax=fig.add_subplot(6,2,9)
-        time_plot(ax,time,X_clean[iX['ut1'],:], X_hat[iX['ut1'],:])
+        time_plot(ax,time,X_clean['ut1'], X_hat['ut1'])
         ax.set_ylabel('TT position [m]')
         ax=fig.add_subplot(6,2,10)
-        spec_plot(ax,time,X_clean[iX['ut1'],:], X_hat[iX['ut1'],:])
+        spec_plot(ax,time,X_clean['ut1'], X_hat['ut1'])
 
         #                
         try:
             ax=fig.add_subplot(6,2,11)
             time_plot(ax,time,KF.M_ref[2], KF.M_sim[2])
             ax.set_ylabel('My [kNm]')
             ax=fig.add_subplot(6,2,12)
```

### Comparing `welib-0.0.2/welib/kalman/TNLin - Copy.py` & `welib-1.0.0/welib/kalman/TNLin.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,19 +1,18 @@
 import numpy as np
 from .kalman import *
 from .kalmanfilter import KalmanFilter
 from .filters import moving_average
-from ws_estimator.tabulated import TabulatedWSEstimator
-import yams
-from yams.TNSB_FAST import FASTmodel2TNSB
-from fast.linmodel import FASTLinModel
+from welib.ws_estimator.tabulated import TabulatedWSEstimator
+from welib.yams.TNSB_FAST import FASTmodel2TNSB
+from welib.fast.linmodel import FASTLinModel, FASTLinModelTNSB
 
 # --- External dependencies!
 import welib.fast.fastlib as fastlib
-import weio
+import welib.weio as weio
 
 #          'WS':'Wind1VelX', 'pitch':'BldPitch1','TTacc':'NcIMUTAxs'}
 #          'Thrust':'RotThrust','Qaero':'RtAeroMxh','Qgen':'GenTq',
 # NOTE: RotThrust contain gravity and inertia
 DEFAULT_COL_MAP={
   ' ut1    ' : ' TTDspFA_[m]                   ' ,
   ' psi    ' : ' {Azimuth_[deg]} * np.pi/180   ' , # [deg] -> [rad]
@@ -26,128 +25,123 @@
   ' WS     ' : ' RtVAvgxh_[m/s]                ' ,
   ' pitch  ' : ' {BldPitch1_[deg]} * np.pi/180 ' , # [deg]->[rad]
   ' TTacc  ' : ' NcIMUTAxs_[m/s^2]             ' 
 }
 
 
 class KalmanFilterTNLin(KalmanFilter):
-    def __init__(KF, FstFile, base, bThrustInStates, StateFile):
+    def __init__(KF, KM, FstFile, base, StateFile):
         """
 
         """
-        nShapes_bld   = 0 # Hard coded for TN
-        nDOF_2nd      = 2 # Mech DOFs     :  q = [u, psi]
-        KF.bThrustInStates = bThrustInStates
-        if bThrustInStates:
-#             sStates     = np.array(['ut1'  ,'psi'  ,'ut1dot','omega'] )
-#             sAug        = np.array(['Qaero','Thrust'])
-#             sMeas       = np.array(['TTacc','omega','Qgen','pitch'])
-#             sInp        = np.array(['Qgen','pitch'])
-#             sStor       = np.array(['WS'])
-            sStates     = np.array(['ut1'  ,'psi'  ,'ut1dot','omega'] )
-            sAug        = np.array(['Thrust','Qaero','Qgen','WS'])
-            sMeas       = np.array(['TTacc','omega','Qgen','pitch'])
-            sInp        = np.array(['pitch'])
-            sStor       = np.array(['WS'])
-        else:
-            sStates     = np.array(['ut1'  ,'psi'  ,'ut1dot','omega'] )
-            sAug        = np.array(['Qaero'])
-            sMeas       = np.array(['TTacc','omega','Qgen','pitch'])
-            sInp        = np.array(['Thrust','Qgen','pitch'])
-            sStor       = np.array(['Thrust','WS'])
-
-        super(KalmanFilterTNLin, KF).__init__(sX0=sStates, sXa=sAug, sU=sInp, sY=sMeas, sS=sStor)
-
-        # --- Building state/outputs connection matrices
-#         M,C,K,Ya,Yv,Yq,Yp,Yu,Fp,Fu,Pp,Pq,Pv = EmptySystemMat (int(KF.nX0/2), KF.nY, KF.nP, KF.nU)
-
-        # This below is problem specific
-#         Ya[0,0] = 1    # uddot                     = qddot[0]
-#         Yv[1,1] = 1    # psidot                    = qdot[1]
-#         Yp[2,2] = 1    # Direct feed-through of Mg
-#         Fp[0,0] = 1    # T                         = p[0]
-#         Fp[1,1] = 1    # dQ                        = p[1] -p[2]
-#         Fp[1,2] = -1   # dQ                        = p[1] -p[2]
-#         Yu[3,0] = 1    # pitch direct feedthrough
-
+        super(KalmanFilterTNLin, KF).__init__(sX0=KM.sStates, sXa=KM.sAug, sU=KM.sInp, sY=KM.sMeas, sS=KM.sStor)
+        iX = KF.iX
+        iY = KF.iY
+        iU = KF.iU
 
         # --- Mechanical system and turbine data
         WT2= FASTmodel2TNSB(FstFile , nShapes_twr=1,nShapes_bld=0, DEBUG=False, bStiffening=True, main_axis='z')    
-        WT2.DD      = WT2.DD*3.5 # increased damping to account for aero damping
+        #WT2.DD      = WT2.DD*3.5 # increased damping to account for aero damping
         KF.WT2=WT2
 
-        WT  = FASTLinModel(FstFile, StateFile=StateFile, DEBUG=False)
-        print(WT)
+        WT  = FASTLinModelTNSB(FstFile, StateFile=StateFile, DEBUG=False)
         KF.WT=WT
         A,B,C,D,M = WT.A, WT.B, WT.C, WT.D, WT.M # To Shorten notations
 
         # --- Creating a wind speed estimator (reads tabulated aerodynamic data)
-        KF.wse = TabulatedWSEstimator(fst_file=FstFile)
-        KF.wse.load_files(base=base,suffix='')
-        print(KF.wse)
+        KF.wse = TabulatedWSEstimator(fstFile=FstFile)
+        #KF.wse.load_files(base=base,suffix='')
+        KF.wse.loadFromBasename(basename=base,suffix='')
         # --- Build linear system
-        nX = len(sStates)+len(sAug)
-        nU = len(sInp   )
-        nY = len(sMeas  )
-        nq = len(sStates)
+        nX = len(KM.sStates)+len(KM.sAug)
+        nU = len(KM.sInp   )
+        nY = len(KM.sMeas  )
+        nq = len(KM.sStates)
         #
         nGear = WT.nGear
         Mqt      =  1/B.iloc[2,0]
         J_LSSnG  = -1/B.iloc[3,1]  # This is JLSS * nGear (scaled by nGea since it takes Torque at HSS and return influences at LSS). It is not J_HSS !!
 
         Mqt_ED   = M.iloc[0,0]
         J_LSS_ED = M.iloc[1,1]
         
         Xx, Xu, Yx, Yu = EmptyStateMat(nX, nU, nY)
         # --- Filling extended state matrices
-        if KF.bThrustInStates:
+        KF.KM = KM
+        if KM.StateModel=='nt1_nx8' or KM.StateModel=='nt1_nx7': # sAug =  ['Thrust','Qaero','Qgen','WS']
             Xx[:nq,:nq ] = A.values
             Yx[:  ,:nq ] = C.values
             #----
             Xu[:nq,:nU ] = B.values[:,2:]
             Yu[:  ,:   ] = D.values[:,2:]
-            Xx[2,4  ] =  2.285e-06  # Thrust
-            Xx[3,5]   =  2.345e-08  # Qa
-            Xx[3,6]   = -2.345e-08  # Qgen
-            Yx[2,6] = 1
-            Xx[2,0:4] =[ -6.132e+00,      0,   -5.730e-02,      0]
-#             # Consistency
-            Yx[0,0:7] =Xx[2,0:7]  # <<<< Important
-#             Xu[3,0]   =-Xx[3,4]*nGear
             #----
-#             Xu[:nq,:nU ] = B.values[:,1:]
-#             Yu[:  ,:   ] = D.values[:,1:]
-#             Xx[nq-1,nq]    = 1/J_LSS_ED # ddpsi Qa # NOTE: LSS
-#             Xx[:nq,nq+1]  =B.values[:,0]
-#             Yx[:,5]       =D.values[:,0]
+            Xx[iX['omega'],iX['Qaero']] = 1/J_LSS_ED # ddpsi Qa # NOTE: LSS
+            Xx[:nq,iX['Thrust']]  = B.values[:,0]
+            Yx[:,  iX['Thrust']]  = D.values[:,0]
+            Yx[iY['Qgen'],iX['Qgen']] = 1
+            # --- Value Hack
+            if KM.ThrustHack:
+                Xx[iX['ut1dot'], iX['Thrust']] =  2.285e-06  # Thrust
+#             Xx[iX['omega'],  iX['Qaero']]  =  2.345e-08  # Qa
+#             Xx[2,0:4] =[ -6.132e+00,      0,   -5.730e-02,      0]
+#             Xx[3,4  ] =  0
+#             Xu[3,0  ] =  0
+            # --- Consistency
+            if KM.Qgen_LSS:
+                Xx[iX['omega'],  iX['Qgen']]   =-Xx[iX['omega'],iX['Qaero']]
+            else:
+                Xx[iX['omega'],  iX['Qgen']]   =-Xx[iX['omega'],iX['Qaero']]*nGear
+            Yx[0,0:] =Xx[2,0:]  # <<<< Important
+
+
+        elif KM.StateModel=='nt1_nx6': # sAug = ['Qaero','Thrust']
+            Xx[:nq,:nq ] = A.values
+            Yx[:  ,:nq ] = C.values
+            #----
+            Xu[:nq,:nU ] = B.values[:,1:]
+            Yu[:  ,:   ] = D.values[:,1:]
+            #----
+            Xx[iX['omega'],  iX['Qaero']] = 1/J_LSS_ED # ddpsi Qa # NOTE: LSS
+            Xx[:nq,iX['Thrust']] = B.values[:,0]
+            Yx[:,  iX['Thrust']] = D.values[:,0]
             #  Value Hack
-#             Xx[2,2]  *= 3.0 # Increased damping
 #             Xx[2,0:4] =[ -6.132e+00,      0,   -5.730e-02,      0]
-#             Xx[2,5  ] =  2.285e-06  # Thrust
-#             Xx[3,4]   =  2.345e-08  # Torque
-#             Xx[3,5  ] =  0
+            if KM.ThrustHack:
+                Xx[2,iX['Thrust']] =  2.285e-06  # Thrust
+#             Xx[3,iX['Qaero' ]] =  2.345e-08  # Torque
+#             Xx[3,4  ] =  0
 #             Xu[2,0  ] =  0
 #             Yu[0,0  ] =  0
-#             # Consistency
-#             Yx[0,0:6] =Xx[2,0:6]  # <<<< Important
-#             Xu[3,0]   =-Xx[3,4]*nGear
-        else:
+            # Consistency
+            if KM.Qgen_LSS:
+                Xu[iX['omega'],iU['Qgen']]  =-Xx[iX['omega'],iX['Qaero']]
+            else:
+                Xu[iX['omega'],iU['Qgen']]  =-Xx[iX['omega'],iX['Qaero']]*nGear
+            Yx[0,0:6] =Xx[2,0:6]  # <<<< Important
+
+        elif KM.StateModel=='nt1_nx5':  # sAug = ['Qaero']
             Xx[:nq,:nq ] = A.values
-            Xu[:nq,:nU ] = B.values
             Yx[:  ,:nq ] = C.values
+            #----
+            Xu[:nq,:nU ] = B.values
             Yu[:  ,:   ] = D.values
-            Xx[nq-1,nq]    = 1/J_LSS_ED # ddpsi Qa # NOTE: LSS
+            #----
+            Xx[iX['omega'],  iX['Qaero']] = 1/J_LSS_ED # ddpsi Qa # NOTE: LSS
             #  Value Hack
 #             Xx[2,0:4] =[ -6.132e+00,      0,   -5.730e-02,      0]
-#             Xu[2,0  ] =  2.285e-06  # Thrust
+            if KM.ThrustHack:
+                Xu[2,0  ] =  2.285e-06  # Thrust
 #             Xx[3,4]   =  2.345e-08  # Torque
             # Consistency
+            if KM.Qgen_LSS:
+                Xu[iX['omega'],iU['Qgen']]  =-Xx[iX['omega'],iX['Qaero']]
+            else:
+                Xu[iX['omega'],iU['Qgen']]  =-Xx[iX['omega'],iX['Qaero']]*nGear
             Yx[0,0:4] = Xx[2,0:4]
             Yu[0,0]   = Xu[2,0]
-            Xu[3,1]   = -Xx[3,4]*nGear
 
 
 
         KF.setMat(Xx, Xu, Yx, Yu)
 
 
 
@@ -165,118 +159,118 @@
         KF.discretize(dt, method='exponential')
         KF.setTimeVec(time)
         KF.setCleanValues(KF.df)
 
         # --- Estimate sigmas from measurements
         sigX_c,sigY_c = KF.sigmasFromClean(factor=1)
 
-    def prepareTimeStepping(KF):
-        # --- Process and measurement covariances
-        KF.P, KF.Q, KF.R = KF.covariancesFromSig()
-        # --- Storage for plot
-        KF.initTimeStorage()
-
     def prepareMeasurements(KF, NoiseRFactor=0, bFilterAcc=False, nFilt=15):
         # --- Creating noise measuremnts
         KF.setYFromClean(R=KF.R, NoiseRFactor=NoiseRFactor)
         if bFilterAcc:
             KF.set_vY('TTacc',  moving_average(KF.get_vY('TTacc'),n=nFilt) )
 
-
-
     def timeLoop(KF):
         # --- Initial conditions
         x = KF.initFromClean()
-        WS_last     = KF.S_clean[KF.iS['WS'    ],0]
-        KF.S_hat[KF.iS['WS'    ], 0]= WS_last
+        P = KF.P        
 
-        if not KF.bThrustInStates:
-            Thrust_last = KF.S_clean[KF.iS['Thrust'],0]
-            KF.S_hat[KF.iS['Thrust'], 0]= Thrust_last
+        # --- WSE
+        WS_last     = KF.S_clean.loc[0,'WS']
+        KF.S_hat.loc[0,'WS']= WS_last
+
+        if not KF.KM.bThrustInStates:
+            Thrust_last = KF.S_clean.loc[0,'Thrust']
+            KF.S_hat.loc[0,'Thrust']= Thrust_last
         
-        KF.X_hat[:,0]   = x
-        P = KF.P
+        KF.X_hat.iloc[0,:]   = x
+
+
+        WSavg      = np.zeros((50,1))
+        WSavg[:]=WS_last
 
-        iY={lab: i   for i,lab in enumerate(KF.sY)}
         for it in range(0,KF.nt-1):    
+            t = it*KF.dt
             # --- "Measurements"
-            y  = KF.Y[:,it]
+            y  = KF.Y.iloc[it,:].values
 
             # --- KF predictions
-            u=KF.U_clean[:,it]
-            if not KF.bThrustInStates:
+            u=KF.U_clean.iloc[it,:].values
+            if not KF.KM.bThrustInStates:
                 u[0] = Thrust_last # (we don't know the thrust)
             x,P,_ = KF.estimateTimeStep(u,y,x,P,KF.Q,KF.R)
 
             # --- Estimate thrust and WS - Non generic code
-#             WS_last=x[KF.iX['WS']]
+            if KF.KM.bWSInStates:
+                WS_last=x[KF.iX['WS']]
             pitch     = y[KF.iY['pitch']]*180/np.pi # deg
             Qaero_hat = x[KF.iX['Qaero']]
             omega     = x[KF.iX['omega']]
-            WS_hat = KF.wse.estimate(Qaero_hat, pitch, omega, WS_last, relaxation = 0)
-            #Qaero_hat = np.max(Qaero_hat,0)
+            WS_hat,_ = KF.wse.estimate(Qaero_hat, pitch, omega, WS_last, relaxation = 0, WSavg=np.mean(WSavg))
+            Qaero_hat = np.max(Qaero_hat,0)
             Thrust = KF.wse.Thrust(WS_hat, pitch, omega)
 
             GF = Thrust
             GF = KF.WT2.GF_lin(Thrust,x,bFull=True)
 
             # --- Store
-            if KF.bThrustInStates:
-                #x[KF.iX['Thrust']] = Thrust
+            if KF.KM.bThrustInStates:
                 x[KF.iX['Thrust']] = GF
-                x[KF.iX['WS']] = WS_hat
             else:
-                KF.S_hat[KF.iS['Thrust'], it+1]= GF
-            KF.S_hat[KF.iS['WS'    ], it+1]= WS_hat
+                KF.S_hat.loc[it+1, 'Thrust']= GF
+            if KF.KM.bWSInStates:
+                x[KF.iX['WS']] = WS_hat
+            KF.S_hat.loc[it+1, 'WS'    ]= WS_hat
             x[KF.iX['psi']]    = np.mod(x[KF.iX['psi']], 2*np.pi)
-            KF.X_hat[:,it+1]   = x
-            KF.Y_hat[:,it+1]   = np.dot(KF.Yx,x) + np.dot(KF.Yu,u)
+            KF.X_hat.iloc[it+1,:]   = x
+            KF.Y_hat.iloc[it+1,:]   = np.dot(KF.Yx,x) + np.dot(KF.Yu,u)
             # --- Propagation to next time step
             Thrust_last = GF
             WS_last     = WS_hat
+            WSavg[1:] = WSavg[0:-1]
+            WSavg[0]  = WS_hat
 
             if np.mod(it,500) == 0:
                 print('Time step %8.0f t=%10.3f  WS=%4.1f Thrust=%.1f' % (it,KF.time[it],WS_hat,Thrust))
-
         KF.P = P
 
     def moments(KF):
         WT=KF.WT2
         z_test = fastlib.ED_TwrGag(WT.ED) - WT.ED['TowerBsHt']
         EI     = np.interp(z_test, WT.Twr.s_span, WT.Twr.EI[0,:])
         kappa  = np.interp(z_test, WT.Twr.s_span, WT.Twr.PhiK[0][0,:])
-        qx    = KF.X_hat[KF.iX['ut1']]
+        qx    = KF.X_hat['ut1']
         KF.M_sim = [qx*EI[i]*kappa[i]/1000 for i in range(len(z_test))]                 # in [kNm]
         KF.M_ref=[]
         for i in range(len(z_test)):
             try:
                 val=KF.df['TwHt{:d}MLyt_[kN-m]'.format(i+1)].values
             except:
                 try:
                     val=KF.df['TwHt{:d}MLyt'.format(i+1)].values
                 except:
                    val=KF.time*0
             KF.M_ref.append(val)
         return KF.M_sim, KF.M_ref
 
     def export(KF,OutputFile):
-        M=np.column_stack([KF.time]+[KF.X_clean[j,:] for j,_ in enumerate(KF.sX)])
-        M=np.column_stack([M]+[KF.X_hat  [j,:] for j,_ in enumerate(KF.sX)])
-        M=np.column_stack([M]+[KF.Y      [j,:] for j,_ in enumerate(KF.sY)])
-        M=np.column_stack([M]+[KF.Y_hat  [j,:] for j,_ in enumerate(KF.sY)])
+        M=np.column_stack([KF.time]+[KF.X_clean[sj] for j,sj in enumerate(KF.sX)])
+        M=np.column_stack([M]+[KF.X_hat  [sj] for j,sj in enumerate(KF.sX)])
+        M=np.column_stack([M]+[KF.Y      [sj] for j,sj in enumerate(KF.sY)])
+        M=np.column_stack([M]+[KF.Y_hat  [sj] for j,sj in enumerate(KF.sY)])
         if len(KF.sS)>0:
-           M=np.column_stack([M]+[KF.S_clean[j,:] for j,_ in enumerate(KF.sS)])
-           M=np.column_stack([M]+[KF.S_hat  [j,:] for j,_ in enumerate(KF.sS)])
+            M=np.column_stack([M]+[KF.S_clean[sj] for j,sj in enumerate(KF.sS)])
+            M=np.column_stack([M]+[KF.S_hat  [sj] for j,sj in enumerate(KF.sS)])
         M=np.column_stack([M]+KF.M_ref)
         M=np.column_stack([M]+KF.M_sim)
         header='time'+','
-        header+=','.join([s+'_ref' for s in KF.sX])+','
-        header+=','.join([s+'_est' for s in KF.sX])+','
-        header+=','.join([s+'_ref' for s in KF.sY])+','
-        header+=','.join([s+'_est' for s in KF.sY])+','
+        header+=','.join(['x_'+s+'_ref' for s in KF.sX])+','
+        header+=','.join(['x_'+s+'_est' for s in KF.sX])+','
+        header+=','.join(['y_'+s+'_ref' for s in KF.sY])+','
+        header+=','.join(['y_'+s+'_est' for s in KF.sY])+','
         if len(KF.sS)>0:
             header+=','.join([s+'_ref' for s in KF.sS])+','
             header+=','.join([s+'_est' for s in KF.sS])+','
         header+=','.join(['My_ref{:d}'.format(j) for j,_ in enumerate(KF.M_ref)])+','
         header+=','.join(['My_est{:d}'.format(j) for j,_ in enumerate(KF.M_sim)])
         np.savetxt(OutputFile,M,delimiter=',',header=header)
 
@@ -336,85 +330,85 @@
         time = KF.time
 
         ##
         fig=plt.figure()
         # fig.set_size_inches(13.8,4.8,forward=True) # default is (6.4,4.8)
         fig.set_size_inches(13.8,8.8,forward=True) # default is (6.4,4.8)
         ax=fig.add_subplot(6,2,1)
-        time_plot(ax,time,X_clean[iX['Qaero'],:]/ 1000, X_hat[iX['Qaero'],:]/ 1000)
+        time_plot(ax,time,X_clean['Qaero']/ 1000, X_hat['Qaero']/ 1000)
         ax.set_ylabel('Aerodynamic Torque [kNm]')
 
         ax=fig.add_subplot(6,2,2)
-        spec_plot(ax,time,X_clean[iX['Qaero'],:]/ 1000, X_hat[iX['Qaero'],:]/ 1000)
+        spec_plot(ax,time,X_clean['Qaero']/ 1000, X_hat['Qaero']/ 1000)
         # ax.set_ylabel('Power Spectral Density (Welch Avg.)') 
 
 
         ax=fig.add_subplot(6,2,3)
         try:
-            time_plot(ax,time,X_clean[iX['WS'],:], X_hat[iX['WS'],:])
+            time_plot(ax,time,X_clean['WS'], X_hat['WS'])
         except:
-            time_plot(ax,time,S_clean[iS['WS'],:], S_hat[iS['WS'],:])
+            time_plot(ax,time,S_clean['WS'], S_hat['WS'])
         ax.set_ylabel('WS [m/s]')
 
         ax=fig.add_subplot(6,2,4)
         try:
-            spec_plot(ax,time,X_clean[iX['WS'],:], X_hat[iX['WS'],:])
+            spec_plot(ax,time,X_clean['WS'], X_hat['WS'])
         except:
-            spec_plot(ax,time,S_clean[iS['WS'],:], S_hat[iS['WS'],:])
+            spec_plot(ax,time,S_clean['WS'], S_hat['WS'])
 
         ax=fig.add_subplot(6,2,5)
-        time_plot(ax,time,X_clean[iX['omega'],:], X_hat[iX['omega'],:])
+        time_plot(ax,time,X_clean['omega'], X_hat['omega'])
         ax.set_ylabel('Omega [RPM]')
 
         ax=fig.add_subplot(6,2,6)
-        spec_plot(ax,time,X_clean[iX['omega'],:], X_hat[iX['omega'],:])
+        spec_plot(ax,time,X_clean['omega'], X_hat['omega'])
 
         ax=fig.add_subplot(6,2,7)
         try:
-            time_plot(ax,time,X_clean[iX['Thrust'],:]/1000, X_hat[iX['Thrust'],:]/1000)
+            time_plot(ax,time,X_clean['Thrust']/1000, X_hat['Thrust']/1000)
         except:
-            time_plot(ax,time,S_clean[iS['Thrust'],:]/1000, S_hat[iS['Thrust'],:]/1000)
+            time_plot(ax,time,S_clean['Thrust']/1000, S_hat['Thrust']/1000)
         ax.set_ylabel('Thrust [kN]')
 
         ax=fig.add_subplot(6,2,8)
         try:
-            spec_plot(ax,time,X_clean[iX['Thrust'],:]/1000, X_hat[iX['Thrust'],:]/1000)
+            spec_plot(ax,time,X_clean['Thrust']/1000, X_hat['Thrust']/1000)
         except:
-            spec_plot(ax,time,S_clean[iS['Thrust'],:]/1000, S_hat[iS['Thrust'],:]/1000)
+            spec_plot(ax,time,S_clean['Thrust']/1000, S_hat['Thrust']/1000)
 
         ax=fig.add_subplot(6,2,9)
-        time_plot(ax,time,X_clean[iX['ut1'],:], X_hat[iX['ut1'],:])
+        time_plot(ax,time,X_clean['ut1'], X_hat['ut1'])
         ax.set_ylabel('TT position [m]')
         ax=fig.add_subplot(6,2,10)
-        spec_plot(ax,time,X_clean[iX['ut1'],:], X_hat[iX['ut1'],:])
+        spec_plot(ax,time,X_clean['ut1'], X_hat['ut1'])
 
         #                
-       # z_test = list(fastlib.ED_TwrGag(KF.WT.ED) - KF.WT.ED['TowerBsHt'])
-       # try:
-       #     for i,z in enumerate(z_test):
-       #         if np.mean(np.abs(KF.M_ref[i] ))>1:
-       #             ax=fig.add_subplot(6,2,11)
-       #             time_plot(ax,time,KF.M_ref[i], KF.M_sim[i])
-       #             ax.set_ylabel('My [kNm] - z={:.1f}'.format(z))
-       #             ax=fig.add_subplot(6,2,12)
-       #             spec_plot(ax,time,KF.M_ref[i], KF.M_sim[i])
-       #             break
-       # except:
-       #     pass
+#         z_test = list(fastlib.ED_TwrGag(KF.WT.ED) - KF.WT.ED['TowerBsHt'])
+#         try:
+#             for i,z in enumerate(z_test):
+#                 if np.mean(np.abs(KF.M_ref[i] ))>1:
+#                     ax=fig.add_subplot(6,2,11)
+#                     time_plot(ax,time,KF.M_ref[i], KF.M_sim[i])
+#                     ax.set_ylabel('My [kNm] - z={:.1f}'.format(z))
+#                     ax=fig.add_subplot(6,2,12)
+#                     spec_plot(ax,time,KF.M_ref[i], KF.M_sim[i])
+#                     break
+#         except:
+#             pass
         try:
             ax=fig.add_subplot(6,2,11)
             time_plot(ax,time,KF.M_ref[2], KF.M_sim[2])
             ax.set_ylabel('My [kNm]')
             ax=fig.add_subplot(6,2,12)
             spec_plot(ax,time,KF.M_ref[2], KF.M_sim[2])
         except:
             pass
-
+#
         #                                         
-    def plot_moments(KF,fig=None):
+    def plot_moments(KF,fig=None,scaleByMean=False):
         import matplotlib
         import matplotlib.pyplot as plt
 
         z_test = list(fastlib.ED_TwrGag(KF.WT.ED) - KF.WT.ED['TowerBsHt'])
         print('z test:',z_test)
         n=len(z_test)
 #         z_test.reverse()
@@ -422,47 +416,56 @@
         cmap = matplotlib.cm.get_cmap('viridis')
         COLRS = [(cmap(v)[0],cmap(v)[1],cmap(v)[2]) for v in np.linspace(0,1,n+1)]
         if fig is None:
             fig=plt.figure()
         fig.set_size_inches(6.4,15.0,forward=True) # default is (6.4,4.8)
         for i,z in enumerate(z_test):
             ax = fig.add_subplot(n,1,i+1)
+            M_sim =KF.M_sim[i]
+            if scaleByMean:
+                M_sim+=-np.mean(KF.M_sim[i])+np.mean(KF.M_ref[i])
+            
             ax.plot (KF.time, KF.M_ref[i], 'k-', color='k',       label='Reference' , lw=1)
-            ax.plot (KF.time, KF.M_sim[i], '--', color=COLRS[i],label='Estimation', lw=0.8)
+            ax.plot (KF.time,    M_sim   , '--', color=COLRS[i],label='Estimation', lw=0.8)
             ax.set_ylabel('My z={:.1f}'.format(z))
             ax.tick_params(direction='in')
 #             if ii<2:
             if i<n-1:
                 ax.set_xticklabels([])
             else:
                 ax.set_xlabel('Time [s]')
                 ax.legend()
 #             # plt.ylim(0.05*10**8,0.8*10**8)
         ax.set_title('KalmanLoads')
 
 
 
-def KalmanFilterTNLinSim(FstFile, MeasFile, OutputFile, base, bThrustInStates, StateFile, nUnderSamp, tRange, bFilterAcc, nFilt, NoiseRFactor, sigX=None, sigY=None, bExport=False, ColMap=DEFAULT_COL_MAP):
+def KalmanFilterTNLinSim(KM, FstFile, MeasFile, OutputFile, base, StateFile, nUnderSamp, tRange, bFilterAcc, nFilt, NoiseRFactor, sigX=None, sigY=None, bExport=False, ColMap=DEFAULT_COL_MAP, debug=True):
     # ---
-    KF=KalmanFilterTNLin(FstFile, base, bThrustInStates, StateFile)
-    print(KF)
+    KF=KalmanFilterTNLin(KM, FstFile, base, StateFile)
+    if debug:
+        print(KF.wse)
+        print(KF.WT)
+        print(KF)
     # --- Loading "Measurements"
     # Defining "clean" values 
     # Estimate sigmas from measurements
     KF.loadMeasurements(MeasFile, nUnderSamp=nUnderSamp, tRange=tRange, ColMap=ColMap)
     KF.sigX=sigX
     KF.sigY=sigY
 
     # --- Process and measurement covariances
     # --- Storage for plot
     KF.prepareTimeStepping()
     # --- Creating noise measuremnts
     KF.prepareMeasurements(NoiseRFactor=NoiseRFactor, bFilterAcc=bFilterAcc, nFilt=nFilt)
 
     # --- Time loop
+    if debug:
+        print(OutputFile)
     KF.timeLoop()
     KF.moments()
 
     if bExport:
         KF.export(OutputFile)
     return KF
```

### Comparing `welib-0.0.2/welib/kalman/examples/Mech_1DOF.py` & `welib-1.0.0/welib/kalman/examples/Mech_1DOF.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,17 +7,17 @@
 import matplotlib.pyplot as plt
 import os
 from  welib.kalman.kalman import BuildSystem_Linear_MechOnly 
 from  welib.kalman.kalmanfilter import KalmanFilter
 
 MyDir=os.path.dirname(__file__)
 
-def main():
+def main(tMax=100):
     # --- Main parameters
-    tRange=[0,100]  # Time range for simulation [s]
+    tRange=[0,tMax]  # Time range for simulation [s]
     nUnderSamp=1    # 1: use same time steps as measurements, >1: undersample
     NoiseRFactor=0  # Add noise to measurements. 0: no noise
     algo     = '3'  # Define algorithm kind for splitting qh into states and inputs
 
     # --- Parameters for the simulation that we will use as "measurements"
     simFile=os.path.join(MyDir,'../../../data/Monopile/MT100_LoadsMotions.csv')
     # Mappign to rename columns present in simulation file, to be uses as measurements and clean states (for comparison)
@@ -142,8 +142,13 @@
 if __name__ == '__main__':
     main()
 #     KF.print_sigmas()
 #     print(KF)
     plt.show()
 
 if __name__ == '__test__':
-    main()
+    main(tMax=1)
+
+if __name__=="__export__":
+    pass
+    #from welib.tools.repo import export_figs_callback
+    #export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_OFLin/001_Linearization_GenerateCase.py` & `welib-1.0.0/welib/kalman/examples/onshore_OFLin/001_Linearization_GenerateCase.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_OFLin/002_Create_FASTLin.py` & `welib-1.0.0/welib/kalman/examples/onshore_OFLin/002_Create_FASTLin.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_OFLin/301_Kalman_2DOF_5States.py` & `welib-1.0.0/welib/kalman/examples/onshore_OFLin/301_Kalman_2DOF_5States.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_OFLin/kalman_models.py` & `welib-1.0.0/welib/kalman/examples/onshore_OFLin/kalman_models.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_YAMS/000_CPLambdaPitch.py` & `welib-1.0.0/welib/kalman/examples/onshore_YAMS/000_CPLambdaPitch.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_YAMS/100_WSEstimation.py` & `welib-1.0.0/welib/kalman/examples/onshore_YAMS/100_WSEstimation.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/examples/onshore_YAMS/300_Kalman_2DOF_7States.py` & `welib-1.0.0/welib/kalman/examples/onshore_YAMS/300_Kalman_2DOF_7States.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/kalman.py` & `welib-1.0.0/welib/kalman/kalman.py`

 * *Files 2% similar despite different names*

```diff
@@ -186,19 +186,20 @@
     Yx = np.zeros((nY,nX)) # Gc 
     Xu = np.zeros((nX,nU)) # Xu 
     Yu = np.zeros((nY,nU)) # Jc 
     return Xx,Xu,Yx,Yu
 
 def EmptyStateDF(nX,nU,nY,sX,sU,sY):
     """ Returns state matrices with proper dimensions, filled with 0 """
+    sXd=['d'+s for s in sX]
     Xx,Xu,Yx,Yu = EmptyStateMat(nX,nU,nY)
-    Xx = pd.DataFrame(data=Xx, index=sX, columns=sX)
-    Xu = pd.DataFrame(data=Xu, index=sX, columns=sU)
-    Yx = pd.DataFrame(data=Yx, index=sY, columns=sX)
-    Yu = pd.DataFrame(data=Yu, index=sY, columns=sU)
+    Xx = pd.DataFrame(data=Xx, index=sXd, columns=sX)
+    Xu = pd.DataFrame(data=Xu, index=sXd, columns=sU)
+    Yx = pd.DataFrame(data=Yx, index=sY , columns=sX)
+    Yu = pd.DataFrame(data=Yu, index=sY , columns=sU)
     return Xx,Xu,Yx,Yu
 
 
 
 def EmptySystemMat(nDOF_2nd, nY, nP=None, nU=None):
     """ Returns matrices with proper dimensions, filled with 0
     INPUTS:
```

### Comparing `welib-0.0.2/welib/kalman/kalmanfilter.py` & `welib-1.0.0/welib/kalman/kalmanfilter.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,23 +1,29 @@
 from .kalman import *
 import numpy as np
 import pandas as pd
 
 class KalmanFilter(object):
-    def __init__(self,sX0,sXa,sU,sY,sS=None):
+    def __init__(self,sX0,sXa,sU,sY,sS=None, sXd=None):
         sS = [] if sS is None else sS
         self.sX0 = sX0
         self.sXa = sXa
         self.sU  = sU
         self.sY  = sY
         self.sS  = sS # Storage, "Misc" values
 
+
         #  State vector is States and Augmented states
         self.sX=np.concatenate((self.sX0,self.sXa))
 
+        if sXd is None:
+            sXd = ['d' + c for c in self.sX] # NOTE: might have duplication...
+        self.sXd = sXd
+
+
         # --- Defining index map for convenience
         self.iX={lab: i   for i,lab in enumerate(self.sX)}
         self.iY={lab: i   for i,lab in enumerate(self.sY)}
         self.iU={lab: i   for i,lab in enumerate(self.sU)}
         self.iS={lab: i   for i,lab in enumerate(self.sS)}
 
         # Standard deviations and covariance matrix
@@ -114,14 +120,21 @@
         if Yu.shape != self.Yu.shape:
             raise Exception('Shape of Yu ({}) not compatible with KF Yu shape ({}) '.format(Yu.shape, self.Yu.shape))
         self.Xx.iloc[:,:]=Xx
         self.Xu.iloc[:,:]=Xu
         self.Yx.iloc[:,:]=Yx
         self.Yu.iloc[:,:]=Yu
 
+        if np.any(np.isnan(Xx)): raise Exception('A matrix contains nan')
+        if np.any(np.isnan(Xu)): raise Exception('B matrix contains nan')
+        if np.any(np.isnan(Yx)): raise Exception('C matrix contains nan')
+        if np.any(np.isnan(Yu)): raise Exception('D matrix contains nan')
+
+
+
     def discretize(self,dt,method='exponential'):
         self.dt=dt
         self.Xxd,self.Xud = KFDiscretize(self.Xx, self.Xu, dt, method=method)
 
     def estimateTimeStep(self,u,y,x,P,Q,R):
         """
         OUTPUTS:
@@ -170,19 +183,25 @@
                 ColMap[k]=k
 
         # --- Defining "clean" values 
         self.X_clean = pd.DataFrame(data=np.zeros((self.nt,self.nX)), columns=self.sX)
         self.Y_clean = pd.DataFrame(data=np.zeros((self.nt,self.nY)), columns=self.sY)
         self.U_clean = pd.DataFrame(data=np.zeros((self.nt,self.nU)), columns=self.sU)
         self.S_clean = pd.DataFrame(data=np.zeros((self.nt,self.nS)), columns=self.sS)
+        self.XD_clean = pd.DataFrame(data=np.zeros((self.nt,self.nX)), columns=self.sXd)
         for i,lab in enumerate(self.sX):
             try:
                 self.X_clean[lab]=df[ColMap[lab]].values
             except:
                 print('[WARN] Clean state not available      :', lab)
+        for i,lab in enumerate(self.XD_clean.columns):
+            try:
+                self.XD_clean[lab]=df[ColMap[lab]].values
+            except:
+                print('[WARN] Clean state not available      :', lab)
 
         for i,lab in enumerate(self.sY):
             try:
                 self.Y_clean[lab]=df[ColMap[lab]].values
             except:
                 print('[WARN] Clean measurement not available:', lab)
         for i,lab in enumerate(self.sU):
@@ -206,14 +225,16 @@
             self.Y[lab]=df[ColMap[lab]]
 
     def initTimeStorage(self):
         self.X_hat = pd.DataFrame(data=np.zeros((self.nt, self.nX)), columns=self.sX)
         self.Y_hat = pd.DataFrame(data=np.zeros((self.nt, self.nY)), columns=self.sY)
         self.Y     = pd.DataFrame(data=np.zeros((self.nt, self.nY)), columns=self.sY)
         self.S_hat = pd.DataFrame(data=np.zeros((self.nt, self.nS)), columns=self.sS)
+        self.U_hat = pd.DataFrame(data=np.zeros((self.nt, self.nU)), columns=self.sU)
+        self.XD_hat = pd.DataFrame(data=np.zeros((self.nt, self.nX)), columns=self.sXd)
     
 #     # TODO use property or dict syntax
 #     def get_vY(self,lab):
 #         return self.Y[lab].values
 #     def set_vY(self, lab, val ):
 #         self.Y[lab]=val
 # 
@@ -345,45 +366,112 @@
 
 
     # --------------------------------------------------------------------------------}
     # --- Plot functions 
     # --------------------------------------------------------------------------------{
 
     def plot_X(KF, title='States X', **kwargs):
+        """ plot states, return fig """
         return _plot(KF.time, KF.X_clean, KF.X_hat, KF.sX, title=title, **kwargs)
 
+
+    def plot_U(KF, title='Inputs U', **kwargs):
+        """ plot inputs, return fig """
+        return _plot(KF.time, KF.U_clean, KF.U_hat, KF.sU, title=title, **kwargs)
+
     def plot_Y(KF, title='Measurements Y', **kwargs):
+        """ plot measurements, return fig """
         return _plot(KF.time, KF.Y_clean, KF.Y_hat, KF.sY, title=title, X_noisy=KF.Y, **kwargs)
 
     def plot_S(KF, title='Stored Values S',**kwargs):
+        """ plot stored values, return fig """
         if KF.nS==0:
             return
         return _plot(KF.time, KF.S_clean, KF.S_hat, KF.sS, title=title, **kwargs)
 
     def save(KF, filename, fmt='pickle'):
         if fmt=='pickle':
             import pickle
             with open(filename,'wb') as f:
                 pickle.dump(self,f)
         else:
             raise NotImplementedError()
 
+    def saveOutputs(KF, filename, fmt='outb', df=None):
+
+        if df is None:
+            df = KF.toDataFrame()
+
+        if fmt=='csv':
+            pass
+        elif fmt=='outb':
+            from welib.weio.fast_output_file import writeDataFrame
+            writeDataFrame(df, filename, binary=True)
+        else:
+            raise NotImplementedError()
+
+        return df
+
+
+    def toDataFrame(KF):
+        """ Concatenante all info into a dataframe """
+
+        def splitunit(s):
+            iu=s.rfind('_[')
+            if iu>1:
+                return s[:iu], s[iu:]
+            else:
+                return s, ''
+
+        def cleancol(l):
+            return ['_clean'.join(splitunit(c)) for c in l]
+
+        cols = []
+        cols += list(KF.X_hat.columns)
+        cols += cleancol(KF.X_clean.columns)
+        cols += list(KF.U_hat.columns)
+        cols += cleancol(KF.U_clean.columns)
+        cols += ['OUT_'+c for c in list(KF.Y_hat.columns)]
+        cols += ['OUT_'+c for c in cleancol(KF.Y_clean.columns)]
+        cols += list(KF.S_hat.columns)
+        cols += cleancol(KF.S_clean.columns)
+        df = pd.concat((KF.X_hat, KF.X_clean, KF.U_hat, KF.U_clean, KF.Y_hat, KF.Y_clean, KF.S_hat, KF.S_clean), axis=1)
+        df.columns = cols
+
+        # "Accelerations" 
+        dfAcc = pd.concat((KF.XD_hat, KF.XD_clean), axis=1)
+        cols = list(KF.XD_hat.columns)
+        cols += cleancol(KF.XD_clean.columns)
+        dfAcc.columns=cols
+        # We keep only the part that is not already in the state vector
+        col_new = [c for c in cols if c not in df.columns]
+        dfAcc=dfAcc[col_new] 
+
+        # 
+        df = pd.concat((df,dfAcc), axis=1)
+
+
+        df.insert(0, 'Time_[s]', KF.time)
+        return df
+
+
     @staticmethod
     def load(filename):
         ext = os.path.splitext(filename)[1].lower()
         if ext=='.pkl':
             import pickle
             with open(filename,'rb') as f:
                 dat=pickle.load(f)
         else:
             raise NotImplementedError()
         return dat
 
 
-def _plot(time, X_clean, X_hat, sX, title='', X_noisy=None, fig=None, COLRS=None, channels=None, nPlotCols=1):
+def _plot(time, X_clean, X_hat, sX, title='', X_noisy=None, fig=None, COLRS=None, channels=None, nPlotCols=1, figSize=(6.4,4.8), stats='sigRatio,eps,R2'):
+    from welib.tools.stats import comparison_stats
     import matplotlib
     import matplotlib.pyplot as plt
     # --- Compare States
     if COLRS is None:
         cmap = matplotlib.cm.get_cmap('viridis')
         COLRS = [(cmap(v)[0],cmap(v)[1],cmap(v)[2]) for v in np.linspace(0,1,3+1)]
 
@@ -399,34 +487,47 @@
             I=np.arange(len(sX))
     else:
         I=np.arange(len(sX))
 
     if fig is None:
 
         if nPlotCols==2:
-            fig,axes = plt.subplots(int(np.ceil(len(I)/2)), 2, sharex=True, figsize=(6.4,4.8)) # (6.4,4.8)
+            fig,axes = plt.subplots(int(np.ceil(len(I)/2)), 2, sharex=True, figsize=figSize) # (6.4,4.8)
             fig.subplots_adjust(left=0.07, right=0.98, top=0.955, bottom=0.05, hspace=0.20, wspace=0.20)
         else:
-            fig,axes = plt.subplots(len(I), 1, sharex=True, figsize=(6.4,4.8)) # (6.4,4.8)
+            fig,axes = plt.subplots(len(I), 1, sharex=True, figsize=figSize) # (6.4,4.8)
             fig.subplots_adjust(left=0.16, right=0.95, top=0.95, bottom=0.12, hspace=0.20, wspace=0.20)
 
-
-
         if not hasattr(axes,'__len__'):
             axes=[axes]
+    else:
+        axes = fig.axes
     axes=(np.asarray(axes).T).ravel()
     
     for j,i in enumerate(I):
         s  = sX[i]
         ax = axes[j]
-        ax.plot(time,X_clean[s],''  , color=COLRS[0],label='Reference')
+        if X_clean is not None:
+            ax.plot(time,X_clean[s],''  , color=COLRS[0],label='Reference')
         if X_noisy is not None:
             ax.plot(time,X_noisy[s],'-.',  color=COLRS[2] ,label='Noisy')
         ax.plot(time,X_hat[s],'--', color=COLRS[1],label='Estimate')
+
+        if stats:
+            if X_clean is not None:
+                _, sStats = comparison_stats(time, X_clean[s], time, X_hat[s], stats=stats)
+                Ylim = ax.get_ylim()
+                Xlim = ax.get_xlim()
+                ax.text(Xlim[0]*1.01 ,Ylim[0]+(Ylim[1]-Ylim[0])*0.82, sStats, fontsize=10)
+
         ax.set_ylabel(s)
         ax.tick_params(direction='in')
     axes[0].set_title(title)
     axes[-1].set_xlabel('Time [s]')
-    axes[-1].legend()
-    return fig, axes
+    axes[len(I)-1].legend()
+    # Remove unnecessary axes
+    if len(axes)>len(I):
+        for j in range(len(I), len(axes)):
+            axes[j].axis('off')
+    return fig
```

### Comparing `welib-0.0.2/welib/kalman/tests/test_kalman.py` & `welib-1.0.0/welib/kalman/tests/test_kalman.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/kalman/tests/test_run_Examples.py` & `welib-1.0.0/welib/FEM/tests/test_run_Examples.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,20 +14,24 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
+        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z_-]*.py'))
         import matplotlib.pyplot as plt
-        print('\n--------------------------------------------------------------')
         for f in files:
+            print('\n--------------------------------------------------------------')
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+
+        try:
+            plt.close('all')
+        except:
+            pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/mesh/fbinary_search.py` & `welib-1.0.0/welib/mesh/fbinary_search.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/mesh/gradient.py` & `welib-1.0.0/welib/mesh/gradient.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/mesh/mesh.py` & `welib-1.0.0/welib/mesh/mesh.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/mesh/tests/test_vectoranalysis.py` & `welib-1.0.0/welib/mesh/tests/test_vectoranalysis.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/mesh/vectoranalysis.py` & `welib-1.0.0/welib/mesh/vectoranalysis.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/moor/mappp.py` & `welib-1.0.0/welib/moor/mappp.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,621 +1,615 @@
-'''
+"""
 Wrapper for MAP DLL
 
 
 Adapted from:
   https://bitbucket.org/mmasciola/map-plus-plus/src/master/
 
   Copyright (C) 2014 mdm                                      
   marco[dot]masciola[at]gmail                                 
-                                                              
-Licensed to the Apache Software Foundation (ASF) under one    
-or more contributor license agreements.  See the NOTICE file  
-distributed with this work for additional information         
-regarding copyright ownership.  The ASF licenses this file    
-to you under the Apache License, Version 2.0 (the             
-"License"); you may not use this file except in compliance    
-with the License.  You may obtain a copy of the License at    
-                                                              
-  http://www.apache.org/licenses/LICENSE-2.0                  
-                                                              
-Unless required by applicable law or agreed to in writing,    
-software distributed under the License is distributed on an   
-"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY        
-KIND, either express or implied.  See the License for the     
-specific language governing permissions and limitations             
-under the License.                                              
-'''
+"""                                                              
+# Licensed to the Apache Software Foundation (ASF) under one   
+# or more contributor license agreements.  See the NOTICE file 
+# distributed with this work for additional information        
+# regarding copyright ownership.  The ASF licenses this file   
+# to you under the Apache License, Version 2.0 (the            
+# "License"); you may not use this file except in compliance   
+# with the License.  You may obtain a copy of the License at   
+#                                                              
+#   http://www.apache.org/licenses/LICENSE-2.0                 
+#                                                              
+# Unless required by applicable law or agreed to in writing,   
+# software distributed under the License is distributed on an  
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       
+# KIND, either express or implied.  See the License for the    
+# specific language governing permissions and limitations            
+# under the License.   
+
 
 
 import numpy as np
 import sys
 from ctypes import *
 import os
-import platform
 
 
-class Map(object):
+from distutils.sysconfig import get_config_var
+
+from sys import platform
+
+
+def setupLib(libpath):
+    """
+    Load the MAP++ library and setup the data types for the C-routines
+    """
+    print('Loading MAP library:', libpath)
+    lib = cdll.LoadLibrary(libpath)
+
+    class ModelData_Type(Structure):
+        _fields_ = []
+
+
+    # void * object ;
+    # double gravity ;
+    # double seaDensity ;
+    # double depth ;
+    # char fileName[255] ;
+    # char summaryFileName[255] ;
+    # char libraryInputLine[255] ;
+    # char nodeInputLine[255] ;
+    # char elementInputLine[255] ;
+    # char optionInputLine[255] ;
+    class InitializationData_Type(Structure):
+        _fields_= [("object",c_void_p),
+                   ("gravity",c_double),
+                   ("seaDensity",c_double),
+                   ("depth",c_double),
+                   ("fileName",c_char*255),
+                   ("summaryFileName",c_char*255),
+                   ("libraryInputLine",c_char*255),
+                   ("nodeInputLine",c_char*255),
+                   ("elementInputLine",c_char*255),
+                   ("optionInputLine",c_char*255)]
+
+        
+
+    # void * object ;
+    # char progName[99] ;
+    # char version[99] ;
+    # char compilingData[24] ;
+    # char * writeOutputHdr ;     int writeOutputHdr_Len ;
+    # char * writeOutputUnt ;     int writeOutputUnt_Len ;
+    class InitializationOutputData_Type(Structure):
+        _fields_ = [("object",c_void_p),
+                    ("progName",c_char*99),
+                    ("version",c_char*99),
+                    ("CompilingData",c_char*99),
+                    ("writeOutputHdr",c_char_p),
+                    ("writeOutputHdr_Len",c_int),
+                    ("writeOutputUnt",c_char_p),
+                    ("writeOutputUnt_Len",c_int)]
+
+    class InputData_Type(Structure):
+        _fields_ = []
+
+
+    class OutputData_Type(Structure):
+        _fields_ = [("object", c_void_p),
+                    ("Fx",POINTER(c_double)),
+                    ("Fx_Len", c_int),
+                    ("Fy",POINTER(c_double)),
+                    ("Fy_Len", c_int),
+                    ("Fz",POINTER(c_double)),
+                    ("Fz_Len", c_int),
+                    ("WriteOuput",POINTER(c_float)),
+                    ("WriteOutput_Len", c_int),
+                    ("wrtOuput",POINTER(c_double)),
+                    ("wrtOutput_Len", c_int)]
+
+        
+    # void * object ;
+    # double g ;
+    # double depth ;
+    # double rhoSea ;
+
+    class ParameterData_Type(Structure):
+        _fields_ = [("object",c_void_p),
+                    ("g",c_double),
+                    ("depth",c_double), 
+                    ("rhoSea", c_double)]
+
+    class ConstraintData_Type(Structure):
+        _fields_ = []
+
+    class ContinuousData_Type(Structure):
+        _fields_ = []
+
+    # fields for the fortran types
+    # 
+    # MAP_EXTERNCALL MAP_InitInputType_t* map_create_init_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_InitOutputType_t* map_create_initout_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_InputType_t* map_create_input_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_ParameterType_t* map_create_parameter_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_ConstraintStateType_t* map_create_constraint_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_OtherStateType_t* map_create_other_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_OutputType_t* map_create_output_type( char* msg, MAP_ERROR_CODE* status );
+    # MAP_EXTERNCALL MAP_ContinuousStateType_t* map_create_continuous_type( char* msg, MAP_ERROR_CODE* status );
+
+    MapData_Type       = POINTER(ModelData_Type)
+    MapInit_Type       = POINTER(InitializationData_Type)
+    MapInitOut_Type    = POINTER(InitializationOutputData_Type)
+    MapInput_Type      = POINTER(InputData_Type)
+    MapOutput_Type     = POINTER(OutputData_Type)
+    MapParameter_Type  = POINTER(ParameterData_Type)
+    MapConstraint_Type = POINTER(ConstraintData_Type)
+    MapContinuous_Type = POINTER(ContinuousData_Type)
+
+    # read file stuff
+    lib.set_init_to_null.argtype=[MapInit_Type, c_char_p, POINTER(c_int) ]
+    lib.map_set_summary_file_name.argtype=[MapInit_Type, c_char_p, POINTER(c_int) ]
+    lib.map_add_cable_library_input_text.argtype=[MapInit_Type]
+    lib.map_add_node_input_text.argtype=[MapInit_Type]
+    lib.map_add_line_input_text.argtype=[MapInit_Type]
+    lib.map_add_options_input_text.argtype=[MapInit_Type]
+
+    lib.map_create_init_type.argtype       = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_initout_type.argtype    = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_input_type.argtype      = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_parameter_type.argtype  = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_constraint_type.argtype = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_other_type.argtype      = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_output_type.argtype     = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_continuous_type.argtype = [ c_char_p, POINTER(c_int) ]
+    lib.map_create_continuous_type.argtype = [ MapData_Type ]
+    
+    lib.map_create_init_type.restype       = MapInit_Type
+    lib.map_create_initout_type.restype    = MapInitOut_Type
+    lib.map_create_input_type.restype      = MapInput_Type
+    lib.map_create_parameter_type.restype  = MapParameter_Type
+    lib.map_create_constraint_type.restype = MapConstraint_Type
+    lib.map_create_other_type.restype      = MapData_Type
+    lib.map_create_output_type.restype     = MapOutput_Type
+    lib.map_create_continuous_type.restype = MapContinuous_Type
+
+    lib.map_set_sea_depth.argtypes   = [ MapParameter_Type, c_double ]
+    lib.map_set_gravity.argtypes     = [ MapParameter_Type, c_double ]
+    lib.map_set_sea_density.argtypes = [ MapParameter_Type, c_double ]
+    
+    lib.map_size_lines.restype = c_int
+
+    # numeric routines
+    lib.map_residual_function_length.restype = c_double
+    lib.map_residual_function_height.restype = c_double
+    lib.map_jacobian_dxdh.restype            = c_double
+    lib.map_jacobian_dxdv.restype            = c_double
+    lib.map_jacobian_dzdh.restype            = c_double
+    lib.map_jacobian_dzdv.restype            = c_double
+ 
+    lib.map_residual_function_length.argtypes = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_residual_function_height.argtypes = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_jacobian_dxdh.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_jacobian_dxdv.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_jacobian_dzdh.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_jacobian_dzdv.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
+      
+    lib.map_get_fairlead_force_2d.argtypes = [POINTER(c_double), POINTER(c_double), MapData_Type, c_int, c_char_p, POINTER(c_int)]
+    lib.map_get_fairlead_force_3d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double), MapData_Type, c_int, c_char_p, POINTER(c_int)]      
+    try:
+        lib.map_get_anchor_force_2d.argtypes = [POINTER(c_double), POINTER(c_double), MapData_Type, c_int, c_char_p, POINTER(c_int)]
+        lib.map_get_anchor_force_3d.argtypes = [POINTER(c_double), POINTER(c_double), POINTER(c_double), MapData_Type, c_int, c_char_p, POINTER(c_int)]
+    except:
+        print('[WARN] map_get_anchor_force_2d not available in this version of MAP')
+
+    # plot routines
+    lib.map_plot_x_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_plot_x_array.restype  = POINTER(c_double)
+    lib.map_plot_y_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_plot_y_array.restype  = POINTER(c_double)
+    lib.map_plot_z_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
+    lib.map_plot_z_array.restype  = POINTER(c_double)
+    lib.map_plot_array_free.argtypes = [ POINTER(c_double) ]
+ 
+    # modifyers
+    lib.map_offset_vessel.argtypes = [MapData_Type, MapInput_Type, c_double, c_double, c_double, c_double, c_double, c_double, c_char_p, POINTER(c_int)]        
+    lib.map_linearize_matrix.argtypes = [MapInput_Type, MapParameter_Type, MapData_Type, MapOutput_Type, MapConstraint_Type, c_double, POINTER(c_int), c_char_p]        
+    lib.map_linearize_matrix.restype  = POINTER(POINTER(c_double))
+    lib.map_free_linearize_matrix.argtypes = [POINTER(POINTER(c_double))]
+
+    try:
+        lib.map_f_op.argtypes = [MapInput_Type, MapParameter_Type, MapData_Type, MapOutput_Type, MapConstraint_Type, POINTER(c_int), c_char_p]        
+        lib.map_f_op.restype  = POINTER(c_double)
+        lib.map_free_f_op.argtypes = [POINTER(c_double)]
+    except:
+        print('[WARN] map_f_op not available in this version of MAP')
+
+    lib.map_init.argtypes = [ MapInit_Type,
+                              MapInput_Type,
+                              MapParameter_Type,
+                              MapContinuous_Type,
+                              c_void_p,
+                              MapConstraint_Type,
+                              MapData_Type,
+                              MapOutput_Type,
+                              MapInitOut_Type,
+                              POINTER(c_int),
+                              c_char_p]
+
+
+    lib.map_update_states.argtypes = [ c_float,
+                                       c_int,
+                                       MapInput_Type,
+                                       MapParameter_Type,
+                                       MapContinuous_Type,
+                                       c_void_p,
+                                       MapConstraint_Type,
+                                       MapData_Type,
+                                       POINTER(c_int),
+                                       c_char_p]
+
+    lib.map_calc_output.argtypes = [c_float,
+                                    MapInput_Type,
+                                    MapParameter_Type,
+                                    MapContinuous_Type,
+                                    c_void_p,
+                                    MapConstraint_Type,
+                                    MapData_Type,
+                                    MapOutput_Type,
+                                    POINTER(c_int),
+                                    c_char_p]            
+    
+    lib.map_end.argtypes = [ MapInput_Type,
+                             MapParameter_Type,
+                             MapContinuous_Type,
+                             c_void_p,
+                             MapConstraint_Type,
+                             MapData_Type,
+                             MapOutput_Type,
+                             POINTER(c_int),
+                             c_char_p]
+    
+    lib.map_initialize_msqs_base.argtypes = [MapInput_Type,
+                                             MapParameter_Type,
+                                             MapContinuous_Type,
+                                             MapConstraint_Type,
+                                             MapData_Type,
+                                             MapOutput_Type,
+                                             MapInitOut_Type]
+
+    lib.map_size_lines.argtypes = [ MapData_Type,
+                                    POINTER(c_int),
+                                    c_char_p]
+
+    lib.map_get_header_string.argtypes = [c_void_p, POINTER(c_char_p),   MapData_Type]
+    lib.map_get_unit_string.argtypes = [c_void_p, POINTER(c_char_p),   MapData_Type]
+    try:
+        lib.map_offset_fairlead.argtypes = [MapInput_Type, c_int, c_double, c_double, c_double, c_char_p, POINTER(c_int)]                    
+    except:
+        print('[WARN] map_offset_fairlead not available in this version of MAP')
+    return lib
+
+class pyMAP(object):
 
     lib = None # Will hold the dll library handle
+
     # read file stuff
     @classmethod
     def initLib(cls, dllFileName=None):
-        #lib =None
-        # lib = cdll.LoadLibrary("map_x64.dll")
         if dllFileName is None:
             MyDir=os.path.dirname(__file__)
-            if platform.system()=='Windows':
+            if platform == "win32":
                 dllFileName=os.path.join(MyDir,'libmap.dll')
             else:
                 dllFileName=os.path.join(MyDir,'libmap.so')
-        print('Loading MAP library: ',dllFileName)
-        lib = cdll.LoadLibrary(dllFileName)
-
-        '''
-        these are the fortran derived types created by the FAST registry.
-        '''
-        f_type_init = None
-        f_type_initout = None
-        f_type_d = None
-        f_type_u = None
-        f_type_x = None
-        f_type_y = None
-        f_type_z = None
-        f_type_p = None
-
-        class ModelData_Type(Structure):
-            _fields_ = []
-
-
-        '''
-        void * object ;
-        double gravity ;
-        double seaDensity ;
-        double depth ;
-        char fileName[255] ;
-        char summaryFileName[255] ;
-        char libraryInputLine[255] ;
-        char nodeInputLine[255] ;
-        char elementInputLine[255] ;
-        char optionInputLine[255] ;
-        '''
-        class InitializationData_Type(Structure):
-            _fields_= [("object",c_void_p),
-                       ("gravity",c_double),
-                       ("seaDensity",c_double),
-                       ("depth",c_double),
-                       ("fileName",c_char*255),
-                       ("summaryFileName",c_char*255),
-                       ("libraryInputLine",c_char*255),
-                       ("nodeInputLine",c_char*255),
-                       ("elementInputLine",c_char*255),
-                       ("optionInputLine",c_char*255)]
-
-            
-        '''
-        void * object ;
-        char progName[99] ;
-        char version[99] ;
-        char compilingData[24] ;
-        char * writeOutputHdr ;     int writeOutputHdr_Len ;
-        char * writeOutputUnt ;     int writeOutputUnt_Len ;
-        '''
-        class InitializationOutputData_Type(Structure):
-            _fields_ = [("object",c_void_p),
-                        ("progName",c_char*99),
-                        ("version",c_char*99),
-                        ("CompilingData",c_char*99),
-                        ("writeOutputHdr",c_char_p),
-                        ("writeOutputHdr_Len",c_int),
-                        ("writeOutputUnt",c_char_p),
-                        ("writeOutputUnt_Len",c_int)]
-
-        class InputData_Type(Structure):
-            _fields_ = []
-
-
-        class OutputData_Type(Structure):
-            _fields_ = [("object", c_void_p),
-                        ("Fx",POINTER(c_double)),
-                        ("Fx_Len", c_int),
-                        ("Fy",POINTER(c_double)),
-                        ("Fy_Len", c_int),
-                        ("Fz",POINTER(c_double)),
-                        ("Fz_Len", c_int),
-                        ("WriteOuput",POINTER(c_float)),
-                        ("WriteOutput_Len", c_int),
-                        ("wrtOuput",POINTER(c_double)),
-                        ("wrtOutput_Len", c_int)]
-
-            
-        '''
-        void * object ;
-        double g ;
-        double depth ;
-        double rhoSea ;
-        '''
-        class ParameterData_Type(Structure):
-            _fields_ = [("object",c_void_p),
-                        ("g",c_double),
-                        ("depth",c_double), 
-                        ("rhoSea", c_double)]
-
-        class ConstraintData_Type(Structure):
-            _fields_ = []
-
-        class ContinuousData_Type(Structure):
-            _fields_ = []
-
-        '''
-        fields for the fortran types
-
-        MAP_EXTERNCALL MAP_InitInputType_t* map_create_init_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_InitOutputType_t* map_create_initout_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_InputType_t* map_create_input_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_ParameterType_t* map_create_parameter_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_ConstraintStateType_t* map_create_constraint_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_OtherStateType_t* map_create_other_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_OutputType_t* map_create_output_type( char* msg, MAP_ERROR_CODE* status );
-        MAP_EXTERNCALL MAP_ContinuousStateType_t* map_create_continuous_type( char* msg, MAP_ERROR_CODE* status );
-        '''
-
-        MapData_Type       = POINTER(ModelData_Type)
-        MapInit_Type       = POINTER(InitializationData_Type)
-        MapInitOut_Type    = POINTER(InitializationOutputData_Type)
-        MapInput_Type      = POINTER(InputData_Type)
-        MapOutput_Type     = POINTER(OutputData_Type)
-        MapParameter_Type  = POINTER(ParameterData_Type)
-        MapConstraint_Type = POINTER(ConstraintData_Type)
-        MapContinuous_Type = POINTER(ContinuousData_Type)
-
-
-
-        lib.set_init_to_null.argtype=[MapInit_Type, c_char_p, POINTER(c_int) ]
-        lib.map_set_summary_file_name.argtype=[MapInit_Type, c_char_p, POINTER(c_int) ]
-        lib.map_add_cable_library_input_text.argtype=[MapInit_Type]
-        lib.map_add_node_input_text.argtype=[MapInit_Type]
-        lib.map_add_line_input_text.argtype=[MapInit_Type]
-        lib.map_add_options_input_text.argtype=[MapInit_Type]
-
-        lib.map_create_init_type.argtype       = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_initout_type.argtype    = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_input_type.argtype      = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_parameter_type.argtype  = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_constraint_type.argtype = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_other_type.argtype      = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_output_type.argtype     = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_continuous_type.argtype = [ c_char_p, POINTER(c_int) ]
-        lib.map_create_continuous_type.argtype = [ MapData_Type ]
-        
-        lib.map_create_init_type.restype       = MapInit_Type
-        lib.map_create_initout_type.restype    = MapInitOut_Type
-        lib.map_create_input_type.restype      = MapInput_Type
-        lib.map_create_parameter_type.restype  = MapParameter_Type
-        lib.map_create_constraint_type.restype = MapConstraint_Type
-        lib.map_create_other_type.restype      = MapData_Type
-        lib.map_create_output_type.restype     = MapOutput_Type
-        lib.map_create_continuous_type.restype = MapContinuous_Type
-
-        lib.map_set_sea_depth.argtypes   = [ MapParameter_Type, c_double ]
-        lib.map_set_gravity.argtypes     = [ MapParameter_Type, c_double ]
-        lib.map_set_sea_density.argtypes = [ MapParameter_Type, c_double ]
-        
-        lib.map_size_lines.restype = c_int
+#             libext = get_config_var('EXT_SUFFIX')
+#             if libext is None or libext == '':
+#                 if platform == "linux" or platform == "linux2":
+#                     libext = '.so'
+#                 elif platform == "darwin":
+#                     #libext = '.dyld'
+#                     libext = '.so'
+#                 elif platform == "win32":
+#                     #libext = '.dll'
+#                     libext = '.pyd'
+#                 elif platform == "cygwin":
+#                     libext = '.dll'
+# 
+#             maplib = '_libmap' + libext
+#             dllFileName = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) + os.path.sep + maplib
 
-        # numeric routines
-        lib.map_residual_function_length.restype = c_double
-        lib.map_residual_function_height.restype = c_double
-        lib.map_jacobian_dxdh.restype            = c_double
-        lib.map_jacobian_dxdv.restype            = c_double
-        lib.map_jacobian_dzdh.restype            = c_double
-        lib.map_jacobian_dzdv.restype            = c_double
-     
-        lib.map_residual_function_length.argtypes = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_residual_function_height.argtypes = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_jacobian_dxdh.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_jacobian_dxdv.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_jacobian_dzdh.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_jacobian_dzdv.argtypes            = [ MapData_Type, c_int, c_char_p, POINTER(c_int) ]
-          
-        lib.map_get_fairlead_force_2d.argtypes = [POINTER(c_double), POINTER(c_double), MapData_Type, c_int, c_char_p, POINTER(c_int)]
-          
-        # plot routines
-        lib.map_plot_x_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_plot_x_array.restype  = POINTER(c_double)
-        lib.map_plot_y_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_plot_y_array.restype  = POINTER(c_double)
-        lib.map_plot_z_array.argtypes = [ MapData_Type, c_int, c_int, c_char_p, POINTER(c_int) ]
-        lib.map_plot_z_array.restype  = POINTER(c_double)
-        lib.map_plot_array_free.argtypes = [ POINTER(c_double) ]
-     
-        # modifyers
-        lib.map_offset_vessel.argtypes = [MapData_Type, MapInput_Type, c_double, c_double, c_double, c_double, c_double, c_double, c_char_p, POINTER(c_int)]        
-        lib.map_linearize_matrix.argtypes = [MapInput_Type, MapParameter_Type, MapData_Type, MapOutput_Type, MapConstraint_Type, c_double, POINTER(c_int), c_char_p]        
-        lib.map_linearize_matrix.restype  = POINTER(POINTER(c_double))
-        lib.map_free_linearize_matrix.argtypes = [POINTER(POINTER(c_double))]
+        # Load the library and setup C-interfaces
+        lib = setupLib(dllFileName)
 
-        try:
-            lib.map_f_op.argtypes = [MapInput_Type, MapParameter_Type, MapData_Type, MapOutput_Type, MapConstraint_Type, POINTER(c_int), c_char_p]        
-            lib.map_f_op.restype  = POINTER(c_double)
-            lib.map_free_f_op.argtypes = [POINTER(c_double)]
-        except:
-            print('[WARN] map_f_op not available in this version of MAP')
-
-        lib.map_init.argtypes = [ MapInit_Type,
-                                  MapInput_Type,
-                                  MapParameter_Type,
-                                  MapContinuous_Type,
-                                  c_void_p,
-                                  MapConstraint_Type,
-                                  MapData_Type,
-                                  MapOutput_Type,
-                                  MapInitOut_Type,
-                                  POINTER(c_int),
-                                  c_char_p]
-
-
-        lib.map_update_states.argtypes = [ c_float,
-                                           c_int,
-                                           MapInput_Type,
-                                           MapParameter_Type,
-                                           MapContinuous_Type,
-                                           c_void_p,
-                                           MapConstraint_Type,
-                                           MapData_Type,
-                                           POINTER(c_int),
-                                           c_char_p]
-
-        lib.map_calc_output.argtypes = [c_float,
-                                        MapInput_Type,
-                                        MapParameter_Type,
-                                        MapContinuous_Type,
-                                        c_void_p,
-                                        MapConstraint_Type,
-                                        MapData_Type,
-                                        MapOutput_Type,
-                                        POINTER(c_int),
-                                        c_char_p]            
-        
-        lib.map_end.argtypes = [ MapInput_Type,
-                                 MapParameter_Type,
-                                 MapContinuous_Type,
-                                 c_void_p,
-                                 MapConstraint_Type,
-                                 MapData_Type,
-                                 MapOutput_Type,
-                                 POINTER(c_int),
-                                 c_char_p]
-        
-        lib.map_initialize_msqs_base.argtypes = [MapInput_Type,
-                                                 MapParameter_Type,
-                                                 MapContinuous_Type,
-                                                 MapConstraint_Type,
-                                                 MapData_Type,
-                                                 MapOutput_Type,
-                                                 MapInitOut_Type]
-
-        lib.map_size_lines.argtypes = [ MapData_Type,
-                                        POINTER(c_int),
-                                        c_char_p]
-
-        lib.map_get_header_string.argtypes = [c_void_p, POINTER(c_char_p),   MapData_Type]
-        lib.map_get_unit_string.argtypes = [c_void_p, POINTER(c_char_p),   MapData_Type]
-        lib.map_offset_fairlead.argtypes = [MapInput_Type, c_int, c_double, c_double, c_double, c_char_p, POINTER(c_int)]                    
-        # Store
+        # Store in object
         cls.lib = lib
 
         cls.ierr = c_int(0)
         cls.status = create_string_buffer(1024)
         cls.val = c_double
 
-    # --------------------------------------------------------------------------------}
-    # --- INIT 
-    # --------------------------------------------------------------------------------{
-    def __init__(self, filename=None, WtrDepth=None, gravity=None, WtrDens=None, sumFile=None, dllFileName=None) :
+
+    def __init__( self, filename=None, lines=None, WtrDepth=None, gravity=None, WtrDens=None, sumFile=None, dllFileName=None ) :
         """
 
         """
         # Call Class method
-        if Map.lib is None:
-            Map.initLib(dllFileName)
-        else:
-            print('Not reinitializing lib.')
+        if pyMAP.lib is None:
+            pyMAP.initLib(dllFileName)
+
         # Misc Data
         self._gravity=None
         self._WtrDepth=None
         self._WtrDens=None
         self._filename=None
         self._K_lin       = None # Linear stiffness matrix
         self._K_lin_point = None # Point where linear stiffness matrix was computed
+        self.Nodes=[]
+        self._initialized = False
 
         # Wrapper data
         self.f_type_d       = self.CreateDataState()
         self.f_type_u       = self.CreateInputState( )
         self.f_type_x       = self.CreateContinuousState( )
         self.f_type_p       = self.CreateParameterState( )
         self.f_type_y       = self.CreateOutputState( )
         self.f_type_z       = self.CreateConstraintState( )
         self.f_type_init    = self.CreateInitState( )
         self.f_type_initout = self.CreateInitoutState( )
-        Map.lib.set_init_to_null(self.f_type_init, self.status, pointer(self.ierr) )
-        Map.lib.map_initialize_msqs_base(self.f_type_u, self.f_type_p, self.f_type_x, self.f_type_z, self.f_type_d, self.f_type_y, self.f_type_initout)
+        pyMAP.lib.set_init_to_null(self.f_type_init, self.status, pointer(self.ierr) )
+        pyMAP.lib.map_initialize_msqs_base(self.f_type_u, self.f_type_p, self.f_type_x, self.f_type_z, self.f_type_d, self.f_type_y, self.f_type_initout)
+
 
+        callInit = False
         # Read input file (either OpenFAST or MAP)
         if filename is not None:
-            from welib.weio import FASTInputFile
             ext = os.path.splitext(filename)[1].lower()
             if ext=='.fst':
+                from welib.weio import FASTInputFile
                 fst = FASTInputFile(filename)
                 if WtrDepth is None:
                     WtrDepth=fst['WtrDpth'] # m
                 if gravity is None:
                     gravity=fst['gravity'] # m/s^2
                 if WtrDens is None:
                     WtrDens=fst['WtrDens'] # kg/m^3
                 filename = os.path.join(os.path.dirname(filename), fst['MooringFile'].replace('"',''))
-                #print('>>> WtrDens={}, WtrDepth={}, gravity={}'.format(WtrDens,WtrDepth,gravity))
             else:
                 # Assume that it's a MAP input file
                 pass
 
             self.read_file(filename)
+            callInit = True
             sumFile = os.path.splitext(filename)[0]+'.map.sum'
 
+        # Read input lines
+        if lines is not None:
+            self.read_list_input(lines)
+            callInit = True
+
         # Set summary file
         if sumFile is None:
-            sumFile = 'map.sum'
+            sumFile = 'outlist.map.sum'
         self.summary_file(sumFile)
 
         # Set env conditions if provided or read from file
         if WtrDepth is not None:
             self.map_set_sea_depth(WtrDepth)  # m
         if gravity is not None:
             self.map_set_gravity(gravity)     # m/s^2
         if WtrDens is not None:
             self.map_set_sea_density(WtrDens) # kg/m^3
 
-
         # If all inputs have been provided, initialize
         if self._WtrDens is not None and self._WtrDepth is not None and self._gravity is not None:
-            if self._filename is not None:
+            if callInit:
                 self.init()
 
     def __repr__(self):
         s ='<{} object> with attributes:\n'.format(type(self).__name__)
         s+='|- Nodes: {}\n'.format(len(self.Nodes))
         for n in self.Nodes:
             s+='|   {}\n'.format(n)
         s+='|- _WtrDepth: {}\n'.format(self._WtrDepth)
         s+='|- _WtrDens : {}\n'.format(self._WtrDens)
         s+='|- _gravity : {}\n'.format(self._gravity)
-        s+='| main methods: \n'
         return s
 
-
-
     def init( self ):
-        Map.lib.map_init( self.f_type_init, self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, self.f_type_initout, pointer(self.ierr), self.status )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        if self._initialized:
+            raise Exception('Cannot call map_init twice')
+        pyMAP.lib.map_init( self.f_type_init, self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, self.f_type_initout, pointer(self.ierr), self.status )
+        if self.ierr.value != 0 : print(self.status.value)
+        self._initialized = True
 
 
     def size_lines(self):
-        size = Map.lib.map_size_lines(self.f_type_d, pointer(self.ierr), self.status )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        size = pyMAP.lib.map_size_lines(self.f_type_d, pointer(self.ierr), self.status )
+        if self.ierr.value != 0 : print(self.status.value)
         return size
 
 
     def update_states(self, t, dt):
-        Map.lib.map_update_states(c_float(t), c_int(dt), self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, pointer(self.ierr), self.status )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        pyMAP.lib.map_update_states(c_float(t), c_int(dt), self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, pointer(self.ierr), self.status )
+        if self.ierr.value != 0 : print(self.status.value)
 
 
     def calc_output(self, t):
-        Map.lib.map_calc_output(c_float(t), self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, pointer(self.ierr), self.status )
+        pyMAP.lib.map_calc_output(c_float(t), self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, pointer(self.ierr), self.status )
         if self.ierr.value != 0 :
             print(self.status.value)
 
 
     def get_output(self):
         size_x, size_y, size_z = self.f_type_y.contents.Fx_Len, self.f_type_y.contents.Fy_Len, self.f_type_y.contents.Fz_Len
         arr_x, arr_y, arr_z = [None]*size_x, [None]*size_y, [None]*size_z
         fx = [self.f_type_y.contents.Fx[j] for j in range(size_x)]
         fy = [self.f_type_y.contents.Fy[j] for j in range(size_y)]
         fz = [self.f_type_y.contents.Fz[j] for j in range(size_z)]        
         return fx, fy, fz
 
 
-
     def get_output_labels(self):
         size = self.f_type_y.contents.WriteOutput_Len + self.f_type_y.contents.wrtOutput_Len
         string_buffers = [create_string_buffer(16) for i in range(size)]
         pointers = (c_char_p*size)(*map(addressof, string_buffers))
-        Map.lib.map_get_header_string(None, pointers, self.f_type_d)
+        pyMAP.lib.map_get_header_string(None, pointers, self.f_type_d)
         return [s.value for s in string_buffers]
 
     
     def get_output_units(self):
         size = self.f_type_y.contents.WriteOutput_Len + self.f_type_y.contents.wrtOutput_Len
         string_buffers = [create_string_buffer(16) for i in range(size)]
         pointers = (c_char_p*size)(*map(addressof, string_buffers))
-        Map.lib.map_get_unit_string(None, pointers, self.f_type_d)
+        pyMAP.lib.map_get_unit_string(None, pointers, self.f_type_d)
         return [s.value for s in string_buffers]
     
     
     def get_output_buffer(self):
         size_float, size_double = self.f_type_y.contents.WriteOutput_Len, self.f_type_y.contents.wrtOutput_Len
         arr_float, arr_double = [None]*size_float, [None]*size_double
         arr_float = [self.f_type_y.contents.WriteOutput[j] for j in range(size_float)]
         arr_double = [self.f_type_y.contents.wrtOuput[j] for j in range(size_double)]
         return arr_float + arr_double
     
         
-    """
-    Calls function in main.c and fordatamanager.c to delete insteads of c structs. First, the malloc'ed arrays need to vanish
-    gracefully; we accomplish this by calling MAP_End(...) routine. Then, the structs themself are deleted. Order is important.
-
-    MAP_EXTERNCALL int MAP_End ( InputData *u, ParameterData *p, ContinuousData *x, ConstraintData *z, ModelData *data, OutputData *y, char *map_msg, MAP_ERROR_CODE *ierr )
-    MAP_EXTERNCALL void MAP_Input_Delete( InputData* u )
-    MAP_EXTERNCALL void MAP_Param_Delete( ParameterData* p )
-    MAP_EXTERNCALL void MAP_ContState_Delete( InputData* x )
-    MAP_EXTERNCALL void MAP_ConstrState_Delete( InputData* z )
-    MAP_EXTERNCALL void MAP_Output_Delete( InputData* y )
-    MAP_EXTERNCALL void MAP_OtherState_Delete( ModelData* data )
-    """
+    # Calls function in main.c and fordatamanager.c to delete insteads of c structs. First, the malloc'ed arrays need to vanish
+    # gracefully; we accomplish this by calling MAP_End(...) routine. Then, the structs themself are deleted. Order is important.
+    # 
+    # MAP_EXTERNCALL int MAP_End ( InputData *u, ParameterData *p, ContinuousData *x, ConstraintData *z, ModelData *data, OutputData *y, char *map_msg, MAP_ERROR_CODE *ierr )
+    # MAP_EXTERNCALL void MAP_Input_Delete( InputData* u )
+    # MAP_EXTERNCALL void MAP_Param_Delete( ParameterData* p )
+    # MAP_EXTERNCALL void MAP_ContState_Delete( InputData* x )
+    # MAP_EXTERNCALL void MAP_ConstrState_Delete( InputData* z )
+    # MAP_EXTERNCALL void MAP_Output_Delete( InputData* y )
+    # MAP_EXTERNCALL void MAP_OtherState_Delete( ModelData* data )
     def end(self):
-        Map.lib.map_end(self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, pointer(self.ierr), self.status)
+        pyMAP.lib.map_end(self.f_type_u, self.f_type_p, self.f_type_x, None, self.f_type_z, self.f_type_d, self.f_type_y, pointer(self.ierr), self.status)
 
 
-    """
-    Set a name for the MAP summary file. Does not need to be called. If not called, the default name is 'outlist.sum.map'
-    """
+    # Set a name for the MAP summary file. Does not need to be called. If not called, the default name is 'outlist.map.sum'
     def summary_file(self, echo_file):
         self.f_type_init.contents.summaryFileName = echo_file.encode('utf-8')
-        Map.lib.map_set_summary_file_name(self.f_type_init, self.status, pointer(self.ierr) )
+        pyMAP.lib.map_set_summary_file_name(self.f_type_init, self.status, pointer(self.ierr) )
 
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL InitializationData* MAP_InitInput_Create( char* map_msg, MAP_ERROR_CODE* ierr )
-    """
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL InitializationData* MAP_InitInput_Create( char* map_msg, MAP_ERROR_CODE* ierr )
     def CreateInitState( self ) :
-        obj = Map.lib.map_create_init_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_init_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL void MAP_InitOutput_Delete( InputData* io )
-    """
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL void MAP_InitOutput_Delete( InputData* io )
     def CreateInitoutState( self ) :
-        obj = Map.lib.map_create_initout_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_initout_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL ModelData *MAP_OtherState_Create( char *map_msg, MAP_ERROR_CODE *ierr )
-    """
+
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL ModelData *MAP_OtherState_Create( char *map_msg, MAP_ERROR_CODE *ierr )
     def CreateDataState( self ) :
-        obj = Map.lib.map_create_other_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_other_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL InputData* MAP_Input_Create( char* map_msg, MAP_ERROR_CODE *ierr )
-    """
+
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL InputData* MAP_Input_Create( char* map_msg, MAP_ERROR_CODE *ierr )
     def CreateInputState( self ) :
-        obj = Map.lib.map_create_input_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_input_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL ContinuousData* MAP_ContState_Create( char* map_msg, MAP_ERROR_CODE *ierr )
-    """
+
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL ContinuousData* MAP_ContState_Create( char* map_msg, MAP_ERROR_CODE *ierr )
     def CreateContinuousState( self ) :
-        obj = Map.lib.map_create_continuous_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_continuous_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL OutputData *MAP_Output_Create( char *map_msg, MAP_ERROR_CODE *ierr )
-    """
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL OutputData *MAP_Output_Create( char *map_msg, MAP_ERROR_CODE *ierr )
     def CreateOutputState( self ) :
-        obj = Map.lib.map_create_output_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_output_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL ConstraintData* MAP_ConstrState_Create( char* map_msg, MAP_ERROR_CODE *ierr )
-    """
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL ConstraintData* MAP_ConstrState_Create( char* map_msg, MAP_ERROR_CODE *ierr )
     def CreateConstraintState( self ) :
-        obj = Map.lib.map_create_constraint_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_constraint_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
 
-    """
-    Calls function in fortdatamanager.c to create instance of c structs
-    MAP_EXTERNCALL ParameterData* MAP_Param_Create( char* map_msg, MAP_ERROR_CODE *ierr )
-    """
+    # Calls function in fortdatamanager.c to create instance of c structs
+    # MAP_EXTERNCALL ParameterData* MAP_Param_Create( char* map_msg, MAP_ERROR_CODE *ierr )
     def CreateParameterState( self ) :
-        obj = Map.lib.map_create_parameter_type( self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
+        obj = pyMAP.lib.map_create_parameter_type( self.status, pointer(self.ierr) )
+        if self.ierr.value != 0 : print(self.status.value)
         return obj
 
 
     def map_set_sea_depth( self, depth ):
          self._WtrDepth=depth
-         Map.lib.map_set_sea_depth( self.f_type_p, depth )
+         pyMAP.lib.map_set_sea_depth( self.f_type_p, depth )
 
          
     def map_set_gravity( self, g ):
         self._gravity=g
-        Map.lib.map_set_gravity( self.f_type_p, g )
+        pyMAP.lib.map_set_gravity( self.f_type_p, g )
 
         
     def map_set_sea_density( self, rho ):
         self._WtrDens=rho
-        Map.lib.map_set_sea_density( self.f_type_p, rho )
+        pyMAP.lib.map_set_sea_density( self.f_type_p, rho )
 
     def plot_x( self, lineNum, length ) :
         arr = [None]*length
         array = POINTER(c_double)
-        array = Map.lib.map_plot_x_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
+        array = pyMAP.lib.map_plot_x_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
-            Map.lib.map_plot_array_free( array )        
+            pyMAP.lib.map_plot_array_free( array )        
             sys.exit('MAP terminated premature.')
         arr = [array[j] for j in range(length)]        
-        Map.lib.map_plot_array_free( array )        
+        pyMAP.lib.map_plot_array_free( array )        
         return arr 
 
     
     def plot_y( self, lineNum, length ) :
         arr = [None]*length
         array = POINTER(c_double)
-        array = Map.lib.map_plot_y_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
+        array = pyMAP.lib.map_plot_y_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
-            Map.lib.map_plot_array_free( array )        
+            pyMAP.lib.map_plot_array_free( array )        
             sys.exit('MAP terminated premature.')
         arr = [array[j] for j in range(length)]        
-        Map.lib.map_plot_array_free( array )        
+        pyMAP.lib.map_plot_array_free( array )        
         return arr 
 
 
     def plot_z( self, lineNum, length ) :
         arr = [None]*length
         array = POINTER(c_double)
-        array = Map.lib.map_plot_z_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
+        array = pyMAP.lib.map_plot_z_array( self.f_type_d, lineNum, length, self.status, pointer(self.ierr) )        
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
-            Map.lib.map_plot_array_free( array )        
+            pyMAP.lib.map_plot_array_free( array )        
             sys.exit('MAP terminated premature.')
         arr = [array[j] for j in range(length)]        
-        Map.lib.map_plot_array_free( array )        
+        pyMAP.lib.map_plot_array_free( array )        
         return arr
     
 
     def get_fairlead_force_2d(self, index):
         """Gets the horizontal and vertical fairlead force in a 2D plane along the 
         straight-line line. Must ensure update_states() is called before accessing 
         this function. The function will not solve the forces for a new vessel position
@@ -627,15 +621,15 @@
         :param index: The line number the fairlead forces are being requested for. Zero indexed
         :returns: horizontal and vertical fairlead force [N]
     
         >>> H,V = print get_fairlead_force_2d(1)        
         """
         H_ref = c_double(-999.9)
         V_ref = c_double(-999.9)
-        Map.lib.map_get_fairlead_force_2d( pointer(H_ref), pointer(V_ref),self.f_type_d, index, self.status, pointer(self.ierr))
+        pyMAP.lib.map_get_fairlead_force_2d( pointer(H_ref), pointer(V_ref),self.f_type_d, index, self.status, pointer(self.ierr))
         return H_ref.value, V_ref.value
     
     
     def get_fairlead_force_3d(self, index):
         """Gets the horizontal and vertical fairlead force in a 3D frame along relative 
         referene global axis. Must ensure update_states() is called before accessing 
         this function. The function will not solve the forces for a new vessel position
@@ -648,86 +642,124 @@
         :returns: horizontal and vertical fairlead force [N]
     
         >>> fx,fy,fz = get_fairlead_force_3d(1)        
         """
         fx = c_double(-999.9)
         fy = c_double(-999.9)
         fz = c_double(-999.9)
-        Map.lib.map_get_fairlead_force_3d( pointer(fx), pointer(fy), pointer(fz), self.f_type_d, index, self.status, pointer(self.ierr))
+        pyMAP.lib.map_get_fairlead_force_3d( pointer(fx), pointer(fy), pointer(fz), self.f_type_d, index, self.status, pointer(self.ierr))
         return fx.value, fy.value, fz.value
         
 
+    def get_anchor_force_2d(self, index):
+        """Gets the horizontal and vertical anchor force in a 2D plane along the 
+        straight-line line. Must ensure update_states() is called before accessing 
+        this function. The function will not solve the forces for a new vessel position
+        if it updated. , otherwise the anchor forces are not updated with the new 
+        vessel position. Called C function:
+        
+        MAP_EXTERNCALL void map_get_anchor_force_2d(double* H, double* V, MAP_OtherStateType_t* other_type, int index, char* map_msg, MAP_ERROR_CODE* ierr);
+    
+        :param index: The line number the anchor forces are being requested for. Zero indexed
+        :returns: horizontal and vertical anchor force [N]
+    
+        >>> H,V = print get_anchor_force_2d(1)        
+        """
+        Ha_ref = c_double(-999.9)
+        Va_ref = c_double(-999.9)
+        pyMAP.lib.map_get_anchor_force_2d( pointer(Ha_ref), pointer(Va_ref),self.f_type_d, index, self.status, pointer(self.ierr))
+        return Ha_ref.value, Va_ref.value
+    
+    
+    def get_anchor_force_3d(self, index):
+        """Gets the horizontal and vertical anchor force in a 3D frame along relative 
+        referene global axis. Must ensure update_states() is called before accessing 
+        this function. The function will not solve the forces for a new vessel position
+        if it updated. , otherwise the anchor forces are not updated with the new 
+        vessel position. Called C function:
+        
+        MAP_EXTERNCALL void map_get_anchor_force_3d(double* fx, double* fy, double* fz, MAP_OtherStateType_t* other_type, int index, char* map_msg, MAP_ERROR_CODE* ierr);
+    
+        :param index: The line number the anchor forces are being requested for. Zero indexed
+        :returns: horizontal and vertical anchor force [N]
+    
+        >>> fx,fy,fz = get_anchor_force_3d(1)        
+        """
+        fxa = c_double(-999.9)
+        fya = c_double(-999.9)
+        fza = c_double(-999.9)
+        pyMAP.lib.map_get_anchor_force_3d( pointer(fxa), pointer(fya), pointer(fza), self.f_type_d, index, self.status, pointer(self.ierr))
+        return fxa.value, fya.value, fza.value
+    
     def funcl( self, i ) :
-        self.val = Map.lib.map_residual_function_length(self.f_type_d, i, self.status, pointer(self.ierr))
+        self.val = pyMAP.lib.map_residual_function_length(self.f_type_d, i, self.status, pointer(self.ierr))
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
     def funch( self, i ) :
-        self.val = Map.lib.map_residual_function_height(self.f_type_d, i, self.status, pointer(self.ierr))
+        self.val = pyMAP.lib.map_residual_function_height(self.f_type_d, i, self.status, pointer(self.ierr))
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
     def dxdh( self, i ) :
-        self.val = Map.lib.map_jacobian_dxdh( self.f_type_d, i, self.status, pointer(self.ierr) )
+        self.val = pyMAP.lib.map_jacobian_dxdh( self.f_type_d, i, self.status, pointer(self.ierr) )
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
     def dxdv( self, i ) :
-        self.val = Map.lib.map_jacobian_dxdv( self.f_type_d, i, self.status, pointer(self.ierr) )
+        self.val = pyMAP.lib.map_jacobian_dxdv( self.f_type_d, i, self.status, pointer(self.ierr) )
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
     def dzdh( self, i ) :
-        self.val = Map.lib.map_jacobian_dzdh( self.f_type_d, i, self.status, pointer(self.ierr) )
+        self.val = pyMAP.lib.map_jacobian_dzdh( self.f_type_d, i, self.status, pointer(self.ierr) )
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
     def dzdv( self, i ) :
-        self.val = Map.lib.map_jacobian_dzdv( self.f_type_d, i, self.status, pointer(self.ierr) )
+        self.val = pyMAP.lib.map_jacobian_dzdv( self.f_type_d, i, self.status, pointer(self.ierr) )
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')
         return self.val
 
 
-    def linear( self, epsilon=1.e-3, point=None) :
+    def linear( self, epsilon=1.e-3) :
         """
-        Return linear matrix, transpose of stiffness matrix
+        Return linear matrix, transpose of stiffness matrix at (0,0,0)
         """
-        if point is not None:
-            raise Exception('Do not call `linear` with argument point, call `stiffness_matrix` instead.') 
         array = POINTER(POINTER(c_double))
-        array = Map.lib.map_linearize_matrix( self.f_type_u, self.f_type_p, self.f_type_d, self.f_type_y, self.f_type_z, epsilon, pointer(self.ierr), self.status)        
+        array = pyMAP.lib.map_linearize_matrix( self.f_type_u, self.f_type_p, self.f_type_d, self.f_type_y, self.f_type_z, epsilon, pointer(self.ierr), self.status)        
         if self.ierr.value != 0 :
            print(self.status.value)
            self.end( )
            sys.exit('MAP terminated premature.')
         arr = [[array[j][i] for i in range(6)] for j in range(6)] 
-        Map.lib.map_free_linearize_matrix(array)        
+        pyMAP.lib.map_free_linearize_matrix(array)        
         # Stiffness matrix is defined at (0,0,0)
         K_0   = np.array(arr) # NOTE: this is a transposed of a stiffness matrix !!!
         return K_0
 
 
     def stiffness_matrix(self, epsilon=1.e-3, point=None) :
         # Stiffness matrix at (0,0,0)
@@ -741,105 +773,107 @@
             F_op_D = F_op_0
         else:
             # Transfer to requested reference point
             r_S  = np.array((0,0,0)) # Source # TODO is it OK when vessel has been displaced?
             r_D = np.array(point)    # Destination
             r0  = r_S - r_D  # 
             K_D = - translateLoadsJacobian(-K_0, r0, F_op_0[:3]) # Jacobians are -K
-            #from welib.FEM.utils import rigidTransformationTwoPoints, rigidTransformationTwoPoints_Loads
-            #T_Ref2HD   = rigidTransformationTwoPoints(r_D, r_S)
-            #T_HD2Ref_l = rigidTransformationTwoPoints_Loads(r_S, r_D)
-            #K_Ref = T_HD2Ref_l.dot(K_0.dot(T_Ref2HD))
             F_op_D = F_op_0.copy()
             F_op_D[3:6] += np.cross(r0,F_op_0[:3])
         self._K_lin       = K_D
         self._K_lin_point = point
         return K_D, F_op_D
 
     def f_op(self) :
         try:
             array = POINTER(c_double)
-            array = Map.lib.map_f_op( self.f_type_u, self.f_type_p, self.f_type_d, self.f_type_y, self.f_type_z, pointer(self.ierr), self.status)        
+            array = pyMAP.lib.map_f_op( self.f_type_u, self.f_type_p, self.f_type_d, self.f_type_y, self.f_type_z, pointer(self.ierr), self.status)        
             if self.ierr.value != 0 :
                print(self.status.value)
                self.end( )
                sys.exit('MAP terminated premature.')
             arr = [array[i] for i in range(6)]
-            Map.lib.map_free_f_op(array)        
+            pyMAP.lib.map_free_f_op(array)        
             Fop   = np.array(arr)
         except:
             print('[WARN] MAP f_op not available in this version of the library')
             Fop=np.zeros(6)
         return Fop
     
 
     def displace_vessel(self,x,y,z,phi,the,psi) :
         """
         NOTE:  
          - phi is rotation around x  
          - the is rotation around y  
          - psi is rotation around z  
         """
-        Map.lib.map_offset_vessel(self.f_type_d, self.f_type_u, x,y,z,phi,the,psi, self.status, pointer(self.ierr) )
+        pyMAP.lib.map_offset_vessel(self.f_type_d, self.f_type_u, x,y,z,phi,the,psi, self.status, pointer(self.ierr) )
         if self.ierr.value != 0 :
             print(self.status.value)
             self.end( )
             sys.exit('MAP terminated premature.')    
 
             
-    def offset_fairlead(self,x,y,z, idx):
-        Map.lib.map_offset_fairlead(self.f_type_u, c_int(idx), x, y, z, self.status, pointer(self.ierr) )
-        if self.ierr.value != 0 :
-            print(self.status.value)
-            self.end( )
-            sys.exit('MAP terminated premature.')    
-
-            
-    def read_file(self, file_name):
-        self._filename = file_name
-        f           = open(file_name, 'r')
+    #def offset_fairlead(self,x,y,z, idx):
+    #    pyMAP.lib.map_offset_fairlead(self.f_type_u, c_int(idx), x, y, z, self.status, pointer(self.ierr) )
+    #    if self.ierr.value != 0 :
+    #        print(self.status.value)
+    #        self.end( )
+    #        sys.exit('MAP terminated premature.')   
+    def read_file( self, fileName ):
+        with open(fileName, 'r', errors="surrogateescape") as f:
+            lines = f.read().splitlines()
+        self.read_list_input( lines )
+# 
+                    
+    def read_list_input(self, listIn):
+        assert isinstance(listIn, list), 'Must input a python list of strings'
+        assert len(listIn) >= 8, 'Must have at least 4 sections, 3 lines per section'
+        assert type(listIn[0]) == type(''), 'List elements must be strings'
+        charptr = POINTER(c_char)
         option_breaks = ("LINE DICTIONARY", "NODE PROPERTIES", "LINE PROPERTIES", "SOLVER OPTIONS")
 
-        # --- Read file lines
+        # --- Read file lines and store in different lists
         sCabLib = []
         sNodes = []
         sProps = []
         sOpts  = []
-        for line in f:
-            line = line
-
+        listIter = iter(listIn)
+        for line in listIter:
+            line = line.strip()
             if "LINE DICTIONARY" in line.upper():
-                for _ in range(3): line = next(f) # Header
+                for _ in range(3): line = next(listIter) # Process Header
                 while not any(opt in line for opt in option_breaks):
                     sCabLib.append(line)
-                    line = next(f)
+                    line = next(listIter)
 
             if "NODE PROPERTIES" in line.upper():
-                for _ in range(3): line = next(f) #Header
+                for _ in range(3): line = next(listIter) # Process Header
                 while not any(opt in line for opt in option_breaks):
                     sNodes.append(line)
-                    line = next(f)
+                    line = next(listIter)
 
             if "LINE PROPERTIES" in line.upper():
-                for _ in range(3): line = next(f)
+                for _ in range(3): line = next(listIter) # Process Header
                 while not any(opt in line for opt in option_breaks):
                     sProps.append(line)
-                    line = next(f)
+                    line = next(listIter)
 
             if "SOLVER OPTIONS" in line.upper():
-                for _ in range(2): line = next(f)
+                for _ in range(2): line = next(listIter) # Process Header
                 try:
-                    line=next(f)
+                    line=next(listIter)
                     while not any(opt in line for opt in option_breaks):
                         sOpts.append(line)
-                        line = next(f,"SOLVER OPTIONS")
+                        line = next(listIter,"SOLVER OPTIONS")
                 except StopIteration:
                     pass
 
-        # --- Store into object
+        # --- Setup a list of Nodes. 
         self.Nodes=[]
         for line in sNodes:
             sp=line.split()
             n = {}
             n['ID']   = int(sp[0])
             n['type'] = sp[1]
             z=sp[4]
@@ -858,74 +892,52 @@
             if y.startswith('#'):
                 print('>>> TODO mappp.py: y starting with #: ', z)
                 y=y[1:]
             x = float(x)
             y = float(y)
             n['position'] = np.array((x, y, z))
             self.Nodes.append(n)
-# ---------------------- LINE DICTIONARY ---------------------------------------
-# LineType     Diam     MassDenInAir    EA        CB   CIntDamp  Ca   Cdn  Cdt
-# (-)          (m)      (kg/m)         (N)       (-)   (Pa-s)   (-)  (-)  (-)
-# Equiv        0.169724 130.0           7.12E9    0.0     0       0   0    0 	
-# ---------------------- NODE PROPERTIES ---------------------------------------
-# Node    Type          X           Y        Z       M     B     FX    FY    FZ
-# (-)     (-)          (m)         (m)      (m)     (kg)  (m?3)  (N)   (N)   (N)
-# 1      fix          330.5       0.0      depth     0     0      #    #    #
-# 2      fix         -165.25   -286.221    depth     0     0      #    #    #
-# 3      fix         -165.25    286.221    depth     0     0      #    #    #
-# 4      vessel       36.0950     0.0      -13.97    0     0      #    #    #
-# 5      vessel      -18.0475   -31.25896  -13.97    0     0      #    #    #
-# 6      vessel      -18.0475    31.25896  -13.97    0     0      #    #    #
-# ---------------------- LINE PROPERTIES ---------------------------------------
-# Line   LineType  UnstrLen    NodeAnch  NodeFair  Flags
-# (-)      (-)       (m)         (-)       (-)       (-)
-# 1      Equiv     371.5          1         4     tension_fair
-# 2      Equiv     371.5          2         5     tension_fair
-# 3      Equiv     371.5          3         6     tension_fair
 
         # --- Load input lines into library
         for line in sCabLib:
-            self.f_type_init.contents.libraryInputLine =  (line+'\0').encode('utf-8')
-            Map.lib.map_add_cable_library_input_text(self.f_type_init)                    
+            self.f_type_init.contents.libraryInputLine =  (line+'\n\0').encode('utf-8')
+            pyMAP.lib.map_add_cable_library_input_text(self.f_type_init)                    
         for line in sNodes:
-            self.f_type_init.contents.nodeInputLine = (line+'\0').encode('utf-8')
-            Map.lib.map_add_node_input_text(self.f_type_init)
+            self.f_type_init.contents.nodeInputLine = (line+'\n\0').encode('utf-8')
+            pyMAP.lib.map_add_node_input_text(self.f_type_init)
         for line in sProps:
-            self.f_type_init.contents.elementInputLine =(line+'\0').encode('utf-8')
-            Map.lib.map_add_line_input_text(self.f_type_init)
+            self.f_type_init.contents.elementInputLine =(line+'\n\0').encode('utf-8')
+            pyMAP.lib.map_add_line_input_text(self.f_type_init)
         for line in sOpts:
-            self.f_type_init.contents.optionInputLine = (line+'\0').encode('utf-8')
-            Map.lib.map_add_options_input_text(self.f_type_init)            
-
-
+            self.f_type_init.contents.optionInputLine = (line+'\n\0').encode('utf-8')
+            pyMAP.lib.map_add_options_input_text(self.f_type_init)            
 
     # --------------------------------------------------------------------------------}
     # --- Utils 
     # --------------------------------------------------------------------------------{
     # user function to plot the mooring profile and footprint
     def plot(self, numPoints, fig=None, ax=None, colors=None, ls='-'):
         """ plot the mooring profile """
         import matplotlib.pyplot as plt
         from mpl_toolkits.mplot3d import Axes3D
 
         if fig is None:
             fig = plt.figure()
-            ax = Axes3D(fig)
+            ax = fig.add_subplot(111, projection="3d")
         if colors is None:
             colors = ['b']
         for i in range(self.size_lines()):
             x = self.plot_x( i, numPoints ) # i is the the line number, and 20 is the number of points plotted on the line 
             y = self.plot_y( i, numPoints)
             z = self.plot_z( i, numPoints)        
             ax.plot(x,y,z, ls=ls, color=colors[np.mod(i,len(colors))])     
         ax.set_xlabel('X [m]')
         ax.set_ylabel('Y [m]')
         ax.set_zlabel('Z [m]')        
         return fig, ax
-#      
 
 class Vessel:
     time = []
     x = []
     y = []
     z = []
     phi = []
@@ -1009,7 +1021,10 @@
                     [ r0til,  I3 ]])
     T2 = np.block([ [ I3   ,-r0til ],
                     [ Z3   ,  I3 ]])
     T3 = np.block([ [ Z3   ,  Z3 ],
                     [ Z3   ,  FS0til.dot(r0til) ] ])
     JD = T1.dot(JS.dot(T2)) + T3
     return JD
+
+
+Map=pyMAP # backward compatibility
```

### Comparing `welib-0.0.2/welib/ode/matlab/fodeKrenk.m` & `welib-1.0.0/welib/ode/matlab/fodeKrenk.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ode/matlab/fodeNewmark.m` & `welib-1.0.0/welib/ode/matlab/fodeNewmark.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ode/matlab/fodeNewmarkNonLinear.m` & `welib-1.0.0/welib/ode/matlab/fodeNewmarkNonLinear.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ode/matlab/fodeProgressBar.m` & `welib-1.0.0/welib/ode/matlab/fodeProgressBar.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/ode/matlab/fodeRK4.m` & `welib-1.0.0/welib/ode/matlab/fodeRK4.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/_PlotTorus.py` & `welib-1.0.0/welib/plot/_PlotTorus.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/examples/JSON3D_01_CreateSimpleFile.py` & `welib-1.0.0/welib/plot/examples/JSON3D_01_CreateSimpleFile.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/examples/Plot_3D_blades.py` & `welib-1.0.0/welib/plot/examples/Plot_3D_blades.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/examples/Plot_3D_surfaces.py` & `welib-1.0.0/welib/plot/examples/Plot_3D_surfaces.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/json3d.py` & `welib-1.0.0/welib/plot/json3d.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/surface3d.py` & `welib-1.0.0/welib/plot/surface3d.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/plot/tests/test_run_Examples.py` & `welib-1.0.0/welib/plot/tests/test_run_Examples.py`

 * *Files 0% similar despite different names*

```diff
@@ -16,21 +16,21 @@
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
         files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-        try:
-            import matplotlib.pyplot as plt
-            plt.close('all')
-        except:
-            pass
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/standards/IEC.py` & `welib-1.0.0/welib/standards/IEC.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/standards/examples/Ex1_TurbulenceClasses.py` & `welib-1.0.0/welib/standards/examples/Ex1_TurbulenceClasses.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/standards/examples/Ex2_EOG.py` & `welib-1.0.0/welib/standards/examples/Ex2_EOG.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/Example_DriveTrainTorsion.py` & `welib-1.0.0/welib/system/examples/Example_DriveTrainTorsion.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/Example_DriveTrainTorsion_Wrap.py` & `welib-1.0.0/welib/system/examples/Example_DriveTrainTorsion_Wrap.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/FirstOrderSystem_Scalar.py` & `welib-1.0.0/welib/system/examples/FirstOrderSystem_Scalar.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/MassSpringDamper_Duhamel.py` & `welib-1.0.0/welib/system/examples/MassSpringDamper_Duhamel.py`

 * *Files 18% similar despite different names*

```diff
@@ -33,31 +33,32 @@
     F = correlated_signal(coeff=0.9, n=len(time), seed=129) # seed provided for reproducibility
     F=F-F[0]
 
 # --- Setup a Mechanical system object, to easily integrate
 sys= MechSystem(M=m, C=c, K=k)
 sys.setForceTimeSeries(time,F)
 print(sys)
-resn = sys.integrate(time, method='LSODA')
-resd = sys.integrate(time, method='duhamel')
+resn, _ = sys.integrate(time, method='LSODA')
+resd, _ = sys.integrate(time, method='duhamel')
 
 # --- Do the same with the linear state space class
 sysl = LinearStateSpace(A=sys.A, B=sys.B)
 sysl.setInputTimeSeries(time,F)
 print(sysl)
-resln = sysl.integrate(time, method='LSODA')
-resld = sysl.integrate(time, method='impulse')
+resln, _ = sysl.integrate(time, method='LSODA')
+resld, _ = sysl.integrate(time, method='impulse')
 
 
 
 # --- Plot
-fig, axes = sys.plot(res  = resn , label = 'MechSys Numerical int.')
-fig, axes = sys.plot(res  = resd , label = 'MechSys convolution (Duhamel)' ,  fig=fig, axes=axes, ls = '--')
-fig, axes = sysl.plot(res = resln, label = 'Lin sys Numerical int.'        ,  fig=fig, axes=axes, ls = ':')
-fig, axes = sysl.plot(res = resld, label = 'Lin sys convolution'           ,  fig=fig, axes=axes, ls = '-.', c = 'k')
+axes = sys.plot(res  = resn , label = 'MechSys Numerical int.')
+axes = sys.plot(res  = resd , label = 'MechSys convolution (Duhamel)' ,  axes=axes, ls = '--')
+axes = sysl.plot_x_legacy(res = resln, label = 'Lin sys Numerical int.', axes=axes, ls = ':')
+axes = sysl.plot_x_legacy(res = resld, label = 'Lin sys convolution'   , axes=axes, ls = '-.', c = 'k')
+fig=axes[0].get_figure()
 fig.subplots_adjust(left=0.14, right=0.99, top=0.98, bottom=0.10, hspace=0.20, wspace=0.20)
 axes[0].legend()
 axes[0].set_title('System - 2nd order - Duhamel or numerical')
 
 # sys.plot_forcing()
 # sysl.plot_inputs()
```

### Comparing `welib-0.0.2/welib/system/examples/MassSpringDamper_ForcedVibrations.py` & `welib-1.0.0/welib/system/examples/MassSpringDamper_ForcedVibrations.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/SecondOrderSystem_Scalar.py` & `welib-1.0.0/welib/system/examples/SecondOrderSystem_Scalar.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/StepResponse.py` & `welib-1.0.0/welib/system/examples/StepResponse.py`

 * *Files 6% similar despite different names*

```diff
@@ -31,21 +31,20 @@
 x_s = step_response   (time, omega0, zeta, b=b, t0=t0, A=A, q0=q0, both=outD)
 
 
 fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
 fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
 ax.plot(time/T, x_s/A    , label='Step')
 ax.plot(time/T, x_d/A    , label='Impulse')
-ax.tick_params(direction='in')
+ax.tick_params(direction='in', top=True, right=True)
 ax.set_xlabel('Time/T [-]')
 ax.set_ylabel('x/A [-]')
 ax.set_title('System - 2nd order - Responses')
 ax.legend()
 
 if __name__ == '__main__':
     plt.show()
 if __name__ == '__test__':
     pass
 if __name__=="__export__":
-    pass
-    #from welib.tools.repo import export_figs_callback
-    #export_figs_callback(__file__)
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/system/examples/pendulum.py` & `welib-1.0.0/welib/system/examples/pendulum.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/examples/pendulum_3d.py` & `welib-1.0.0/welib/system/examples/pendulum_3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -259,14 +259,14 @@
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     ax.plot( time, CG[0,:], label='x')
     ax.plot( time, CG[1,:], label='y')
     ax.plot( time, CG[2,:], label='z')
     ax.set_xlabel('Time [s]')
     ax.set_ylabel('COG position [m]')
-    ax.set_title('3D pendulum - motion')
+    ax.set_title('System - 3D pendulum - motion')
     ax.legend()
     ax.tick_params(direction='in')
 
     from welib.tools.repo import export_figs_callback
     export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/system/examples/pendulum_on_prescribed_cart.py` & `welib-1.0.0/welib/system/examples/pendulum_on_prescribed_cart.py`

 * *Files 2% similar despite different names*

```diff
@@ -57,15 +57,15 @@
     return Force
 
 # --- Define a system and perform time integration
 sys=MechSystem(M,C,K)
 #sys.setForceTimeSeries(time,Fx_lin)
 sys.setForceFunction(Fx)
 sys.setInitialConditions([theta_0*np.pi/180],[0])
-res=sys.integrate(time, method='RK45') # **options):
+res,_=sys.integrate(time, method='RK45') # **options):
 
 # --- Post process
 theta = res.y[0,:]
 x_cart= motion(time)[0]
 x_end = l*np.sin(theta)  + x_cart 
 y_end =-l*np.cos(theta)
```

### Comparing `welib-0.0.2/welib/system/examples_stab/exA1.py` & `welib-1.0.0/welib/system/wtmodels/examples/model15M_exA1.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,150 +1,156 @@
+
+import os
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 
-from .model15DOFs import *
-
+from welib.fast.campbell import campbellModeStyles
 from welib.system.statespace import StateMatrix
 from welib.system.eva import eig, eigA
-from pyFAST.linearization.campbell import campbellModeStyles
 
+from welib.system.wtmodels.model15M import *
 
+scriptDir=os.path.dirname(__file__)
+outDir=os.path.join(scriptDir,'_outputs')
+os.makedirs(outDir, exist_ok=True)
 
-np.set_printoptions(linewidth=300, precision =5)
-
-vOmega=np.arange(0,1.55,0.05) #omegas up to rate omega Rotor Speed
-# vOmega=np.arange(0,10.55,0.05) #omegas up to rate omega Rotor Speed
 
+np.set_printoptions(linewidth=300, precision =5)
 
-p=parameters() # Turbine parameters
-lambda1 = 1.8751 # NOTE: constant for analytical bending mode 1
-c1      = 0.7341 # NOTE: constant for analytical bending mode 1, see bendingMode!
-
-df=pd.DataFrame()
-df['Omega_[rad/s]']  = vOmega
-df['f_flap_[Hz]']    = vOmega*0
-df['f_edge_[Hz]']     = vOmega*0
-df['f_tors_[Hz]'] = vOmega*0
-
-for i,Omega in enumerate(vOmega):
-    Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
-    A=StateMatrix(M=Mb,K=Kb)
-    Q,freq =eig(K=Kb,M=Mb, freq_out=True, sort=True)
-    freq2, zeta, Q2, freq_0  = eigA(A, nq=Mb.shape[0])
-    df.loc[i,'f_flap_[Hz]'] = freq[0]
-    df.loc[i,'f_edge_[Hz]'] = freq[1]
-    df.loc[i,'f_tors_[Hz]'] = freq[2]
-
-print(df)
-
-df.to_csv('_outputs/A_freq.csv', sep='\t', index=False)
-
-
-# --- Plot 
-fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-fig.subplots_adjust(left=0.12, right=0.95, top=0.75, bottom=0.11, hspace=0.20, wspace=0.20)
-lbl='1st blade flap' # TODO Mode 1
-c, ls, ms, mk = campbellModeStyles(0, lbl)
-ax.plot(vOmega, df['f_flap_[Hz]'], ls, marker=mk, color=c, label=lbl)
-
-lbl='1st blade edge' # TODO Mode 2
-c, ls, ms, mk = campbellModeStyles(1, lbl)
-ax.plot(vOmega, df['f_edge_[Hz]'], ls, marker=mk, color=c, label=lbl)
-
-lbl='1st blade torsion' # TODO TODO
-c, ls, ms, mk = campbellModeStyles(2, lbl)
-ax.plot(vOmega, df['f_tors_[Hz]'], ls, marker=mk, color=c, label=lbl)
-
-ax.set_xlabel(r'$\Omega$ [rad/s]')
-ax.set_ylabel(r'Frequency [Hz]')
-ax.legend()
-
-
-# --------------------------------------------------------------------------------}
-# ---  
-# --------------------------------------------------------------------------------{
-x=np.linspace(0,50,51)
-nDOF= 3
-phi_e = bendingMode(x,1)  
-phi_t = torsionalMode(x,1)
-phi_f = bendingMode(x,1)  
-Phi = np.column_stack((phi_f, phi_e, phi_t))
-# for j in np.arange(nDOF):
-#     Phi[:,j] /= Phi[-1,j]
-
-# print(Phi)
-
-# --- Eigen vector 
-def getShape(Omega):
-    Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
-    A = StateMatrix(M=Mb,K=Kb)
-    freq2, zeta, Q, freq_0  = eigA(A, nq=Mb.shape[0], normQ='byMax')
-
-    Q0,freq0 =eig(K=Kb,M=Mb, freq_out=True, sort=True, normQ='byMax')
-    phase = np.angle(Q)
-    ampl  = np.abs(Q)
-    #print(phase)
-    #print(ampl)
-    Modes = np.zeros((Q.shape[1], Phi.shape[0], Phi.shape[1]))
-    for j in np.arange(Q.shape[1]):
-        q_j = Q[:,j]
-        #a_j = np.abs(q_j) # TODO figure out how to incorpoorate sign with phase
-        phi_j = np.angle(q_j) 
-        a_j = Q0[:,j] 
-        Mode = np.multiply(Phi, a_j)
-        Mode_end=Mode[-1,:]
-        scale = np.max(Mode_end)
-        Modes[j][:,:] = Mode/scale
-    return Modes, phase
-
-Modes0,phase0 = getShape(Omega=0)   
-ModesR,phaseR = getShape(Omega=1.5)
-
-for j in np.arange(nDOF):
-    Mode0=Modes0[j]
-    ModeR=ModesR[j]
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-    ax.plot(x, Mode0[:,0], label='flap')
-    ax.plot(x, Mode0[:,1], label='edge')
-    ax.plot(x, Mode0[:,2], label='torsion')
-    ax.plot(x, ModeR[:,0], 'kx')
-    ax.plot(x, ModeR[:,1], 'kx')
-    ax.plot(x, ModeR[:,2], 'kx')
-    ax.set_xlabel('Blade span [m]')
-    ax.set_ylabel('Mode content')
-    ax.set_title('Mode {}'.format(j+1))
-    ax.legend()
-plt.show()
 
+def main(test=False):
+    vOmega=np.arange(0,1.55,0.05) #omegas up to rate omega Rotor Speed
+    # vOmega=np.arange(0,10.55,0.05) #omegas up to rate omega Rotor Speed
+    p=parameters() # Turbine parameters
+    lambda1 = 1.8751 # NOTE: constant for analytical bending mode 1
+    c1      = 0.7341 # NOTE: constant for analytical bending mode 1, see bendingMode!
+
+    df=pd.DataFrame()
+    df['Omega_[rad/s]'] = vOmega
+    df['f_flap_[Hz]']   = vOmega*0
+    df['f_edge_[Hz]']   = vOmega*0
+    df['f_tors_[Hz]']   = vOmega*0
+
+    for i,Omega in enumerate(vOmega):
+        Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
+        A=StateMatrix(M=Mb,K=Kb)
+        Q,freq =eig(K=Kb,M=Mb, freq_out=True, sort=True)
+        freq2, zeta, Q2, freq_0  = eigA(A, nq=Mb.shape[0])
+        df.loc[i,'f_flap_[Hz]'] = freq[0]
+        df.loc[i,'f_edge_[Hz]'] = freq[1]
+        df.loc[i,'f_tors_[Hz]'] = freq[2]
 
+    if not test:
+        df.to_csv(os.path.join(outDir,'A_freq.csv'), sep='\t', index=False)
 
 
-# plt.plot(df)
-# plt.show()
+    # --- Plot 
+    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+    fig.subplots_adjust(left=0.12, right=0.95, top=0.75, bottom=0.11, hspace=0.20, wspace=0.20)
+    lbl='1st blade flap' # TODO Mode 1
+    c, ls, ms, mk = campbellModeStyles(0, lbl)
+    ax.plot(vOmega, df['f_flap_[Hz]'], ls, marker=mk, color=c, label=lbl)
+
+    lbl='1st blade edge' # TODO Mode 2
+    c, ls, ms, mk = campbellModeStyles(1, lbl)
+    ax.plot(vOmega, df['f_edge_[Hz]'], ls, marker=mk, color=c, label=lbl)
+
+    lbl='1st blade torsion' # TODO TODO
+    c, ls, ms, mk = campbellModeStyles(2, lbl)
+    ax.plot(vOmega, df['f_tors_[Hz]'], ls, marker=mk, color=c, label=lbl)
 
+    ax.set_xlabel(r'$\Omega$ [rad/s]')
+    ax.set_ylabel(r'Frequency [Hz]')
+    ax.legend()
+    if not test:
+        fig.savefig(os.path.join(outDir,'ExA1_ModeFreqs.png'))
 
 
+    # --------------------------------------------------------------------------------}
+    # ---  
+    # --------------------------------------------------------------------------------{
+    x=np.linspace(0,50,51)
+    nDOF= 3
+    phi_e = bendingMode(x,1)  
+    phi_t = torsionalMode(x,1)
+    phi_f = bendingMode(x,1)  
+    Phi = np.column_stack((phi_f, phi_e, phi_t))
+    # for j in np.arange(nDOF):
+    #     Phi[:,j] /= Phi[-1,j]
+
+    # print(Phi)
+
+    # --- Eigen vector 
+    def getShape(Omega):
+        Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
+        A = StateMatrix(M=Mb,K=Kb)
+        freq2, zeta, Q, freq_0  = eigA(A, nq=Mb.shape[0], normQ='byMax')
+
+        Q0,freq0 =eig(K=Kb,M=Mb, freq_out=True, sort=True, normQ='byMax')
+        phase = np.angle(Q)
+        ampl  = np.abs(Q)
+        #print(phase)
+        #print(ampl)
+        Modes = np.zeros((Q.shape[1], Phi.shape[0], Phi.shape[1]))
+        for j in np.arange(Q.shape[1]):
+            q_j = Q[:,j]
+            #a_j = np.abs(q_j) # TODO figure out how to incorpoorate sign with phase
+            phi_j = np.angle(q_j) 
+            a_j = Q0[:,j] 
+            Mode = np.multiply(Phi, a_j)
+            Mode_end=Mode[-1,:]
+            scale = np.max(Mode_end)
+            Modes[j][:,:] = Mode/scale
+        return Modes, phase
+
+    Modes0,phase0 = getShape(Omega=0)   
+    ModesR,phaseR = getShape(Omega=1.5)
+
+    for j in np.arange(nDOF):
+        Mode0=Modes0[j]
+        ModeR=ModesR[j]
+        fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+        fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+        ax.plot(x, Mode0[:,0], label='flap')
+        ax.plot(x, Mode0[:,1], label='edge')
+        ax.plot(x, Mode0[:,2], label='torsion')
+        ax.plot(x, ModeR[:,0], 'kx')
+        ax.plot(x, ModeR[:,1], 'kx')
+        ax.plot(x, ModeR[:,2], 'kx')
+        ax.set_xlabel('Blade span [m]')
+        ax.set_ylabel('Mode content')
+        ax.set_title('Mode {}'.format(j+1))
+        ax.legend()
+        if not test:
+            fig.savefig(os.path.join(outDir,'ExA1_Mode{}.png'.format(j+1)))
+    return df, ModesR
 # print(Omega)
 # print('Mb\n',Mb)
 # print('Kb\n',Kb)
 # print('Mt\n',Mt)
 # print('Gt\n',Gt)
 # print('Kt\n',Kt)
-# 
 # print('Q\n',Q)
 # print('freq\n',freq)
-# 
 # print('Q\n',np.imag(Q2))
 # print('freq_d\n',freq_d)
-
-
-
-# 
 # fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
 # fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
 # ax.plot(x, phi_e    , label='')
 # ax.set_xlabel('')
 # ax.set_ylabel('')
 # ax.legend()
-# plt.show()
+
+if __name__ == '__main__':
+    df, ModesR = main()
+    print(df)
+    plt.show()
+
+
+if __name__ == '__test__':
+    df, ModesR = main(test=True)
+    np.testing.assert_almost_equal(df['f_flap_[Hz]'].values[:3], [1.386216,1.386236,1.386296],5) 
+    np.testing.assert_almost_equal(df['f_tors_[Hz]'].values[:3], [4.139987,4.140006,4.140064],5) 
+    np.testing.assert_almost_equal(ModesR[2][-4:,0], [0.917416, 0.944941, 0.97247 , 1.], 6)
+    np.testing.assert_almost_equal(ModesR[2][1:4,0], [0.0006967, 0.0027612, 0.0061546], 6)
+    np.testing.assert_almost_equal(ModesR[2][1:4,2], [0.0167179, 0.0334194, 0.0500879], 5)
```

### Comparing `welib-0.0.2/welib/system/examples_stab/exB1.py` & `welib-1.0.0/welib/system/wtmodels/examples/model15M_exB1.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,172 +1,185 @@
+import os
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 
-from .model15DOFs import *
-
+from welib.fast.campbell import campbellModeStyles
 from welib.system.statespace import StateMatrix
 from welib.system.eva import eig, eigA, eigMCK
-from pyFAST.linearization.campbell import campbellModeStyles
-
-
-
-np.set_printoptions(linewidth=300, precision =5)
-
-
-
-# --- Polar
-alpha = np.linspace(-np.pi,np.pi,100)
-Cl,Cd,Clp,Cdp = liftDrag(alpha)
-alpha=alpha*180/np.pi
-M=np.column_stack((alpha,Cl,Cd,Clp,Cdp))
-df = pd.DataFrame(data=M,columns=['alpha_[deg]','Cl_[-]','Cd_[-]','Clp_[-]','Cdp_[-]'])
-df.to_csv('_outputs/B1_polars.csv',index=False,sep=',')
-
-
-
-aero=True
-
-p=parameters() # Turbine parameters
-lambda1 = 1.8751 # NOTE: constant for analytical bending mode 1
-c1      = 0.7341 # NOTE: constant for analytical bending mode 1, see bendingMode!
-
 
-Omega=1.5
-vWS=np.arange(5,26,1)
-nDOF=3
+from welib.system.wtmodels.model15M import *
 
 
-if aero:
-    flag=''
-else:
-    flag='_NoAero'
+scriptDir=os.path.dirname(__file__)
+outDir=os.path.join(scriptDir,'_outputs')
+os.makedirs(outDir, exist_ok=True)
 
+np.set_printoptions(linewidth=300, precision =5)
 
 
-x=np.linspace(0,50,51)
-phi_e = bendingMode(x,1)  
-phi_t = torsionalMode(x,1)
-phi_f = bendingMode(x,1)  
-Phi = np.column_stack((phi_f, phi_e, phi_t))
-
-
-FreqDamp=np.zeros((len(vWS),nDOF*2));
-ModesAmplitudes = np.zeros((len(vWS),nDOF, nDOF));
-ModesPhases     = np.zeros((len(vWS),nDOF, nDOF));
-ue = np.zeros((len(x), nDOF))
-uf = np.zeros((len(x), nDOF))
-ut = np.zeros((len(x), nDOF))
-phie = np.zeros((len(x), nDOF))
-phif = np.zeros((len(x), nDOF))
-phit = np.zeros((len(x), nDOF))
 
-for iWS,WS in enumerate(vWS):
-    print('--------------------------',WS)
-    Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
+def main(test=False):
+    # --- Polar
+    alpha = np.linspace(-np.pi,np.pi,100)
+    Cl,Cd,Clp,Cdp = liftDrag(alpha)
+    alpha=alpha*180/np.pi
+    M=np.column_stack((alpha,Cl,Cd,Clp,Cdp))
+    df = pd.DataFrame(data=M,columns=['alpha_[deg]','Cl_[-]','Cd_[-]','Clp_[-]','Cdp_[-]'])
+    df.to_csv(os.path.join(outDir,'B1_polars.csv'),index=False,sep=',')
+    aero=True
+
+    p=parameters() # Turbine parameters
+    lambda1 = 1.8751 # NOTE: constant for analytical bending mode 1
+    c1      = 0.7341 # NOTE: constant for analytical bending mode 1, see bendingMode!
+    Omega=1.5
+    if test:
+        vWS=np.arange(5,10,1)
+    else:
+        vWS=np.arange(5,26,1)
+    nDOF=3
 
-    aeroMat = aerodynMatrix(p,Omega,WS)
-    Cab=aeroMat['Cab'];
-    Kab=aeroMat['Kab'];
     if aero:
-        Kb+= Kab
-        Cb = Cab
+        flag=''
     else:
-        Cb  = Kb*0
-    A=StateMatrix(M=Mb, K=Kb, C=Cb)
-    #Q,freq =eig(K=Kb, M=Mb, C=Cb, freq_out=True, sort=True)
-    freq1, zeta1, Q1, freq_01  = eigMCK(Mb, Cb, Kb)
-    freq2, zeta2, Q , freq_02  = eigA(A, nq=Mb.shape[0])
-    np.testing.assert_almost_equal(freq1,freq2)
-    np.testing.assert_almost_equal(zeta1,zeta2)
-
-    FreqDamp[iWS,0:nDOF*2:2]=freq2 
-    FreqDamp[iWS,1:nDOF*2:2]=zeta2
-
-    # For each mode, extract "content"
-
-    M=x
-
-    for iMod in np.arange(nDOF):
-        ModeVector = Q[:,iMod]
-        imax       = np.argmax(np.abs(ModeVector))
-        zm         = ModeVector[imax]
-        ModeVectorScaled=ModeVector*np.conj(zm)/abs(zm)**2 # complex, but normalized to unity for max amplitude 
-        ModesPhases[iWS,iMod,:]=np.angle(ModeVectorScaled)/(2*np.pi)
-
-        PhaseMod = np.angle(ModeVectorScaled);
-        AmpMod   = np.abs(ModeVectorScaled)  ;
-#        
-        if (imax==1 or imax ==2):
-            Amp=AmpMod/2  # because shape functions are not normalized...
-        else:
-            Amp=AmpMod
-        uf[:,iMod]=phi_f*Amp[0]
-        ue[:,iMod]=phi_e*Amp[1]
-        ut[:,iMod]=phi_t*Amp[2]
-        phif[:,iMod]=[PhaseMod[0]]*len(x)
-        phie[:,iMod]=[PhaseMod[1]]*len(x)
-        phit[:,iMod]=[PhaseMod[2]]*len(x)
-
-        M=np.column_stack((M,uf[:,iMod], phif[:,iMod], ue[:,iMod], phie[:,iMod], ut[:,iMod], phit[:,iMod]))
-    if  WS==8 or WS == 16:
-        filename='_outputs/B1_modes_{:}ms{}.csv'.format(WS,flag)
-        print(filename)
-        headers=['r_[m]','m1_a_flap_[-]','m1_phi_flap_[rad]','m1_a_edge_[-]','m1_phi_edge_[rad]','m1_a_tors_[-]','m1_phi_tors_[rad]','m2_a_flap_[-]','m2_phi_flap_[rad]','m2_a_edge_[-]','m2_phi_edge_[rad]','m2_a_tors_[-]','m2_phi_tors_[rad]','m3_a_flap_[-]','m3_phi_flap_[rad]','m3_a_edge_[-]','m3_phi_edge_[rad]','m3_a_tors_[-]','m3_phi_tors_[rad]'];
-        df      = pd.DataFrame(data=M, columns = headers)
-        df.to_csv(filename, index=False, sep=',')
-        if WS==8:
-            Res1=M
-        else:
-            Res2=M
-
-# --- Export Cambell Data
-M       = np.column_stack((vWS,FreqDamp))
-headers = ['WS_[m/s]','F1_[Hz]','D1_[-]','F2_[Hz]','D2_[-]','F3_[Hz]','D3_[-]'];
-df      = pd.DataFrame(data=M, columns = headers)
-df.to_csv('_outputs/B1_freq{}.csv'.format(flag),index=False,sep=',')
-
-# --- Plot Blade Campbell
-fig,axes = plt.subplots(1, 2, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-fig.subplots_adjust(left=0.12, right=0.95, top=0.75, bottom=0.11, hspace=0.20, wspace=0.20)
-lbl='Mode 1 (1st blade flap)' # TODO Mode 1
-c, ls, ms, mk = campbellModeStyles(0, lbl)
-axes[0].plot(vWS, df['F1_[Hz]'], ls, marker=mk, color=c, label=lbl)
-axes[1].plot(vWS, df['D1_[-]'] , ls, marker=mk, color=c, label=lbl)
-
-lbl='Mode 2 (1st blade edge)' # TODO Mode 2
-c, ls, ms, mk = campbellModeStyles(1, lbl)
-axes[0].plot(vWS, df['F2_[Hz]'], ls, marker=mk, color=c, label=lbl)
-axes[1].plot(vWS, df['D2_[-]'],  ls, marker=mk, color=c, label=lbl)
-
-lbl='Mode 3 (1st blade torsion)' # TODO TODO
-c, ls, ms, mk = campbellModeStyles(2, lbl)
-axes[0].plot(vWS, df['F3_[Hz]'], ls, marker=mk, color=c, label=lbl)
-axes[1].plot(vWS, df['F3_[Hz]'], ls, marker=mk, color=c, label=lbl)
-
-axes[0].set_xlabel(r'WS [m/s]')
-axes[0].set_ylabel(r'Frequency [Hz]')
-axes[1].set_ylabel(r'Damping ratio [-]')
-axes[0].legend()
+        flag='_NoAero'
 
-
-
-# --- Plot mode shapes at 8 and 16m/s
-for iMod in np.arange(3):
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-    ax.plot(x,Res1[:,iMod*2*nDOF+1:(iMod*2*nDOF+nDOF*2):2]  )
-    ax.set_xlabel('')
-    ax.set_ylabel('')
-    ax.set_title('Mode {} - WS 8'.format(iMod)) 
-    #ax.legend('Flap','Edge','Torsion',0)
-# for iMod in np.arange(3):
-#     figure(iMod+100)
-#     plot(x,Res2(:,1+(iMod-1)*2*ndof+(1:2:(ndof*2)) ))
-#     title(sprintf('Mode %d - WS 16',iMod)); 
-#     legend('Flap','Edge','Torsion',0)
-# end
-
-
-
-plt.show()
+    x=np.linspace(0,50,51)
+    phi_e = bendingMode(x,1)  
+    phi_t = torsionalMode(x,1)
+    phi_f = bendingMode(x,1)  
+    Phi = np.column_stack((phi_f, phi_e, phi_t))
+
+    FreqDamp=np.zeros((len(vWS),nDOF*2));
+    ModesAmplitudes = np.zeros((len(vWS),nDOF, nDOF));
+    ModesPhases     = np.zeros((len(vWS),nDOF, nDOF));
+    ue = np.zeros((len(x), nDOF))
+    uf = np.zeros((len(x), nDOF))
+    ut = np.zeros((len(x), nDOF))
+    phie = np.zeros((len(x), nDOF))
+    phif = np.zeros((len(x), nDOF))
+    phit = np.zeros((len(x), nDOF))
+
+    for iWS,WS in enumerate(vWS):
+        #print('--------------------------',WS)
+        Mb,Kb,Gb,Mt,Gt,Kt = diagonalStructuralMatrices(p,Omega,lambda1,c1)
+
+        aeroMat = aerodynMatrix(p,Omega,WS)
+        Cab=aeroMat['Cab'];
+        Kab=aeroMat['Kab'];
+        if aero:
+            Kb+= Kab
+            Cb = Cab
+        else:
+            Cb  = Kb*0
+        A=StateMatrix(M=Mb, K=Kb, C=Cb)
+        #Q,freq =eig(K=Kb, M=Mb, C=Cb, freq_out=True, sort=True)
+        freq1, zeta1, Q1, freq_01  = eigMCK(Mb, Cb, Kb)
+        freq2, zeta2, Q , freq_02  = eigA(A, nq=Mb.shape[0])
+        np.testing.assert_almost_equal(freq1,freq2)
+        np.testing.assert_almost_equal(zeta1,zeta2)
+
+        FreqDamp[iWS,0:nDOF*2:2]=freq2 
+        FreqDamp[iWS,1:nDOF*2:2]=zeta2
+
+        # For each mode, extract "content"
+
+        M=x
+
+        for iMod in np.arange(nDOF):
+            ModeVector = Q[:,iMod]
+            imax       = np.argmax(np.abs(ModeVector))
+            zm         = ModeVector[imax]
+            ModeVectorScaled=ModeVector*np.conj(zm)/abs(zm)**2 # complex, but normalized to unity for max amplitude 
+            ModesPhases[iWS,iMod,:]=np.angle(ModeVectorScaled)/(2*np.pi)
+
+            PhaseMod = np.angle(ModeVectorScaled);
+            AmpMod   = np.abs(ModeVectorScaled)  ;
+    #        
+            if (imax==1 or imax ==2):
+                Amp=AmpMod/2  # because shape functions are not normalized...
+            else:
+                Amp=AmpMod
+            uf[:,iMod]=phi_f*Amp[0]
+            ue[:,iMod]=phi_e*Amp[1]
+            ut[:,iMod]=phi_t*Amp[2]
+            phif[:,iMod]=[PhaseMod[0]]*len(x)
+            phie[:,iMod]=[PhaseMod[1]]*len(x)
+            phit[:,iMod]=[PhaseMod[2]]*len(x)
+
+            M=np.column_stack((M,uf[:,iMod], phif[:,iMod], ue[:,iMod], phie[:,iMod], ut[:,iMod], phit[:,iMod]))
+        if  WS==8 or WS == 16:
+            filename=os.path.join(outDir,'B1_modes_{:}ms{}.csv'.format(WS,flag))
+            #print(filename)
+            headers=['r_[m]','m1_a_flap_[-]','m1_phi_flap_[rad]','m1_a_edge_[-]','m1_phi_edge_[rad]','m1_a_tors_[-]','m1_phi_tors_[rad]','m2_a_flap_[-]','m2_phi_flap_[rad]','m2_a_edge_[-]','m2_phi_edge_[rad]','m2_a_tors_[-]','m2_phi_tors_[rad]','m3_a_flap_[-]','m3_phi_flap_[rad]','m3_a_edge_[-]','m3_phi_edge_[rad]','m3_a_tors_[-]','m3_phi_tors_[rad]'];
+            df      = pd.DataFrame(data=M, columns = headers)
+            df.to_csv(filename, index=False, sep=',')
+            if WS==8:
+                Res1=M
+            else:
+                Res2=M
+
+    # --- Export Cambell Data
+    M       = np.column_stack((vWS,FreqDamp))
+    headers = ['WS_[m/s]','F1_[Hz]','D1_[-]','F2_[Hz]','D2_[-]','F3_[Hz]','D3_[-]'];
+    df      = pd.DataFrame(data=M, columns = headers)
+    if not test:
+        df.to_csv(os.path.join(outDir,'B1_freq{}.csv'.format(flag)),index=False,sep=',')
+
+    # --- Plot Blade Campbell
+    fig,axes = plt.subplots(1, 2, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+    fig.subplots_adjust(left=0.12, right=0.95, top=0.75, bottom=0.11, hspace=0.20, wspace=0.20)
+    lbl='Mode 1 (1st blade flap)' # TODO Mode 1
+    c, ls, ms, mk = campbellModeStyles(0, lbl)
+    axes[0].plot(vWS, df['F1_[Hz]'], ls, marker=mk, color=c, label=lbl)
+    axes[1].plot(vWS, df['D1_[-]'] , ls, marker=mk, color=c, label=lbl)
+
+    lbl='Mode 2 (1st blade edge)' # TODO Mode 2
+    c, ls, ms, mk = campbellModeStyles(1, lbl)
+    axes[0].plot(vWS, df['F2_[Hz]'], ls, marker=mk, color=c, label=lbl)
+    axes[1].plot(vWS, df['D2_[-]'],  ls, marker=mk, color=c, label=lbl)
+
+    lbl='Mode 3 (1st blade torsion)' # TODO TODO
+    c, ls, ms, mk = campbellModeStyles(2, lbl)
+    axes[0].plot(vWS, df['F3_[Hz]'], ls, marker=mk, color=c, label=lbl)
+    axes[1].plot(vWS, df['F3_[Hz]'], ls, marker=mk, color=c, label=lbl)
+
+    axes[0].set_xlabel(r'WS [m/s]')
+    axes[0].set_ylabel(r'Frequency [Hz]')
+    axes[1].set_ylabel(r'Damping ratio [-]')
+    axes[0].legend()
+    if not test:
+        fig.savefig(os.path.join(outDir,'ExB1_BladeCampbell.png'))
+
+
+    # --- Plot mode shapes at 8 and 16m/s
+    for iMod in np.arange(3):
+        fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+        fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+        M = Res1[:,iMod*2*nDOF+1:(iMod*2*nDOF+nDOF*2):2]
+        print(M.shape)
+        ax.plot(x,M[:,0], label='Flap'  )
+        ax.plot(x,M[:,1], label='Edge'  )
+        ax.plot(x,M[:,2], label='Torsion'  )
+        ax.set_xlabel('Blade Span [m]')
+        ax.set_ylabel('')
+        ax.legend()
+        ax.set_title('Mode {} - WS 8'.format(iMod+1)) 
+        if not test:
+            fig.savefig(os.path.join(outDir,'ExB1_WS8_Mode{}+.png'.format(iMod+1)))
+    # for iMod in np.arange(3):
+    #     figure(iMod+100)
+    #     plot(x,Res2(:,1+(iMod-1)*2*ndof+(1:2:(ndof*2)) ))
+    #     title(sprintf('Mode %d - WS 16',iMod)); 
+    #     legend('Flap','Edge','Torsion',0)
+    # end
+    return df
+
+if __name__ == '__main__':
+    df = main()
+    print(df)
+    plt.show()
+if __name__ == '__test__':
+    df = main(test=True)
+    np.testing.assert_almost_equal(df['F1_[Hz]'].values[:5], [1.5840093, 1.5815942, 1.5771179, 1.5694763, 1.5574542],5)
+    np.testing.assert_almost_equal(df['F3_[Hz]'].values[:5], [3.6157, 3.6219, 3.6345, 3.6569, 3.6928],4)
```

### Comparing `welib-0.0.2/welib/system/examples_stab/model15DOFs.py` & `welib-1.0.0/welib/system/wtmodels/model15M.py`

 * *Files 2% similar despite different names*

```diff
@@ -215,72 +215,14 @@
     K = np.block([
         [Kb   , Z3   , Z3   , Z36]  , 
         [Z3   , Kb   , Z3   , Z36]  , 
         [Z3   , Z3   , Kb   , Z36]  , 
         [Ktb1 , Ktb2 , Ktb3 , Kt]])
     return M,C,K
 
-def Bmat(psi1,Omega): 
-    """ 
-     See Hansen 2003 Eq. 14 15, 16
-    """
-    psi2 = psi1 + (2 * np.pi / 3)
-    psi3 = psi2 + (2 * np.pi / 3)
-    B = np.block([
-        [np.eye(3    , 3)  , np.eye(3 , 3) * np.cos(psi1) , np.eye(3 , 3) * np.sin(psi1) , np.zeros((3 , 6))] , 
-        [np.eye(3    , 3)  , np.eye(3 , 3) * np.cos(psi2) , np.eye(3 , 3) * np.sin(psi2) , np.zeros((3 , 6))] , 
-        [np.eye(3    , 3)  , np.eye(3 , 3) * np.cos(psi3) , np.eye(3 , 3) * np.sin(psi3) , np.zeros((3 , 6))] , 
-        [np.zeros((6 , 9)) , np.eye(6 , 6)]]) # TODO Omega t?
-    Bdot = np.block([
-        [np.zeros((3 , 3)) , Omega * np.eye(3 , 3) * - np.sin(psi1) , Omega * np.eye(3 , 3) * np.cos(psi1) , np.zeros((3 , 6))] , 
-        [np.zeros((3 , 3)) , Omega * np.eye(3 , 3) * - np.sin(psi2) , Omega * np.eye(3 , 3) * np.cos(psi2) , np.zeros((3 , 6))] , 
-        [np.zeros((3 , 3)) , Omega * np.eye(3 , 3) * - np.sin(psi3) , Omega * np.eye(3 , 3) * np.cos(psi3) , np.zeros((3 , 6))] , 
-        [np.zeros((6 , 9)) , np.zeros((6      , 6))]])
-    mu = np.block([
-        [(1 / 3) * np.eye(3 , 3)  , np.zeros((3        , 3)) , np.zeros((3        , 3)) , np.zeros((3 , 3)) , np.zeros((3 , 3))]  , 
-        [np.zeros((3        , 3)) , (2 / 3) * np.eye(3 , 3)  , np.zeros((3        , 3)) , np.zeros((3 , 3)) , np.zeros((3 , 3))]  , 
-        [np.zeros((3        , 3)) , np.zeros((3        , 3)) , (2 / 3) * np.eye(3 , 3)  , np.zeros((3 , 3)) , np.zeros((3 , 3))]  ,  # Should be 2/3
-        [np.zeros((3        , 3)) , np.zeros((3        , 3)) , np.zeros((3        , 3)) , np.eye(3    , 3)  , np.zeros((3 , 3))]  , 
-        [np.zeros((3        , 3)) , np.zeros((3        , 3)) , np.zeros((3        , 3)) , np.zeros((3 , 3)) , np.eye(3    , 3)]])
-    R = np.linalg.inv(B).dot(Bdot)
-    # invB=inv(B);
-    # transB=B';
-    # invbt=inv(transB)
-    # mu=invB*invbt
-    
-    return B,mu,Bdot,R
-
-def MbCbKbmat(B, M, C, K, mu): 
-    """
-     See Hansen 2003 Eq. 16
-    """
-    MB = mu.dot(np.transpose(B)).dot(M).dot(B)
-    CB = mu.dot(np.transpose(B)).dot(C).dot(B)
-    KB = mu.dot(np.transpose(B)).dot(K).dot(B)
-    return MB,CB,KB
-
-def MCKTildemat(B, MB, CB, KB, mu, R): 
-    """ 
-     Compute tilde matrices, ie the matrices of the system in z (Coleman coordinates)
-     See Hansen 2003 Eq. 16
-    """
-    MBT = MB
-    CBT = 2 * MB.dot(R) + CB
-    KBT = MB.dot(R).dot(R) + CB.dot(R) + KB
-    return MBT,CBT,KBT
-
-def Coleman2Comp(a0, a1, b1):
-    """ """
-    A0    = 0.5 * np.sqrt( np.real(a0) ** 2 + np.imag(a0) ** 2)
-    ABW   = 0.5 * np.sqrt((np.real(b1) - np.imag(a1)) ** 2 + (np.imag(b1) + np.real(a1)) ** 2)
-    AFW   = 0.5 * np.sqrt((np.real(b1) + np.imag(a1)) ** 2 + (np.real(a1) - np.imag(b1)) ** 2)
-    phi0  = np.arctan2( np.imag(a0),  np.real(a0))
-    phiBW = np.arctan2(np.imag(a1) - np.real(b1),np.imag(b1) + np.real(a1))
-    phiFW = np.arctan2(np.real(b1) + np.imag(a1),np.real(a1) - np.imag(b1))
-    return A0,ABW,AFW,phi0,phiBW,phiFW
     
 def aerodynMatrix(par,Omega,W): 
     # computation parameters
     N = 500
     z = np.linspace(0,par['R'],N)
     h = z[1] - z[0]
     # bending modes
```

### Comparing `welib-0.0.2/welib/system/examples_stab/test_model.py` & `welib-1.0.0/welib/system/wtmodels/tests/test_model15M.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,11 +1,11 @@
 import unittest
 import os
 import numpy as np    
-from welib.system.examples_stab.model15DOFs import *
+from welib.system.wtmodels.model15M import *
 
 MyDir=os.path.dirname(__file__)
 
 class Test(unittest.TestCase):
 
     def test_constant_matrices(self):
         p=parameters() # Turbine parameters
@@ -203,17 +203,19 @@
    
         np.testing.assert_almost_equal(M, M_ref, 5)
         np.testing.assert_almost_equal(K, K_ref, 5)
         np.testing.assert_almost_equal(C, C_ref, 5)
 
 
     def test_Bmat(self):
+        from welib.system.mbc import MBC3_Bmat
+
         Omega=0.5;
         psi1 = np.pi/3
-        B,mu,Bdot,R = Bmat( psi1,Omega ) 
+        B, Binv, Bdot, Bddot, mu, _ = MBC3_Bmat(3, 6, ns=0, psi1=psi1, Omega=Omega, ordering='increasing')
 
         mu_ref = np.array([
         [   0.33333 , 0.00000 , 0.00000,  0.00000 , 0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
         [   0.00000 , 0.33333 , 0.00000,  0.00000 , 0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
         [   0.00000 , 0.00000 , 0.33333,  0.00000 , 0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
         [   0.00000 , 0.00000 , 0.00000,  0.66667 , 0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
         [   0.00000 , 0.00000 , 0.00000,  0.00000 , 0.66667 , 0.00000,  0.00000 , 0.00000,  0.00000 , 0.00000,  0.00000,  0.00000,  0.00000,  0.00000,  0.00000],
```

### Comparing `welib-0.0.2/welib/system/firstorder.py` & `welib-1.0.0/welib/system/firstorder.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/linearization.py` & `welib-1.0.0/welib/system/linearization.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,11 +1,20 @@
+""" 
+Tools for linearizing functions.
+
+Generic functions:
+- numerical_jacobian(f, op, arg_number, deltas, *f_args):
+
+-  df/dx        = linearize_Fx(F, x0, dx, *p)             where F = F(x, p)
+-  df/dx, df/du = linearize_Fxu(F, x0, u0, dx, du, *p)    where F = F(x, u, p)
+
+"""
 import numpy as np
 import copy
 
-
 # --------------------------------------------------------------------------------}
 # --- Generic functions 
 # --------------------------------------------------------------------------------{
 def numerical_jacobian(f, op, arg_number, deltas, *f_args):
     """
     Compute the jacobian of the function `f` at the operating point `op`
     with respect to its argument `arg_number` using the symmetric difference quotient method.
@@ -37,17 +46,32 @@
     op = copy.deepcopy(op)
     op[arg_number] = np.asarray(op[arg_number]).astype(float)
     #dtype_op   = op[arg_number].dtype
     #dtype_delta =deltas.dtype
     #if dtype_op!=dtype_op:
     #    raise Exception('Type of op ({}) and deltas ({}) are not the same'.format(dtype_op, dtype_delta))
 
+    # --- Calling at operating point and checking that output is simple, array-like
     # Number of states assumed from call at operating point
-    f_op= f(*(op+f_args))
-    nx=len(f_op)
+    f_op = f(*(op+f_args))
+    if hasattr(f_op, '__len__'):
+        nx   = len(f_op)
+        if isinstance(f_op, np.ndarray):
+            shape=f_op.shape
+            if len(shape)==2:
+                if shape[1]!=1:
+                    print('>>> f_op:',f_op)
+                    raise Exception('Output of function is multidimensional (see above), whereas it should be array-like')
+                f_op = f_op[:,0]
+        for i in range(nx):
+            if isinstance(f_op[i], np.ndarray) or isinstance(f_op[i], list):
+                print('>>> f_op:',f_op)
+                raise Exception('Output of function to linearize is not "clean", it contains arrays/lists (see line above). It should return a scalar, a list, or an array-like')
+    else:
+        nx = 1
     
     # Number of variables obtained from argument number 
     nj = len(op[arg_number])
     if nj!=len(deltas):
         raise Exception('Number of deltas ({}) different from dimension of operating point number {} ({}) '.format(len(deltas), arg_number, len(op[arg_number])))
 
     jac = np.zeros((nx,nj))
@@ -56,16 +80,16 @@
     for j in range(nj):
         # Positive and negative perturbation of operating point for arg
         op_p = copy.deepcopy(op)
         op_m = copy.deepcopy(op)
         op_p[arg_number][j] += deltas[j]
         op_m[arg_number][j] -= deltas[j]
         # Evaluation of the function at these points
-        f_j_p= f(*(op_p+f_args)).flatten()
-        f_j_m= f(*(op_m+f_args)).flatten()
+        f_j_p= np.asarray(f(*(op_p+f_args))).flatten()
+        f_j_m= np.asarray(f(*(op_m+f_args))).flatten()
         # Partial derivative using symmetric difference quotient
         jac[:,j] = (f_j_p-f_j_m) / (2*deltas[j])
 
     return jac
 
 
 def linearize_function(F, xop, Iargs, delta_args,  *p):
```

### Comparing `welib-0.0.2/welib/system/mech_system.py` & `welib-1.0.0/welib/system/mech_system.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 import numpy as np
+import pandas as pd
 from numpy.linalg import inv
 from scipy.integrate import  solve_ivp #odeint
 from scipy.optimize import OptimizeResult as OdeResultsClass 
 from scipy.interpolate import interp1d
 from .statespace import StateMatrix
 
 
@@ -28,18 +29,19 @@
        - F: forcing term, function of t,x,xdot, or, tuple (time, Force time series)
 
        - q : full state vector
 
        NOTE: A~, B~ are not linear state space matrices in the general case
 
     """
-    def __init__(self, M, C=None, K=None, F=None, x0=None, xdot0=None, sX=None, sXd=None):
+    def __init__(self, M, C=None, K=None, F=None, x0=None, xdot0=None, sX=None, sXd=None, sY=None):
         """ 
         sX:  list of variable names for x    (e.g., used for plotting)
         sXd: list of variable names for xdot (e.g., used for plotting)
+        sY: list of variable names for outputs. Can also be set using setOutputFunction
         """
 
         # Functions that return the mass matrix and its inverse
         if hasattr(M, '__call__'):  
             self.M_is_func=True
             self._fM    = M
             self._fMinv = lambda x : inv(M(x))
@@ -80,14 +82,17 @@
 
         # Time integration results
         self.res=None
 
         # Channel names
         self._sX = sX
         self._sXd = sXd
+        self.sY = None
+
+        self.verbose=False
 
 
     def find_nDOF(self):
         if self.M_is_func:
             x=np.zeros((5000,1)) # Using a huge number of states..
             return len(self.M(x))
         else:
@@ -110,14 +115,21 @@
         else:
             return self._sXd
 
     @property
     def sQ(self):
         return self.sX+self.sXd
 
+    @property
+    def sOutputs(self):
+        if self.sY is not None:
+            return self.sY
+        else:
+            return None
+
     # --------------------------------------------------------------------------------}
     # --- Time domain
     # --------------------------------------------------------------------------------{
     def setInitialConditions(self,x0,xdot0):
         self.q0 = np.zeros(2*self.nDOF)
         if x0 is not None:
             if len(x0)!=self.nDOF:
@@ -176,14 +188,29 @@
                  x   : (nDOF,) array, position of each DOF
                  xdot: (nDOF,) array, velocities of each DOF
                  F   : (nDOF x 1) array, forces in each DOF
         
         """
         self._force_fn = fn
 
+    def setOutputFunction(self, fn, sY=None):
+        """
+
+        INPUTS:
+         - fn: handle to a python function. The interface of the function fn is: 
+
+               y =  f(t, x, xdot, **kwargs) 
+
+            where y is an array of size n or a pandas series with index corresponding to the output names 
+         - sY : array-like, list of of column names for outputs
+        """
+        self._output_fn = fn
+        if sY is not None:
+            self.sY = sY
+
     def Forces(self, t, x=None, xdot=None, q=None, **kwargs):
         """ 
         Return Forces on degrees of freedom at one time step, or multiple time steps
         The force is obtained using either:
           - the function provided by the user using setForceFunction (a nonlinear function of states)
           - the time series provided by the user using setForceTimeSeries
         Multiple time steps are only supported when time series were provided
@@ -246,16 +273,38 @@
                 # If no input for instance or not forcing F might be empty array..
                 # TODO DO THIS BETTER, very at init or something
                 pass
             return B
         else:
             raise Exception('Please specify a time series of force using `setForceTimeSeries` or a function using `setForceFunction` ')
 
+    # --------------------------------------------------------------------------------}
+    # --- OUTPUTS
+    # --------------------------------------------------------------------------------{
+    def Outputs(self, t, q):
+        nDOF = self.nDOF
+        x    = q[0:nDOF]
+        xd   = q[nDOF:]
+        if hasattr(self,'_output_fn'):
+            return self._output_fn(t, x, xd)
+        else:
+            raise NotImplementedError('Calculation of outputs when `setOutputFunction` not called')
+
+    def dqdt_calcOutput(self, signatureWanted='t,q', **kwargs):
+        """ Return function handle that computes outputs with a requested signature """
+        if signatureWanted=='t,q':
+            return self.Outputs
+        else:
+            raise NotImplementedError()
+
 
-    def integrate(self,t_eval, method='RK45', y0=None, **options):
+    # --------------------------------------------------------------------------------}
+    # --- Time integration 
+    # --------------------------------------------------------------------------------{
+    def integrate(self,t_eval, method='RK45', y0=None, calc='', **options):
         """ Perform time integration of system 
             method: 'RK54', 'LSODA'  (see solve_ivp)
         """
         #
         if y0 is not None:
             self.setStateInitialConditions(y0)
 
@@ -286,15 +335,17 @@
                 odefun = lambda t, q : np.dot(A,q)+self.B_tilde(t,q)
             else:
                 odefun = self.dqdt
                 #odefun = lambda t, q : self.B(t,q)
             res = solve_ivp(fun=odefun, t_span=[t_eval[0], t_eval[-1]], y0=self.q0, t_eval=t_eval, method=method, vectorized=True, **options)   
         # Store
         self.res    = res
-        return res
+
+        df=self.res2DataFrame(calc=calc)
+        return res, df
 
 
     def dqdt(self, t, q):
         if self.has_A:
             q=q.reshape((-1,1))
             A=self.A_tilde
             dqdt= np.dot(A,q)+self.B_tilde(t,q)
@@ -321,22 +372,224 @@
           NOTE: B~ may be a function of x, linearization is not done here 
         """
         if self.M_is_func:
             raise Exception('A matrix not a property when M is a function')
         else:
             return StateMatrix(self._Minv,self.C,self.K)
 
+
+    # --------------------------------------------------------------------------------}
+    # --- Simulation storage
+    # --------------------------------------------------------------------------------{
+    def cleanSimData(self):
+        self.res      = None
+        #self.dfIn     = None
+        self.dfOut    = None
+        #self.dfStates = None
+        self.df       = None
+
+    def save(self, filename, DOFs=None, Factors=None):
+        """ Save time integration results to file 
+        DOFs: array of string for DOFs names
+        """
+        df = self.res2DataFrame(DOFs=DOFs, Factors=Factors)
+        df.to_csv(filename, sep=',', index=False)
+
+    def res2DataFrame(self, res=None, sStates=None, Factors=None, 
+            x0=None, xd0=None, 
+            calc='xdd,f', # xdd, f, y
+            sAcc=None, sForcing=None
+            ):
+        """ Return time integration results as a dataframe
+        sStates: array of string for DOFs names   (2xnDOF, positions and velocities)
+        Factors: array of floats to scale the DOFs (2xnDOF)
+        x0 :  array of floats to add to the DOF (1xnDOF)
+        xd0:  array of floats to add to the velocities (1xnDOF)
+              NOTE: the positions will be increased linearly
+        """
+        # TODO harmonize with statespace.res2DataFrame
+        import pandas as pd
+
+        calcVals = calc.split(',')
+
+        if res is None:
+            if self.res is None:
+                raise Exception('Call integrate before res2DataFrame')
+            res = self.res
+
+        if sStates is None:
+            sStates  = ['x_{}'.format(i) for i in np.arange(self.nDOF)]
+            sStates += ['xd_{}'.format(i) for i in np.arange(self.nDOF)]
+        if sAcc is None:
+            sAcc = ['xdd_{}'.format(i) for i in np.arange(self.nDOF)]
+        if sForcing is None:
+            sForcing = ['F_{}'.format(i) for i in np.arange(self.nDOF)]
+
+        # --- Time and states
+        dfStates = self.store_states(res, sStates=sStates, x0=x0, xd0=xd0, Factors=Factors)
+
+        # --- Accelerations 
+        dfAcc = None
+        if 'xdd' in calcVals:
+            xdd = self.TS_Acceleration
+            dfAcc =  pd.DataFrame(data=xdd.T, columns=sAcc)
+
+        # --- Forcing
+        dfF = None
+        if 'f' in calcVals:
+            F     = self.TS_Forcing
+            dfF =  pd.DataFrame(data=F.T, columns=sForcing)
+
+        # --- Try to compute outputs
+        dfOut = None
+        if 'y' in calcVals:
+            dfOut = self.calc_outputs(insertTime=True, yoffset=None)
+        # --- Try to compute inputs
+
+        # --- Concatenates everything into one DataFrame
+        df = pd.concat((dfStates, dfAcc, dfF, dfOut), axis=1)
+        df = df.loc[:,~df.columns.duplicated()].copy()
+
+        return df
+
+    def store_states(self, res, sStates=None, x0=None, xd0=None, Factors=None):
+        #nStates = len(self.q0)
+        #if sStates is None and self.sX is None:
+        #    sStates = ['x{}'.format(i+1) for i in range(nStates)] # TODO
+        #else:
+        #    if sStates is None:
+        #        sStates = self.sX
+        #    nCols = self.res.y.shape[0]
+        #    if len(self.sX)!=nCols:
+        #        raise Exception("Inconsistency in length of states columnNames. Number of columns detected from res: {}. States columNames (sX): {}".format(nCols, self.sX))
+        #self.sX = sStates
+
+        # Store as a matrix
+        M = res.y.T.copy()
+
+        # Scaling
+        if Factors is not None:
+            for i, f in enumerate(Factors):
+                M[:,i] *= f
+        # Scaling offsets
+        if Factors is not None and x0 is not None:
+            x0 *= np.asarray(Factors[:self.nDOF])
+        if Factors is not None and xd0 is not None:
+            xd0 *= np.asarray(Factors[self.nDOF:])
+
+        # Offset Velocity
+        if xd0 is not None:
+            for i, xd0_ in enumerate(xd0):
+                M[:,self.nDOF+i] += xd0_       # Add to velocity
+                M[:,i]           += xd0_*res.t # Position increases linearly (e.g. azimuth)
+        # Offset position
+        if x0 is not None:
+            for i, x0_ in enumerate(x0):
+                M[:,i] += x0_
+
+        # Degrees
+        for i,d in enumerate(sStates):
+            if sStates[i].find('[deg]')>1: 
+                if np.max(M[:,i])>180:
+                    M[:,i] = np.mod(M[:,i], 360)
+        # Insert time
+        dfStates =  pd.DataFrame(data=M, columns=sStates)
+        dfStates.insert(0, 'Time_[s]', res.t)
+        return dfStates
+
+
+
+
+    def _prepareOutputDF(self, res):
+        cols    = self._inferOutputCols(res)
+        data    = np.full((len(res.t), len(cols)), np.nan)
+        df      = pd.DataFrame(columns = cols, data = data)
+        self.sY = cols
+        return df
+
+    def _inferOutputCols(self, res):
+        """ See what the calcOutput returns at t[0] to allocate storage memory """
+        try:
+            out = self.dqdt_calcOutput()(res.t[0], self.q0)
+        except TypeError:
+            print("[FAIL] Error evaluating model outputs. Does the function dqdt has the argument `calcOutput`?")
+            return None
+        if not isinstance(out, pd.core.series.Series):
+            # If array
+            cols = ['y{:d}'.format(i+1) for i in range(len(out))]
+        else:
+            # If pandas series
+            cols     = out.index
+
+        # --- Check consistency with self.sY
+        if self.sY is not None:
+            if len(self.sY)!=len(cols):
+                raise Exception("Inconsistency in length of output columnnames. Number of columns detected from `calcOuputt`: {}. Ouput columNames (sY):".format(len(cols), self.sY))
+            cols = self.sY
+        return cols
+
+    def _calc_outputs(self, time, q, df):
+        """ low level implementation leaving room for optimization for other subclass."""
+        calcOutput = self.dqdt_calcOutput()
+        if self.verbose:
+            print('Calc output...')
+        for i,t in enumerate(time):
+            df.iloc[i,:] = calcOutput(t, q[:,i])
+
+    def calc_outputs(self, res=None, insertTime=True, dataFrame=True, yoffset=None):
+        """ 
+        Call use calcOutput function for each time step and store values
+        """
+        # --- Get calcOutput function
+        
+        if res is None:
+            res = self.res
+        if res is None:
+            raise Exception('Provide `res` or call `integrate` before calling calc_outputs')
+
+        # --- Infer column names and allocate
+        df = self._prepareOutputDF(res)
+
+        # --- Calc output based on states
+        self._calc_outputs(res.t, res.y, df)
+        if yoffset is not None:
+            raise Exception()
+
+        if insertTime:
+            df.insert(0,'Time_[s]', res.t)
+        self.dfOut = df
+
+        if dataFrame:
+            return df
+        else:
+            return df.values
+
+
     # --------------------------------------------------------------------------------}
     # --- Time series after time integration
     # --------------------------------------------------------------------------------{
     @property
+    def time(self):
+        if self.res is None:
+            # Res or self.res not provided, return time series provided by user
+            if hasattr(self,'_force_ts'):
+                return self._time_ts
+            else:
+                raise Exception('Cannot return time when a function is used and no time integration was performed. Call `integrate`.')
+        else:
+            # Res provided
+            return self.res.t
+
+
+    @property
     def TS_Forcing_CK(self):
         """ Return time series of forcing from Stiffness and Damping matrix """
         if self.res is None:
             raise Exception('Run `integrate` before calling CKforcing')
+        time = self.time
         nDOF = self.nDOF
         FK = np.zeros((self.nDOF,len(time)))
         FC = np.zeros((self.nDOF,len(time)))
         if self.K is not None:
             for it, t in enumerate(time):
                 q  = res.y[:,it]
                 x  = q[0:nDOF]
@@ -358,14 +611,15 @@
                 time = self._time_ts
                 F    = self._force_ts
             else:
                 raise Exception('Cannot compute forcing when a function is used and no time integration was performed. Call `integrate`.')
         else:
             # Res provided
             time =self.res.t
+            res =self.res
             if hasattr(self,'_force_ts'):
                 F = self.Forces(time)
             else:
                 F = np.zeros((self.nDOF,len(time)))
                 for it, t in enumerate(time):
                     F[:,it] = self.Forces(t, q=res.y[:,it]).ravel()
         return F
@@ -389,29 +643,35 @@
     # --- "Linear"
     # --------------------------------------------------------------------------------{
     # TODO consider using system.linearization.py to get linear model
     @property
     def A(self):
         if self.M_is_func:
             raise Exception('A matrix not a property when M is a function')
-        if hasattr(self,'_force_fn') or not hasattr(self,'_force_ts'):
-            print('[WARN] The A matrix is not guaranteed to be the linearized version when force is given as a function')
+        #if hasattr(self,'_force_fn') or not hasattr(self,'_force_ts'):
+        #    print('[WARN] The A matrix is not guaranteed to be the linearized version when force is given as a function')
         return StateMatrix(self._Minv,self.C,self.K)
 
+    def eigA(self):
+        from welib.tools.eva import eigA
+        A = self.A # NOTE: not always defined...
+        freq_d, zeta, Q, freq_0 = eigA(A, fullEV=False, normQ=None, sort=True)
+        return freq_d, zeta, Q, freq_0 
+
     @property
     def B(self):
         """ 
         Returns B when applicable
             xdot = A x + B u 
         where u is assumed to be the forces in each DOF
         """
         if self.M_is_func:
             raise Exception('B matrix not a property when M is a function')
-        if hasattr(self,'_force_fn') or not hasattr(self,'_force_ts'):
-            print('[WARN] The B matrix is not guaranteed to be the linearized version when force is given as a function')
+        #if hasattr(self,'_force_fn') or not hasattr(self,'_force_ts'):
+        #    print('[WARN] The B matrix is not guaranteed to be the linearized version when force is given as a function')
         nDOF = self.nDOF
         B = np.zeros((2*nDOF,nDOF))
         B[nDOF:,:] = self._Minv
         return B
 
     @property
     def x0(self): return self.q0[:self.nDOF]
@@ -456,16 +716,28 @@
             s+='| - B:  \n'
             s+=str(self.B)+'\n'
         except:
             pass
 
         return s
 
+    def picklable(self):
+        """ Make the object picklable..."""
+        def noneIfLambda(attr):
+            obj = getattr(self, attr)
+            if callable(obj) and obj.__name__ == "<lambda>":
+                print('MechSystem: picklable: removing ', attr)
+                setattr(self, attr, None)
+        noneIfLambda('M')
+        noneIfLambda('_fM')
+        noneIfLambda('_fMinv')
+        noneIfLambda('_force_fn')
+
 
-    def plot(self, fig=None, axes=None, label=None, res=None, **kwargs):
+    def plot(self, fig=None, axes=None, label=None, res=None, calc='', qFactors=None, **kwargs):
         """ Simple plot of states after time integration"""
         if res is None:
             res=self.res
         if res is None:
             raise Exception('Call integrate before plotting, or provide a `res` output structure')
 
         if axes is None:
@@ -475,41 +747,56 @@
             axes_provided=False
         else:
             axes_provided=True
 
         axes = np.atleast_1d(axes)
         n=self.nDOF
 
-        df=self.toDataFrame(DOFs=None, Factors=None, x0=None, xd0=None, acc=False, sAcc=None, forcing=False, sForcing=None)
+        df=self.res2DataFrame(sStates=None, Factors=qFactors, x0=None, xd0=None, calc=calc, sAcc=None, sForcing=None)
         for i,ax in enumerate(axes):
             if i+1>len(df.columns):
                 continue
             chan=df.columns[i+1]
             lbl = '$'+self.sQ[i]+'$'
             ax.plot(res.t, res.y[i,:], label=label, **kwargs)
             if not axes_provided:
                 ax.set_ylabel(lbl)
             ax.tick_params(direction='in')
         if not axes_provided:
             axes[-1].set_xlabel('Time [s]')
 
-        return fig, axes
+        return axes
+
+    def plot_outputs(self, df=None, keys=None, axes=None, **kwargs):
+        """ 
+        plot outputs. Requires to call `integrate` or `calc_outputs` before
+        """
+        if df is None:
+            if self.dfOut is None:
+                raise Exception("Call calc_outputs or `integrate` before plot_outputs")
+            df = self.dfOut
+            if df is None:
+                print('[WARN] no outputs to plot')
+                return
+        keys = list(self.sOutputs)
+
+        return _plot(df, keys=keys, title='', nPlotCols=1, axes=axes, **kwargs)
+
 
-    def plot_forcing(self, fig=None, axes=None, label=None, res=None, includeCK=False, plotCK0=False, **kwargs):
+    def plot_forcing(self, axes=None, label=None, res=None, includeCK=False, plotCK0=False, **kwargs):
         """ 
         Simple plot of forcing
           - if `res` is provided, use time and states from res
           - if time integration was performed, use time and states from self.res
           otherwise: 
           - if a time series was provided, plot that
           - if a function was provided for the forcing, abort
         """
-        if res is None:
-            res=self.res
-
+        # 
+        time = self.time
         # Compute Forcing 
         F = self.TS_Forcing
         # Compute Forcing  contributions from Damping and Stiffness
         if includeCK:
             FC, FK = self.TS_Forcing_CK
             F0=F.copy()
             F=F0+FK+FC
@@ -527,89 +814,49 @@
                 ax.plot(time, F0[i,:], ':' , label='(F0)', **kwargs)
                 ax.plot(time, FC[i,:], '-' , label='(FC)', **kwargs)
                 ax.plot(time, FK[i,:], '--', label='(FK)', **kwargs)
             ax.set_ylabel(lbl)
             ax.tick_params(direction='in')
         axes[-1].set_xlabel('Time [s]')
 
-        return fig, axes
-
-
-    def save(self, filename, DOFs=None, Factors=None):
-        """ Save time integration results to file 
-        DOFs: array of string for DOFs names
-        """
-        df = self.toDataFrame(DOFs=DOFs, Factors=Factors)
-        df.to_csv(filename, sep=',', index=False)
-
-    def toDataFrame(self, DOFs=None, Factors=None, x0=None, xd0=None, 
-            acc=False, sAcc=None, forcing=False, sForcing=None):
-        """ Return time integration results as a dataframe
-        DOFs:    array of string for DOFs names   (2xnDOF, positions and velocities)
-        Factors: array of floats to scale the DOFs (2xnDOF)
-        x0 :  array of floats to add to the DOF (1xnDOF)
-        xd0:  array of floats to add to the velocities (1xnDOF)
-              NOTE: the positions will be increased linearly
-        """
-        import pandas as pd
-        if self.res is None:
-            raise Exception('Call integrate before save')
-
-        if DOFs is None:
-            DOFs  = ['x_{}'.format(i) for i in np.arange(self.nDOF)]
-            DOFs += ['xd_{}'.format(i) for i in np.arange(self.nDOF)]
-        if sAcc is None:
-            sAcc = ['xdd_{}'.format(i) for i in np.arange(self.nDOF)]
-        if sForcing is None:
-            sForcing = ['F_{}'.format(i) for i in np.arange(self.nDOF)]
-
-        header = ' Time_[s], '+','.join(DOFs)
-
-        res = self.res
-
-        # Combine time series into a matrix
-        M    = np.column_stack((res.t, res.y.T))
-        time = res.t
-        cols = ['Time_[s]']+DOFs
-
-        # Scaling
-        if Factors is not None:
-            for i, f in enumerate(Factors):
-                M[:,i+1] *= f
-        # Offset Velocity
-        if xd0 is not None:
-            for i, xd0_ in enumerate(xd0):
-                if Factors is not None:
-                    M[:,self.nDOF+i+1] += xd0_*Factors[i+self.nDOF] # Add to velocity
-                    M[:,i+1]           += (xd0_*time)*Factors[i]    # Position increases linearly
-                else:
-                    M[:,self.nDOF+i+1] += xd0_      # Add to velocity
-                    M[:,i+1]           += xd0_*time # Position increases linearly
-        # Offset position
-        if x0 is not None:
-            for i, x0_ in enumerate(x0):
-                if Factors is not None:
-                    M[:,i+1] += x0_*Factors[i]
-                else:
-                    M[:,i+1] += x0_
-
-        for i,d in enumerate(DOFs):
-            if DOFs[i].find('[deg]')>1: 
-                if np.max(M[:,i+1])>180:
-                    M[:,i+1] = np.mod(M[:,i+1], 360)
-
-        # Accelerations 
-        if acc:
-            xdd = self.TS_Acceleration
-            M     = np.column_stack((M,xdd.T))
-            cols += sAcc
-        # Forcing
-        if forcing:
-            F     = self.TS_Forcing
-            M     = np.column_stack((M,F.T))
-            cols += sForcing
+        return axes
 
 
-        return pd.DataFrame(data=M, columns=cols)
 
+def _plot(df, keys=None, label=None, title='', nPlotCols=1, axes=None, **kwargs):
+    import matplotlib
+    import matplotlib.pyplot as plt
+    #if COLRS is None:
+    #    cmap = matplotlib.cm.get_cmap('viridis')
+    #    COLRS = [(cmap(v)[0],cmap(v)[1],cmap(v)[2]) for v in np.linspace(0,1,3+1)]
+
+    time = df['Time_[s]'].values
+    if keys is None:
+        keys = [k for k in df.keys() if k!='Time_[s]']
+
+    I=np.arange(len(keys))
+
+    if axes is None:
+
+        if nPlotCols==2:
+            fig,axes = plt.subplots(int(np.ceil(len(I)/2)), 2, sharex=True, figsize=(6.4,4.8)) # (6.4,4.8)
+            fig.subplots_adjust(left=0.07, right=0.98, top=0.955, bottom=0.05, hspace=0.20, wspace=0.20)
+        else:
+            fig,axes = plt.subplots(len(I), 1, sharex=True, figsize=(6.4,4.8)) # (6.4,4.8)
+            fig.subplots_adjust(left=0.16, right=0.95, top=0.95, bottom=0.12, hspace=0.20, wspace=0.20)
+
+        if not hasattr(axes,'__len__'):
+            axes=[axes]
+    axes=(np.asarray(axes).T).ravel()
+    
+    for j,i in enumerate(I):
+        s  = keys[i]
+        ax = axes[j]
+        ax.plot(time, df[s], label=label, **kwargs)
+        ax.set_ylabel(s)
+        ax.tick_params(direction='in')
+    axes[0].set_title(title)
+    axes[-1].set_xlabel('Time [s]')
+    axes[-1].legend()
+    return axes
```

### Comparing `welib-0.0.2/welib/system/secondorder.py` & `welib-1.0.0/welib/system/secondorder.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/singledof.py` & `welib-1.0.0/welib/system/singledof.py`

 * *Files 1% similar despite different names*

```diff
@@ -72,15 +72,15 @@
     """
     H0  = (F0_over_k) / np.sqrt((1 - frat**2)** 2 + (2*zeta*frat)**2)
     phi = np.arctan2(-2 * zeta * frat , (1 - frat ** 2)) # NOTE sign convention for sin(Om*t-phi)
     return H0, phi
 
 def forced_vibration_particular(vt, k, m, F0, Omega, zeta):
     """
-    Particualr solution to forced harmonic vibrations, , x=H0 sin(Omega t - Phi)
+    Particular solution to forced harmonic vibrations, , x=H0 sin(Omega t - Phi)
     """
     omega0       = np.sqrt(k / m)
     H0, phi      = forced_vibration_particular_cst(Omega/omega0, F0/k, zeta)
     x_particular = H0 * np.sin(Omega * vt + phi)
     return x_particular
 
 def forced_vibration_transient(vt, k, m, F0, Omega, zeta, x0, xdot0):
```

### Comparing `welib-0.0.2/welib/system/statespacelinear.py` & `welib-1.0.0/welib/weio/wetb/hawc2/Hawc2io.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,414 +1,343 @@
-import numpy as np
-from numpy.linalg import inv
-from numpy.linalg import solve
-from numpy.linalg import eigvals, matrix_rank
-from scipy.integrate import  solve_ivp #odeint
-from scipy.interpolate import interp1d
-from scipy.optimize import OptimizeResult as OdeResultsClass 
-from scipy.linalg import expm
-# Local
-
-# --------------------------------------------------------------------------------}
-# --- Simple statespace functions ltiss (linear time invariant state space)
-# --------------------------------------------------------------------------------{
-def state_function(t, x, u, p):
-    return p['A'].dot(x) + p['B'].dot(u)
-
-def output_function(t, x, u, p):
-    return p['C'].dot(x) + p['D'].dot(u)
-
-def integrate(t_eval, q0, A, B, fU, method='LSODA', **options):
-    """ 
-    Perform time integration of a LTI state space system
-
-    INPUTS:
-     - q0: initial states, array of length nStates
-     - A: state matrix (nStates x nStates)
-     - B: input matrix (nStates x nInputs)
-     - fU: function/interpolants interface U=fU(t) or U=fU(t,q)
-          U : array of inputs
-
-    OUTPUTS:
-     - res: object with attributes `t` and `y`(states for now..) and other attributse from solve_ivp
-
-    """
-    hasq=False
-    try:
-        fU(t_eval[0],q0)
-        hasq=True
-    except:
-        try:
-            fU(t_eval[0])
-            hasq=False
-        except:
-            raise
-
-    if hasq:
-        odefun = lambda t, q : np.dot(A, q) + np.dot(B, fU(t,q))
-    else:
-        odefun = lambda t, q : np.dot(A, q) + np.dot(B, fU(t) )
-
-    res = solve_ivp(fun=odefun, t_span=[t_eval[0], t_eval[-1]], y0=q0, t_eval=t_eval, method=method, vectorized=False, **options)   
+# -*- coding: utf-8 -*-
+"""
+Author:
+    Bjarne S. Kallesoee
+
+
+Description:
+    Reads all HAWC2 output data formats, HAWC2 ascii, HAWC2 binary and FLEX
+
+call ex.:
+    # creat data file object, call without extension, but with parth
+    file = ReadHawc2("HAWC2ex/tests")
+    # if called with ReadOnly = 1 as
+    file = ReadHawc2("HAWC2ex/tests",ReadOnly=1)
+    # no channels a stored in memory, otherwise read channels are stored for reuse
+
+    # channels are called by a list
+    file([0,2,1,1])  => channels 1,3,2,2
+    # if empty all channels are returned
+    file()  => all channels as 1,2,3,...
+    file.t => time vector
 
-    # TODO consider returning y
+1. version: 19/4-2011
+2. version: 5/11-2015 fixed columns to get description right, fixed time vector (mmpe@dtu.dk)
 
-    return res
+Need to be done:
+    * add error handling for allmost every thing
 
+"""
+import numpy as np
+import os
 
-def integrate_convolution(time, A, B, fU, C=None):
-    """ 
-    Perform time integration of a LTI state space system using convolution method
-
-    INPUTS:
-     - A: state matrix (nStates x nStates)
-     - B: input matrix (nStates x nInputs)
-     - fU: function/interpolants with interface U=fU(t) or U=fU(t,q)
-           where U is the array of inputs at t
-
-    OUTPUTS:
-     - x: state vector
-
-    """
-    H = impulse_response_matrix(time, A, B)
-
-    x = np.zeros((A.shape[0], len(time)))
+#from wetb import gtsdf
 
-    from welib.tools.signal_analysis import convolution_integral
-    # TODO inline and optimize
-    try:
-        U = fU(time)
-    except:
-        print('[WARN] Cannot evaluate fU for all time, doing a for loop...')
-        U = np.zeros((B.shape[1], len(time)))
-        for it,t in enumerate(time):
-            U[:,it] = fU(t) # NOTE: cannot do state dependency here
-
-    for i in np.arange(H.shape[0]):
-        x_sum=0
-        for j in np.arange(H.shape[1]):
-            x_sum  += convolution_integral(time, U[j,:], H[i,j,:] )
-        x[i,:] = x_sum
-    return x
-
-    # TODO consider returning y
-
-def impulse_response_matrix(time, A, B, C=None, outputBoth=False):
-    """ 
-    Return the impulse response matrix for all time steps defined by `time`
-        H_x(t) =   exp(At) B
-        H_y(t) = C exp(At) B
-        see e.g. 
-           Friedland p 76
+# FIXME: numpy doesn't like io.open binary fid in PY27, why is that? As a hack
+# workaround, use opent for PY23 compatibility when handling text files,
+# and default open for binary
+
+################################################################################
+################################################################################
+################################################################################
+# Read HAWC2 class
+################################################################################
+class ReadHawc2(object):
     """
-    H_x = np.zeros((A.shape[0], B.shape[1], len(time)))
-    for it, t in enumerate(time):
-        H_x[:,:, it] = expm(A*t).dot(B)
-
-    if outputBoth:
-        raise NotImplementedError()
-        if C is None:
-            raise Exception('Provide `C` to output both impulse response matrices H_x and H_y')
-        H_y = C.dot(H_x) # TODO verify
-        return H_x, H_y
-    else:
-        return H_x
-
-# --------------------------------------------------------------------------------}
-# --- Linear State Space system
-# --------------------------------------------------------------------------------{
-class LinearStateSpace():
-    """ 
-    def setStateInitialConditions(self,q0=None):
-    def setInputTimeSeries(self,vTime,vU):
-    def setInputFunction(self,fn):
-    def Inputs(self,t,x=None):
-    def integrate(self, t_eval, method='RK4', y0=None, **options):
-    def dqdt(self, t, q):
-    def RHS(self,t,q):
-    def nStates(self):
-    def nInputs(self):
-    def nOuputs(self):
     """
-    def __init__(self,A,B,C=None,D=None,q0=None):
-        self.A=np.asarray(A)
-        self.B=np.asarray(B)
-        if C is None:
-            self.C=np.eye(A.shape[0]) # output all states
-        else:
-            self.C=np.asarray(C)
-        if D is None:
-            self.D=np.zeros((self.C.shape[0],0))
-        else:
-            self.D=np.asarray(D)
-
-        # Initial conditions
-        self.setStateInitialConditions(q0)
-
-        # Time integration results
-        self.res=None
-
-    @property
-    def nStates(self):
-        return self.A.shape[0]
-
-    @property
-    def nInputs(self):
-        return self.B.shape[1]
-
-    @property
-    def nOuputs(self):
-        if self.C is not None:
-            return self.C.shape[1]
-        else:
-            return 0
-
-    # --------------------------------------------------------------------------------}
-    # --- Time domain 
-    # --------------------------------------------------------------------------------{
-    def setStateInitialConditions(self,q0=None):
-        self.q0 = np.zeros(self.nStates)
-        if q0 is not None:
-            if len(q0)!=self.nStates:
-                raise Exception('Wrong dimension for q0 ({} instead of {} )'.format(len(q0),self.nStates))
-            self.q0 = q0
-
-    def setInputTimeSeries(self,vTime,vU):
-        """ 
-        Set the inputs as a time series of time
-        INPUTS:
-         - vTime: 1d array of time steps (do not need to be regular), of length nt
-         - vF   : nStates x nt array of forces at each time steps, for the nStates states
-        """
-        vTime = np.asarray(vTime)
-        vU    = np.asarray(vU)
-        if self.nInputs==1:
-            vU = vU.reshape((1,-1))
-        if vU.shape[0]!=self.nInputs:
-            raise Exception('Wrong first dimension for Inputs time series ({} instead of {} )'.format(vU.shape[0],self.nInputs))
-        if vU.shape[1]!=len(vTime):
-            raise Exception('Second dimension of Input time series does not match time dimension ({} instead of {} )'.format(vU.shape[1],len(vTime)))
-
-        # Store raw data
-        self._inputs_ts = vU
-        self._time_ts  = vTime
-        # Create interpolant for faster evaluation
-        self._inputs_fn_t = interp1d(vTime, vU)
-
-    def setInputFunction(self,fn):
-        """ 
-        Set the inputs as a function of time and states
-        The function will be used during the time integration
-
-        INPUTS:
-          fn: handle to a python function. The interface of the function fn is: 
-
-               u =  f(t, q) 
-
-              where:
-                 t   : scalar, time
-                 q   : (nStates,) array, states
-                 u   : (nInputs,) array, inputs 
-        
-        """
-        self._inputs_fn = fn
-
-    def Inputs(self, t, q=None):
-        if hasattr(self,'_inputs_fn_t'):
-            return self._inputs_fn_t(t) # NOTE: interpolant, works for scalar or arrays
-        elif hasattr(self,'_inputs_fn'):
-            return self._inputs_fn_t(t, q=q) # TODO what if user doesn't care for states..
-        else:
-            raise Exception('Please specify a time series of inputs using `setInputsTimeSeries` or a function using `setInputsFunction` ')
-
-
-    def integrate(self, t_eval, method='RK4', y0=None, **options):
-        #
-        if y0 is not None:
-            self.setStateInitialConditions(y0)
-
-        if method.lower()=='impulse':
-            # TODO add check on initial conditions
-            x = integrate_convolution(t_eval, self.A, self.B, self.Inputs)
-
-            res = OdeResultsClass(t=t_eval, y=x) # To mimic result class of solve_ivp
-
-        else:
-            res = integrate(t_eval, self.q0, self.A, self.B, self.Inputs, method=method, **options)
-
-        if self.nOuputs>0:
-            print('>>> TODO: do something to compute outputs after states')
-
-        # Store
-        self.res    = res
-
-        return res
-
-    def dqdt(self, t, q):
-        # NOTE: this can cause issues if q is not flat
-        return np.dot(self.A, q) + np.dot(self.B, self.Inputs(t,q))
-
-    def RHS(self,t,q):
-        return self.dqdt(t,q)
-
-    # --------------------------------------------------------------------------------}
-    # --- Frequency domain and transfer function
-    # --------------------------------------------------------------------------------{
-    def transferFunction(self, s):
-        """Evaluate the systems's transfer function for a complex variable
-
-        H(s) = C [sI-A]^-1 B + D
-
-        Returns a matrix of values evaluated at complex variable s.
-
-        A more efficient function may be found in TB05Ad from Slycot
-        from slycot import tb05ad
-        see control.statesp.horner
+################################################################################
+# read *.sel file
+    def _ReadSelFile(self):
         """
-        if hasattr(s, '__len__'):
-            nu = self.nInputs
-            ny = self.nOuputs
-            ns = len(s)
-            H = np.empty((ny, nu, ns), dtype=np.complex128)
-            for k,sk in enumerate(s.ravel()):
-                H[:,:,k] =np.dot(self.C, solve(sk* np.eye(self.nStates) - self.A, self.B)) + self.D
-            #H = np.array([np.dot(self.C, solve(sk* np.eye(self.nStates) - self.A, self.B)) + self.D  for sk in s.ravel()])
-            #H=H.reshape([ny,nu]+list(s.shape))
-        else:
-            H =           np.dot(self.C, solve(s * np.eye(self.nStates) - self.A, self.B)) + self.D
-
-        return H
+        Some title
+        ==========
 
-
-    def frequency_response(self, omega):
-        """Evaluate the system's transfer function at a list of frequencies
-        Reports the frequency response of the system,
-
-             H(j*omega) = mag*exp(j*phase)
-
-        for continuous time. For discrete time systems, the response is
-        evaluated around the unit circle such that
-
-             H(exp(j*omega*dt)) = mag*exp(j*phase).
+        Using docstrings formatted according to the reStructuredText specs
+        can be used for automated documentation generation with for instance
+        Sphinx: http://sphinx.pocoo.org/.
 
         Parameters
         ----------
-        omega : array_like
-            A list of frequencies in radians/sec at which the system should be
-            evaluated. The list can be either a python list or a numpy array
+        signal : ndarray
+            some description
 
         Returns
         -------
-        mag : (self.outputs, self.inputs, len(omega)) ndarray
-            The magnitude (absolute value, not dB or log10) of the system
-            frequency response.
-        phase : (self.outputs, self.inputs, len(omega)) ndarray
-            The wrapped phase in radians of the system frequency response.
+        output : int
+            describe variable
         """
-        omega = np.asarray(omega)
 
-        numFreqs = len(omega)
-        #Gfrf = np.empty((self.outputs, self.inputs, numFreqs), dtype=np.complex128)
-        #if isdtime(self, strict=True):
-        #    dt = timebase(self)
-        #    cmplx_freqs = exp(1.j * omega * dt)
-        #    if max(np.abs(omega)) * dt > math.pi:
-        #        warn("freqresp: frequency evaluation above Nyquist frequency")
-        #else:
-        s = omega * 1.j
-        H = self.transferFunction(s)
-        return np.abs(H), np.angle(H)
-
-    # --------------------------------------------------------------------------------}
-    # ---  IO functions for printing/plotting/saving
-    # --------------------------------------------------------------------------------{
-    def __repr__(self):
-        s='<{} object>\n'.format(type(self).__name__)
-        s+='|Read-only attributes:\n'
-        s+='| - nState:{} \n'.format(self.nStates)
-        if hasattr(self,'_force_ts'):
-            if len(self._time_ts)>1:
-                dt=self._time_ts[1]-self._time_ts[0]
-            else:
-                dt=np.nan
-            s+='|Force time series \n'
-            s+='| - Time: [{} ... {}],  dt: {}, n: {} \n'.format(self._time_ts[0],self._time_ts[-1],dt,len(self._time_ts))
-            s+='| - Force t0  : {} \n'.format(self._force_ts[:,0])
-            s+='| - Force tend: {} \n'.format(self._force_ts[:,-1])
-        s+='|Attributes:\n'
-        s+='| - A: State-State Matrix  \n'
-        s+=str(self.A)+'\n'
-        s+='| - B: State-Input Matrix  \n'
-        s+=str(self.B)+'\n'
-        s+='| - q0: Initial conditions (state) \n'
-        s+=str(self.q0)+'\n'
-        return s
-
-    def plot(self, fig=None, axes=None, label=None, res=None, **kwargs):
-        """ Simple plot of states after time integration"""
-        if res is None:
-            res=self.res
-        if res is None:
-            raise Exception('Call integrate before plotting, or provide a `res` output structure')
-
-        if axes is None:
-            import matplotlib.pyplot as plt
-            fig,axes = plt.subplots( self.nStates,1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-            fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-            axes_provided=False
+        # read *.sel hawc2 output file for result info
+        if self.FileName.lower().endswith('.sel'):
+            self.FileName = self.FileName[:-4]
+        fid = open(self.FileName + '.sel', 'r')
+        Lines = fid.readlines()
+        fid.close()
+        if Lines[0].lower().find('bhawc')>=0:
+            # --- Find line with scan info
+            iLine=0
+            for i in np.arange(5,10):
+                if Lines[i].lower().find('scans')>=0:
+                    iLine=i+1
+            if iLine==0:
+                raise Exception('Cannot find the keyword "scans"')
+            temp = Lines[iLine].split()
+            self.NrSc = int(temp[0])
+            self.NrCh = int(temp[1])
+            self.Time = float(temp[2])
+            self.Freq = self.NrSc / self.Time
+            self.t = np.linspace(0, self.Time, self.NrSc + 1)[1:]
+            # --- Find line with channel info
+            iLine=0
+            for i in np.arange(5,13):
+                if Lines[i].lower().find('channel')>=0:
+                    iLine=i+1
+            if iLine==0:
+                raise Exception('Cannot find the keyword "Channel"')
+
+            # reads channel info (name, unit and description)
+            Name = []; Unit = []; Description = [];
+            for i in range(0, self.NrCh+1):
+                if (i+iLine)>=len(Lines):
+                    break
+                line = Lines[i + iLine].strip()
+                if len(line)==0:
+                    continue
+                # --- removing number and unit
+                sp=[sp.strip() for sp in line.split() if len(sp.strip())>0]
+                num   = sp[0]
+                iNum  = line.find(num)
+                line  = line[iNum+len(num)+1:]
+                unit  = sp[-1]
+                iUnit = line.find(unit)
+                line  = line[:iUnit]
+                # --- Splitting to find label and description
+                sp=[sp.strip() for sp in line.split('\t') if len(sp.strip())>0]
+                if len(sp)!=2:
+                    for nSpaces in np.arange(2,15):
+                        sp=[sp.strip() for sp in line.split(' '*nSpaces) if len(sp.strip())>0]
+                        if len(sp)==2:
+                            break
+                if len(sp)!=2:
+                    raise Exception('Dont know how to split the input of the sel file into 4 columns')
+
+                Unit.append(unit)
+                Description.append(sp[0]) 
+                Name.append(sp[1]) 
+
+            self.ChInfo = [Name, Unit, Description]
+            self.FileFormat = 'BHAWC_ASCII'
         else:
-            axes_provided=True
 
-        axes = np.atleast_1d(axes)
-        for i,ax in enumerate(axes):
-            lbl=r'$x_{}$'.format(i+1)
-            ax.plot(res.t, res.y[i,:], label=label, **kwargs)
-            if not axes_provided:
-                ax.set_ylabel(lbl)
-            ax.tick_params(direction='in')
-        if not axes_provided:
-            axes[-1].set_xlabel('Time [s]')
-
-        return fig, axes
-
-    def plot_inputs(self, axes=None, label=None, res=None, **kwargs):
-        """ 
-        Simple plot of inputs
-          - if `res` is provided, use time and states from res
-          - if time integration was performed, use time and states from self.res
-          otherwise: 
-          - if a time series was provided, plot that
-          - if a function was provided for the forcing, abort
-        """
-        if res is None:
-            res=self.res
-        if res is None:
-            # Res or self.res not provided
-            if hasattr(self,'_inputs_ts'):
-                time = self._time_ts
-                U    = self._inputs_ts
+            # findes general result info (number of scans, number of channels,
+            # simulation time and file format)
+            temp = Lines[8].split()
+            self.NrSc = int(temp[0])
+            self.NrCh = int(temp[1])
+            self.Time = float(temp[2])
+            self.Freq = self.NrSc / self.Time
+            self.t = np.linspace(0, self.Time, self.NrSc + 1)[1:]
+            Format = temp[3]
+            # reads channel info (name, unit and description)
+            Name = []; Unit = []; Description = [];
+            for i in range(0, self.NrCh):
+                temp = str(Lines[i + 12][12:43]); Name.append(temp.strip())
+                temp = str(Lines[i + 12][43:54]); Unit.append(temp.strip())
+                temp = str(Lines[i + 12][54:-1]); Description.append(temp.strip())
+            self.ChInfo = [Name, Unit, Description]
+            # if binary file format, scaling factors are read
+            if Format.lower() == 'binary':
+                self.ScaleFactor = np.zeros(self.NrCh)
+                self.FileFormat = 'HAWC2_BINARY'
+                for i in range(0, self.NrCh):
+                    self.ScaleFactor[i] = float(Lines[i + 12 + self.NrCh + 2])
             else:
-                raise NotImplementedError()
+                self.FileFormat = 'HAWC2_ASCII'
+################################################################################
+# read sensor file for FLEX format
+    def _ReadSensorFile(self):
+        # read sensor file used if results are saved in FLEX format
+        DirName = os.path.dirname(self.FileName)
+        try:
+            fid = opent(DirName + r"\sensor ", 'r')
+        except IOError:
+            print("can't finde sensor file for FLEX format")
+            return
+        Lines = fid.readlines()
+        fid.close()
+        # reads channel info (name, unit and description)
+        self.NrCh = 0
+        Name = []
+        Unit = []
+        Description = []
+        for i in range(2, len(Lines)):
+            temp = Lines[i]
+            if not temp.strip():
+                break
+            self.NrCh += 1
+            temp = str(Lines[i][38:45])
+            Unit.append(temp.strip())
+            temp = str(Lines[i][45:53])
+            Name.append(temp.strip())
+            temp = str(Lines[i][53:])
+            Description.append(temp.strip())
+        self.ChInfo = [Name, Unit, Description]
+        # read general info from *.int file
+        fid = open(self.FileName, 'rb')
+        fid.seek(4 * 19)
+        if not np.fromfile(fid, 'int32', 1) == self.NrCh:
+            print("number of sensors in sensor file and data file are not consisten")
+        fid.seek(4 * (self.NrCh) + 4, 1)
+        self.Version = np.fromfile(fid, 'int32',1)[0]
+        time_start, time_step = np.fromfile(fid, 'f', 2)
+        self.Freq = 1 / time_step
+        self.ScaleFactor = np.fromfile(fid, 'f', self.NrCh)
+        fid.seek(2 * 4 * self.NrCh + 48 * 2)
+        self.NrSc = int(len(np.fromfile(fid, 'int16')) / self.NrCh)
+        self.Time = self.NrSc * time_step
+        self.t = np.arange(0, self.Time, time_step) + time_start
+        fid.close()
+################################################################################
+# init function, load channel and other general result file info
+    def __init__(self, FileName, ReadOnly=0):
+        self.FileName = FileName
+        self.ReadOnly = ReadOnly
+        self.Iknown = []  # to keep track of what has been read all ready
+        self.Data = np.zeros(0)
+        if FileName.lower().endswith('.sel') or os.path.isfile(FileName + ".sel"):
+             self._ReadSelFile()
+        elif FileName.lower().endswith('.dat') and os.path.isfile(os.path.splitext(FileName)[0] + ".sel"):
+             self.FileName = os.path.splitext(FileName)[0]
+             self._ReadSelFile()
+        elif FileName.lower().endswith('.int') or FileName.lower().endswith('.res'):
+             self.FileFormat = 'FLEX'
+             self._ReadSensorFile()
+        elif os.path.isfile(self.FileName + ".int"):
+             self.FileName = self.FileName + ".int"
+             self.FileFormat = 'FLEX'
+             self._ReadSensorFile()
+        elif os.path.isfile(self.FileName + ".res"):
+             self.FileName = self.FileName + ".res"
+             self.FileFormat = 'FLEX'
+             self._ReadSensorFile()
+        elif FileName.lower().endswith('.hdf5') or os.path.isfile(self.FileName + ".hdf5"):
+            self.FileFormat = 'GTSDF'
+            self.ReadGtsdf()
         else:
-            # Res provided
-            time =res.t
-            if hasattr(self,'_inputs_ts'):
-                U = self.Inputs(time)
-            else:
-                U = np.zeros((self.nInputs,len(time)))
-                for it, t in enumerate(time):
-                    U[:,it] = self.Inputs(t, q=res.y[:,it])
-        ## Plot
-        if axes is None:
-            import matplotlib.pyplot as plt
-            fig,axes = plt.subplots( self.nInputs, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-            fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
-        axes = np.atleast_1d(axes)
-        for i,ax in enumerate(axes):
-            lbl=r'$u_{}$'.format(i+1)
-            ax.plot(time, U[i,:], label=label, **kwargs)
-            ax.set_ylabel(lbl)
-            ax.tick_params(direction='in')
-        axes[-1].set_xlabel('Time [s]')
-
-        return fig, axes
+            raise Exception("unknown file: " + FileName)
+################################################################################
+# Read results in binary format
+    def ReadBinary(self, ChVec=None):
+        ChVec = [] if ChVec is None else ChVec
+        if not ChVec:
+            ChVec = range(0, self.NrCh)
+        with open(self.FileName + '.dat', 'rb') as fid:
+            data = np.zeros((self.NrSc, len(ChVec)))
+            j = 0
+            for i in ChVec:
+                fid.seek(i * self.NrSc * 2, 0)
+                data[:, j] = np.fromfile(fid, 'int16', self.NrSc) * self.ScaleFactor[i]
+                j += 1
+        return data
+################################################################################
+# Read results in ASCII format
+    def ReadAscii(self, ChVec=None):
+        ChVec = [] if ChVec is None else ChVec
+        if not ChVec:
+            ChVec = range(0, self.NrCh)
+        temp = np.loadtxt(self.FileName + '.dat', usecols=ChVec)
+        return temp.reshape((self.NrSc, len(ChVec)))
+################################################################################
+# Read results in FLEX format
+    def ReadFLEX(self, ChVec=None):
+        ChVec = [] if ChVec is None else ChVec
+        if not ChVec:
+            ChVec = range(1, self.NrCh)
+        fid = open(self.FileName, 'rb')
+        fid.seek(2 * 4 * self.NrCh + 48 * 2)
+        temp = np.fromfile(fid, 'int16')
+        if self.Version==3:
+            temp = temp.reshape(self.NrCh, self.NrSc).transpose()
+        else:
+            temp = temp.reshape(self.NrSc, self.NrCh)
+        fid.close()
+        return np.dot(temp[:, ChVec], np.diag(self.ScaleFactor[ChVec]))
+################################################################################
+# Read results in GTSD format
+    def ReadGtsdf(self):
+        raise NotImplementedError
+        #self.t, data, info = gtsdf.load(self.FileName + '.hdf5')
+        #self.Time = self.t
+        #self.ChInfo = [['Time'] + info['attribute_names'],
+        #               ['s'] + info['attribute_units'],
+        #               ['Time'] + info['attribute_descriptions']]
+        #self.NrCh = data.shape[1] + 1
+        #self.NrSc = data.shape[0]
+        #self.Freq = self.NrSc / self.Time
+        #self.FileFormat = 'GTSDF'
+        #self.gtsdf_description = info['description']
+        #data = np.hstack([self.Time[:,np.newaxis], data])
+        #return data
+################################################################################
+# One stop call for reading all data formats
+    def ReadAll(self, ChVec=None):
+        ChVec = [] if ChVec is None else ChVec
+        if not ChVec and not self.FileFormat == 'GTSDF':
+            ChVec = range(0, self.NrCh)
+        if self.FileFormat == 'HAWC2_BINARY':
+            return self.ReadBinary(ChVec)
+        elif self.FileFormat == 'HAWC2_ASCII' or self.FileFormat == 'BHAWC_ASCII':
+            return self.ReadAscii(ChVec)
+        elif self.FileFormat == 'GTSDF':
+            return self.ReadGtsdf()
+        elif self.FileFormat == 'FLEX':
+            return self.ReadFLEX(ChVec)
+        else:
+            raise Exception('Unknown file format {} for hawc2 out file'.format(self.FileFormat))
 
+################################################################################
+# Main read data call, read, save and sort data
+    def __call__(self, ChVec=None):
+        ChVec = [] if ChVec is None else ChVec
+        if not ChVec:
+            ChVec = range(0, self.NrCh)
+        elif max(ChVec) >= self.NrCh:
+            print("to high channel number")
+            return
+        # if ReadOnly, read data but no storeing in memory
+        if self.ReadOnly:
+            return self.ReadAll(ChVec)
+        # if not ReadOnly, sort in known and new channels, read new channels
+        # and return all requested channels
+        else:
+            # sort into known channels and channels to be read
+            I1 = []
+            I2 = []  # I1=Channel mapping, I2=Channels to be read
+            for i in ChVec:
+                try:
+                    I1.append(self.Iknown.index(i))
+                except:
+                    self.Iknown.append(i)
+                    I2.append(i)
+                    I1.append(len(I1))
+            # read new channels
+            if I2:
+                temp = self.ReadAll(I2)
+                # add new channels to Data
+                if self.Data.any():
+                    self.Data = np.append(self.Data, temp, axis=1)
+                # if first call, so Daata is empty
+                else:
+                    self.Data = temp
+            return self.Data[:, tuple(I1)]
+
+
+################################################################################
+################################################################################
+################################################################################
+# write HAWC2 class, to be implemented
+################################################################################
+
+if __name__ == '__main__':
+    res_file = ReadHawc2('structure_wind')
+    results = res_file.ReadAscii()
+    channelinfo = res_file.ChInfo
```

### Comparing `welib-0.0.2/welib/system/system.py` & `welib-1.0.0/welib/system/system.py`

 * *Files 4% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 The equations can be implicit or explicit non linear differential equations 
 
 """
 import numpy as np
 from numpy.linalg import inv
 #from scipy.integrate import  solve_ivp #odeint
 
-from .linearization import * 
+from .linearization import linearize_function
 
 # --------------------------------------------------------------------------------}
 # --- Linear system
 # --------------------------------------------------------------------------------{
 class System():
     """ 
     Handles a general system made of a state equation and an optional output equation.
@@ -45,37 +45,50 @@
           'xup'    :  Fx(t,x,u,p)        Y(t,x,u,p)        (explicit)
           'xdotx'  :  Fx(t,xdot,x)       Y(t,x)            (implicit)
           'xdotxp' :  Fx(t,xdot,x,p)     Y(t,x,p)          (implicit)
           'xdotxu' :  Fx(t,xdot,x,u)     Y(t,x,u)          (implicit)
           'xdotxup':  Fx(t,xdot,x,u,p)   Y(t,x,u,p)        (implicit)
 
         """
+        # TODO Need to handle different interface for Fx and Y!
+
+
+        interface=interface.replace(',','').replace('q','x')
+
         self.Fx        = Fx
         self.Y         = Y
         self.interface = interface
         self.param     = param
 
+
         self.implicit  = interface.find('xdot')==0
-        self.has_param = interface.find('p')>0
+        self.has_param = interface.find('p')>0 
         self.has_input = interface.find('u')>0
-        self.has_output = Y is not None
-        if self.has_param and param is None:
-            raise Exception('Parameters needs to be provided since necessary for the function interface')
+        # Being relaxed about parameters being provided
+        #if self.has_param and param is None:
+        #    raise Exception('Parameters needs to be provided since necessary for the function interface')
 
+    @property
+    def has_output(self):
+        return self.Y is not None
 
-    def linearize(self, op, dx, dxp=None, du=None, use_implicit=False):
+
+    def linearize(self, op, dx, dxd=None, du=None, use_implicit=False):
         """ 
         Linearize the system
 
         if implicit:
             op = (t_op, xdot_op, x_op, u_op) (with u_op optional)
         if explicit:
             op = (t_op, x_op, u_op)          (with u_op optional)
         
         """
+        if self.has_param and self.param is None:
+            raise Exception('Parameters needs to be provided since necessary for the function interface')
+
         # Checks
         if not isinstance(op,tuple):
             raise Exception('Operating point needs to be specified as a tuple')
 
         if len(op)!=self.nArgs:
             raise Exception('Number of values of operating point ({}) does not match number of main argument of function ({}), with interface {} '.format(len(op),self.nArgs,self.interface))
         if self.has_input and du is None:
@@ -92,20 +105,20 @@
                 op_imp = (op[0], xdot0)+tuple(op[1:]) # (t, xdot0, x0, u0)
             else:
                 op_imp=op
 
             if len(op_imp)!=self.nArgsImplicit:
                 raise Exception('Number of values of implicit operating point ({}) does not match number of main argument of implicit function ({}), with interface {} '.format(len(op_imp),self.nArgsImplicit,self.interface))
 
-            if dxp is None:
+            if dxd is None:
                 raise Exception('delta_xdot needs to be specicified for linearization of implicit equations')
 
             F=self.implicit_function
 
-            deltas = np.array([None, dxp, dx, du], dtype=object)     # (dt, dxp, dx, du)
+            deltas = np.array([None, dxd, dx, du], dtype=object)     # (dt, dxd, dx, du)
             Iargs  = list(range(1,self.nArgsImplicit)) # [1,2] or [1,2,3]
             deltas = deltas[Iargs]
 
             # --- Compute necessary jacobians
             jacs= linearize_function(F, op_imp, Iargs, deltas, self.param)
 
             E  =   jacs[0]
@@ -121,22 +134,28 @@
         else:
             # --- Linearization of explicit equation
             deltas = np.array([None, dx, du], dtype=object)  # (dt, dx, du)
             Iargs  = list(range(1,self.nArgs)) # [1] or [1,2]
             deltas = deltas[Iargs]
 
             # --- Compute necessary jacobians
-            A, B = linearize_function(self.Fx, op, Iargs, deltas, self.param)
+            if self.has_param:
+                A, B = linearize_function(self.Fx, op, Iargs, deltas, self.param)
+            else:
+                A, B = linearize_function(self.Fx, op, Iargs, deltas)
 
         # --- Linearization of output equation
         if self.has_output:
             deltas = np.array([None, dx, du], dtype=object)  # (dt, dx, du)
             Iargs  = list(range(1,self.nArgs)) # [1] or [1,2]
             deltas = deltas[Iargs]
-            C, D = linearize_function(self.Y, op, Iargs, deltas, self.param)
+            if self.has_param:
+                C, D = linearize_function(self.Y, op, Iargs, deltas, self.param)
+            else:
+                C, D = linearize_function(self.Y, op, Iargs, deltas)
 
             return A, B, C, D
         else:
             return A, B
 
     @property
     def implicit_function(self):
@@ -188,15 +207,14 @@
         s+=' - interface: {}\n'.format(self.interface)
         s+=' - implicit:  {}\n'.format(self.implicit)
         s+=' - has_param: {}\n'.format(self.has_param)
         s+=' - has_input: {}\n'.format(self.has_input)
         return s
 
 if __name__ == '__main__':
-    from pybra.clean_exceptions import *
 
     def model(t, x, u, p):
         return p['A'].dot(x) + p['B'].dot(u)
 
     def output(t, x, u, p):
         return p['C'].dot(x) + p['D'].dot(u)
 
@@ -236,15 +254,15 @@
 
 
     delta_x  = np.zeros(x0.shape)+0.001
     delta_xd = np.zeros(x0.shape)+0.001
     delta_u  = np.zeros(u0.shape)+0.001
 
     op=(0,x0,u0)
-    A,B,C,D=sys.linearize(op, dx=delta_x, dxp=delta_xd, du=delta_u, use_implicit=True)
+    A,B,C,D=sys.linearize(op, dx=delta_x, dxd=delta_xd, du=delta_u, use_implicit=True)
     print('A')
     print(A)
     print('B')
     print(B)
     print('C')
     print(C)
     print('D')
```

### Comparing `welib-0.0.2/welib/system/tests/test_eva.py` & `welib-1.0.0/welib/system/tests/test_eva.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/tests/test_linearization.py` & `welib-1.0.0/welib/system/tests/test_linearization.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/tests/test_run_Examples.py` & `welib-1.0.0/welib/wt_theory/tests/test_run_Examples.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,20 +14,24 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
+        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z_-]*.py'))
         import matplotlib.pyplot as plt
-        print('\n--------------------------------------------------------------')
         for f in files:
+            print('\n--------------------------------------------------------------')
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+
+        try:
+            plt.close('all')
+        except:
+            pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/system/tests/test_singledof.py` & `welib-1.0.0/welib/system/tests/test_singledof.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/system/tests/test_system.py` & `welib-1.0.0/welib/system/tests/test_system.py`

 * *Files 0% similar despite different names*

```diff
@@ -20,16 +20,14 @@
         p['D'] = np.random.randint(5, size=(nx, nu)).astype(float)
         
         x0 = np.random.randint(5, size=(nx, 1)).astype(float)
         u0 = np.random.randint(5, size=(nu, 1)).astype(float)
 
         return p, x0, u0
 
-
-
     def test_system_implicit(self):
         # --- test that implicit function returns 0 at a solved operating point from explicit model
         # Create some simple state space 
         nx = 5
         p, x0, u0 = self.get_LTI(nx)
         # Initial system
         sys = System(Fx=state_function, Y=output_function, interface='xup', param = p )
@@ -53,15 +51,15 @@
 
         delta_x  = np.zeros(x0.shape)+0.001
         delta_xd = np.zeros(x0.shape)+0.001
         delta_u  = np.zeros(u0.shape)+0.001
 
         # --- Test implicit linearization feature of an explicit system
         op=(0,x0,u0)
-        A,B,C,D=sys.linearize(op, dx=delta_x, dxp=delta_xd, du=delta_u, use_implicit=True)
+        A,B,C,D=sys.linearize(op, dx=delta_x, dxd=delta_xd, du=delta_u, use_implicit=True)
         np.testing.assert_almost_equal(A, p['A'])
         np.testing.assert_almost_equal(B, p['B'])
         np.testing.assert_almost_equal(C, p['C'])
         np.testing.assert_almost_equal(D, p['D'])
 
         # --- Test explicit linearization feature of an explicit system
         A,B,C,D=sys.linearize(op, dx=delta_x, du=delta_u)
```

### Comparing `welib-0.0.2/welib/time/TimeManager.m` & `welib-1.0.0/welib/time/TimeManager.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/README.md` & `welib-1.0.0/welib/tools/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/SpectralAnalysis/fLogSmooth.m` & `welib-1.0.0/welib/tools/SpectralAnalysis/fLogSmooth.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/SpectralAnalysis/fSpectrum.m` & `welib-1.0.0/welib/tools/SpectralAnalysis/fSpectrum.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/SpectralAnalysis/fSpectrumAngular.m` & `welib-1.0.0/welib/tools/SpectralAnalysis/fSpectrumAngular.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/bithashlib.py` & `welib-1.0.0/welib/tools/bithashlib.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/clean_exceptions.py` & `welib-1.0.0/welib/tools/clean_exceptions.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/colors.py` & `welib-1.0.0/welib/tools/colors.py`

 * *Files 0% similar despite different names*

```diff
@@ -152,15 +152,15 @@
 MathematicaYellow     = np.array([152,140,61  ])/255.;
 MathematicaLightBlue  = np.array([159,159,204 ])/255.;
 MathematicaLightRed   = np.array([204,158,184 ])/255.;
 MathematicaLightGreen = np.array([158,204,170 ])/255.;
 # 
 ManuDarkBlue    = np.array([0   ,0  ,0.7 ])     ;
 ManuDarkRed     = np.array([138 ,42 ,93  ])/255.;
-ManuDarkOrange  = np.array([245 ,131,1   ])/255.;
+# ManuDarkOrange  = np.array([245 ,131,1   ])/255.;
 ManuDarkOrange  = np.array([198 ,106,1   ])/255.;
 ManuLightOrange = np.array([255.,212,96  ])/255.;
 # 
 Red    = np.array([1  ,0  ,0]);
 Blue   = np.array([0  ,0  ,1]);
 Green  = np.array([0  ,0.6,0]);
 Yellow = np.array([0.8,0.8,0]);
```

### Comparing `welib-0.0.2/welib/tools/compare.py` & `welib-1.0.0/welib/tools/compare.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/curve_fitting.py` & `welib-1.0.0/welib/tools/curve_fitting.py`

 * *Files 2% similar despite different names*

```diff
@@ -188,14 +188,76 @@
     y_fit = pfit[0] * (x / z_ref) ** pfit[1]
     coeffs_dict=OrderedDict([('u_ref',pfit[0]),('alpha',pfit[1])])
     formula = '{u_ref} * (z / {z_ref}) ** {alpha}'
     fitted_fun = lambda xx: pfit[0] * (xx / z_ref) ** pfit[1]
     return y_fit, pfit, {'coeffs':coeffs_dict,'formula':formula,'fitted_function':fitted_fun}
 
 
+def polyfit2d(x, y, z, kx=3, ky=3, order=None):
+    '''
+    Two dimensional polynomial fitting by least squares.
+    Fits the functional form f(x,y) = z.
+
+    Notes
+    -----
+    Resultant fit can be plotted with:
+    np.polynomial.polynomial.polygrid2d(x, y, soln.reshape((kx+1, ky+1)))
+
+    Parameters
+    ----------
+    x, y: array-like, 1d
+        x and y coordinates.
+    z: np.ndarray, 2d
+        Surface to fit.
+    kx, ky: int, default is 3
+        Polynomial order in x and y, respectively.
+    order: int or None, default is None
+        If None, all coefficients up to maxiumum kx, ky, ie. up to and including x^kx*y^ky, are considered.
+        If int, coefficients up to a maximum of kx+ky <= order are considered.
+
+    Returns
+    -------
+    Return paramters from np.linalg.lstsq.
+
+    soln: np.ndarray
+        Array of polynomial coefficients.
+    residuals: np.ndarray
+    rank: int
+    s: np.ndarray
+
+    # The resultant fit can be visualised with:
+    # 
+    # fitted_surf = np.polynomial.polynomial.polyval2d(x, y, soln.reshape((kx+1,ky+1)))
+    # plt.matshow(fitted_surf
+
+
+    '''
+
+    # grid coords
+    x, y = np.meshgrid(x, y)
+    # coefficient array, up to x^kx, y^ky
+    coeffs = np.ones((kx+1, ky+1))
+
+    # solve array
+    a = np.zeros((coeffs.size, x.size))
+
+    # for each coefficient produce array x^i, y^j
+    for index, (j, i) in enumerate(np.ndindex(coeffs.shape)): # TODO should it be i,j
+        # do not include powers greater than order
+        if order is not None and i + j > order:
+            arr = np.zeros_like(x)
+        else:
+            arr = coeffs[i, j] * x**i * y**j
+        a[index] = arr.ravel()
+
+    # do leastsq fitting and return leastsq result
+    return np.linalg.lstsq(a.T, np.ravel(z), rcond=None)
+
+
+
 # --------------------------------------------------------------------------------}
 # --- Predifined functions NOTE: they need to be registered in variable `MODELS`
 # --------------------------------------------------------------------------------{
 def gaussian(x, p):
     """ p = (mu,sigma) """
     return 1/(p[1]*np.sqrt(2*np.pi)) * np.exp(-1/2*((x-p[0])/p[1])**2)
 
@@ -1015,15 +1077,15 @@
         y_fit= np.dot(pfit, X_poly)
         self.store_fit_info(y_fit, pfit)
 
         # --- Return a fitted function
         def fitted_function(xx):
             y=np.zeros(xx.shape)
             for i,(e,c) in enumerate(zip(self.exponents,pfit)):
-                y += c*x**e
+                y += c*xx**e
             return y
         self.model['fitted_function']=fitted_function
 
 
 class SinusoidFitter(ModelFitter):
     def __init__(self, physical=False, x=None, y=None, p0=None, bounds=None):
         ModelFitter.__init__(self, x=None, y=None, p0=p0, bounds=bounds)
```

### Comparing `welib-0.0.2/welib/tools/curves.py` & `welib-1.0.0/welib/tools/curves.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/damping.py` & `welib-1.0.0/welib/tools/damping.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-from __future__ import division, print_function
 import numpy as np
 
 __all__  = ['logDecFromDecay']
 __all__ += ['TestDamping']
 
 def indexes(y, thres=0.3, min_dist=1, thres_abs=False):
     """Peak detection routine.
```

### Comparing `welib-0.0.2/welib/tools/examples/ExampleCoherence.py` & `welib-1.0.0/welib/tools/examples/ExampleCoherence.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/examples/ExampleCorrelation.py` & `welib-1.0.0/welib/tools/examples/ExampleCorrelation.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/examples/Example_FFT.py` & `welib-1.0.0/welib/tools/examples/Example_FFT.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/examples/VortexCylinderPressure.py` & `welib-1.0.0/welib/tools/examples/VortexCylinderPressure.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/external/_lic_demo.py` & `welib-1.0.0/welib/tools/external/_lic_demo.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/external/lic_internal.c` & `welib-1.0.0/welib/tools/external/lic_internal.c`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/external/lic_internal.pyx` & `welib-1.0.0/welib/tools/external/lic_internal.pyx`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/fatigue.py` & `welib-1.0.0/welib/tools/fatigue.py`

 * *Files 17% similar despite different names*

```diff
@@ -20,27 +20,78 @@
 The methods uses the rainflow counting routines (See documentation in top of methods):
 - 'rainflow_windap': (Described in "Recommended Practices for Wind Turbine Testing - 3. Fatigue Loads",
                       2. edition 1990, Appendix A)
 or
 - 'rainflow_astm' (based on the c-implementation by Adam Nieslony found at the MATLAB Central File Exchange
                    http://www.mathworks.com/matlabcentral/fileexchange/3026)
 '''
-from __future__ import division
-from __future__ import print_function
-from __future__ import unicode_literals
-from __future__ import absolute_import
-from future import standard_library
 import warnings
-standard_library.install_aliases()
 import numpy as np
 
 
 __all__  = ['rainflow_astm', 'rainflow_windap','eq_load','eq_load_and_cycles','cycle_matrix','cycle_matrix2']
 
 
+def equivalent_load(time, signal, m=3, Teq=1, nBins=100, method='rainflow_windap'):
+    """Equivalent load calculation
+
+    Calculate the equivalent loads for a list of Wohler exponent
+
+    Parameters
+    ----------
+    time : array-like, the time values corresponding to the signal (s)
+    signals : array-like, the load signal
+    m :    Wohler exponent (default is 3)
+    Teq : The equivalent period (Default 1Hz)
+    nBins : Number of bins in rainflow count histogram
+    method: 'rainflow_windap, rainflow_astm, fatpack
+
+    Returns
+    -------
+    Leq : the equivalent load for given m and Tea
+    """
+    time   = np.asarray(time)
+    signal = np.asarray(signal)
+
+    # Remove nan, might not be the cleanest
+    b = ~np.isnan(signal)
+    signal = signal[b]
+    time   = time[b]
+
+    T = time[-1]-time[0] # time length of signal (s)
+
+    neq = T/Teq # number of equivalent periods
+
+    rainflow_func_dict = {'rainflow_windap':rainflow_windap, 'rainflow_astm':rainflow_astm}
+    if method in rainflow_func_dict.keys():
+        # Call wetb function for one m
+        Leq = eq_load(signal, m=[m], neq=neq, no_bins=nBins, rainflow_func=rainflow_func_dict[method])[0][0]
+
+    elif method=='fatpack':
+        import fatpack
+        # find rainflow ranges
+        try:
+            ranges = fatpack.find_rainflow_ranges(signal)
+        except IndexError:
+            # Currently fails for constant signal
+            return np.nan
+        # find range count and bin
+        Nrf, Srf = fatpack.find_range_count(ranges, nBins)
+        # get DEL 
+        DELs = Srf**m * Nrf / neq
+        Leq = DELs.sum() ** (1/m)
+
+    else:
+        raise NotImplementedError(method)
+
+    return Leq
+
+ 
+
+
 def check_signal(signal):
     # check input data validity
     if not type(signal).__name__ == 'ndarray':
         raise TypeError('signal must be ndarray, not: ' + type(signal).__name__)
 
     elif len(signal.shape) not in (1, 2):
         raise TypeError('signal must be 1D or 2D, not: ' + str(len(signal.shape)))
```

### Comparing `welib-0.0.2/welib/tools/fields.py` & `welib-1.0.0/welib/tools/fields.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/figure.py` & `welib-1.0.0/welib/tools/figure.py`

 * *Files 4% similar despite different names*

```diff
@@ -160,15 +160,15 @@
             print('  \\hfill\\includegraphics[width=0.49\\textwidth]{%s}\\hfill'%(figName));
             print('  \\caption{%s}\\label{fig:%s}%%'%(titleLatexSafe,figNameLast));
             print('\\end{figure}');
             print('% --------------------------------------------------------------------------------')
             print(' ')
 
     @staticmethod
-    def export(fig,figformat,i=1,n=1,width=None,height=None,figNameLast='',script_name='',script_run_dir='',script_run_date='', print_latex=True):
+    def export(fig,figformat,i=1,n=1,width=None,height=None,figNameLast='',script_name='',script_run_dir='',script_run_date='', print_latex=True, verbose=False):
         if i is None:
             i=1
         # params (for now, using global params)
         params=_global_params
         title,axTitle=findtitle(fig)
         titleLatexSafe = re.sub(r"[_%^]", "", title)
         #print('>>>>> TITLE',title)
@@ -197,19 +197,21 @@
             #xlims=get(gca,'XLim');
             #ylims=get(gca,'YLim');
             #pause(1)
             #set(gca,'XLim',xlims);
             #set(gca,'YLim',ylims);
 
         # --- Exporting in figure pathc
-        print('Export path: ',params.path)
+        if verbose:
+            print('Export path: ',params.path)
         for ifp in range(len(params.path)):
             filename='%s%s.%s'%(params.path[ifp],figName,figformat);
             fig.savefig(filename)
-            print('Figure file: ',filename)
+            if verbose:
+                print('Figure file: ',filename)
             # restoring the title
             if axTitle is not None:
                 axTitle.set_title(title)
             else:
                 fig.suptitle(title)
 
         # --- Generating latex code 
@@ -224,15 +226,15 @@
                     if i==n:
                         FigureExporter.print1figure(figName,titleLatexSafe,script_name,script_run_dir,script_run_date)
 
         figNameLast=figName;
         return figNameLast, filename, title
 
 # --- Export call wrapper 
-def export(figformat,fig=None,i=None,width=None,height=None,print_latex=True):
+def export(figformat,fig=None,i=None,width=None,height=None,print_latex=True, verbose=True):
     import pylab
     import inspect
     import os
     import os.path
     import datetime
     frame=inspect.stack()[2]
     script_name=os.path.basename(frame[0].f_code.co_filename)
@@ -244,37 +246,38 @@
     fileNames = []
     titles = []
     if fig is None:
         # We'll loop over all figures
         figures=[manager.canvas.figure for manager in pylab.matplotlib._pylab_helpers.Gcf.get_all_fig_managers()]
         figNameLast=''
         for i, figure in enumerate(figures):
-            figNameLast, filename, title=__exporter.export(fig=figure,figformat=figformat,i=(i+1),n=len(figures),width=width,height=height,figNameLast=figNameLast,script_name=script_name,script_run_dir=script_run_dir,script_run_date=script_run_date,print_latex=print_latex)
+            figNameLast, filename, title=__exporter.export(fig=figure,figformat=figformat,i=(i+1),n=len(figures),width=width,height=height,figNameLast=figNameLast,script_name=script_name,script_run_dir=script_run_dir,script_run_date=script_run_date,print_latex=print_latex, verbose=verbose)
             figNames.append(figNameLast)
             fileNames.append(filename)
             titles.append(title)
 
     else:
-        figNameLast, filename, title = __exporter.export(fig=fig,figformat=figformat,i=i,width=width,height=height,script_name=script_name,script_run_dir=script_run_dir,script_run_date=script_run_date, print_latex=print_latex)
+        figNameLast, filename, title = __exporter.export(fig=fig,figformat=figformat,i=i,width=width,height=height,script_name=script_name,script_run_dir=script_run_dir,script_run_date=script_run_date, print_latex=print_latex, verbose=verbose)
         figNames.append(figNameLast)
         fileNames.append(filename)
         titles.append(title)
     
-    for ifp in range(len(_global_params.path)):
-        print('Figure saved in: %s'%_global_params.path[ifp]);
-    print(' ');
+    if verbose:
+        for ifp in range(len(_global_params.path)):
+            print('Figure saved in: %s'%_global_params.path[ifp]);
+        print(' ');
 
     return figNames, fileNames, titles
 
-def export2pdf(fig=None,i=None,width=None,height=None,print_latex=True):
-    return export('pdf',fig=fig,i=i,width=width,height=height,print_latex=print_latex)
-def export2png(fig=None,i=None,width=None,height=None,print_latex=True):
-    return export('png',fig=fig,i=i,width=width,height=height,print_latex=print_latex)
-def export2eps(fig=None,i=None,width=None,height=None,print_latex=True):
-    return export('png',fig=fig,i=i,width=width,height=height,print_latex=print_latex)
+def export2pdf(fig=None,i=None,width=None,height=None,print_latex=True, verbose=True):
+    return export('pdf',fig=fig,i=i,width=width,height=height,print_latex=print_latex, verbose=verbose)
+def export2png(fig=None,i=None,width=None,height=None,print_latex=True, verbose=True):
+    return export('png',fig=fig,i=i,width=width,height=height,print_latex=print_latex, verbose=verbose)
+def export2eps(fig=None,i=None,width=None,height=None,print_latex=True, verbose=True):
+    return export('png',fig=fig,i=i,width=width,height=height,print_latex=print_latex, verbose=verbose)
 
 
 # --------------------------------------------------------------------------------}
 # --- Tools to move figures, set them on a grid on different screens
 # --------------------------------------------------------------------------------{
 """ 
 Set of tools to move figures
```

### Comparing `welib-0.0.2/welib/tools/galib.py` & `welib-1.0.0/welib/tools/galib.py`

 * *Files 0% similar despite different names*

```diff
@@ -597,18 +597,14 @@
             x=individual[i] + dx
             # if outside the limits, we bounce modulo the range
             if x>xu:
                 x=xu-math.fmod(dx,xu-xl)
             elif x<xl:
                 x=xl+math.fmod(abs(dx),xu-xl)
             #individual[i] = min(max(x,low),up)
-            #if x>up:
-            #   pdb.set_trace(); 
-            #if x<low:
-            #   pdb.set_trace(); 
             individual[i] = x
 
     return individual,
 
 def mutUniformBounded(individual, low, up, indpb):
     """Mutate an individual by replacing attributes, with probability *indpb*,
     by a integer uniformly drawn between *low* and *up* inclusively.
@@ -824,16 +820,15 @@
     print(len(Sel),k)
     #jjprint(Sel)
     print('Unique ones')
     print(len(SelU),k)
     #print(SelU)
     if len(SelU)<k:
         print('>>>>>> NEED FOR MORE')
-        #import pdb
-        #pdb.set_trace()
+        raise Exception()
 
     return  Sel
 
 
 
 def _randomizedPartition(array, begin, end):
     i = random.randint(begin, end)
```

### Comparing `welib-0.0.2/welib/tools/latex.py` & `welib-1.0.0/welib/tools/latex.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/lic.py` & `welib-1.0.0/welib/tools/lic.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/pycmd.py` & `welib-1.0.0/welib/tools/pycmd.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/repo.py` & `welib-1.0.0/welib/tools/repo.py`

 * *Files 15% similar despite different names*

```diff
@@ -4,26 +4,27 @@
 """
 
 import numpy as np
 import os
 import re
 from welib.tools.figure import *
 import matplotlib.pyplot as plt
+from termcolor import colored, cprint
 
 FIG_MD=[]
 TIT_MD=[]
 
 def export_figs_callback(filename):
     from welib.tools.repo import FIG_MD, TIT_MD
     script_dir = os.path.dirname(filename)
     setFigurePath('_figs/')
-    figNames, filenames, titles = export2png(print_latex=False)
+    figNames, filenames, titles = export2png(print_latex=False, verbose=False)
     print('filename:',filename)
     print('figNames:',figNames)
-    print('titles:',titles)
+    print('titles:  ',titles)
     for fign, fn, t in zip(figNames,filenames,titles):
         TIT_MD+=['[{}](/{})'.format(t, filename.replace('\\','/'))]
         FIG_MD+=['![{}](/../figs/{})'.format(t, fn)]
 
 def export_figs_rec(maindir):
     """ 
     Recursively loop in directory structure, look for example files
@@ -32,26 +33,38 @@
     try:
         os.mkdir('_figs')
     except:
         pass
     print(FIG_MD)
     reobj = re.compile('[a-zA-Z0-9][a-zA-Z0-9_]*.py')
     for root,dirnames,filenames in os.walk(maindir):
+        sp = re.split(r'/|\\', root)
+        if any([s.startswith('_') for s in sp]):
+            #print('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> SKIPPING',root)
+            continue
+
         if os.path.basename(root)=='examples':
             for f in filenames:
                 if reobj.match(f):
                     print('--------------------------------------------------------------')
                     fullpath=os.path.join(root,f)
                     print('Running example script: {}'.format(fullpath))
                     plt.close('all')
+                    n1=len(TIT_MD)
                     execfile(fullpath, {'__name__': '__export__', 'print': lambda *_:None})
+                    n2=len(TIT_MD)
+                    if n2>n1:
+                        cprint('[ OK ] {} figure(s)'.format(n2-n1), 'green')
+                    else:
+                        cprint('[INFO] No figure: {}'.format(fullpath), 'red')
     print('--------------------------------------------------------------')
     nCols= 5
     nRow= np.int(np.ceil(len(TIT_MD)/nCols))
 
+    # --- Generate markdown for README.md
     k=0
     kk=0
     print(''.join(['| ']*nCols) +  ' |')
     print(''.join(['| :-------------------------: ']*nCols) +' |')
     for i in np.arange(nRow):
         kk=k
         print('| ',end='')
```

### Comparing `welib-0.0.2/welib/tools/spectral.py` & `welib-1.0.0/welib/tools/spectral.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,16 +13,14 @@
 # 
 #     Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
 #     Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
 #     Neither the name of Enthought nor the names of the SciPy Developers may be used to endorse or promote products derived from this software without specific prior written permission.
 # 
 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-from __future__ import division, print_function, absolute_import
-
 import numpy as np
 import pandas as pd
 from six import string_types
 
 __all__  = ['fft_wrap','welch', 'psd', 'fft_amplitude']
 __all__ += ['pwelch', 'csd', 'coherence']
 __all__ += ['fnextpow2']
@@ -47,23 +45,29 @@
     """
 
     # Formatting inputs
     output_type      = output_type.lower()
     averaging        = averaging.lower()
     averaging_window = averaging_window.lower()
     y = np.asarray(y)
+    n0 = len(y) 
+    nt = len(t) 
+    if len(t)!=len(y):
+        raise Exception('t and y should have the same length')
     y = y[~np.isnan(y)]
     n = len(y) 
 
     if dt is None:
         dtDelta0 = t[1]-t[0]
         # Hack to use a constant dt
-        dt = (np.max(t)-np.min(t))/(n-1)
-        if dtDelta0 !=dt:
-            print('[WARN] dt from tmax-tmin different from dt from t2-t1' )
+        dt = (np.max(t)-np.min(t))/(n0-1)
+        relDiff = abs(dtDelta0-dt)/dt*100
+        #if dtDelta0 !=dt:
+        if relDiff>0.01:
+            print('[WARN] dt from tmax-tmin different from dt from t2-t1 {} {}'.format(dt, dtDelta0) )
     Fs = 1/dt
     if averaging =='none':
         frq, PSD, Info = psd(y, fs=Fs, detrend=detrend, return_onesided=True)
     elif averaging =='binning':
         frq, PSD, Info = psd_binned(y, fs=Fs, detrend=detrend, return_onesided=True, nPerDecade=nPerDecade)
     elif averaging=='welch':
         # --- Welch - PSD
@@ -662,21 +666,23 @@
             nperseg=fnextpow2(math.sqrt(x.shape[-1]/(1-overlap_frac)));
 
     # MANU accepting true as detrend
     if detrend==True:
         detrend='constant'
 
     freqs, Pxx, Info = csd(x, x, fs, window, nperseg, noverlap, nfft, detrend,
-                     return_onesided, scaling, axis)
+                     return_onesided, scaling, axis, returnInfo=True)
 
     return freqs, Pxx.real, Info
 
 
 def csd(x, y, fs=1.0, window='hann', nperseg=None, noverlap=None, nfft=None,
-        detrend='constant', return_onesided=True, scaling='density', axis=-1):
+        detrend='constant', return_onesided=True, scaling='density', axis=-1,
+        returnInfo=False
+        ):
     r"""
     Estimate the cross power spectral density, Pxy, using Welch's
     method.
     """
 
     freqs, _, Pxy, Info = _spectral_helper(x, y, fs, window, nperseg, noverlap, nfft,
                                      detrend, return_onesided, scaling, axis,
@@ -685,15 +691,18 @@
     # Average over windows.
     if len(Pxy.shape) >= 2 and Pxy.size > 0:
         if Pxy.shape[-1] > 1:
             Pxy = Pxy.mean(axis=-1)
         else:
             Pxy = np.reshape(Pxy, Pxy.shape[:-1])
 
-    return freqs, Pxy, Info
+    if returnInfo:
+        return freqs, Pxy, Info
+    else:
+        return freqs, Pxy
 
 
 
 def coherence(x, y, fs=1.0, window='hann', nperseg=None, noverlap=None,
               nfft=None, detrend='constant', axis=-1):
     r"""
     Estimate the magnitude squared coherence estimate, Cxy, of
@@ -702,15 +711,15 @@
     ``Cxy = abs(Pxy)**2/(Pxx*Pyy)``, where `Pxx` and `Pyy` are power
     spectral density estimates of X and Y, and `Pxy` is the cross
     spectral density estimate of X and Y.
     """
 
     freqs, Pxx, Infoxx = welch(x, fs, window, nperseg, noverlap, nfft, detrend, axis=axis)
     _, Pyy, Infoyy     = welch(y, fs, window, nperseg, noverlap, nfft, detrend, axis=axis)
-    _, Pxy, Infoxy     = csd(x, y, fs, window, nperseg, noverlap, nfft, detrend, axis=axis)
+    _, Pxy, Infoxy     = csd(x, y, fs, window, nperseg, noverlap, nfft, detrend, axis=axis, returnInfo=True)
 
     Cxy = np.abs(Pxy)**2 / Pxx / Pyy
 
     return freqs, Cxy, Infoxx
 
 
 def _spectral_helper(x, y, fs=1.0, window='hann', nperseg=None, noverlap=None,
```

### Comparing `welib-0.0.2/welib/tools/stats.py` & `welib-1.0.0/welib/tools/stats.py`

 * *Files 22% similar despite different names*

```diff
@@ -7,15 +7,72 @@
 """
 import numpy as np
 import pandas as pd
 
 # --------------------------------------------------------------------------------}
 # --- Stats measures 
 # --------------------------------------------------------------------------------{
-def rsquare(y,f, c = True): 
+def comparison_stats(t1, y1, t2, y2, stats='sigRatio,eps,R2', method='mean', absVal=True):
+    """
+    y1: ref
+    y2: other
+
+    """
+    from welib.tools.fatigue import equivalent_load
+
+    sp=stats.split(',')
+    stats = {}
+    sStats=[]
+
+    t1=np.asarray(t1).astype(float)
+    y1=np.asarray(y1).astype(float)
+    t2=np.asarray(t2).astype(float)
+    y2=np.asarray(y2).astype(float)
+
+    # Loop on statistics requested
+    for s in sp:
+        s= s.strip().lower()
+        if s=='sigratio':
+            # Ratio of standard deviation:
+            sig_ref = float(np.nanstd(y1))
+            sig_est = float(np.nanstd(y2))
+            try:
+                r_sig = sig_est/sig_ref
+            except:
+                r_sig = np.nan
+            stats = {'sigRatio':r_sig}
+            sStats+= [r'$\sigma_\mathrm{est}/\sigma_\mathrm{ref} = $'+r'{:.3f}'.format(r_sig)]
+
+        elif s=='eps':
+            # Mean relative error
+            eps     = float(mean_rel_err(t1, y1, t2, y2, method=method, absVal=absVal))
+            stats['eps'] = eps
+            sStats+=['$\epsilon=$'+r'{:.1f}%'.format(eps)]
+
+        elif s=='r2':
+            # Rsquare
+            R2 = float(rsquare(y2, y1)[0])
+            stats['R2'] = R2
+            sStats+=[r'$R^2=$'+r'{:.3f}'.format(R2)]
+
+        elif s=='epsleq':
+            Leq1 = equivalent_load(t1, y1, m=5, nBins=100, method='fatpack')
+            Leq2 = equivalent_load(t2, y2, m=5, nBins=100, method='fatpack')
+            epsLeq = (Leq2-Leq1)/Leq1*100
+            stats['epsLeq'] = epsLeq
+            sStats+=[r'$\epsilon L_{eq}=$'+r'{:.1f}%'.format(epsLeq)]
+
+        else:
+            raise NotImplementedError(s)
+    sStats=' - '.join(sStats)
+    return stats, sStats
+
+
+
+def rsquare(y, f, c = True): 
     """ Compute coefficient of determination of data fit model and RMSE
     [r2 rmse] = rsquare(y,f)
     [r2 rmse] = rsquare(y,f,c)
     RSQUARE computes the coefficient of determination (R-square) value from
     actual data Y and model data F. The code uses a general version of
     R-square, based on comparing the variability of the estimation errors
     with the variability of the original values. RSQUARE also outputs the
@@ -31,17 +88,19 @@
               constant term is included in the model.
       [DEFAULT] TRUE : Use traditional R-square computation
                FALSE : Uses alternate R-square computation for model
                      without constant term [R2 = 1 - NORM(Y-F)/NORM(Y)]
     # OUTPUT
       R2      : Coefficient of determination
       RMSE    : Root mean squared error """
-    # Compare inputs
+    # Sanity
     if not np.all(y.shape == f.shape) :
         raise Exception('Y and F must be the same size')
+    y = np.asarray(y).astype(float)
+    f = np.asarray(f).astype(float)
     # Check for NaN
     tmp = np.logical_not(np.logical_or(np.isnan(y),np.isnan(f))) 
     y = y[tmp]
     f = f[tmp]
     if c:
         r2 = max(0,1-np.sum((y-f)**2)/np.sum((y-np.mean(y))** 2))
     else:
@@ -49,53 +108,60 @@
         if r2 < 0:
             import warnings
             warnings.warn('Consider adding a constant term to your model')
             r2 = 0
     rmse = np.sqrt(np.mean((y - f) ** 2))
     return r2,rmse
 
-def mean_rel_err(t1=None, y1=None, t2=None, y2=None, method='mean', verbose=False, varname=''):
+def mean_rel_err(t1=None, y1=None, t2=None, y2=None, method='meanabs', verbose=False, varname='', absVal=True):
     """ 
     return mean relative error in % 
 
     Methods: 
       'mean'   : 100 * |y1-y2|/mean(y1)
       'meanabs': 100 * |y1-y2|/mean(|y1|)
       'minmax': y1 and y2 scaled between 0.5 and 1.5
                 |y1s-y2s|/|y1|
       '0-2': signals are scalled between 0 & 2
     """
+    def myabs(y):
+        if absVal:
+            return np.abs(y)
+        else:
+            return y
+
+
     if t1 is None and t2 is None:
         pass
     else:
         if len(y1)!=len(y2):
             y2=np.interp(t1,t2,y2)
     if method=='mean':
         # Method 1 relative to mean
-        ref_val = np.mean(y1)
-        meanrelerr = np.mean(np.abs(y2-y1)/ref_val)*100 
+        ref_val = np.nanmean(y1)
+        meanrelerr = np.nanmean(myabs(y2-y1)/ref_val)*100 
     elif method=='meanabs':
-        ref_val = np.mean(np.abs(y1))
-        meanrelerr = np.mean(np.abs(y2-y1)/ref_val)*100 
+        ref_val = np.nanmean(abs(y1))
+        meanrelerr = np.nanmean(myabs(y2-y1)/ref_val)*100 
     elif method=='loc':
-        meanrelerr = np.mean(np.abs(y2-y1)/abs(y1))*100 
+        meanrelerr = np.nanmean(myabs(y2-y1)/abs(y1))*100 
     elif method=='minmax':
         # Method 2 scaling signals
-        Min=min(np.min(y1), np.min(y2))
-        Max=max(np.max(y1), np.max(y2))
+        Min=min(np.nanmin(y1), np.nanmin(y2))
+        Max=max(np.nanmax(y1), np.nanmax(y2))
         y1=(y1-Min)/(Max-Min)+0.5
         y2=(y2-Min)/(Max-Min)+0.5
-        meanrelerr = np.mean(np.abs(y2-y1)/np.abs(y1))*100 
+        meanrelerr = np.nanmean(myabs(y2-y1)/np.abs(y1))*100 
     elif method=='1-2':
         # transform values from 1 to 2
-        Min=min(np.min(y1), np.min(y2))
-        Max=max(np.max(y1), np.max(y2))
+        Min=min(np.nanmin(y1), np.nanmin(y2))
+        Max=max(np.nanmax(y1), np.nanmax(y2))
         y1 = (y1-Min)/(Max-Min)+1
         y2 = (y2-Min)/(Max-Min)+1
-        meanrelerr = np.mean(np.abs(y2-y1)/np.abs(y1))*100
+        meanrelerr = np.nanmean(myabs(y2-y1)/np.abs(y1))*100
     else:
         raise Exception('Unknown method',method)
 
     if verbose:
         if len(varname)>0:
             print('Mean rel error {:15s} {:7.2f} %'.format(varname, meanrelerr))
         else:
@@ -170,15 +236,15 @@
 # --- Binning 
 # --------------------------------------------------------------------------------{
 def bin_DF(df, xbins, colBin, stats='mean'):
     """ 
     Perform bin averaging of a dataframe
     INPUTS:
       - df   : pandas dataframe
-      - xBins: end points delimiting the bins, array of ascending x values)
+      - xBins: end points delimiting the bins, array of ascending x values
       - colBin: column name (string) of the dataframe, used for binning 
     OUTPUTS:
        binned dataframe, with additional columns 'Counts' for the number 
 
     """
     if colBin not in df.columns.values:
         raise Exception('The column `{}` does not appear to be in the dataframe'.format(colBin))
@@ -194,33 +260,82 @@
     df2['Counts'] = dfCount['Counts']
     # Just in case some bins are missing (will be nan)
     df2       = df2.reindex(xmid)
     return df2
 
 def bin_signal(x, y, xbins=None, stats='mean', nBins=None):
     """ 
-    Perform bin averaging of a dataframe
+    Perform bin averaging of a signal
     INPUTS:
-      - df   : pandas dataframe
-      - xBins: end points delimiting the bins, array of ascending x values)
-      - colBin: column name (string) of the dataframe, used for binning 
+      - x: x-values 
+      - y: y-values, signal values
+      - xBins: end points delimiting the bins, array of ascending x values
     OUTPUTS:
-       binned dataframe, with additional columns 'Counts' for the number 
+      - xBinned, yBinned
 
     """
     if xbins is None:
         xmin, xmax = np.min(x), np.max(x)
         dx = (xmax-xmin)/nBins
         xbins=np.arange(xmin, xmax+dx/2, dx)
     df = pd.DataFrame(data=np.column_stack((x,y)), columns=['x','y'])
     df2 = bin_DF(df, xbins, colBin='x', stats=stats)
     return df2['x'].values, df2['y'].values
 
 
 
+def bin2d_signal(x, y, z, xbins=None, ybins=None, nXBins=None, nYBins=None):
+    """ 
+    Bin signal z based on x and y values using xbins and ybins
+
+    """
+    if xbins is None:
+        xmin, xmax = np.min(x), np.max(x)
+        dx = (xmax-xmin)/nXBins
+        xbins=np.arange(xmin, xmax+dx/2, dx)
+    if ybins is None:
+        ymin, ymax = np.min(y), np.max(y)
+        dy = (ymax-ymin)/nYBins
+        ybins=np.arange(ymin, ymax+dy/2, dy)
+
+    x = np.asarray(x).flatten()
+    y = np.asarray(y).flatten()
+    z = np.asarray(z).flatten()
+
+    Counts = np.zeros((len(xbins)-1, len(ybins)-1))
+    XMean  = np.zeros((len(xbins)-1, len(ybins)-1))*np.nan
+    YMean  = np.zeros((len(xbins)-1, len(ybins)-1))*np.nan
+    ZMean  = np.zeros((len(xbins)-1, len(ybins)-1))*np.nan
+    ZStd   = np.zeros((len(xbins)-1, len(ybins)-1))*np.nan
+
+    xmid = xbins[:-1] + np.diff(xbins)/2
+    ymid = ybins[:-1] + np.diff(ybins)/2
+    YMid, XMid = np.meshgrid(ymid, xmid)
+
+    for ixb, xb in enumerate(xbins[:-1]):
+        print(ixb)
+        bX = np.logical_and(x >= xb, x <= xbins[ixb+1]) # TODO decide on bounds
+        for iyb, yb in enumerate(ybins[:-1]):
+            bY = np.logical_and(y >= yb, y <= ybins[iyb+1]) # TODO decide on bounds
+
+            bXY = np.logical_and(bX, bY)
+            Counts[ixb, iyb] = sum(bXY)
+            if Counts[ixb,iyb]>0:
+                ZMean [ixb, iyb] = np.mean(z[bXY])
+                ZStd  [ixb, iyb] = np.std( z[bXY])
+                XMean [ixb, iyb] = np.mean(x[bXY])
+                YMean [ixb, iyb] = np.mean(y[bXY])
+
+    return XMean, YMean, ZMean, ZStd, Counts, XMid, YMid
+
+
+
+
+
+
 def azimuthal_average_DF(df, psiBin=np.arange(0,360+1,10), colPsi='Azimuth_[deg]', tStart=None, colTime='Time_[s]'):
     """ 
     Average a dataframe based on azimuthal value
     Returns a dataframe with same amount of columns as input, and azimuthal values as index
     """
     if tStart is not None:
         if colTime not in df.columns.values:
```

### Comparing `welib-0.0.2/welib/tools/tests/test_functions.py` & `welib-1.0.0/welib/tools/tests/test_functions.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/tests/test_signal.py` & `welib-1.0.0/welib/tools/tests/test_signal.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/tests/test_vectoranalyses.py` & `welib-1.0.0/welib/tools/tests/test_vectoranalyses.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/tools/tictoc.py` & `welib-1.0.0/welib/tools/tictoc.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,8 +1,7 @@
-from __future__ import print_function
 import numpy as np
 import time
 
 def pretty_time(t):
     # fPrettyTime: returns a 6-characters string corresponding to the input time in seconds.
     #   fPrettyTime(612)=='10m12s'
     # AUTHOR: E. Branlard
```

### Comparing `welib-0.0.2/welib/vortilib/elements/InviscidVortexPatch.py` & `welib-1.0.0/welib/vortilib/elements/InviscidVortexPatch.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/LambOseen.py` & `welib-1.0.0/welib/vortilib/elements/LambOseen.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/SourceEllipsoid.py` & `welib-1.0.0/welib/vortilib/elements/SourceEllipsoid.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,17 +15,14 @@
     zeta0 = 1/e
 
     x= k \cos\theta \cosh eta = k * mu * zeta
     r= k \sin\theta \sinh eta = k * sqrt(1-mu**2) * sqrt(zeta**2 -1)
 
 """
 
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import unittest
 import numpy as np
 # --- Local
 
 
 def T_semielliptic_cart(mu,zeta,theta,k=1):
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexCylinder.py` & `welib-1.0.0/welib/vortilib/elements/VortexCylinder.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,20 +1,17 @@
 """
 References:
     [1] E. Branlard, M. Gaunaa - Cylindrical vortex wake model: right cylinder - Wind Energy, 2014
     [2] E. Branlard - Wind Turbine Aerodynamics and Vorticity Based Method, Springer, 2017
     [3] E. Branlard, A. Meyer Forsting, Using a cylindrical vortex model to assess the induction zone n front of aligned and yawed rotors, in Proceedings of EWEA Offshore Conference, 2015
 """
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import unittest
 import numpy as np
-import numpy.matlib
+# import numpy.matlib
 # --- Local
 try:
     from .elliptic import ellipticPiCarlson, ellipe, ellipk
     from .VortexLine import vl_semiinf_straight_u
     from .VortexDoublet import doublet_line_polar_u
 except:
     from elliptic import ellipticPiCarlson, ellipe, ellipk
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexCylinderSkewed.py` & `welib-1.0.0/welib/vortilib/elements/VortexCylinderSkewed.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,12 @@
 """
 References:
     [1] E. Branlard, M. Gaunaa - Cylindrical vortex wake model: skewed cylinder, application to yawed or tilted rotors - Wind Energy, 2015
     [2] E. Branlard - Wind Turbine Aerodynamics and Vorticity Based Method, Springer, 2017
 """
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import unittest
 import numpy as np
 import numpy.matlib
 # --- Local
 try:
     from .elliptic import ellipticPiCarlson, ellipe, ellipk
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexDoublet.py` & `welib-1.0.0/welib/vortilib/elements/VortexDoublet.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-#--- Legacy python 2.7
-from __future__ import division
 import numpy as np
 import unittest
     
 
 # --------------------------------------------------------------------------------}
 # --- Point doublet 
 # --------------------------------------------------------------------------------{
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexHelix.py` & `welib-1.0.0/welib/vortilib/elements/VortexHelix.py`

 * *Files 0% similar despite different names*

```diff
@@ -114,15 +114,15 @@
     uz=uz.reshape(shape_in)
 
     return ur,ut,uz
 
 
 def vh_u(Xcp,Ycp,Zcp,Gamma,R,h,psih=0,nB=3,bWT=True,method='wrench',bSemi=True,polar_out=True):
     """
-    Induced velocity by nB azimuthally dstributed helices
+    Induced velocity by nB azimuthally distributed helices
 
     INPUTS:
        - psih : reference azimuthal position of the first helix
        - bSemi: Semi-infinite helices may be obtained using bSemi=True, but then only the axial and tangential 
             velocity field are correct, and only on the "lifting line"
        - Others: See vh_theory_helical_u
     """
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexLine.py` & `welib-1.0.0/welib/vortilib/elements/VortexLine.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,18 +1,15 @@
 """
 Reference:
     [1] E. Branlard - Wind Turbine Aerodynamics and Vorticity Based Method, Springer, 2017
 """
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import unittest
 import numpy as np
-import numpy.matlib
+# import numpy.matlib
 
 # --------------------------------------------------------------------------------}
 # --- Semi infinite vortex line
 # --------------------------------------------------------------------------------{
 def vl_semiinf_u(xa,ya,za,xe,ye,ze,Gamma,visc_model,t):
     """ Induced velocity at point A, from a semi infinite vortex line starting at point 0, and directed along e
     See fUi_VortexlineSemiInfinite
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexParticle.py` & `welib-1.0.0/welib/vortilib/elements/VortexParticle.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexPatch2DGaussian.py` & `welib-1.0.0/welib/vortilib/elements/VortexPatch2DGaussian.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexPoint.py` & `welib-1.0.0/welib/vortilib/elements/VortexPoint.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexRing.py` & `welib-1.0.0/welib/vortilib/elements/VortexRing.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,11 @@
 """
 References:
     [1] E. Branlard - Wind Turbine Aerodynamics and Vorticity Based Method, Springer, 2017
 """
-#--- Legacy python 2.7
-from __future__ import division
 # --- General
 import unittest
 import numpy as np
 import numpy.matlib
 from scipy.special import ellipk, ellipe
 # import warnings
 # warnings.filterwarnings('error')
```

### Comparing `welib-0.0.2/welib/vortilib/elements/VortexSegment.py` & `welib-1.0.0/welib/vortilib/elements/VortexSegment.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,11 @@
 """
 Reference:
     [1] E. Branlard - Wind Turbine Aerodynamics and Vorticity Based Method, Springer, 2017
 """
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import unittest
 import numpy as np
 
 # --------------------------------------------------------------------------------{
 def vs_u_raw(CP, Pa, Pb, Gamma, RegFunction=0, RegParam=0, nt=None, RegParamW=None):
     """ Induced velocity from a vortex segment on one control point
```

### Comparing `welib-0.0.2/welib/vortilib/elements/elliptic.py` & `welib-1.0.0/welib/vortilib/elements/elliptic.py`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,7 @@
-#--- Legacy python 2.7
-from __future__ import division
-from __future__ import print_function
 # --- General
 import numpy as np
 import unittest
 from scipy.special import ellipk, ellipe
 
 def ellipticPiCarlson(n,m):
     # Elliptic integral of the third kind using the method of Carlson
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/InviscidVortexPatch.py` & `welib-1.0.0/welib/vortilib/elements/examples/InviscidVortexPatch.py`

 * *Files 10% similar despite different names*

```diff
@@ -11,63 +11,63 @@
 from welib.tools.colors import fColrs
 from welib.tools.clean_exceptions import *
 from welib.tools.curves import streamQuiver
 from welib.vortilib.elements.InviscidVortexPatch import *
 
 def main():
 
+    fig,axes = plt.subplots(2, 2, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+    fig.subplots_adjust(left=0.09, right=0.92, top=0.88, bottom=0.09, hspace=0.47, wspace=0.29)
+
     # --- Plot vorticity distribution for different k values
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     r=np.linspace(0,2,100)
     theta=r*0
+    ax = axes[0,0]
     for i,k in enumerate([1/2,1,2,4]):
         omega = ivp_omega(r, theta, k=k, polarIn=True)
         ax.plot(r, omega, color=fColrs(i+1), label=r'$k={}$'.format(k))
     ax.set_xlabel('$r$ [m]')
     ax.set_ylabel(r'$\omega_z$ [1/s]')
     ax.autoscale(tight=True)
     ax.legend()
     ax.tick_params(direction='in')
-    ax.set_title('Inviscid Vortex Patch - Vorticity')
+    ax.set_title('Vorticity')
 
 
     # --- Plot tangential velocity for different k values
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     r=np.linspace(0,2,100)
     theta=r*0
+    ax = axes[0,1]
     ax.plot(r, r/2,'k--', label=r'$r/2$ slope')
     for i,k in enumerate([1/2,1,2,4]):
         ur,utheta = ivp_u(r, theta, k=k, polarIn=True, polarOut=True)
         ax.plot(r, utheta, color=fColrs(i+1), label=r'$k={}$'.format(k))
     ax.set_xlabel('$r$ [m]')
     ax.set_ylabel(r'$u_\theta$ [m/s]')
     ax.autoscale(tight=True)
     ax.set_ylim([0,0.35])
     ax.legend()
     ax.tick_params(direction='in')
-    ax.set_title('Inviscid Vortex Patch - Velocity')
+    ax.set_title('Velocity')
 
 
     # --- Plot circulation 
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
     r     = np.linspace(0,2,100)
+    ax = axes[1,0]
     for i,k in enumerate([1/2,1,2,4]):
         Gamma = ivp_Gamma(r, k=k)
         ax.plot(r, Gamma/np.pi, color=fColrs(i+1), label=r'$k={}$'.format(k))
 
     ax.set_xlabel('$r$ [m]')
     ax.set_ylabel(r'$\Gamma/\pi$ [m$^2$/s]')
     ax.autoscale(tight=True)
     ax.set_ylim([0,0.7])
     ax.legend()
     ax.tick_params(direction='in')
-    ax.set_title('Inviscid Vortex Patch - Circulation')
+    ax.set_title('Circulation')
 
 
     # --- Plot velocity field
     k=1
     Gamma=ivp_Gamma([3],k=k)
     #  Control points
     nX=100
@@ -77,52 +77,61 @@
     vX = np.linspace(-4,4,nX)
     vY = np.linspace(-4,4,nY)
     XCP,YCP = np.meshgrid(vX,vY)
     Xcp = XCP.flatten()
     Ycp = YCP.flatten()
     Zcp = Xcp*0
     # Velocity field
-    Ux, Uy, _ = ivp_u(Xcp, Ycp, k=k)
+    Ux, Uy = ivp_u(Xcp, Ycp, k=k)
     Ux    = Ux.reshape(XCP.shape)
     Uy    = Uy.reshape(XCP.shape)
     Speed = np.sqrt((Ux**2+Uy**2))
     print('min: ',np.min(Speed.ravel()),' - max: ',np.max(Speed.ravel()))
     Speed= Speed/ np.max(Speed) # TODO can easiy be computed analytically
 
     # Plot
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.2,4.6)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.98, top=0.96, bottom=0.12, hspace=0.20, wspace=0.20)
+    ax = axes[1,1]
     im = ax.contourf(XCP, YCP, Speed, levels=np.linspace(minSpeed,maxSpeed,250), vmin=minSpeed, vmax=maxSpeed)
     cb=fig.colorbar(im)
     yseed=np.linspace(0.1,3.8,15)
     start=np.array([yseed*0,yseed])
     sp=ax.streamplot(vX,vY,Ux,Uy,color='k',start_points=start.T,linewidth=0.7,density=30,arrowstyle='-')
     qv=streamQuiver(ax,sp,n=7,scale=40,angles='xy')
     ax.set_xlabel('x [m]')
     ax.set_ylabel('y [m]')
     ax.set_aspect('equal','box')
-    ax.set_title('Inviscid Vortex Patch - Velocity Field')
+    ax.set_title('Velocity Field')
+
+    fig.suptitle('Vortilib - Inviscid Vorticity Patch')
+
 
 
+if __name__ == '__main__':
+    main()
+    plt.show()
+if __name__=="__test__":
     # --- Check that circulation match analytical value
-    def circulationSurvey(r, nTheta=100):
+    def circulationSurvey(r, nTheta=100, k=1):
         theta=np.linspace(0,2*np.pi,nTheta+1)
         dTheta=theta[1]-theta[0]
         Xcp=r*np.cos(theta)
         Ycp=r*np.sin(theta)
         Zcp=0*Xcp
-        Ux, Uy, _ = ivp_u(Xcp, Ycp, k=k)
+        Ux, Uy = ivp_u(Xcp, Ycp, k=k)
         Ut = Uy * np.cos(theta) - Ux * np.sin(theta)
         GammaTheory = ivp_Gamma([r], k=k)[0]
         #GammaCalc   = 2*np.pi * r*Ut[0]
         GammaCalc = r* np.trapz(Ut,theta)
         return  GammaCalc, GammaTheory
 
+    np.testing.assert_almost_equal(*circulationSurvey(0.1))
     print(circulationSurvey(0.1))
     print(circulationSurvey(0.5))
     print(circulationSurvey(0.9))
     print(circulationSurvey(1.0))
     print(circulationSurvey(2.0))
     print(circulationSurvey(3.0))
-
-    plt.show()
+if __name__=="__export__":
+    main()
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/LambOseenFenics.py` & `welib-1.0.0/welib/vortilib/elements/examples/LambOseenFenics.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 
 The boundary condition of the vector potential needs to be set on a circle to properly retrieve the solution 
 
 Comparison is done with analytical formulae of velocity, vector potential and vorticity.
 
 """
 
-from __future__ import print_function
 import matplotlib.pyplot as plt
 import numpy as np
 
 from scipy.special import expi, gammainc
 # try:
 #     from mshr import *
 #     from fenics import *
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/SourceEllipsoid_Deriv.py` & `welib-1.0.0/welib/vortilib/elements/examples/SourceEllipsoid_Deriv.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,11 @@
-from sympy import *
 
 def main():
+    from sympy import symbols, sqrt, diff
+
     r, x, k = symbols('r x k')
     a, b, c = symbols('a b c')
     delta, zeta, mu = symbols('delta zeta mu')
     b               = -(k**2+x**2+r**2)
     a               = k**2
     c               = x**2
     delta           = b**2 - 4 * a*c
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/SourceEllipsoid_Plots.py` & `welib-1.0.0/welib/vortilib/elements/examples/SourceEllipsoid_Plots.py`

 * *Files 22% similar despite different names*

```diff
@@ -51,16 +51,26 @@
     yseed=np.linspace(np.min(vy)*0.85,np.max(vy)*0.85,8)
     start=np.array([yseed*0-2*a*0.9,yseed])
     sp=ax.streamplot(vx,vy,Utot,V,color='k',start_points=start.T,linewidth=0.7,density=30,arrowstyle='-')
     qv=streamQuiver(ax,sp,n=7,scale=40,angles='xy')
     ax.plot(xe,ye,'k',lw=3)
     ax.set_ylim([-4*b,4*b])
     ax.set_xlim([-2*a,2*a])
-    ax.set_xlabel('x/a [-]')
-    ax.set_ylabel('r/a [-]')
+    ax.set_xlabel(r'$x/a$ [-]')
+    ax.set_ylabel(r'$r/a$ [-]')
     ax.set_aspect('equal','box')
-    fig.savefig('figs/SourceEllipsoidStreamlines.pdf')
-    plt.show()
+    ax.tick_params(direction='in', top=True, right=True)
+    ax.set_title('Vortilib - Flow about an Ellipsoid')
 
 
+if __name__ == '__main__':
+    main()
+    plt.show()
+if __name__=="__test__":
+    main()
+    pass
+if __name__=="__export__":
+    main()
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/VortexHelix.py` & `welib-1.0.0/welib/vortilib/elements/examples/VortexHelix.py`

 * *Files 12% similar despite different names*

```diff
@@ -27,57 +27,61 @@
     bSemi     = True # infinite helix or at the rotor
     vr        = np.linspace(0.1,2,100)*R
     Xcp       = vr
     Ycp       = Xcp*0
     Zcp       = Xcp*0
     Omega = U0*Lambda/R
 
+    fig,axes = plt.subplots(1, 2, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+    fig.subplots_adjust(left=0.12, right=0.95, top=0.91, bottom=0.11, hspace=0.20, wspace=0.39)
+
     # --- Axial induction on the lifting line 
-    fig,ax = plt.subplots(1,1)
-    ax.plot([0,1],[-a,-a],'k--',label='Momentum T. (B=infty)',lw=3)
+    ax = axes[0]
+    ax.plot([0,1],[-a,-a],'k--',label='Momentum T. (B=infty)',lw=3.5)
     ax.plot([1,2],[ 0, 0],'k--',lw=3)
 
     for nB in [1, 3, 10, 500]:
         ur,ut,uz = vh_u(Xcp,Ycp,Zcp,Gamma_tot/nB,R,h,psih=psi_blade,nB=nB,bWT=bWT,method=method,bSemi=bSemi)
         ax.plot(Xcp/R,uz/U0, label='B = {:d}'.format(nB))
 
-    ax.set_xlabel('r/R [-]')
-    ax.set_ylabel('uz/U0 [-]')
+    ax.set_xlabel(r'$r/R$ [-]')
+    ax.set_ylabel(r'$u_z/U_0$ [-]')
     ax.set_ylim([-2*a, 1/2*a])
-    ax.set_title('Axial induced velocity on the lifting line')
-    ax.legend()
+    ax.tick_params(direction='in')
+    #ax.legend()
 
     # --- Tangential induction on the lifting line 
-
-    fig,ax = plt.subplots(1,1)
+    ax = axes[1]
     #ax.plot([0,1],[-a,-a],'k--',label='Momentum T. (B=infty)',lw=3)
     ut_th_inf=np.zeros(vr.shape)
     ut_th_inf[vr<R]=0
     ut_th_inf[vr>R]=Gamma_tot/(2*np.pi*vr[vr>R])/2
-    ax.plot(vr/R,ut_th_inf,'k--',label='Vortex cylinder (B=infty)',lw=3)
+    ax.plot(vr/R,ut_th_inf,'k--',label='Vortex cylinder (B=infty)',lw=3.5)
 
     for nB in [1, 3, 10, 500]:
         ur,ut,uz = vh_u(Xcp,Ycp,Zcp,Gamma_tot/nB,R,h,psih=psi_blade,nB=nB,bWT=bWT,method=method,bSemi=bSemi)
         ax.plot(vr/R,ut, label='B = {:d}'.format(nB))
 
     #a,U0,R,Lambda,nB,h,CT,Gamma_B=Params(Lambda=0.1,nB=10)
     #h=1000
     #nB=10
     #ur,ut,uz = vh_u(Xcp,Ycp,Zcp,Gamma_tot/nB,R,h,psih=psi_blade,nB=nB,bWT=bWT,method=method,bSemi=bSemi)
     #ax.plot(vr/R,ut, label='B= {:d} - Lambda = {:.1f}'.format(nB,Lambda))
 
 
     ax.set_xlabel('r/R [-]')
-    ax.set_ylabel('ut [m/s]')
+    ax.set_ylabel(r'$u_t$ [m/s]')
     ax.set_ylim([-1, 1])
-    ax.set_title('Tangential induced velocity on the lifting line')
+    ax.tick_params(direction='in')
     ax.legend()
 
-
-
-
-    plt.show()
+    fig.suptitle('Vortilib - Vortex helix lifting line velocity')
 
 
 
 if __name__ == '__main__':
     main()
+    plt.show()
+if __name__=="__export__":
+    main()
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/VortexParticle_Regularization.py` & `welib-1.0.0/welib/vortilib/elements/examples/VortexParticle_Regularization.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,18 +1,16 @@
 """ 
 Plot regularization for 3D particles
 
 """
 import numpy as np
 import matplotlib.pyplot as plt
-import matplotlib as mpl
 from welib.tools.colors import fColrs
 from welib.vortilib.elements.VortexParticle import *
 
-
 def main():
     # --- Comparison of regularization
     PPart=np.array([0,0,0])
     L       = 1
     Gamma   = 1
     Alpha   = [0,0,L*Gamma]
     Epsilon = 0.5*L
@@ -37,10 +35,22 @@
     ax.set_xticks(np.arange(0,2.1,0.5))
     ax.set_xticklabels(['0','0.5','1','1.5','2'])
     ax.grid(ls=':')
     ax.legend()
     ax.set_ylim([0,0.5])
     ax.set_xlim([0,2])
     ax.tick_params(direction='in')
-    fig.savefig('figs/VortexParticleRegularization.pdf')
+    ax.set_title('Vortilib - Vortex particle regularization')
+
+if __name__ == '__main__':
+    main()
     plt.show()
+if __name__=="__test__":
+    import warnings
+    warnings.resetwarnings()
+    main()
+    pass
+if __name__=="__export__":
+    main()
+    from welib.tools.repo import export_figs_callback
+    export_figs_callback(__file__)
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/VortexPoint2DDistribution.py` & `welib-1.0.0/welib/vortilib/elements/examples/VortexPoint2DDistribution.py`

 * *Files 17% similar despite different names*

```diff
@@ -1,45 +1,46 @@
 """ 
 Compute velocity field from a distribution of vorticity in 2D using a set of vortex point
 
-NOTE: see also vorticilib.particles.examples, for methods "vortex particles" method
+NOTE: see also vortilib.particles.examples, for methods "vortex particles" method
 
 """
 import numpy as np
 import matplotlib.pyplot as plt
 # Local 
 from welib.tools.curves import streamQuiver
 # Analytical vorticity distributions
 from welib.vortilib.elements.VortexPoint           import * # vps_u
 from welib.vortilib.elements.InviscidVortexPatch   import * # ivp_u, ivp_omega
 from welib.vortilib.elements.LambOseen             import * # lo_omega
 from welib.vortilib.elements.VortexPatch2DGaussian import * # vpg_omega
 
-def main():
+def main(test=False):
     # --- Parameters
     minSpeed=0
     nX=30
     nY=31
     distribution='LambOseen'
-    # distribution='InviscidVortexPatch'
+    distribution='InviscidVortexPatch'
     distribution='VortexPatchGaussian'
-    distribution='VortexPatchGaussianAsym'
+    #distribution='VortexPatchGaussianAsym'
     SmoothModel = 0   # Can be inviscid=0 for this example since we evaluate on Vortex points
     SmoothParam = 0.1 # as function of diagonal length (should be <1 since no projection of omega)
     KernelOrder = 2
 
-    # Control points
+    # --- Control points
     vX = np.linspace(-8,8,nX)
     vY = np.linspace(-8,8,nY)
     XCP,YCP = np.meshgrid(vX,vY)
     Xcp = XCP.flatten()
     Ycp = YCP.flatten()
     Area = (vX[1]-vX[0])*(vY[1]-vY[0]) # Area occupied by each particles
     dr   = np.sqrt((vX[1]-vX[0])**2 + (vY[1]-vY[0])**2) # Diagonal of cells, used for regularization
-    # Particles, put at control points...
+    # --- Vorticity distribution, discretized onto particles
+    # Particles are put at control points here
     PartP     = np.column_stack((Xcp, Ycp))
     u_th = None
     if distribution=='LambOseen':
         omega=lo_omega
         u_th =lo_u
         maxSpeed=0.0508
     elif distribution=='InviscidVortexPatch':
@@ -52,27 +53,30 @@
         maxSpeed = 0.102
     elif distribution=='VortexPatchGaussianAsym':
         omega    = vpga_omega
         u_th     = vpga_u
         maxSpeed = 0.057
     else:
         raise NotImplementedError('')
-
+    # Particle intensities: omega * Area (where omega is a function)
     PartGammas = omega(Xcp, Ycp)*Area
 
 
     # --- Computing U
-    print('Computing...')
+    if not test:
+        print('Computing...')
     U_num = vps_u(PartP,PartP[:,:2],PartGammas,SmoothModel,KernelOrder,SmoothParam=SmoothParam*dr)
-    print('Done!')
+    if not test:
+        print('Done!')
     Ux_num = np.reshape(U_num[:,0],(nY,nX))
     Uy_num = np.reshape(U_num[:,1],(nY,nX))
     Speed_num = np.sqrt(Ux_num**2 + Uy_num**2)
     #omega_z_num_calc,__ = matlab_curl_2d(X,Y,U2,V2)
-    print('min: ',np.min(Speed_num.ravel()),' - max: ',np.max(Speed_num.ravel()))
+    if not test:
+        print('min: ',np.min(Speed_num.ravel()),' - max: ',np.max(Speed_num.ravel()))
 
 
     fig,axes = plt.subplots(1, 2, sharey=False, figsize=(6.2,4.6)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.96, top=0.96, bottom=0.12, hspace=0.20, wspace=0.30)
     ax=axes[0]
     im = ax.contourf(XCP, YCP, Speed_num, levels=np.linspace(minSpeed,maxSpeed,250), vmin=minSpeed, vmax=maxSpeed)
     yseed=np.linspace(0.1,3.0,10)
@@ -87,37 +91,47 @@
 
     # --- Analytical results
     if u_th is not None:
         Ux_th, Uy_th = u_th(PartP[:,0],PartP[:,1])
         Ux_th = np.reshape(Ux_th,(nY,nX))
         Uy_th = np.reshape(Uy_th,(nY,nX))
         Speed_th = np.sqrt(Ux_th**2 + Uy_th**2)
-        print('min: ',np.min(Speed_th.ravel()),' - max: ',np.max(Speed_th.ravel()))
+        if not test:
+            print('min: ',np.min(Speed_th.ravel()),' - max: ',np.max(Speed_th.ravel()))
         ax=axes[1]
         im = ax.contourf(XCP, YCP, Speed_th, levels=np.linspace(minSpeed,maxSpeed,250), vmin=minSpeed, vmax=maxSpeed)
         sp=ax.streamplot(vX,vY,Ux_th,Uy_th,color='k',start_points=start.T,linewidth=0.7,density=30,arrowstyle='-')
         qv=streamQuiver(ax,sp,n=7,scale=40,angles='xy')
         ax.set_xlabel('x [m]')
         ax.set_aspect('equal','box')
         ax.set_title('Theory')
+    fig.suptitle('Vortilib - 2D vorticity patch discretized with vortex points')
     # cb=fig.colorbar(im)
 
 
-
-    fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.2,4.6)) # (6.4,4.8)
-    fig.subplots_adjust(left=0.12, right=0.98, top=0.96, bottom=0.12, hspace=0.20, wspace=0.20)
-    ix=np.argmin(np.abs(vX))
-    iy=np.argmin(np.abs(vY))
-    ax.plot(vY,Ux_num[:,ix], label='x=0 num')
-    ax.plot(vX,Uy_num[iy,:], label='y=0 num')
-    ax.plot(vY,Ux_th[:,ix] , label='x=0 th')
-    ax.plot(vX,Uy_th[iy,:] , label='y=0 th')
-    ax.legend()
-
-
+    if not test:
+        fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.2,4.6)) # (6.4,4.8)
+        fig.subplots_adjust(left=0.12, right=0.98, top=0.96, bottom=0.12, hspace=0.20, wspace=0.20)
+        ix=np.argmin(np.abs(vX))
+        iy=np.argmin(np.abs(vY))
+        ax.plot(vY,Ux_num[:,ix], label='x=0 num')
+        ax.plot(vX,Uy_num[iy,:], label='y=0 num')
+        ax.plot(vY,Ux_th[:,ix] , label='x=0 th')
+        ax.plot(vX,Uy_th[iy,:] , label='y=0 th')
+        ax.legend()
 
 
 
 
 
+if __name__ == '__main__':
+    main()
     plt.show()
+#if __name__=="__test__":
+#    main()
+#    pass
+if __name__=="__export__":
+   main(test=True)
+   from welib.tools.repo import export_figs_callback
+   export_figs_callback(__file__)
+
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/VortexSegment_CrossField.py` & `welib-1.0.0/welib/vortilib/elements/examples/VortexSegment_CrossField.py`

 * *Files 4% similar despite different names*

```diff
@@ -121,11 +121,19 @@
     # fig.subplots_adjust(left=0.12, right=0.98, top=0.96, bottom=0.12, hspace=0.20, wspace=0.20)
     # ix=np.argmin(np.abs(vX))
     # iy=np.argmin(np.abs(vY))
     # ax.plot(vY/L,Ux[:,ix]/Gamma *np.pi*L , label='x=0')
     # ax.plot(vX/L,Uy[iy,:]/Gamma *np.pi*L , label='y=0')
     # ax.legend()
     # 
+if __name__ == '__main__':
+    main()
+    plt.show()
+#if __name__=="__test__":
+#    main()
+#    pass
+#if __name__=="__export__":
+#    main()
+#    from welib.tools.repo import export_figs_callback
+#    export_figs_callback(__file__)
 
 
-    # fig.savefig('VortexFilamentRegularization.pdf')
-    plt.show()
```

### Comparing `welib-0.0.2/welib/vortilib/elements/examples/VortexSegment_Regularization.py` & `welib-1.0.0/welib/vortilib/elements/examples/VortexSegment_Regularization.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,10 +1,9 @@
 import numpy as np
 import matplotlib.pyplot as plt
-import matplotlib as mpl
 from welib.tools.colors import fColrs
 from welib.vortilib.elements.VortexSegment import *
 
 def main():
     # --- Comparison of regularization
     z0=1
     Pa      = np.array([[ 0, 0, -z0]])
@@ -23,24 +22,37 @@
     U4x, U4y, U4z = vs_u(Xcp, Ycp, Zcp, Pa, Pb, Gamma=Gamma, RegFunction=4, RegParam=Epsilon*1)
     U_th = Gamma*(L/2)/(2*np.pi*Xcp * np.sqrt(Xcp**2 + z0**2))
 
 
     # plot
     fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.2,4.6)) # (6.4,4.8)
     fig.subplots_adjust(left=0.12, right=0.98, top=0.96, bottom=0.12, hspace=0.20, wspace=0.20)
-    ax.plot(Xcp[1:]/L  ,U0y[1:] / Gamma*np.pi*L, '-', color=fColrs(1), label = 'Singular'       )
-    ax.plot(Xcp/L  ,U1y / Gamma*np.pi*L, '-.', color=fColrs(2), label = 'Rankine'    )
-    ax.plot(Xcp/L  ,U2y / Gamma*np.pi*L, '-', color=fColrs(3), label = 'Lamb-Oseen' )
-    ax.plot(Xcp/L  ,U3y / Gamma*np.pi*L, '--', color=fColrs(4), label = 'Vatistas n=2'   )
-    ax.plot(Xcp/L  ,U4y / Gamma*np.pi*L, ':', color=fColrs(5), label = 'Denominator')
+    ax.plot(Xcp[1:]/L  ,U0y[1:] / Gamma*np.pi*L, '-' , color=fColrs(1), label = 'Singular'       )
+    ax.plot(Xcp/L  ,    U1y     / Gamma*np.pi*L, '-.', color=fColrs(2), label = 'Rankine'    )
+    ax.plot(Xcp/L  ,    U2y     / Gamma*np.pi*L, '-' , color=fColrs(3), label = 'Lamb-Oseen' )
+    ax.plot(Xcp/L  ,    U3y     / Gamma*np.pi*L, '--', color=fColrs(4), label = 'Vatistas n=2'   )
+    ax.plot(Xcp/L  ,    U4y     / Gamma*np.pi*L, ':' , color=fColrs(5), label = 'Denominator')
     # ax.plot(Xcp/L  ,U_th/ Gamma*np.pi*L, '--',color='k', label = 'Theory'       )
     ax.set_xlabel(r'$\rho/L$ [-]')
     ax.set_ylabel(r'$u \pi L / \Gamma$ [-]')
     ax.set_xticks(np.arange(0,2.1,0.5))
     ax.set_xticklabels(['0','0.5','1','1.5','2'])
     ax.legend()
     ax.grid(ls=':')
     ax.set_ylim([0,1])
     ax.set_xlim([0,2])
     ax.tick_params(direction='in')
-    fig.savefig('figs/VortexFilamentRegularization.pdf')
+    ax.set_title('Vortilib - Vortex segment regularization')
+
+
+if __name__ == '__main__':
+    main()
     plt.show()
+#if __name__=="__test__":
+#    main()
+#    pass
+if __name__=="__export__":
+   main()
+   from welib.tools.repo import export_figs_callback
+   export_figs_callback(__file__)
+
+
```

### Comparing `welib-0.0.2/welib/vortilib/elements/fUi_VortexSegment11_smooth.py` & `welib-1.0.0/welib/vortilib/elements/fUi_VortexSegment11_smooth.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/EllipticIntegrals.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/EllipticIntegrals.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/MathConstants.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/MathConstants.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/Part.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/Part.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/PrecisionMod.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/PrecisionMod.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/Sgmt.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/Sgmt.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/SurfaceMap.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/SurfaceMap.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIBlobs.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIBlobs.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIHillsVortex.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIHillsVortex.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIPanels.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIPanels.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIPointSource.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIPointSource.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UISegments.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UISegments.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIVortexCylinders.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIVortexCylinders.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIVortexPoint2D.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIVortexPoint2D.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIVortexPoint2DPerdiodic.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIVortexPoint2DPerdiodic.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/fortran/UIVortexRings.f90` & `welib-1.0.0/welib/vortilib/elements/fortran/UIVortexRings.f90`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/elements/tests/test_elements.py` & `welib-1.0.0/welib/vortilib/elements/tests/test_elements.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/particles/examples/MainVC2D_TestProj.py` & `welib-1.0.0/welib/vortilib/particles/examples/MainVC2D_TestProj.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/particles/initialization.py` & `welib-1.0.0/welib/vortilib/particles/initialization.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/particles/particles.py` & `welib-1.0.0/welib/vortilib/particles/particles.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/vortilib/particles/projection.py` & `welib-1.0.0/welib/vortilib/particles/projection.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/_NEWFILE_TEMPLATE.py` & `welib-1.0.0/welib/weio/_NEWFILE_TEMPLATE.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -4,18 +4,18 @@
 import numpy as np
 import pandas as pd
 import os
 
 try:
     from .file import File, WrongFormatError, BrokenFormatError
 except:
+    File=dict
     EmptyFileError    = type('EmptyFileError', (Exception,),{})
     WrongFormatError  = type('WrongFormatError', (Exception,),{})
     BrokenFormatError = type('BrokenFormatError', (Exception,),{})
-    File=dict
 
 class XXXFile(File):
     """ 
     Read/write a XXX file. The object behaves as a dictionary.
     
     Main methods
     ------------
```

### Comparing `welib-0.0.2/welib/weio/__init__.py` & `welib-1.0.0/welib/weio/__init__.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,16 +15,20 @@
 
 def fileFormats(userpath=None, ignoreErrors=False, verbose=False):
     """ return list of fileformats supported by the library
     If userpath is provided, 
 
     """
     global _FORMATS
+    errors=[]
     if _FORMATS is not None:
-        return _FORMATS
+        if ignoreErrors:
+            return _FORMATS, errors
+        else:
+            return _FORMATS
     # --- Library formats
     from .fast_input_file         import FASTInputFile
     from .fast_output_file        import FASTOutputFile
     from .csv_file                import CSVFile
     from .fast_wind_file          import FASTWndFile
     from .fast_linearization_file import FASTLinearizationFile
     from .fast_summary_file       import FASTSummaryFile
@@ -48,16 +52,18 @@
     from .turbsim_file            import TurbSimFile
     from .netcdf_file             import NetCDFFile
     from .tdms_file               import TDMSFile
     from .tecplot_file            import TecplotFile 
     from .vtk_file import VTKFile
     from .bladed_out_file         import BladedFile
     from .parquet_file            import ParquetFile
+    from .pickle_file             import PickleFile        
     from .cactus_file             import CactusFile
     from .raawmat_file            import RAAWMatFile
+    from .rosco_discon_file       import ROSCODISCONFile
     from .rosco_performance_file  import ROSCOPerformanceFile
     priorities = []
     formats = []
     def addFormat(priority, fmt):
         priorities.append(priority)
         formats.append(fmt)
     addFormat(0, FileFormat(CSVFile))
@@ -82,19 +88,21 @@
     addFormat(30, FileFormat(MannBoxFile))
     addFormat(40, FileFormat(FLEXBladeFile))
     addFormat(40, FileFormat(FLEXProfileFile))
     addFormat(40, FileFormat(FLEXOutFile))
     addFormat(40, FileFormat(FLEXWaveKinFile))
     addFormat(40, FileFormat(FLEXDocFile))
     addFormat(50, FileFormat(BModesOutFile))
+    addFormat(50, FileFormat(ROSCODISCONFile))
     addFormat(50, FileFormat(ROSCOPerformanceFile))
     addFormat(60, FileFormat(NetCDFFile))
     addFormat(60, FileFormat(VTKFile))
     addFormat(60, FileFormat(TDMSFile))
     addFormat(60, FileFormat(ParquetFile))
+    addFormat(60, FileFormat(PickleFile))
     addFormat(70, FileFormat(CactusFile))
     addFormat(70, FileFormat(RAAWMatFile))
 
     # --- User defined formats from user path
     UserClasses, UserPaths, UserModules, UserModuleNames, errors = userFileClasses(userpath, ignoreErrors, verbose=verbose)
     for cls, f in zip(UserClasses, UserPaths):
         try:
@@ -237,14 +245,16 @@
         i += 1
 
     if not detected:
         raise FormatNotDetectedError('The file format could not be detected for the file: '+filename)
 
 def read(filename, fileformat=None, **kwargs):
     F = None
+    if not os.path.exists(filename):
+        raise FileNotFoundError('weio cannot read the following file because it does not exist:\n   Inp. path: {}\n   Abs. path: {}'.format(filename, os.path.abspath(filename)))
     # Detecting format if necessary
     if fileformat is None:
         fileformat,F = detectFormat(filename, **kwargs)
     # Reading the file with the appropriate class if necessary
     if not isinstance(F, fileformat.constructor):
         F=fileformat.constructor(filename=filename)
     return F
```

### Comparing `welib-0.0.2/welib/weio/bladed_out_file.py` & `welib-1.0.0/welib/weio/bladed_out_file.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,21 +1,19 @@
-# -*- coding: utf-8 -*-
 import os
 import numpy as np
 import re
 import pandas as pd
 import glob
 import shlex
-# try:
-from .file import File, WrongFormatError, BrokenFormatError, isBinary
-# except:
-#     EmptyFileError    = type('EmptyFileError', (Exception,),{})
-#     WrongFormatError  = type('WrongFormatError', (Exception,),{})
-#     BrokenFormatError = type('BrokenFormatError', (Exception,),{})
-#     File=dict
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
         
 # --------------------------------------------------------------------------------}
 # --- Helper functions 
 # --------------------------------------------------------------------------------{
 def read_bladed_sensor_file(sensorfile):        
     """ 
@@ -367,14 +365,29 @@
             df.columns.name = k # hack for pyDatView when one dataframe is returned
             dfs[k] = df
         if len(dfs)==1:
             return dfs[next(iter(dfs))]
         else:
             return dfs
     
+
+def isBinary(filename):
+    with open(filename, 'r') as f:
+        try:
+            # first try to read as string
+            l = f.readline()
+            # then look for weird characters
+            for c in l:
+                code = ord(c)
+                if code<10 or (code>14 and code<31):
+                    return True
+            return False
+        except UnicodeDecodeError:
+            return True
+
 if __name__ == '__main__':
     pass
     #filename = r'E:\Work_Google Drive\Bladed_Sims\Bladed_out_binary.$41'
     #Output = BladedFile(filename)
     #df = Output.toDataFrame()
```

### Comparing `welib-0.0.2/welib/weio/bmodes_out_file.py` & `welib-1.0.0/welib/weio/bmodes_out_file.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -4,18 +4,18 @@
 import numpy as np
 import pandas as pd
 import os
 
 try:
     from .file import File, WrongFormatError, BrokenFormatError
 except:
+    File=dict
     EmptyFileError    = type('EmptyFileError', (Exception,),{})
     WrongFormatError  = type('WrongFormatError', (Exception,),{})
     BrokenFormatError = type('BrokenFormatError', (Exception,),{})
-    File=dict
 
 class BModesOutFile(File):
     """ 
     Read/write a BModes output file. The object behaves as a dictionary.
     
     Main methods
     ------------
```

### Comparing `welib-0.0.2/welib/weio/cactus_element_file.py` & `welib-1.0.0/welib/weio/cactus_element_file.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/cactus_file.py` & `welib-1.0.0/welib/weio/cactus_file.py`

 * *Ordering differences only*

 * *Files 1% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 import numpy as np
 import pandas as pd
 import os
 
 try:
     from .file import File, WrongFormatError, BrokenFormatError, EmptyFileError
 except:
+    File=dict
     EmptyFileError    = type('EmptyFileError', (Exception,),{})
     WrongFormatError  = type('WrongFormatError', (Exception,),{})
     BrokenFormatError = type('BrokenFormatError', (Exception,),{})
-    File=dict
 
 class CactusFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.in']
```

### Comparing `welib-0.0.2/welib/weio/csv_file.py` & `welib-1.0.0/welib/weio/csv_file.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,12 +1,7 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
 import os
 
 from .file import File, WrongFormatError
 import pandas as pd
 
 class CSVFile(File):
     """ 
@@ -245,16 +240,14 @@
         except pd.errors.ParserError as e:
             raise WrongFormatError('CSV File {}: '.format(self.filename)+e.args[0])
 
         if (len(self.colNames)==0) or (len(self.colNames)!=len(self.data.columns)):
             self.colNames=['C{}'.format(i) for i in range(len(self.data.columns))]
         self.data.columns = self.colNames;
         self.data.rename(columns=lambda x: x.strip(),inplace=True)
-        #import pdb
-        #pdb.set_trace()
 
     def _write(self):
         # --- Safety
         if self.sep==r'\s+' or self.sep=='':
             self.sep='\t'
         # Write
         if len(self.header)>0:
```

### Comparing `welib-0.0.2/welib/weio/examples/ModifyAeroDynBladeFile.py` & `welib-1.0.0/welib/weio/examples/ModifyAeroDynBladeFile.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/excel_file.py` & `welib-1.0.0/welib/weio/excel_file.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,13 +1,7 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
-
 from .file import File, WrongFormatError, BrokenFormatError
 import numpy as np
 import pandas as pd
 
 # from pandas import ExcelWriter
 from pandas import ExcelFile
```

### Comparing `welib-0.0.2/welib/weio/fast_input_deck.py` & `welib-1.0.0/welib/weio/fast_input_deck.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,16 +1,7 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import range
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
 import os
 import numpy as np
 import re
 import pandas as pd
 
 from .fast_input_file import FASTInputFile
 
@@ -29,29 +20,31 @@
           - readlist: list of module files to be read, or ['all'], modules are identified as follows:
                 ['Fst','ED','AD','BD','BDbld','EDtwr','EDbld','ADbld','AF','AC','IW','HD','SrvD','SD','MD']
                 where: 
                  AF: airfoil polars
                  AC: airfoil coordinates (if present)
 
         """
+
         # Sanity
         if type(verbose) is not bool: 
             raise Exception('`verbose` arguments needs to be a boolean')
 
+        # Main Data
+        self.inputFilesRead = {}
         self.filename = fullFstPath
         self.verbose  = verbose
         self.readlist = readlist
         if not type(self.readlist) is list:
             self.readlist=[readlist]
         if 'all' in self.readlist:
             self.readlist = ['Fst','ED','AD','BD','BDbld','EDtwr','EDbld','ADbld','AF','AC','IW','HD','SrvD','SD','MD']
         else:
             self.readlist = ['Fst']+self.readlist
 
-        self.inputfiles = {}
 
         # --- Harmonization with AeroElasticSE
         self.FAST_ver       = 'OPENFAST'
         self.path2dll       = None   # Path to dll file
 
         self.fst_vt={}
         self.fst_vt['description']       = ''            
@@ -79,14 +72,27 @@
 
         self.ADversion=''
 
         # Read all inputs files
         if len(fullFstPath)>0:
             self.read()
 
+    @property
+    def ED(self):
+        ED = self.fst_vt['ElastoDyn']
+        if ED is None:
+            if 'ED' not in self.readlist:
+                self.readlist.append('ED')
+            if self.verbose:
+                print('>>> Reading ED', self.ED_path)
+            self.fst_vt['ElastoDyn'] = self._read(self.fst_vt['Fst']['EDFile'],'ED')
+            return self.fst_vt['ElastoDyn']
+        else:
+            return ED
+
 
     def readAD(self, filename=None, readlist=None, verbose=False, key='AeroDyn15'):
         """ 
         readlist: 'AD','AF','AC'
         """
         if readlist is not None:
             readlist_bkp = self.readlist
@@ -150,112 +156,110 @@
 
 
     @property
     def inputFiles(self):
         files=[]
         files+=[self.ED_path, self.ED_twr_path, self.ED_bld_path]
         files+=[self.BD_path, self.BD_bld_path]
+        files+=[self.SD_path]
         return [f for f in files if f not in self.unusedNames]
 
-
-    @property
-    def ED_relpath(self):
-        try:
-            return self.fst_vt['Fst']['EDFile'].replace('"','')
-        except:
-            return 'none'
-
-    @property
-    def ED_twr_relpath(self):
-        try:
-            return os.path.join(os.path.dirname(self.fst_vt['Fst']['EDFile']).replace('"',''), self.fst_vt['ElastoDyn']['TwrFile'].replace('"',''))
-        except:
-            return 'none'
-
-    @property
-    def ED_bld_relpath(self):
+    def _relpath(self, k1, k2=None, k3=None):
         try:
-            if 'BldFile(1)' in self.fst_vt['ElastoDyn'].keys():
-                return os.path.join(os.path.dirname(self.fst_vt['Fst']['EDFile'].replace('"','')), self.fst_vt['ElastoDyn']['BldFile(1)'].replace('"',''))
+            if k2 is None:
+                return self.fst_vt['Fst'][k1].replace('"','')
             else:
-                return os.path.join(os.path.dirname(self.fst_vt['Fst']['EDFile'].replace('"','')), self.fst_vt['ElastoDyn']['BldFile1'].replace('"',''))
-        except:
-            return 'none'
-
-    @property
-    def BD_relpath(self):
-        try:
-            return self.fst_vt['Fst']['BDBldFile(1)'].replace('"','')
+                parent = os.path.dirname(self.fst_vt['Fst'][k1]).replace('"','')
+                if type(k3)==list:
+                    for k in k3:
+                        if k in self.fst_vt[k2].keys():
+                            child =  self.fst_vt[k2][k].replace('"','')
+                else:
+                    child =  self.fst_vt[k2][k3].replace('"','')
+                return os.path.join(parent, child)
         except:
             return 'none'
 
     @property
-    def BD_bld_relpath(self):
-        try:
-            return os.path.join(os.path.dirname(self.fst_vt['Fst']['BDBldFile(1)'].replace('"','')), self.fst_vt['BeamDyn']['BldFile'].replace('"',''))
-        except:
-            return 'none'
-
+    def ED_path(self): return self._fullpath(self._relpath('EDFile'))
     @property
-    def ED_path(self): return self._fullpath(self.ED_relpath)
+    def SD_path(self): return self._fullpath(self._relpath('SubFile'))
     @property
-    def BD_path(self): return self._fullpath(self.BD_relpath)
+    def BD_path(self): return self._fullpath(self._relpath('BDBldFile(1)'))
     @property
-    def BD_bld_path(self): return self._fullpath(self.BD_bld_relpath)
+    def BD_bld_path(self): return self._fullpath(self._relpath('BDBldFile(1)','BeamDyn','BldFile'))
     @property
-    def ED_twr_path(self): return self._fullpath(self.ED_twr_relpath)
+    def ED_twr_path(self): return self._fullpath(self._relpath('EDFile','ElastoDyn','TwrFile'))
     @property
-    def ED_bld_path(self): return self._fullpath(self.ED_bld_relpath)
+    def ED_bld_path(self): return self._fullpath(self._relpath('EDFile','ElastoDyn',['BldFile(1)','BldFile1']))
 
 
 
     def _fullpath(self, relfilepath):
         relfilepath = relfilepath.replace('"','')
         basename = os.path.basename(relfilepath)
         if basename.lower() in self.unusedNames:
             return 'none'
         else:
             return os.path.join(self.FAST_directory, relfilepath)
 
 
     def read(self, filename=None):
+        """ 
+        Read all OpenFAST inputs files, based on the requested list of modules `readlist`
+        """
         if filename is not None:
             self.filename = filename
 
-        # Read OpenFAST files
+        # Read main file (.fst, or .drv) and store into key "Fst"
+        if self.verbose:
+            print('Reading:', self.FAST_InputFile)
         self.fst_vt['Fst'] = self._read(self.FAST_InputFile, 'Fst')
         if self.fst_vt['Fst'] is None:
             raise Exception('Error reading main file {}'.format(self.filename))
         keys = self.fst_vt['Fst'].keys()
 
-
+        # Detect driver or OpenFAST version
         if 'NumTurbines' in keys:
             self.version='AD_driver'
+        elif 'DynamicSolve' in keys:
+            self.version='BD_driver'
         elif 'InterpOrder' in self.fst_vt['Fst'].keys():
             self.version='OF2'
         else:
             self.version='F7'
 
-
         if self.version=='AD_driver':
             # ---- AD Driver
             # InflowWind
             if self.fst_vt['Fst']['CompInflow']>0:
                 self.fst_vt['InflowWind'] = self._read(self.fst_vt['Fst']['InflowFile'],'IW')
 
             self.readAD(key='AeroDyn15')
 
+        elif self.version=='BD_driver':
+            # --- BD driver
+            self.fst_vt['BeamDyn'] = self._read(self.fst_vt['Fst']['InputFile'],'BD')
+            if self.fst_vt['BeamDyn'] is not None:
+                # Blades
+                bld_file = os.path.join(os.path.dirname(self.fst_vt['Fst']['InputFile']), self.fst_vt['BeamDyn']['BldFile'])
+                print('bld_file', bld_file)
+                self.fst_vt['BeamDynBlade']= self._read(bld_file,'BDbld')
+
+            del self.fst_vt['af_data']
+            del self.fst_vt['ac_data']
+
         elif self.version=='OF2':
             # ---- Regular OpenFAST file
             # ElastoDyn
             if 'EDFile' in self.fst_vt['Fst'].keys():
                 self.fst_vt['ElastoDyn'] = self._read(self.fst_vt['Fst']['EDFile'],'ED')
                 if self.fst_vt['ElastoDyn'] is not None:
-                    twr_file = self.ED_twr_relpath
-                    bld_file = self.ED_bld_relpath
+                    twr_file = self.ED_twr_path
+                    bld_file = self.ED_bld_path
                     self.fst_vt['ElastoDynTower'] = self._read(twr_file,'EDtwr')
                     self.fst_vt['ElastoDynBlade'] = self._read(bld_file,'EDbld')
 
             # InflowWind
             if self.fst_vt['Fst']['CompInflow']>0:
                 self.fst_vt['InflowWind'] = self._read(self.fst_vt['Fst']['InflowFile'],'IW')
 
@@ -271,15 +275,15 @@
 
             # HydroDyn
             if self.fst_vt['Fst']['CompHydro']== 1:
                 self.fst_vt['HydroDyn'] = self._read(self.fst_vt['Fst']['HydroFile'],'HD')
 
             # SubDyn
             if self.fst_vt['Fst']['CompSub'] == 1:
-                self.fst_vt['SubDyn'] = self._read(self.fst_vt['Fst']['SubFile'],'HD')
+                self.fst_vt['SubDyn'] = self._read(self.fst_vt['Fst']['SubFile'], 'SD')
 
             # Mooring
             if self.fst_vt['Fst']['CompMooring']==1:
                 self.fst_vt['MAP'] = self._read(self.fst_vt['Fst']['MooringFile'],'MD')
             if self.fst_vt['Fst']['CompMooring']==2:
                 self.fst_vt['MoorDyn'] = self._read(self.fst_vt['Fst']['MooringFile'],'MD')
 
@@ -289,23 +293,24 @@
                 if self.fst_vt['BeamDyn'] is not None:
                     # Blades
                     bld_file = os.path.join(os.path.dirname(self.fst_vt['Fst']['BDBldFile(1)']), self.fst_vt['BeamDyn']['BldFile'])
                     self.fst_vt['BeamDynBlade']= self._read(bld_file,'BDbld')
 
         # --- Backward compatibility
         self.fst = self.fst_vt['Fst']
-        self.ED  = self.fst_vt['ElastoDyn']
+        self._ED  = self.fst_vt['ElastoDyn']
         if not hasattr(self,'AD'):
             self.AD = None
         if self.AD is not None:
             self.AD.Bld1 = self.fst_vt['AeroDynBlade']
             self.AD.AF  = self.fst_vt['af_data']
         self.IW  = self.fst_vt['InflowWind']
         self.BD  = self.fst_vt['BeamDyn']
         self.BDbld  = self.fst_vt['BeamDynBlade']
+        self.SD  = self.fst_vt['SubDyn']
 
     @ property
     def unusedNames(self):
         return ['unused','nan','na','none']
 
     def _read(self, relfilepath, shortkey):
         """ read any openfast input """
@@ -321,122 +326,152 @@
         # Skip "unused" and "NA"
         if basename.lower() in self.unusedNames:
             if self.verbose:
                 print('>>> Unused ',shortkey)
             return None
 
         # Attempt reading
-        fullpath =os.path.join(self.FAST_directory, relfilepath)
+        if relfilepath.startswith(self.FAST_directory):
+            fullpath = relfilepath
+        else:
+            fullpath = os.path.join(self.FAST_directory, relfilepath)
         try:
             data = FASTInputFile(fullpath)
             if self.verbose:
                 print('>>> Read: ',fullpath)
-            self.inputfiles[shortkey] = fullpath
+            self.inputFilesRead[shortkey] = fullpath
             return data
         except FileNotFoundError:
             print('[WARN] File not found '+fullpath)
             return None
 
 
 
     def write(self, filename=None, prefix='', suffix='', directory=None):
         """ Write a standardized input file deck"""
         if filename is None:
             filename=self.filename # Overwritting
         self.filename=filename
         if directory is None:
             directory = os.path.dirname(filename)
+        else:
+            # Making sure filename is within directory
+            filename = os.path.join(directory, os.path.basename(filename))
+        if not os.path.exists(directory):
+            os.makedirs(directory)
+  
         basename = os.path.splitext(os.path.basename(filename))[0]
 
 
         fst = self.fst_vt['Fst']
 
-        # Filenames
-        filename_ED     = os.path.join(directory,prefix+'ED'+suffix+'.dat')      if fst['CompElast']>0   else 'none'
-        filename_IW     = os.path.join(directory,prefix+'IW'+suffix+'.dat')      if fst['CompInflow']>0  else 'none'
-        filename_BD     = os.path.join(directory,prefix+'BD'+suffix+'.dat')      if fst['CompElast']==2  else 'none'
-        filename_AD     = os.path.join(directory,prefix+'AD'+suffix+'.dat')      if fst['CompAero']>0    else 'none'
-        filename_HD     = os.path.join(directory,prefix+'HD'+suffix+'.dat')      if fst['CompHydro']>0   else 'none'
-        filename_SD     = os.path.join(directory,prefix+'SD'+suffix+'.dat')      if fst['CompSub']>0     else 'none'
-        filename_MD     = os.path.join(directory,prefix+'MD'+suffix+'.dat')      if fst['CompMooring']>0 else 'none'
-        filename_SvD    = os.path.join(directory,prefix+'SvD'+suffix+'.dat')     if fst['CompServo']>0   else 'none'
-        filename_Ice    = os.path.join(directory,prefix+'Ice'+suffix+'.dat')     if fst['CompIce']>0     else 'none'
-        filename_ED_bld = os.path.join(directory,prefix+'ED_bld'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
-        filename_ED_twr = os.path.join(directory,prefix+'ED_twr'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
-        filename_BD_bld = os.path.join(directory,prefix+'BD_bld'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
-        # TODO AD Profiles and OLAF
-
-        fst['EDFile']       = '"' + os.path.basename(filename_ED) + '"'
-        fst['BDBldFile(1)'] = '"' + os.path.basename(filename_BD) + '"'
-        fst['BDBldFile(2)'] = '"' + os.path.basename(filename_BD) + '"'
-        fst['BDBldFile(3)'] = '"' + os.path.basename(filename_BD) + '"'
-        fst['InflowFile']   = '"' + os.path.basename(filename_IW) + '"'
-        fst['AeroFile']     = '"' + os.path.basename(filename_AD) + '"'
-        fst['ServoFile']    = '"' + os.path.basename(filename_AD) + '"'
-        fst['HydroFile']    = '"' + os.path.basename(filename_HD) + '"'
-        fst['SubFile']      = '"' + os.path.basename(filename_SD) + '"'
-        fst['MooringFile']  = '"' + os.path.basename(filename_MD) + '"'
-        fst['IceFile']      = '"' + os.path.basename(filename_Ice)+ '"'
-        fst.write(filename)
-
-
-        ED =  self.fst_vt['ElastoDyn']
-        if fst['CompElast']>0:
-            ED['TwrFile'] = '"' + os.path.basename(filename_ED_twr)+ '"'
-            self.fst_vt['ElastoDynTower'].write(filename_ED_twr)
-        if fst['CompElast']==1:
-            if 'BldFile1' in ED.keys():
-                ED['BldFile1'] = '"' + os.path.basename(filename_ED_bld)+ '"'
-                ED['BldFile2'] = '"' + os.path.basename(filename_ED_bld)+ '"'
-                ED['BldFile3'] = '"' + os.path.basename(filename_ED_bld)+ '"'
-            else:
-                ED['BldFile(1)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
-                ED['BldFile(2)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
-                ED['BldFile(3)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
-            self.fst_vt['ElastoDynBlade'].write(filename_ED_bld)
 
-        elif fst['CompElast']==2:
+        if self.version=='AD_driver':
+            raise NotImplementedError()
+
+        elif self.version=='BD_driver':
+            # --- BD driver
+            filename_BD     = os.path.join(directory, prefix+'BD'+suffix+'.dat')
+            filename_BD_bld = os.path.join(directory, prefix+'BD_bld'+suffix+'.dat')
+            fst['InputFile'] = '"' + os.path.basename(filename_BD) + '"'
+            fst.write(filename)
             BD = self.fst_vt['BeamDyn'] 
             BD['BldFile'] = '"'+os.path.basename(filename_BD_bld)+'"'
             self.fst_vt['BeamDynBlade'].write(filename_BD_bld)  # TODO TODO pick up the proper blade file!
             BD.write(filename_BD)
-        ED.write(filename_ED)
-
 
-        if fst['CompInflow']>0:
-            self.fst_vt['InflowWind'].write(filename_IW)
-
-        if fst['CompAero']>0:
-            self.fst_vt['AeroDyn15'].write(filename_AD)
-            # TODO other files
-
-        if fst['CompServo']>0:
-            self.fst_vt['ServoDyn'].write(filename_SvD)
+        elif self.version=='OF2':
 
-        if fst['CompHydro']==1:
-            self.fst_vt['HydroDyn'].write(filename_HD)
+            # Filenames
+            filename_ED     = os.path.join(directory,prefix+'ED'+suffix+'.dat')      if fst['CompElast']>0   else 'none'
+            filename_IW     = os.path.join(directory,prefix+'IW'+suffix+'.dat')      if fst['CompInflow']>0  else 'none'
+            filename_BD     = os.path.join(directory,prefix+'BD'+suffix+'.dat')      if fst['CompElast']==2  else 'none'
+            filename_AD     = os.path.join(directory,prefix+'AD'+suffix+'.dat')      if fst['CompAero']>0    else 'none'
+            filename_HD     = os.path.join(directory,prefix+'HD'+suffix+'.dat')      if fst['CompHydro']>0   else 'none'
+            filename_SD     = os.path.join(directory,prefix+'SD'+suffix+'.dat')      if fst['CompSub']>0     else 'none'
+            filename_MD     = os.path.join(directory,prefix+'MD'+suffix+'.dat')      if fst['CompMooring']>0 else 'none'
+            filename_SvD    = os.path.join(directory,prefix+'SvD'+suffix+'.dat')     if fst['CompServo']>0   else 'none'
+            filename_Ice    = os.path.join(directory,prefix+'Ice'+suffix+'.dat')     if fst['CompIce']>0     else 'none'
+            filename_ED_bld = os.path.join(directory,prefix+'ED_bld'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
+            filename_ED_twr = os.path.join(directory,prefix+'ED_twr'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
+            filename_BD_bld = os.path.join(directory,prefix+'BD_bld'+suffix+'.dat')  if fst['CompElast']>0   else 'none'
+            # TODO AD Profiles and OLAF
+
+            fst['EDFile']       = '"' + os.path.basename(filename_ED) + '"'
+            fst['BDBldFile(1)'] = '"' + os.path.basename(filename_BD) + '"'
+            fst['BDBldFile(2)'] = '"' + os.path.basename(filename_BD) + '"'
+            fst['BDBldFile(3)'] = '"' + os.path.basename(filename_BD) + '"'
+            fst['InflowFile']   = '"' + os.path.basename(filename_IW) + '"'
+            fst['AeroFile']     = '"' + os.path.basename(filename_AD) + '"'
+            fst['ServoFile']    = '"' + os.path.basename(filename_AD) + '"'
+            fst['HydroFile']    = '"' + os.path.basename(filename_HD) + '"'
+            fst['SubFile']      = '"' + os.path.basename(filename_SD) + '"'
+            fst['MooringFile']  = '"' + os.path.basename(filename_MD) + '"'
+            fst['IceFile']      = '"' + os.path.basename(filename_Ice)+ '"'
+            fst.write(filename)
+
+
+            ED =  self.fst_vt['ElastoDyn']
+            if fst['CompElast']>0:
+                ED['TwrFile'] = '"' + os.path.basename(filename_ED_twr)+ '"'
+                self.fst_vt['ElastoDynTower'].write(filename_ED_twr)
+            if fst['CompElast']==1:
+                if 'BldFile1' in ED.keys():
+                    ED['BldFile1'] = '"' + os.path.basename(filename_ED_bld)+ '"'
+                    ED['BldFile2'] = '"' + os.path.basename(filename_ED_bld)+ '"'
+                    ED['BldFile3'] = '"' + os.path.basename(filename_ED_bld)+ '"'
+                else:
+                    ED['BldFile(1)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
+                    ED['BldFile(2)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
+                    ED['BldFile(3)']   = '"' + os.path.basename(filename_ED_bld)+ '"'
+                self.fst_vt['ElastoDynBlade'].write(filename_ED_bld)
+
+            elif fst['CompElast']==2:
+                BD = self.fst_vt['BeamDyn'] 
+                BD['BldFile'] = '"'+os.path.basename(filename_BD_bld)+'"'
+                self.fst_vt['BeamDynBlade'].write(filename_BD_bld)  # TODO TODO pick up the proper blade file!
+                BD.write(filename_BD)
+            ED.write(filename_ED)
+
+
+            if fst['CompInflow']>0:
+                self.fst_vt['InflowWind'].write(filename_IW)
+
+            if fst['CompAero']>0:
+                self.fst_vt['AeroDyn15'].write(filename_AD)
+                # TODO other files
+
+            if fst['CompServo']>0:
+                self.fst_vt['ServoDyn'].write(filename_SvD)
+
+            if fst['CompHydro']==1:
+                self.fst_vt['HydroDyn'].write(filename_HD)
+
+            if fst['CompSub']==1:
+                self.fst_vt['SubDyn'].write(filename_SD)
+            elif fst['CompSub']==2:
+                raise NotImplementedError()
 
-        if fst['CompSub']==1:
-            self.fst_vt['SubDyn'].write(filename_SD)
-        elif fst['CompSub']==2:
-            raise NotImplementedError()
+            if fst['CompMooring']==1:
+                self.fst_vt['MAP'].write(filename_MD)
+            if self.fst_vt['Fst']['CompMooring']==2:
+                self.fst_vt['MoorDyn'].write(filename_MD)
 
-        if fst['CompMooring']==1:
-            self.fst_vt['MAP'].write(filename_MD)
-        if self.fst_vt['Fst']['CompMooring']==2:
-            self.fst_vt['MoorDyn'].write(filename_MD)
+        return filename
 
 
 
     def __repr__(self):
         s='<weio.FastInputDeck object>'+'\n'
         s+='filename   : '+self.filename+'\n'
+        s+='readlist   : {}'.format(self.readlist)+'\n'
         s+='version    : '+self.version+'\n'
         s+='AD version : '+self.ADversion+'\n'
         s+='fst_vt     : dict{'+','.join([k for k,v in self.fst_vt.items() if v is not None])+'}\n'
         s+='inputFiles : {}\n'.format(self.inputFiles)
+        s+='inputFilesRead : {}\n'.format(self.inputFilesRead)
         s+='\n'
         return s
 
 if __name__ == "__main__":
     fst=FASTInputDeck('NREL5MW.fst')
     print(fst)
```

### Comparing `welib-0.0.2/welib/weio/fast_input_file.py` & `welib-1.0.0/welib/airfoils/section.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,1291 +1,1419 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import range
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-try:
-    from .file import File, WrongFormatError, BrokenFormatError
-except:
-    # --- Allowing this file to be standalone..
-    class WrongFormatError(Exception):
-        pass
-    class BrokenFormatError(Exception):
-        pass
-    File = dict
-import os
+""" 
+Dynamics of a cross section
+
+Degrees of freedom:
+    - x "flapwise"
+    - y "edgewise"
+    - theta "torsion" (opposite around z) OR phi_z : positive around z
+
+We use a string to select the degrees of freedom that are active:
+    sx = 'x,y,th' : all DOF active
+    sx = 'x'      : only x active, etc.
+
+INPUTS:
+    Ux      = u['Ux'](t)    # (disturbed) wind speed (typically 0) [m/s]
+    Uy      = u['Uy'](t)    # (disturbed) wind speed (contains "Omega r"  [m/s]
+    theta_p = u['pitch'](t) # Total pitch angle (twist+pitch) [rad]
+
+Coordinate system:         
+                            ^ x_a
+                            |
+                            |
+                            |             
+                     ___.-------------...
+ y_A         _....---*                   \
+ <----- TE <        T       A       Q     |  LE
+            *------......._             ./
+                            *----------*
+
+States:
+  - q = [x, xd, xa] 
+  - x : structural motions   : e.g.  (x, y, th )  when sx=(x,y,th)
+  - xd: structural velocities: e.g.  (xd,yd,thd)  when sx=(x,y,th)
+  - xa: aerodynamic states   : e.g.  (fs)         when sxa=(fs)
+
+References:
+  [1] Branlard, Jonkman (2023) The aeroelastic cross section [TODO]
+
+"""
 import numpy as np
-import re
 import pandas as pd
+import matplotlib.pyplot as plt
+from collections import OrderedDict
+# Local
+from welib.airfoils.Polar import Polar
+from welib.system.statespace import StateSpace
+
+# Dynamic stall
+from welib.airfoils.DynamicStall import dynstall_oye_dxdt_simple
+from welib.airfoils.DynamicStall import dynstall_mhh_dxdt_simple
+from welib.airfoils.DynamicStall import dynstall_oye_output_simple
+from welib.airfoils.DynamicStall import dynstall_mhh_outputs_simple
+from welib.airfoils.DynamicStall import dynstall_oye_param_from_polar
+from welib.airfoils.DynamicStall import dynstall_mhh_param_from_polar
+from welib.airfoils.DynamicStall import dynstall_mhh_steady_simple
+from welib.airfoils.DynamicStall import dynstall_oye_steady
+# Dynamic inflow
+from welib.dyninflow.DynamicInflow import dynflow_oye_dxdt_simple
+from welib.dyninflow.DynamicInflow import dynflow_oye_steady_simple
+from welib.dyninflow.DynamicInflow import tau1_dbemt, tau2_oye
 
-__all__  = ['FASTInputFile']
-
-TABTYPE_NOT_A_TAB          = 0
-TABTYPE_NUM_WITH_HEADER    = 1
-TABTYPE_NUM_WITH_HEADERCOM = 2
-TABTYPE_NUM_NO_HEADER      = 4
-TABTYPE_NUM_BEAMDYN        = 5
-TABTYPE_MIX_WITH_HEADER    = 6
-TABTYPE_FIL                = 3
-TABTYPE_FMT                = 9999 # TODO
 
 # --------------------------------------------------------------------------------}
-# --- INPUT FILE 
+# --- Main Wrapper Class 
 # --------------------------------------------------------------------------------{
-class FASTInputFile(File):
-    """ 
-    Read/write an OpenFAST input file. The object behaves like a dictionary.
+class Section(object):
+    """Section"""
+    def __init__(self):
+        #self.arg = arg
+        # --- Main data
+        self._r_bar = None # r/R [-]
+        self._R     = None # R [m]
+        self._beta  = 0 # [rad] Twist, negative about z, typically positive
+        # Raw constant
+        self._M33   = None # 3x3 mass matrix
+        self._C33   = None # 3x3 damping matrix
+        self._K33   = None # 3x3 stiffness matrix
+        self._chord = None # chord
+        self._rho   = None # airdensity
+        self._x_AQ  = 0    # location of aerodynamic center "Q"
+        self._y_AQ  = None 
+        self._x_AT  = 0    # location of three quarter chord point "T"
+        self._y_AT  = None 
+        self._pol   = None # Polar, instance of Polar class
+        self._ppol  = None # Polar parameters
+        self._tau   = None # TODO stieg oye time constant
+        # Induction / dynamic infloe
+        self._a0      = 0
+        self._ap0     = 0
+
+#     def setup_nonlinear_model_p(M, C, K, sx='x,y,th', 
+#             rho=1.225, chord=0.2, polarFilename='tjaere11_ds.csv', drag=False,  # Aero options
+#             y_AQ=0, y_AT=None, x_AQ=0, x_AT=0,
+
+        # Simulation data
+        self.sx_sim   = None # Degree of freedom
+        self.ds_model = None
+        self.di_model = None
+        self.p_sim    = None
+        self.u_sim    = None
+        self.x0_sim   = None     # Initial condition for simulation
+        self.x0_sim_dict = None
+        self.sys_sim = None
+        self.res_sim = None
+        self.df_sim = None
+        #  
+        self.u_op     = None
 
-    Main methods
-    ------------
-    - read, write, toDataFrame, keys
-
-    Main keys
-    ---------
-    The keys correspond to the keys used in the file. For instance for a .fst file: 'DT','TMax'
-
-    Examples
-    --------
-
-        filename = 'AeroDyn.dat'
-        f = FASTInputFile(filename)
-        f['TwrAero'] = True
-        f['AirDens'] = 1.225
-        f.write('AeroDyn_Changed.dat')
+        
+    def fromOpenFAST(self, fstFilename, r_bar=1.0):
+        """ Setup section from an OpenFAST input file. """
+        pass
 
-    """
+    # --------------------------------------------------------------------------------}
+    # --- Structural model
+    # --------------------------------------------------------------------------------{
+    def setMassMatrix(self, M33=None, m=0, J_zz=0, x_G=0, y_G=0):
+        """ set the 3x3 mass matrix, either using M33 or individual components """
+        self._M33 = massMatrix(m=m, J_zz=J_zz, x_G=x_G, y_G=y_G, M33=M33, sx='x,y,th')
+        return self._M33
+
+    def setStifMatrix(self, K33=None, kxx=0, kyy=0, kzz=0, kxy=0, kxz=0, kyz=0):
+        """ set the 3x3 mass matrix, either using K33 or individual components """
+        self._K33 = stifMatrix(kxx=kxx, kyy=kyy, kzz=kzz, kxy=kxy, kxz=kxz, kyz=kyz, K33=K33, sx='x,y,th')
+        return self._K33
+
+    def setDampMatrix(self, C33=None, cxx=0, cyy=0, czz=0, cxy=0, cxz=0, cyz=0):
+        """ set the 3x3 mass matrix, either using M33 or individual components """
+        self._C33 = dampMatrix(cxx=cxx, cyy=cyy, czz=czz, cxy=cxy, cxz=cxz, cyz=cyz, C33=C33, sx='x,y,th')
+        return self._C33
+
+    @property
+    def r(self):
+        return self._r_bar * self._R
+
+    # --------------------------------------------------------------------------------}
+    # --- Structure
+    # --------------------------------------------------------------------------------{
+    def setStrucDOF(self):
+        #
+        pass
 
-    @staticmethod
-    def defaultExtensions():
-        return ['.dat','.fst','.txt','.fstf']
-
-    @staticmethod
-    def formatName():
-        return 'FAST input file'
-
-    def __init__(self, filename=None, **kwargs):
-        self._size=None
-        self._encoding=None
-        if filename:
-            self.filename = filename
-            self.read()
-        else:
-            self.filename = None
 
-    def keys(self):
-        self.labels = [ d['label'] for d in self.data if not d['isComment'] ]
-        return self.labels
-
-    def getID(self,label):
-        i=self.getIDSafe(label)
-        if i<0:
-            raise KeyError('Variable `'+ label+'` not found in FAST file:'+self.filename)
+    # --------------------------------------------------------------------------------}
+    # --- Polar 
+    # --------------------------------------------------------------------------------{
+    def polarFromCSV(self, polarFilename, fformat=None):
+        self._pol = Polar(polarFilename, fformat=fformat, radians=True, compute_params=True) # compute_params for DS
+        # TODO TODO as a trigger
+        ppol = polarParams(self._pol, chord=self._chord, tau=self._tau)
+        self._ppol = ppol
+
+    def plotPolar(self):
+        pol    = self._ppol['Polar']
+        fPolar = self._ppol['fPolar'] #['cl','cd','cm','fs','cl_inv','cl_fs'], radians=True)
+        # p['alpha_0']  = alpha_0  # TODO HARMONIZATION WITH DS
+        # p['Cl_slope'] = Cl_slope  # TODO HARMONIZATION WITH DS
+        # p['alpha_range']     = None
+        # p['alpha_range_lin'] = None
+
+        alpha = np.linspace(pol.alpha[0], pol.alpha[-1], 100)
+        M     = fPolar(alpha)
+
+
+        fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+        fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+        ax.plot(alpha*180/np.pi, M[0,:], '-', label = 'cl')
+        ax.plot(alpha*180/np.pi, M[1,:], '-', label = 'cd')
+        ax.plot(alpha*180/np.pi, M[2,:], '-', label = 'cm')
+        ax.plot(alpha*180/np.pi, M[3,:], '-', label = 'fs')
+        ax.plot(alpha*180/np.pi, M[4,:], '--', label = 'cl_inv')
+        ax.plot(alpha*180/np.pi, M[5,:], ':', label = 'cl_fs')
+
+        ax.set_xlabel('angle of attack [deg]')
+        ax.legend()
+        #plt.show()
+        return ax
+
+    # --------------------------------------------------------------------------------}
+    # --- Dynamic stall 
+    # --------------------------------------------------------------------------------{
+    def setDynStall(self, ds_model=None, **kwargs):
+        self.ds_model = ds_model
+        # TODO trigger
+
+
+    # --------------------------------------------------------------------------------}
+    # --- Dynamic inflow
+    # --------------------------------------------------------------------------------{
+    def setDynInflow(self, di_model=None, a0=0, ap0=0, **kwargs):
+        self.di_model = di_model
+        self._a0      = a0
+        self._ap0     = ap0
+        if di_model is None:
+
+            pass
+        elif di_model=='oye':
+            # Check that main variables are set
+            if self._r_bar is None:
+                raise Exception('_r_bar must be set for Oye dyninflow model')
+            if self._R is None:
+                raise Exception('_R must be set for Oye dyninflow model')
         else:
-            return i
+            raise NotImplementedError()
 
-    def getIDs(self,label):
-        I=[]
-        # brute force search
-        for i in range(len(self.data)):
-            d = self.data[i]
-            if d['label'].lower()==label.lower():
-                I.append(i)
-        if len(I)<0:
-            raise KeyError('Variable `'+ label+'` not found in FAST file:'+self.filename)
+    @property
+    def di_tau1(self):
+        if self.di_model is None:
+            return np.nan
+        if self.u_op is None:
+            raise Exception('Operational input is None. Set it.')
+        U0 = self.u_op['Ux']
+        return tau1_dbemt(self._a0, self._R, U0)
+    @property
+    def di_tau2(self):
+        if self.di_model is None:
+            return np.nan
+        return tau2_oye(self._r_bar, self.di_tau1)
+
+
+    # --------------------------------------------------------------------------------}
+    # --- Simulation 
+    # --------------------------------------------------------------------------------{
+    @property
+    def nq(self):
+        p = self.p_sim
+        return len(p['sq'].split(','))
+
+    @property
+    def q0(self):
+        return np.zeros(self.nq)
+
+    @property
+    def state_space(self):
+        """ return state space model
+        NOTE: safer to call it everytime in case number of DOF change
+        """
+        sys = StateSpace(dqdt=nonlinear_model, signature='t,q,u,p', verbose=False)
+        return sys
+
+    def calcOutput(self, t, q, u, p):
+        S = nonlinear_model(t, q, u, p, calcOutput=True)
+        return S
+
+    # For convenience
+    def Faero(self, t, q, u, p, calcOutput=False, m=None):
+        return Faero(t, q, u, p, calcOutput=calcOutput, m=m)
+
+
+
+    # TODO get rid of this
+    def setParameters(self, sx_sim=None):
+        """ setup parameters for a given simulation"""
+        # TODO rething that ..
+        #if sx_sim is not None:
+        #if ds_model is not None:
+        #if di_model is not None:
+        self.sx_sim = sx_sim
+        p = defaultParams(chord=self._chord, rho=self._rho, sx=self.sx_sim, ds=self.ds_model, di=self.di_model,
+                M=self._M33, C=self._C33, K=self._K33)
+        p['beta'] = self._beta
+        if len(p['Iq'])==0:
+            raise Exception('No states are present')
+
+        # --- Dynamic inflow / induction
+        p['a0']  = self._a0
+        p['ap0'] = self._ap0
+        p['di_tau1'] = self.di_tau1
+        p['di_tau2'] = self.di_tau2
+
+        # --- Aerodynamic parameters
+        if self._y_AQ>0: 
+            print('[WARN] y_AQ positive is unconventional')
+        p['y_AQ'] = self._y_AQ
+        if self._y_AT is None:
+            p['y_AT'] = self._y_AQ+self._chord/2 # default is approximatively half a chord behind
         else:
-            return I
-
-    def getIDSafe(self,label):
-        # brute force search
-        for i in range(len(self.data)):
-            d = self.data[i]
-            if d['label'].lower()==label.lower():
-                return i
-        return -1
-
-    # Making object an iterator
-    def __iter__(self):
-        self.iCurrent=-1
-        self.iMax=len(self.data)-1
-        return self
-
-    def __next__(self): # Python 2: def next(self)
-        if self.iCurrent > self.iMax:
-            raise StopIteration
+            p['y_AT'] = self._y_AT
+        p['x_AQ'] = self._x_AQ
+        p['x_AT'] = self._x_AT
+        if self._ppol is None:
+            raise Exception('Polar parameters need to be set')
+        p.update(self._ppol)
+        #     #     p.update({'linModel':False, 'drag':drag})
+
+        self.p_sim = p
+
+    def setInitialConditions(self, q=None, x=0, y=0, th=0, xd=0, yd=0, thd=0, 
+            fs=None, x_mhh=None,
+            wx=0, wy=0, wxr=0, wyr=0,
+            uop=None,
+            equilibrium=False,
+            di_eq=False,
+            ds_eq=False,
+            verbose=False
+            ):
+
+        p = self.p_sim
+        if p is None:
+            raise Exception('Call `setParameters` first')
+        if q is not None:
+            state0=q
         else:
-            self.iCurrent += 1
-            return self.data[self.iCurrent]
-
-    # Making it behave like a dictionary
-    def __setitem__(self,key,item):
-        I = self.getIDs(key)
-        for i in I: 
-            self.data[i]['value'] = item
-
-    def __getitem__(self,key):
-        i = self.getID(key)
-        return self.data[i]['value']
-
-    def __repr__(self):
-        s ='Fast input file: {}\n'.format(self.filename)
-        return s+'\n'.join(['{:15s}: {}'.format(d['label'],d['value']) for i,d in enumerate(self.data)])
-
-    def addKeyVal(self,key,val,descr=None):
-        d=getDict()
-        d['label']=key
-        d['value']=val
-        if descr is not None:
-            d['descr']=descr
-        self.data.append(d)
-
-    def read(self, filename=None):
-        if filename:
-            self.filename = filename
-        if self.filename:
-            if not os.path.isfile(self.filename):
-                raise OSError(2,'File not found:',self.filename)
-            if os.stat(self.filename).st_size == 0:
-                raise EmptyFileError('File is empty:',self.filename)
-            self._read()
-        else:  
-            raise Exception('No filename provided')
-
-    def _read(self):
-
-        # --- Tables that can be detected based on the "Value" (first entry on line)
-        # TODO members for  BeamDyn with mutliple key point                                                                                                                                                                                                                                                                                                        ####### TODO PropSetID is Duplicate SubDyn and used in HydroDyn
-        NUMTAB_FROM_VAL_DETECT  = ['HtFract'  , 'TwrElev'   , 'BlFract'  , 'Genspd_TLU' , 'BlSpn'        , 'WndSpeed' , 'HvCoefID' , 'AxCoefID' , 'JointID'  , 'Dpth'      , 'FillNumM'    , 'MGDpth'    , 'SimplCd'  , 'RNodes'       , 'kp_xr'      , 'mu1'           , 'TwrHtFr'   , 'TwrRe'  , 'WT_X']
-        NUMTAB_FROM_VAL_DIM_VAR = ['NTwInpSt' , 'NumTwrNds' , 'NBlInpSt' , 'DLL_NumTrq' , 'NumBlNds'     , 'NumCases' , 'NHvCoef'  , 'NAxCoef'  , 'NJoints'  , 'NCoefDpth' , 'NFillGroups' , 'NMGDepths' , 1          , 'BldNodes'     , 'kp_total'   , 1               , 'NTwrHt'    , 'NTwrRe' , 'NumTurbines']
-        NUMTAB_FROM_VAL_VARNAME = ['TowProp'  , 'TowProp'   , 'BldProp'  , 'DLLProp'    , 'BldAeroNodes' , 'Cases'    , 'HvCoefs'  , 'AxCoefs'  , 'Joints'   , 'DpthProp'  , 'FillGroups'  , 'MGProp'    , 'SmplProp' , 'BldAeroNodes' , 'MemberGeom' , 'DampingCoeffs' , 'TowerProp' , 'TowerRe', 'WindTurbines']
-        NUMTAB_FROM_VAL_NHEADER = [2          , 2           , 2          , 2            , 2              , 2          , 2          , 2          , 2          , 2           , 2             , 2           , 2          , 1              , 2            , 2               , 1           , 1        , 2 ]
-        NUMTAB_FROM_VAL_TYPE    = ['num'      , 'num'       , 'num'      , 'num'        , 'num'          , 'num'      , 'num'      , 'num'      , 'num'      , 'num'       , 'num'         , 'num'       , 'num'      , 'mix'          , 'num'        , 'num'           , 'num'       , 'num'    , 'mix']
-        # SubDyn
-        NUMTAB_FROM_VAL_DETECT  += [ 'RJointID'        , 'IJointID'        , 'COSMID'             , 'CMJointID'         ]
-        NUMTAB_FROM_VAL_DIM_VAR += [ 'NReact'          , 'NInterf'         , 'NCOSMs'             , 'NCmass'            ]
-        NUMTAB_FROM_VAL_VARNAME += [ 'BaseJoints'      , 'InterfaceJoints' , 'MemberCosineMatrix' , 'ConcentratedMasses']
-        NUMTAB_FROM_VAL_NHEADER += [ 2                 , 2                 , 2                    , 2                   ]
-        NUMTAB_FROM_VAL_TYPE    += [ 'mix'             , 'num'             , 'num'                , 'num'               ]
-
-
-        # --- Tables that can be detected based on the "Label" (second entry on line)
-        # NOTE: MJointID1, used by SubDyn and HydroDyn
-        NUMTAB_FROM_LAB_DETECT   = ['NumAlf'  , 'F_X'       , 'MemberCd1'    , 'MJointID1' , 'NOutLoc'    , 'NOutCnt'    , 'PropD'       ,'Diam'       ,'Type'           ,'LineType' ]
-        NUMTAB_FROM_LAB_DIM_VAR  = ['NumAlf'  , 'NKInpSt'   , 'NCoefMembers' , 'NMembers'  , 'NMOutputs'  , 'NMOutputs'  , 'NPropSets'   ,'NTypes'     ,'NConnects'      ,'NLines'   ]
-        NUMTAB_FROM_LAB_VARNAME  = ['AFCoeff' , 'TMDspProp' , 'MemberProp'   , 'Members'   , 'MemberOuts' , 'MemberOuts' , 'SectionProp' ,'LineTypes'  ,'ConnectionProp' ,'LineProp' ]
-        NUMTAB_FROM_LAB_NHEADER  = [2         , 2           , 2              , 2           , 2            , 2            , 2             , 2           , 2               , 2         ]
-        NUMTAB_FROM_LAB_NOFFSET  = [0         , 0           , 0              , 0           , 0            , 0            , 0             , 0           , 0               , 0         ]
-        NUMTAB_FROM_LAB_TYPE     = ['num'     , 'num'       , 'num'          , 'mix'       , 'num'        , 'num'        , 'num'         ,'mix'        ,'mix'            ,'mix'      ]
-        # SubDyn
-        NUMTAB_FROM_LAB_DETECT   += ['GuyanDampSize'     , 'YoungE'   , 'YoungE'    , 'EA'             , 'MatDens'       ]
-        NUMTAB_FROM_LAB_DIM_VAR  += [6                   , 'NPropSets', 'NXPropSets', 'NCablePropSets' , 'NRigidPropSets']
-        NUMTAB_FROM_LAB_VARNAME  += ['GuyanDampMatrix'   , 'BeamProp' , 'BeamPropX' , 'CableProp'      , 'RigidProp'     ]
-        NUMTAB_FROM_LAB_NHEADER  += [0                   , 2          , 2           , 2                , 2               ]
-        NUMTAB_FROM_LAB_NOFFSET  += [1                   , 0          , 0           , 0                , 0               ]
-        NUMTAB_FROM_LAB_TYPE     += ['num'               , 'num'      , 'num'       , 'num'            , 'num'           ]
-        # OLAF
-        NUMTAB_FROM_LAB_DETECT   += ['GridName'   ]
-        NUMTAB_FROM_LAB_DIM_VAR  += ['nGridOut'   ]
-        NUMTAB_FROM_LAB_VARNAME  += ['GridOutputs']
-        NUMTAB_FROM_LAB_NHEADER  += [0            ]
-        NUMTAB_FROM_LAB_NOFFSET  += [2            ]
-        NUMTAB_FROM_LAB_TYPE     += ['mix'        ]
-
-        FILTAB_FROM_LAB_DETECT   = ['FoilNm' ,'AFNames']
-        FILTAB_FROM_LAB_DIM_VAR  = ['NumFoil','NumAFfiles']
-        FILTAB_FROM_LAB_VARNAME  = ['FoilNm' ,'AFNames']
-
-        # Using lower case to be more tolerant..
-        NUMTAB_FROM_VAL_DETECT_L = [s.lower() for s in NUMTAB_FROM_VAL_DETECT]
-        NUMTAB_FROM_LAB_DETECT_L = [s.lower() for s in NUMTAB_FROM_LAB_DETECT]                                         
-        FILTAB_FROM_LAB_DETECT_L = [s.lower() for s in FILTAB_FROM_LAB_DETECT]
-
-
-
-
-        self.data   = []
-        self.hasNodal=False
-        self.module = None
-        #with open(self.filename, 'r', errors="surrogateescape") as f:
-        with open(self.filename, 'r', errors="surrogateescape") as f:
-            lines=f.read().splitlines()
-        # IF NEEDED> DO THE FOLLOWING FORMATTING:
-            #lines = [str(l).encode('utf-8').decode('ascii','ignore') for l in f.read().splitlines()]
-
-        # Fast files start with ! or -
-        #if lines[0][0]!='!' and lines[0][0]!='-':
-        #    raise Exception('Fast file do not start with ! or -, is it the right format?')
-
-        # Special filetypes
-        if self.detectAndReadExtPtfmSE(lines):
-            return
-        if self.detectAndReadAirfoil(lines):
-            return
-
-        # Parsing line by line, storing each line into a dictionary
-        i=0    
-        nComments  = 0
-        nWrongLabels = 0
-        allowSpaceSeparatedList=False
-        while i<len(lines):
-            line = lines[i]
-
-            # --- Read special sections
-            if line.upper().find('ADDITIONAL OUTPUTS')>0 \
-            or line.upper().find('MESH-BASED OUTPUTS')>0 \
-            or line.upper().find('OUTPUT CHANNELS'   )>0: # "OutList - The next line(s) contains a list of output parameters. See OutListParameters.xlsx for a listing of available output channels, (-)'"
-                # TODO, lazy implementation so far, MAKE SUB FUNCTION
-                parts = re.match(r'^\W*\w+', line)
-                if parts:
-                    firstword = parts.group(0).strip()
-                else:
-                    raise NotImplementedError
-                remainer  = re.sub(r'^\W*\w+\W*', '', line)
-                # Parsing outlist, and then we continue at a new "i" (to read END etc.)
-                OutList,i = parseFASTOutList(lines,i+1) 
-                d = getDict()
-                if self.hasNodal:
-                    d['label']   = firstword+'_Nodal'
-                else:
-                    d['label']   = firstword
-                d['descr']   = remainer
-                d['tabType'] = TABTYPE_FIL # TODO
-                d['value']   = ['']+OutList
-                self.data.append(d)
-                if i>=len(lines):
-                    break
-                # --- Here we cheat and force an exit of the input file
-                # The reason for this is that some files have a lot of things after the END, which will result in the file being intepreted as a wrong format due to too many comments
-                if i+2<len(lines) and (lines[i+2].lower().find('bldnd_bladesout')>0 or lines[i+2].lower().find('bldnd_bloutnd')>0):
-                    self.hasNodal=True
-                else:
-                    self.data.append(parseFASTInputLine('END of input file (the word "END" must appear in the first 3 columns of this last OutList line)',i+1))
-                    self.data.append(parseFASTInputLine('---------------------------------------------------------------------------------------',i+2))
-                    break
-            elif line.upper().find('SSOUTLIST'   )>0 or line.upper().find('SDOUTLIST'   )>0:
-                # SUBDYN Outlist doesn not follow regular format
-                self.data.append(parseFASTInputLine(line,i))
-                # OUTLIST Exception for BeamDyn
-                OutList,i = parseFASTOutList(lines,i+1) 
-                # TODO
-                for o in OutList:
-                    d = getDict()
-                    d['isComment'] = True
-                    d['value']=o
-                    self.data.append(d)
-                # --- Here we cheat and force an exit of the input file
-                self.data.append(parseFASTInputLine('END of input file (the word "END" must appear in the first 3 columns of this last OutList line)',i+1))
-                self.data.append(parseFASTInputLine('---------------------------------------------------------------------------------------',i+2))
-                break
-            elif line.upper().find('ADDITIONAL STIFFNESS')>0:
-                # TODO, lazy implementation so far, MAKE SUB FUNCTION
-                self.data.append(parseFASTInputLine(line,i))
-                i +=1
-                KDAdd = []
-                for _ in range(19):
-                    KDAdd.append(lines[i])
-                    i +=1
-                d = getDict()
-                d['label']   = 'KDAdd'   # TODO
-                d['tabType'] = TABTYPE_FIL # TODO
-                d['value']   = KDAdd
-                self.data.append(d)
-                if i>=len(lines):
-                    break
-            elif line.upper().find('DISTRIBUTED PROPERTIES')>0:
-                self.data.append(parseFASTInputLine(line,i));
-                i+=1;
-                self.readBeamDynProps(lines,i)
-                return
-
-            # --- Parsing of standard lines: value(s) key comment
-            line = lines[i]
-            d = parseFASTInputLine(line,i,allowSpaceSeparatedList)
-
-            # --- Handling of special files
-            if d['label'].lower()=='kp_total':
-                # BeamDyn has weird space speparated list around keypoint definition
-                allowSpaceSeparatedList=True
-            elif d['label'].lower()=='numcoords':
-                # TODO, lazy implementation so far, MAKE SUB FUNCTION
-                if isStr(d['value']):
-                    if d['value'][0]=='@':
-                        # it's a ref to the airfoil coord file
-                        pass
-                else:
-                    if not strIsInt(d['value']): 
-                        raise WrongFormatError('Wrong value of NumCoords')
-                    if int(d['value'])<=0:
+            state0 = setup_nonlinear_model_x0(x=x, y=y, th=th, xd=xd, yd=yd, thd=thd, 
+                    fs=fs, x_mhh=x_mhh, 
+                    wx=wx, wy=wy, wxr=wxr, wyr=wyr,
+                    p=self.p_sim)
+        if verbose:
+            state0_dict = OrderedDict((k,v) for k,v in zip(p['sq'].split(','), state0) )
+            print('q0 (user input):', dict(state0_dict))
+
+        # --- Equilibrim
+        if uop is None:
+            uop = self.u_sim
+
+        if equilibrium:
+            # We find full equilibrium
+            state0 = self.equilibrium(x0=state0, u0=uop)
+            if verbose:
+                state0_dict = OrderedDict((k,v) for k,v in zip(p['sq'].split(','), state0) )
+                print('q0 (full equil):', dict(state0_dict))
+        else:
+            if ds_eq or di_eq: 
+                q = state0
+                qx, qxd, qxa_ua, qxa_di = split_q(q, p['Iqxs'], p['Iqxsd'], p['Iqxa_ua'], p['Iqxa_di'])
+                q_full, x, xd = inflate_q(q, Iq=p['Iq'])
+                V_rel2_AC, phi_AC, alpha_AC, Vrel_AC, Uw_AC, Vel_AC, Wqs_AC, W_AC = aeroVarsSS(0, x, xd, qxa_di, p, self.u_sim, point='Q')
+                V_rel2_ds, phi_ds, alpha_ds, Vrel_ds, Uw_ds, Vel_ds, Wqs_ds, W_ds = aeroVarsSS(0, x, xd, qxa_di, p, self.u_sim, point=p['ds_inflow_point'])
+                if di_eq:
+                    if p['dynamicInflowModel'] is None:
                         pass
+                    elif p['dynamicInflowModel'] =='oye':
+                        qxa_di[:2] = dynflow_oye_steady_simple(Wqs_AC[0], p['di_k'])
+                        qxa_di[2:] = dynflow_oye_steady_simple(Wqs_AC[1], p['di_k'])
                     else:
-                        self.data.append(d); i+=1;
-                        # 3 comment lines
-                        self.data.append(parseFASTInputLine(lines[i],i)); i+=1;
-                        self.data.append(parseFASTInputLine(lines[i],i)); i+=1;
-                        self.data.append(parseFASTInputLine(lines[i],i)); i+=1;
-                        splits=cleanAfterChar(cleanLine(lines[i]),'!').split()
-                        # Airfoil ref point
-                        try:
-                            pos=[float(splits[0]), float(splits[1])]
-                        except:
-                            raise WrongFormatError('Wrong format while reading coordinates of airfoil reference')
-                        i+=1
-                        d = getDict()
-                        d['label'] = 'AirfoilRefPoint'
-                        d['value'] = pos
-                        self.data.append(d)
-                        # 2 comment lines
-                        self.data.append(parseFASTInputLine(lines[i],i)); i+=1;
-                        self.data.append(parseFASTInputLine(lines[i],i)); i+=1;
-                        # Table of coordinats itself
-                        d = getDict()
-                        d['label']     = 'AirfoilCoord'
-                        d['tabDimVar'] = 'NumCoords'
-                        d['tabType']   = TABTYPE_NUM_WITH_HEADERCOM
-                        nTabLines = self[d['tabDimVar']]-1  # SOMEHOW ONE DATA POINT LESS
-                        d['value'], d['tabColumnNames'],_  = parseFASTNumTable(self.filename,lines[i:i+nTabLines+1],nTabLines,i,1)
-                        d['tabUnits'] = ['(-)','(-)']
-                        self.data.append(d)
-                        break
-
-
-
-            #print('label>',d['label'],'<',type(d['label']));
-            #print('value>',d['value'],'<',type(d['value']));
-            #print(isStr(d['value']))
-            #if isStr(d['value']):
-            #    print(d['value'].lower() in NUMTAB_FROM_VAL_DETECT_L)
-
-                
-            # --- Handling of tables
-            if isStr(d['value']) and d['value'].lower() in NUMTAB_FROM_VAL_DETECT_L:
-                # Table with numerical values, 
-                ii             = NUMTAB_FROM_VAL_DETECT_L.index(d['value'].lower())
-                tab_type       = NUMTAB_FROM_VAL_TYPE[ii]
-                if tab_type=='num':
-                    d['tabType']   = TABTYPE_NUM_WITH_HEADER
-                else:
-                    d['tabType']   = TABTYPE_MIX_WITH_HEADER
-                d['label']     = NUMTAB_FROM_VAL_VARNAME[ii]
-                d['tabDimVar'] = NUMTAB_FROM_VAL_DIM_VAR[ii]
-                nHeaders       = NUMTAB_FROM_VAL_NHEADER[ii]
-                nTabLines=0
-                if isinstance(d['tabDimVar'],int):
-                    nTabLines = d['tabDimVar']
-                else:
-                    nTabLines = self[d['tabDimVar']]
-                #print('Reading table {} Dimension {} (based on {})'.format(d['label'],nTabLines,d['tabDimVar']));
-                d['value'], d['tabColumnNames'], d['tabUnits'] = parseFASTNumTable(self.filename,lines[i:i+nTabLines+nHeaders], nTabLines, i, nHeaders, tableType=tab_type, varNumLines=d['tabDimVar'])
-                i += nTabLines+nHeaders-1
-
-                # --- Temporary hack for e.g. SubDyn, that has duplicate table, impossible to detect in the current way...
-                # So we remove the element form the list one read
-                del NUMTAB_FROM_VAL_DETECT[ii]  
-                del NUMTAB_FROM_VAL_DIM_VAR[ii] 
-                del NUMTAB_FROM_VAL_VARNAME[ii] 
-                del NUMTAB_FROM_VAL_NHEADER[ii] 
-                del NUMTAB_FROM_VAL_TYPE   [ii] 
-                del NUMTAB_FROM_VAL_DETECT_L[ii]  
-
-            elif isStr(d['label']) and d['label'].lower() in NUMTAB_FROM_LAB_DETECT_L:
-                ii      = NUMTAB_FROM_LAB_DETECT_L.index(d['label'].lower())
-                tab_type       = NUMTAB_FROM_LAB_TYPE[ii]
-                # Special case for airfoil data, the table follows NumAlf, so we add d first
-                if d['label'].lower()=='numalf':
-                    d['tabType']=TABTYPE_NOT_A_TAB
-                    self.data.append(d)
-                    # Creating a new dictionary for the table
-                    d = {'value':None, 'label':'NumAlf', 'isComment':False, 'descr':'', 'tabType':None}
-                    i += 1
-                nHeaders       = NUMTAB_FROM_LAB_NHEADER[ii]
-                nOffset        = NUMTAB_FROM_LAB_NOFFSET[ii]
-                if nOffset>0:
-                    # Creating a dictionary for that entry
-                    dd = {'value':d['value'], 'label':d['label'], 'isComment':False, 'descr':d['descr'], 'tabType':TABTYPE_NOT_A_TAB}
-                    self.data.append(dd)
-
-                d['label']     = NUMTAB_FROM_LAB_VARNAME[ii]
-                d['tabDimVar'] = NUMTAB_FROM_LAB_DIM_VAR[ii]
-                if d['label'].lower()=='afcoeff' :
-                    d['tabType']        = TABTYPE_NUM_WITH_HEADERCOM
-                else:
-                    if tab_type=='num':
-                        d['tabType']   = TABTYPE_NUM_WITH_HEADER
+                        raise NotImplementedError()
+
+                if ds_eq:
+                    if p['dynamicStallModel'] is None:
+                        pass
+                    elif p['dynamicStallModel'] == 'mhh':
+                        qxa_ua = dynstall_mhh_steady_simple(np.sqrt(V_rel2_ds), alpha_ds, p)
+                    elif p['dynamicStallModel'] == 'oye':
+                        qxa_ua[0] = dynstall_oye_steady(alpha_ds, p)
                     else:
-                        d['tabType']   = TABTYPE_MIX_WITH_HEADER
-                if isinstance(d['tabDimVar'],int):
-                    nTabLines = d['tabDimVar']
-                else:
-                    nTabLines = self[d['tabDimVar']]
-                #print('Reading table {} Dimension {} (based on {})'.format(d['label'],nTabLines,d['tabDimVar']));
-                d['value'], d['tabColumnNames'], d['tabUnits'] = parseFASTNumTable(self.filename,lines[i:i+nTabLines+nHeaders+nOffset],nTabLines,i, nHeaders, tableType=tab_type, nOffset=nOffset, varNumLines=d['tabDimVar'])
-                i += nTabLines+1-nOffset
-
-                # --- Temporary hack for e.g. SubDyn, that has duplicate table, impossible to detect in the current way...
-                # So we remove the element form the list one read
-                del NUMTAB_FROM_LAB_DETECT[ii]  
-                del NUMTAB_FROM_LAB_DIM_VAR[ii] 
-                del NUMTAB_FROM_LAB_VARNAME[ii] 
-                del NUMTAB_FROM_LAB_NHEADER[ii] 
-                del NUMTAB_FROM_LAB_NOFFSET[ii] 
-                del NUMTAB_FROM_LAB_TYPE   [ii] 
-                del NUMTAB_FROM_LAB_DETECT_L[ii]  
-
-            elif isStr(d['label']) and d['label'].lower() in FILTAB_FROM_LAB_DETECT_L:
-                ii             = FILTAB_FROM_LAB_DETECT_L.index(d['label'].lower())
-                d['label']     = FILTAB_FROM_LAB_VARNAME[ii]
-                d['tabDimVar'] = FILTAB_FROM_LAB_DIM_VAR[ii]
-                d['tabType']   = TABTYPE_FIL
-                nTabLines = self[d['tabDimVar']]
-                #print('Reading table {} Dimension {} (based on {})'.format(d['label'],nTabLines,d['tabDimVar']));
-                d['value'] = parseFASTFilTable(lines[i:i+nTabLines],nTabLines,i)
-                i += nTabLines-1
+                        raise NotImplementedError()
+                state0 = np.concatenate((qx, qxd, qxa_ua, qxa_di)) # NOTE: assumed order here
+                if verbose:
+                    print('q0 (ds di eq)  :', dict(state0_dict))
+
+        state0_dict = OrderedDict((k,v) for k,v in zip(p['sq'].split(','), state0) )
+
+        self.x0_sim = state0
+        self.x0_sim_dict = state0_dict
+        if verbose:
+            print('q0 (final)     :', dict(state0_dict))
+        return state0 
+
+    def setConstantInputs(self, Ux=0, Uy=0, theta_p=0):
+        """ setup inputs for the non linear model, constant inputs with time """
+        self.u_sim = setup_nonlinear_model_u_cst(Ux=Ux, Uy=Uy, theta_p=theta_p)
+        self.u_op = {'Ux':Ux, 'Uy':Uy, 'theta_p':0}
+        return self.u_sim
+
+    def integrate(self, t_eval, y0=None, p=None, u=None, calc='u,y', **options):
+        #def integrate(self, t_eval, method='RK45', y0=None, p=None, u=None, calc='u,y,qd', xoffset=None, **options):
+        if y0 is None:
+            y0 = self.x0_sim.copy()
+        if p is None:
+            p = self.p_sim
+        if u is None:
+            u = self.u_sim
+
+        self.sys_sim = self.state_space
+        res, df = self.sys_sim.integrate(t_eval, p=p, u=u, y0=y0, calc=calc, **options)
+        self.res_sim = res
+        self.df_sim = df
+        return res, df
+
+    def saveSim(self, filename, df=None):
+        from welib.tools.pandalib import remap_df
+        # --- Scale
+        ColMap={'alpha_AC':'{alpha_AC}*180/np.pi',
+                'alpha_ds':'{alpha_ds}*180/np.pi',
+                'thetat':  '{thetat}*180/np.pi',
+                'theta':   '{theta}*180/np.pi',
+                'pitch':   '{pitch}*180/np.pi',
+                }
+        if df is None:
+            df = self.df_sim
+        df = remap_df(df, ColMap)
+        df.to_csv(filename, index=False, sep=',')
+
+    def plot_states(self, *args, **kwargs):
+        return self.sys_sim.plot_states(*args, **kwargs)
+
+    # --------------------------------------------------------------------------------}
+    # --- Linearization and equilibrium
+    # --------------------------------------------------------------------------------{
+    @property
+    def dx(self):
+        """ Perturtbation size for finite difference on states """
+        if self.p_sim is None:
+            raise Exception('Call setParameters before calling dx')
+        dx = setup_nonlinear_model_dx(self.p_sim)
+        return dx
+
+    @property
+    def du(self):
+        """ Perturtbation size for finite difference on inputs"""
+        du = setup_nonlinear_model_du() # Ux, Uy, theta_p
+        return du
+
+    def u0_default(self, u0=None, t=0):
+        if u0 is None:
+            u0 = self.u_sim(t)
+            print('Section: using default input: {} at t={}'.format(u0,t))
+        return u0
+
+    def equilibrium(self, x0=None, u0=None, t=0, **kwargs):
+        if x0 is None:
+            x0=self.q0
+        u0 = self.u0_default(u0, t)
+        sys = self.state_space
+        xop = sys.equilibrium(x0=x0, u0=u0, dx=self.dx, du=self.du, p=self.p_sim, **kwargs)
+        return xop
+
+    def linearize(self, x0=None, u0=None, t=0):
+        u0 = self.u0_default(u0, t)
+        if x0 is None:
+            x0 = self.equilibrium(x0=self.x0_sim, u0=u0) 
+            print('Section: linearize: using equilibrium x: {}'.format(x0))
+        sys = self.state_space
+        A, B, C, D = sys.linearize(x0, u0=u0, dx=self.dx, du=self.du, p=self.p_sim)
+        return A, B, C, D
+
+    def eigA(self, x0=None, u0=None, t=0, A=None, normQ=None, fullEV=False):
+        from welib.tools.eva import eigA
+        if A is None:
+            A,_,_,_ = self.linearize(x0, u0=u0, t=t) 
+        if len(self.p_sim['sx'])>0:
+            nq2 = len(self.p_sim['sx'].split(','))
+        else:
+            nq2=0
+        freq_d, zeta, Q, freq_0 = eigA(A, nq=nq2, fullEV=fullEV, normQ=normQ, sort=True)
+        return freq_d, zeta, Q, freq_0 , A
+
+
+    # --------------------------------------------------------------------------------}
+    # --- Parametric/Campbell
+    # --------------------------------------------------------------------------------{
+    def campbell(self, WS, RPM, Pitch, A=None, AP=None, sx_sim=None):
+        """ 
+        - WS [deg]
+        - Pitch [deg]
+        - Pitch [deg]
+        """
+        # Default arguments
+        if A is None:
+            A=np.zeros_like(WS)
+        if AP is None:
+            AP=np.zeros_like(WS)
+
+        # Prepare outputs
+        AMat = []   # A matrices
+        df   = None
+
+        qop=None
+        r = self.r
+        for i,(U0, rpm, pitch, a0, ap0) in enumerate(zip(WS, RPM, Pitch, A, AP)):
+            Omega = np.asarray(rpm) * 2*np.pi/60
+            Ux      = U0
+            Uy      = Omega * r
+            theta_p = pitch *np.pi/180
+            u0 = [Ux, Uy, theta_p]
+            # TODO update interface
+            self.setConstantInputs(Ux, Uy, theta_p=theta_p)
+            self.setDynInflow(di_model=self.di_model, a0=a0, ap0=ap0)
+            self.setDynStall(ds_model=self.ds_model)
+            self.setParameters(sx_sim=sx_sim) # TODO
+            # --- Frequencies
+            if qop is None:
+                qop=self.q0
+            qop = self.equilibrium(x0=qop, u0=u0, tol=1e-8, verbose=False)
+            A,_,_,_ = self.linearize(x0=qop, u0=u0)
+            freq_d, zeta, Q, freq_0, A = self.eigA(A=A)
+            # --- Store
+            AMat.append(A)
+            S = self.calcOutput(0, qop, self.u_sim, self.p_sim)
+            S['WS']   = U0
+            S['RPM']  = rpm
+            S['theta'] = pitch
+            for i,(f,z) in enumerate(zip(freq_0,zeta)):
+                S['f'+str(i+1)] = f
+                S['d'+str(i+1)] = z*100
+            if i==0:
+                df = pd.DataFrame(S).T
+            else:
+                dfloc = pd.DataFrame(S).T
+                df = pd.concat((df,dfloc))
+        return df, AMat
 
 
 
-            self.data.append(d)
-            i += 1
-            # --- Safety checks
-            if d['isComment']:
-                #print(line)
-                nComments +=1
-            else:
-                if hasSpecialChars(d['label']):
-                    nWrongLabels +=1
-                    #print('label>',d['label'],'<',type(d['label']),line);
-                    if i>3: # first few lines may be comments, we allow it
-                        #print('Line',i,'Label:',d['label'])
-                        raise WrongFormatError('Special Character found in Label: `{}`, for line: `{}`'.format(d['label'],line))
-                if len(d['label'])==0:
-                    nWrongLabels +=1
-            if nComments>len(lines)*0.35:
-                #print('Comment fail',nComments,len(lines),self.filename)
-                raise WrongFormatError('Most lines were read as comments, probably not a FAST Input File')
-            if nWrongLabels>len(lines)*0.10:
-                #print('Label fail',nWrongLabels,len(lines),self.filename)
-                raise WrongFormatError('Too many lines with wrong labels, probably not a FAST Input File')
-
-        # --- PostReading checks
-        labels = self.keys()
-        duplicates = set([x for x in labels if (labels.count(x) > 1) and x!='OutList' and x.strip()!='-'])
-        if len(duplicates)>0:
-            print('[WARN] Duplicate labels found in file: '+self.filename)
-            print('       Duplicates: '+', '.join(duplicates))
-            print('       It\'s strongly recommended to make them unique! ')
-#         except WrongFormatError as e:    
-#             raise WrongFormatError('Fast File {}: '.format(self.filename)+'\n'+e.args[0])
-#         except Exception as e:    
-#             raise e
-# #             print(e)
-#             raise Exception('Fast File {}: '.format(self.filename)+'\n'+e.args[0])
-
-            
-    def toString(self):
-        s=''
-        # Special file formats, TODO subclass
-        if self.module=='ExtPtfm':
-            s+='!Comment\n'
-            s+='!Comment Flex 5 Format\n'
-            s+='!Dimension: {}\n'.format(self['nDOF'])
-            s+='!Time increment in simulation: {}\n'.format(self['dt'])
-            s+='!Total simulation time in file: {}\n'.format(self['T'])
-
-            s+='\n!Mass Matrix\n'
-            s+='!Dimension: {}\n'.format(self['nDOF'])
-            s+='\n'.join(''.join('{:16.8e}'.format(x) for x in y) for y in self['MassMatrix'])
-
-            s+='\n\n!Stiffness Matrix\n'
-            s+='!Dimension: {}\n'.format(self['nDOF'])
-            s+='\n'.join(''.join('{:16.8e}'.format(x) for x in y) for y in self['StiffnessMatrix'])
-
-            s+='\n\n!Damping Matrix\n'
-            s+='!Dimension: {}\n'.format(self['nDOF'])
-            s+='\n'.join(''.join('{:16.8e}'.format(x) for x in y) for y in self['DampingMatrix'])
-
-            s+='\n\n!Loading and Wave Elevation\n'
-            s+='!Dimension: 1 time column -  {} force columns\n'.format(self['nDOF'])
-            s+='\n'.join(''.join('{:16.8e}'.format(x) for x in y) for y in self['Loading'])
-            return s
-
-        def toStringVLD(val,lab,descr):
-            val='{}'.format(val)
-            lab='{}'.format(lab)
-            if len(val)<13:
-                val='{:13s}'.format(val)
-            if len(lab)<13:
-                lab='{:13s}'.format(lab)
-            return val+' '+lab+' - '+descr.strip().strip('-').strip()+'\n'
-
-        def beamdyn_section_mat_tostring(x,K,M):
-            def mat_tostring(M,fmt='24.16e'):
-                return '\n'.join(['   '+' '.join(['{:24.16E}'.format(m) for m in M[i,:]]) for i in range(np.size(M,1))])
-            s=''
-            s+='{:.6f}\n'.format(x)
-            s+=mat_tostring(K)
-            #s+=np.array2string(K)
-            s+='\n'
-            s+='\n'
-            s+=mat_tostring(M)
-            #s+=np.array2string(M)
-            s+='\n'
-            s+='\n'
-            return s
-
-
-        for i in range(len(self.data)):
-            d=self.data[i]
-            if d['isComment']:
-                s+='{}'.format(d['value'])
-            elif d['tabType']==TABTYPE_NOT_A_TAB:
-                if isinstance(d['value'], list):
-                    sList=', '.join([str(x) for x in d['value']])
-                    s+='{} {} {}'.format(sList,d['label'],d['descr'])
-                else:
-                    s+=toStringVLD(d['value'],d['label'],d['descr']).strip()
-            elif d['tabType']==TABTYPE_NUM_WITH_HEADER:
-                if d['tabColumnNames'] is not None:
-                    s+='{}'.format(' '.join(['{:15s}'.format(s) for s in d['tabColumnNames']]))
-                #s+=d['descr'] # Not ready for that
-                    if d['tabUnits'] is not None:
-                        s+='\n'
-                        s+='{}'.format(' '.join(['{:15s}'.format(s) for s in d['tabUnits']]))
-                    newline='\n'
-                else:
-                    newline=''
-                if np.size(d['value'],0) > 0 :
-                    s+=newline
-                    s+='\n'.join('\t'.join( ('{:15.0f}'.format(x) if int(x)==x else '{:15.8e}'.format(x) )  for x in y) for y in d['value'])
-            elif d['tabType']==TABTYPE_MIX_WITH_HEADER:
-                s+='{}'.format(' '.join(['{:15s}'.format(s) for s in d['tabColumnNames']]))
-                if d['tabUnits'] is not None:
-                    s+='\n'
-                    s+='{}'.format(' '.join(['{:15s}'.format(s) for s in d['tabUnits']]))
-                if np.size(d['value'],0) > 0 :
-                    s+='\n'
-                    s+='\n'.join('\t'.join('{}'.format(x) for x in y) for y in d['value'])
-            elif d['tabType']==TABTYPE_NUM_WITH_HEADERCOM:
-                s+='! {}\n'.format(' '.join(['{:15s}'.format(s) for s in d['tabColumnNames']]))
-                s+='! {}\n'.format(' '.join(['{:15s}'.format(s) for s in d['tabUnits']]))
-                s+='\n'.join('\t'.join('{:15.8e}'.format(x) for x in y) for y in d['value'])
-            elif d['tabType']==TABTYPE_FIL:
-                #f.write('{} {} {}\n'.format(d['value'][0],d['tabDetect'],d['descr']))
-                s+='{} {} {}\n'.format(d['value'][0],d['label'],d['descr']) # TODO?
-                s+='\n'.join(fil for fil in d['value'][1:])
-            elif d['tabType']==TABTYPE_NUM_BEAMDYN:
-                data = d['value']
-                Cols =['Span'] 
-                Cols+=['K{}{}'.format(i+1,j+1) for i in range(6) for j in range(6)] 
-                Cols+=['M{}{}'.format(i+1,j+1) for i in range(6) for j in range(6)] 
-                for i in np.arange(len(data['span'])):
-                    x = data['span'][i]
-                    K = data['K'][i]
-                    M = data['M'][i]
-                    s += beamdyn_section_mat_tostring(x,K,M)
-            else:
-                raise Exception('Unknown table type for variable {}'.format(d))
-            if i<len(self.data)-1:
-                s+='\n'
+    # --------------------------------------------------------------------------------}
+    # --- IO 
+    # --------------------------------------------------------------------------------{
+    def __repr__(self):
+        s='<{} object>:\n'.format(type(self).__name__)
+        s+='Parameters:\n'
+        s+=' - rho    :            {} \n'.format(self._rho)
+        s+=' - chord  :            {} \n'.format(self._chord)
+        if self.p_sim is not None:
+            s+=' - p_sim: simulation parameters:\n'
+            s+='   - sx:            {} \n'.format(self.p_sim['sx'])
+            s+='   - sq:            {} \n'.format(self.p_sim['sq'])
+            s+='   - dynamicStallModel : {} \n'.format(self.p_sim['dynamicStallModel'])
+            s+='   - dynamicInflowModel: {} \n'.format(self.p_sim['dynamicInflowModel'])
+        if self.x0_sim is not None:
+            #s+='- x0_sim:            {} \n'.format(self.x0_sim)
+            s+='- x0_sim_dict        {} \n'.format(dict(self.x0_sim_dict))
+        s+='Useful methods:\n'
+        s+=' - setParameters\n'
+        s+=' - setInitialConditions\n'
+        s+=' - integrate(t, x0)\n'
+        s+=' - equilibrium(x0, u0)\n'
         return s
 
-    def write(self, filename=None):
-        if filename:
-            self.filename = filename
-        if self.filename:
-            self._write()
-        else:
-            raise Exception('No filename provided')
 
-    def _write(self):
-        with open(self.filename,'w') as f:
-            f.write(self.toString())
-
-    def _toDataFrame(self):
-        dfs={}
-        # Special types, TODO Subclass
-        if self.module=='ExtPtfm':
-            nDOF=self['nDOF']
-            Cols=['Time_[s]','InpF_Fx_[N]', 'InpF_Fy_[N]', 'InpF_Fz_[N]', 'InpF_Mx_[Nm]', 'InpF_My_[Nm]', 'InpF_Mz_[Nm]']
-            Cols+=['CBF_{:03d}_[-]'.format(iDOF+1) for iDOF in np.arange(nDOF)]
-            Cols=Cols[:nDOF+1]
-            #dfs['Loading']         = pd.DataFrame(data = self['Loading'],columns  = Cols)
-            dfs = pd.DataFrame(data = self['Loading'],columns  = Cols)
-
-            #Cols=['SurgeAcc_[m/s]', 'SwayAcc_[m/s]', 'HeaveAcc_[m/s]', 'RollAcc_[rad/s]', 'PitchAcc_[rad/s]', 'YawAcc_[rad/s]']
-            #Cols+=['CBQD_{:03d}_[-]'.format(iDOF+1) for iDOF in np.arange(nDOF)]
-            #Cols=Cols[:nDOF]
-            #dfs['MassMatrix']      = pd.DataFrame(data = self['MassMatrix'], columns=Cols)
-
-            #Cols=['SurgeVel_[m/s]', 'SwayVel_[m/s]', 'HeaveVel_[m/s]', 'RollVel_[rad/s]', 'PitchVel_[rad/s]', 'YawVel_[rad/s]']
-            #Cols+=['CBQD_{:03d}_[-]'.format(iDOF+1) for iDOF in np.arange(nDOF)]
-            #Cols=Cols[:nDOF]
-            #dfs['DampingMatrix']   = pd.DataFrame(data = self['DampingMatrix'], columns=Cols)
-
-            #Cols=['Surge_[m]', 'Sway_[m]', 'Heave_[m]', 'Roll_[rad]', 'Pitch_[rad]', 'Yaw_[rad]']
-            #Cols+=['CBQ_{:03d}_[-]'.format(iDOF+1) for iDOF in np.arange(nDOF)]
-            #Cols=Cols[:nDOF]
-            #dfs['StiffnessMatrix'] = pd.DataFrame(data = self['StiffnessMatrix'], columns=Cols)
-            return dfs
-
-        for i in range(len(self.data)): 
-            d=self.data[i]
-            if d['tabType'] in [TABTYPE_NUM_WITH_HEADER, TABTYPE_NUM_WITH_HEADERCOM, TABTYPE_NUM_NO_HEADER, TABTYPE_MIX_WITH_HEADER]:
-                Val= d['value']
-                if d['tabUnits'] is None:
-                    Cols=d['tabColumnNames']
-                else:
-                    Cols=['{}_{}'.format(c,u.replace('(','[').replace(')',']')) for c,u in zip(d['tabColumnNames'],d['tabUnits'])]
-                #print(Val)
-                #print(Cols)
-
-                # --- Adding some useful tabulated data for some files (Shapefunctions, polar)
-                if self.getIDSafe('BldFl1Sh(2)')>0:
-                    # Hack for blade files, we add the modes
-                    x=Val[:,0]
-                    Modes=np.zeros((x.shape[0],3))
-                    Modes[:,0] = x**2 * self['BldFl1Sh(2)'] \
-                               + x**3 * self['BldFl1Sh(3)'] \
-                               + x**4 * self['BldFl1Sh(4)'] \
-                               + x**5 * self['BldFl1Sh(5)'] \
-                               + x**6 * self['BldFl1Sh(6)'] 
-                    Modes[:,1] = x**2 * self['BldFl2Sh(2)'] \
-                               + x**3 * self['BldFl2Sh(3)'] \
-                               + x**4 * self['BldFl2Sh(4)'] \
-                               + x**5 * self['BldFl2Sh(5)'] \
-                               + x**6 * self['BldFl2Sh(6)'] 
-                    Modes[:,2] = x**2 * self['BldEdgSh(2)'] \
-                               + x**3 * self['BldEdgSh(3)'] \
-                               + x**4 * self['BldEdgSh(4)'] \
-                               + x**5 * self['BldEdgSh(5)'] \
-                               + x**6 * self['BldEdgSh(6)'] 
-                    Val = np.hstack((Val,Modes))
-                    Cols = Cols + ['ShapeFlap1_[-]','ShapeFlap2_[-]','ShapeEdge1_[-]']
-                  
-                elif self.getIDSafe('TwFAM1Sh(2)')>0:
-                    # Hack for tower files, we add the modes
-                    x=Val[:,0]
-                    Modes=np.zeros((x.shape[0],4))
-                    Modes[:,0] = x**2 * self['TwFAM1Sh(2)'] \
-                               + x**3 * self['TwFAM1Sh(3)'] \
-                               + x**4 * self['TwFAM1Sh(4)'] \
-                               + x**5 * self['TwFAM1Sh(5)'] \
-                               + x**6 * self['TwFAM1Sh(6)'] 
-                    Modes[:,1] = x**2 * self['TwFAM2Sh(2)'] \
-                               + x**3 * self['TwFAM2Sh(3)'] \
-                               + x**4 * self['TwFAM2Sh(4)'] \
-                               + x**5 * self['TwFAM2Sh(5)'] \
-                               + x**6 * self['TwFAM2Sh(6)'] 
-                    Modes[:,2] = x**2 * self['TwSSM1Sh(2)'] \
-                               + x**3 * self['TwSSM1Sh(3)'] \
-                               + x**4 * self['TwSSM1Sh(4)'] \
-                               + x**5 * self['TwSSM1Sh(5)'] \
-                               + x**6 * self['TwSSM1Sh(6)'] 
-                    Modes[:,3] = x**2 * self['TwSSM2Sh(2)'] \
-                               + x**3 * self['TwSSM2Sh(3)'] \
-                               + x**4 * self['TwSSM2Sh(4)'] \
-                               + x**5 * self['TwSSM2Sh(5)'] \
-                               + x**6 * self['TwSSM2Sh(6)'] 
-                    Val = np.hstack((Val,Modes))
-                    Cols = Cols + ['ShapeForeAft1_[-]','ShapeForeAft2_[-]','ShapeSideSide1_[-]','ShapeSideSide2_[-]']
-                elif d['label']=='AFCoeff':
-                    try:
-                        pol   = d['value']
-                        alpha = pol[:,0]*np.pi/180.
-                        Cl    = pol[:,1]
-                        Cd    = pol[:,2]
-                        Cd0   = self['Cd0']
-                        # Cn (with or without Cd0)
-                        Cn1 = Cl*np.cos(alpha)+ (Cd-Cd0)*np.sin(alpha) 
-                        Cn  = Cl*np.cos(alpha)+ Cd*np.sin(alpha) 
-                        Val=np.column_stack((Val,Cn));  Cols+=['Cn_[-]']
-                        Val=np.column_stack((Val,Cn1)); Cols+=['Cn_Cd0off_[-]']
-
-                        CnLin = self['C_nalpha']*(alpha-self['alpha0']*np.pi/180.)
-                        CnLin[alpha<-20*np.pi/180]=np.nan
-                        CnLin[alpha> 30*np.pi/180]=np.nan
-                        Val=np.column_stack((Val,CnLin)); Cols+=['Cn_pot_[-]']
-
-                        # Highlighting points surrounding 0 1 2 Cn points
-                        CnPoints = Cn*np.nan
-                        iBef2 = np.where(alpha<self['alpha2']*np.pi/180.)[0][-1]
-                        iBef1 = np.where(alpha<self['alpha1']*np.pi/180.)[0][-1]
-                        iBef0 = np.where(alpha<self['alpha0']*np.pi/180.)[0][-1]
-                        CnPoints[iBef2:iBef2+2] = Cn[iBef2:iBef2+2]
-                        CnPoints[iBef1:iBef1+2] = Cn[iBef1:iBef1+2]
-                        CnPoints[iBef0:iBef0+2] = Cn[iBef0:iBef0+2]
-                        Val=np.column_stack((Val,CnPoints)); Cols+=['Cn_012_[-]']
-                    except:
-                        pass
 
-                name=d['label']
 
-                if name=='DampingCoeffs':
-                    pass
-                else:
-                    dfs[name]=pd.DataFrame(data=Val,columns=Cols)
-            elif d['tabType'] in [TABTYPE_NUM_BEAMDYN]:
-                span = d['value']['span']
-                M    = d['value']['M']
-                K    = d['value']['K']
-                nSpan=len(span)
-                MM=np.zeros((nSpan,1+36+36))
-                MM[:,0]    = span
-                MM[:,1:37] = K.reshape(nSpan,36)
-                MM[:,37:]  = M.reshape(nSpan,36)
-                Cols =['Span'] 
-                Cols+=['K{}{}'.format(i+1,j+1) for i in range(6) for j in range(6)] 
-                Cols+=['M{}{}'.format(i+1,j+1) for i in range(6) for j in range(6)] 
-                # Putting the main terms first
-                IAll = range(1+36+36)
-                IMain= [0] + [i*6+i+1 for i in range(6)] + [i*6+i+37 for i in range(6)]
-                IOrg = IMain + [i for i in range(1+36+36) if i not in IMain]
-                Cols = [Cols[i] for i in IOrg]
-                data = MM[:,IOrg]
-                name=d['label']
-                dfs[name]=pd.DataFrame(data=data,columns=Cols)
-        if len(dfs)==1:
-            dfs=dfs[list(dfs.keys())[0]]
-        return dfs
-
-    def toGraph(self):
-        from .fast_input_file_graph import fastToGraph
-        return fastToGraph(self)
-        
+
 
 
 # --------------------------------------------------------------------------------}
-# --- SubReaders /detectors
+# --- Indices 
 # --------------------------------------------------------------------------------{
-    def detectAndReadExtPtfmSE(self,lines):
-        def readmat(n,m,lines,iStart):
-            M=np.zeros((n,m))
-            for j in np.arange(n):
-                i=iStart+j
-                M[j,:]=np.array(lines[i].split()).astype(float)
-            return M
-        if len(lines)<10:
-            return False
-        if not (lines[0][0]=='!' and lines[1][0]=='!'):
-            return False
-        if lines[1].lower().find('flex')<0:
-            return
-        if  lines[2].lower().find('!dimension')<0:
-            return
-        # --- At this stage we assume it's in the proper format
-        self.module='ExtPtfm'
-        nDOFCommon = -1
-        i=2;
-        try:
-            while i<len(lines):
-                l=lines[i].lower()
-                if l.find('!mass')==0:
-                    l=lines[i+1]
-                    nDOF=int(l.split(':')[1])
-                    if nDOF<-1 or nDOF!=nDOFCommon:
-                        raise BrokenFormatError('ExtPtfm stiffness matrix nDOF issue. nDOF common: {}, nDOF provided: {}'.format(nDOFCommon,nDOF))
-                    self.addKeyVal('MassMatrix',readmat(nDOF,nDOF,lines,i+2))
-                    i=i+1+nDOF
-                elif l.find('!stiffness')==0:
-                    l=lines[i+1]
-                    nDOF=int(l.split(':')[1])
-                    if nDOF<-1 or nDOF!=nDOFCommon:
-                        raise BrokenFormatError('ExtPtfm stiffness matrix nDOF issue nDOF common: {}, nDOF provided: {}'.format(nDOFCommon,nDOF))
-                    self.addKeyVal('StiffnessMatrix',readmat(nDOF,nDOF,lines,i+2))
-                    i=i+1+nDOF
-                elif l.find('!damping')==0:
-                    l=lines[i+1]
-                    nDOF=int(l.split(':')[1])
-                    if nDOF<-1 or nDOF!=nDOFCommon:
-                        raise BrokenFormatError('ExtPtfm damping matrix nDOF issue nDOF common: {}, nDOF provided: {}'.format(nDOFCommon,nDOF))
-                    self.addKeyVal('DampingMatrix',readmat(nDOF,nDOF,lines,i+2))
-                    i=i+1+nDOF
-                elif l.find('!loading')==0:
-                    try: 
-                        nt=int(self['T']/self['dt'])+1
-                    except:
-                        raise BrokenFormatError('Cannot read loading since time step and simulation time not properly set.')
-                    self.addKeyVal('Loading',readmat(nt,nDOFCommon+1,lines,i+2))
-                    i=i+nt+1
-                elif len(l)>0:
-                    if l[0]=='!':
-                        if l.find('!dimension')==0:
-                            self.addKeyVal('nDOF',int(l.split(':')[1]))
-                            nDOFCommon=self['nDOF']
-                        elif l.find('!time increment')==0:
-                            self.addKeyVal('dt',float(l.split(':')[1]))
-                        elif l.find('!total simulation time')==0:
-                            self.addKeyVal('T',float(l.split(':')[1]))
-                    elif len(l.strip())==0:
-                        pass
-                    else:
-                        raise BrokenFormatError('Unexcepted content found on line {}'.format(i))
-                i+=1
-        except BrokenFormatError as e:
-            raise e
-        except: 
-            raise
-
-
-        return True
+def s2Iq(sq, sxs, sdi='', sua=''):
+    """ 
+    Return indices such that
+      xs    = q[Ix]     # Structural motion, match sx
+      xsd   = q[Ixd]    # Structual velocities, match sx
+      xa    = q[Iqa]    # Aerodynamic states, match sua+sdi
+      xa_ua = q[Ixa_ua] # Aerodynamic states
+      xa_di = q[Ixa_di] # Aerodynamic states dynamic inflow
+
+    INPUTS:
+     - sq: list of all state names (structural and aero), comma separated
+           Example: sq = 'x,xd,fs'
+     - sx: list of structural state names, comma separated
+           Example: sq = 'x'
+    """
+    sq     = sq.split(',')
+    if len(sxs)>0:
+        Ixs     = [sq.index(s) for s in sxs.split(',')]
+        Ixsd    = [sq.index(s+'d') for s in sxs.split(',')]
+    else:
+        Ixs = []
+        Ixsd = []
+    if len(sua)>0:
+        Ixa_ua = [sq.index(s) for s in sua.split(',')]
+    else:
+        Ixa_ua =[]
+    if len(sdi)>0:
+        Ixa_di = [sq.index(s) for s in sdi.split(',')]
+    else:
+        Ixa_di =[]
+    return Ixs, Ixsd, Ixa_ua, Ixa_di
         
 
+def sx2I(sx):
+    """ from structural DOF string to indices """
+    D={'x':0,'y':1,'th':2,'p':2}
+    if len(sx)>0:
+        return [D[s] for s in sx.split(',')]
+    else:
+        return []
+
+def sq2I(sq, ds=None, di=None):
+    D = {'x':0,'y':1,'th':2,'ph':2,'xd':3,'yd':4,'thd':5,'pd':5}
+    iMax = 5
+    if di is not None: 
+        if di.lower()=='oye':
+            Ddi = {'wxr': iMax+1 ,'wx':iMax+2, 'wyr':iMax+3, 'wy':iMax+4}
+            iMax+=4
+        else:
+            raise NotImplementedError()
+        D.update(Ddi)
+    if ds is not None: 
+        if ds.lower()=='oye':
+            Dua = {'fs':iMax+1}
+            iMax+=1
+        elif ds.lower()=='mhh':
+            Dua = {'x1':iMax+1,'x2':iMax+2,'x3':iMax+3, 'x4':iMax+4}
+            iMax+=4
+        else:
+            raise NotImplementedError()
+        D.update(Dua)
+    return [D[s] for s in sq.split(',') if s in D.keys()]
+
+def split_q(q, Iqxs, Iqxsd, Iqxa_ua, Iqxa_di):
+    q= np.asarray(q)
+    qx     = q[Iqxs]
+    qxd    = q[Iqxsd]
+    qxa_ua = q[Iqxa_ua]
+    qxa_di = q[Iqxa_di]
+    return qx, qxd, qxa_ua, qxa_di
+
+def inflate_q(q, Iq):
+    # Expanding q into "full" arrays including inactive DOFs
+    nFull = max(6,np.max(Iq))
+    q_full = np.zeros(nFull+1) # TODO default init state for states that are not zero!
+    q_full[Iq] = q
+    x      = q_full[:3]
+    xd     = q_full[3:6]
+#     xa     = q_full[6:]
+    return q_full, x, xd
 
-    def detectAndReadAirfoil(self,lines):
-        if len(lines)<14:
-            return False
-        # Reading number of tables
-        L3 = lines[2].strip().split()
-        if len(L3)<=0:
-            return False
-        if not strIsInt(L3[0]):
-            return False
-        nTables=int(L3[0])
-        # Reading table ID
-        L4 = lines[3].strip().split()
-        if len(L4)<=nTables:
-            return False
-        TableID=L4[:nTables]
-        if nTables==1:
-            TableID=['']
-        # Keywords for file format
-        KW1=lines[12].strip().split()
-        KW2=lines[13].strip().split()
-        if len(KW1)>nTables and len(KW2)>nTables:
-            if KW1[nTables].lower()=='angle' and KW2[nTables].lower()=='minimum':
-                d = getDict(); d['isComment'] = True; d['value'] = lines[0]; self.data.append(d);
-                d = getDict(); d['isComment'] = True; d['value'] = lines[1]; self.data.append(d);
-                for i in range(2,14):
-                    splits = lines[i].split()
-                    #print(splits)
-                    d = getDict()
-                    d['label'] = ' '.join(splits[1:]) # TODO
-                    d['descr'] = ' '.join(splits[1:]) # TODO
-                    d['value'] = float(splits[0])
-                    self.data.append(d)
-                #pass
-                #for i in range(2,14):
-                nTabLines=0
-                while 14+nTabLines<len(lines) and  len(lines[14+nTabLines].strip())>0 :
-                    nTabLines +=1
-                #data = np.array([lines[i].strip().split() for i in range(14,len(lines)) if len(lines[i])>0]).astype(float)
-                #data = np.array([lines[i].strip().split() for i in takewhile(lambda x: len(lines[i].strip())>0, range(14,len(lines)-1))]).astype(float)
-                data = np.array([lines[i].strip().split() for i in range(14,nTabLines+14)]).astype(float)
-                #print(data)
-                d = getDict()
-                d['label']     = 'Polar'
-                d['tabDimVar'] = nTabLines
-                d['tabType']   = TABTYPE_NUM_NO_HEADER
-                d['value']     = data
-                if np.size(data,1)==1+nTables*3:
-                    d['tabColumnNames'] = ['Alpha']+[n+l for l in TableID for n in ['Cl','Cd','Cm']]
-                    d['tabUnits']       = ['(deg)']+['(-)' , '(-)' , '(-)']*nTables
-                elif np.size(data,1)==1+nTables*2:
-                    d['tabColumnNames'] = ['Alpha']+[n+l for l in TableID for n in ['Cl','Cd']]
-                    d['tabUnits']       = ['(deg)']+['(-)' , '(-)']*nTables
-                else:
-                    d['tabColumnNames'] = ['col{}'.format(j) for j in range(np.size(data,1))]
-                self.data.append(d)
-                return True
-
-    def readBeamDynProps(self,lines,iStart):
-        nStations=self['station_total']
-        #M=np.zeros((nStations,1+36+36))
-        M    = np.zeros((nStations,6,6))
-        K    = np.zeros((nStations,6,6))
-        span = np.zeros(nStations)
-        i=iStart;
-        try:
-            for j in range(nStations):
-                # Read span location
-                span[j]=float(lines[i]); i+=1;
-                # Read stiffness matrix
-                K[j,:,:]=np.array((' '.join(lines[i:i+6])).split()).astype(float).reshape(6,6)
-                i+=7
-                # Read mass matrix
-                M[j,:,:]=np.array((' '.join(lines[i:i+6])).split()).astype(float).reshape(6,6)
-                i+=7
-        except: 
-            raise WrongFormatError('An error occured while reading section {}/{}'.format(j+1,nStations))
-
-        d = getDict()
-        d['label']   = 'BeamProperties'
-        d['descr']   = ''
-        d['tabType'] = TABTYPE_NUM_BEAMDYN
-        d['value']   = {'span':span, 'K':K, 'M':M}
-        self.data.append(d)
 
 # --------------------------------------------------------------------------------}
-# --- Helper functions 
+# --- Aeroelastic model 
 # --------------------------------------------------------------------------------{
-def isStr(s):
-    # Python 2 and 3 compatible
-    # Two options below
-    # NOTE: all this avoided since we import str from builtins
-    # --- Version 2
-    #     isString = False;
-    #     if(isinstance(s, str)):
-    #         isString = True;
-    #     try:
-    #         if(isinstance(s, basestring)): # todo unicode as well
-    #             isString = True;
-    #     except NameError:
-    #         pass; 
-    #     return isString
-    # --- Version 1
-    #     try: 
-    #        basestring # python 2
-    #        return isinstance(s, basestring) or isinstance(s,unicode)
-    #     except NameError:
-    #          basestring=str #python 3
-    #     return isinstance(s, str)
-   return isinstance(s, str)
-
-def strIsFloat(s):
-    #return s.replace('.',',1').isdigit()
-    try:
-        float(s)
-        return True
-    except:
-        return False
-
-def strIsBool(s):
-    return s.lower() in ['true','false','t','f']
-
-def strIsInt(s):
-    s = str(s)
-    if s[0] in ('-', '+'):
-        return s[1:].isdigit()
-    return s.isdigit()    
-
-def strToBool(s):
-    return s.lower() in ['true','t']
-
-def hasSpecialChars(s):
-    # fast allows for parenthesis
-    # For now we allow for - but that's because of BeamDyn geometry members 
-    return not re.match("^[\"\'a-zA-Z0-9_()-]*$", s)
-
-def cleanLine(l):
-    # makes a string single space separated
-    l = l.replace('\t',' ')
-    l = ' '.join(l.split())
-    l = l.strip()
-    return l
-
-def cleanAfterChar(l,c):
-    # remove whats after a character
-    n = l.find(c);
-    if n>0:
-        return l[:n]
+def nonlinear_model(t, q, u, p, calcOutput=False):
+    """ 
+    Return right hand side of the first order model of 1-DOF airfoil
+
+    INPUTS:
+     - q: vector of states: (x,xd,fs)
+     - t: evaluation time, scalar
+     - u:  three options supported: 
+            - Input dictionary, function of times: u[key](t) with key in 'Ux','Uy','pitch'
+            - interpolant                           u(t)     =[Ux, Uy, pitch]
+            - values                                u        =[Ux, Uy, pitch]
+     - p: parameters
+          dictionnary with keys: 
+             rho, c
+             fPolar, tau
+             invM, K, C
+    OUTPUTS:
+     - dq/dt, dfs
+    """
+    # Compute variables useful to several other functions
+    m = calcMisc(t, q, u, p)
+
+    # Aerodynamic Force (length 3)
+    Fa, aeroOut = Faero(t, q, u, p, calcOutput=calcOutput, m=m)
+
+    # Inertial force (length 3)
+    Fs = Fstruct(t, q, u, p, calcOutput=calcOutput, m=m)
+
+    # Total force
+    F = np.zeros(3)
+    F[0] = Fa[0] + Fs[0]
+    F[1] = Fa[1] + Fs[1]
+    F[2] =-Fa[2] - Fs[2]
+
+    # Derivative of states (structural and aero)
+    dqxd = dxd_dt(t, m['qx'], m['qxd'], F[p['Ix']], p)
+    dxa  = dxa_dt(t, m['x'], m['xd'], m['qxa_ua'], m['qxa_di'], p, u)
+    dq = np.concatenate((m['qxd'], dqxd, dxa)) # NOTE: assumed order here
+
+    if calcOutput:
+        dq_full, xd, xdd = inflate_q(dq, Iq=p['Iq'])
+        d = dict()
+        ## Structural states
+        d['x']       = m['x'][0]
+        d['y']       = m['x'][1]
+        d['thetat']  = m['x'][2]
+        d['xd']      = m['xd'][0]
+        d['yd']      = m['xd'][1]
+        d['thetad']  = m['xd'][2]
+        d['xdd']     = xdd[0]
+        d['ydd']     = xdd[1]
+        d['thetadd'] = xdd[2]
+        # Inputs
+        # (NOTE: computed with "calc='u')
+        #m['Ux'], m['Uy'], m['theta_p'] = inputsAtTime(t, u)
+        # Struct
+        d['theta'] = m['theta']
+        d['rho_x'] = m['rho_x']
+        d['rho_y'] = m['rho_y']
+        ## Aero
+        d.update(aeroOut)
+        if p['dynamicStallModel'] == 'oye':
+            d['fs']  = m['qxa_ua'][0]
+            d['dfs'] = dxa        [0]
+        elif p['dynamicStallModel'] == 'mhh':
+            d['x1_ds']  = m['qxa_ua'][0]
+            d['x2_ds']  = m['qxa_ua'][1]
+            d['x3_ds']  = m['qxa_ua'][2]
+            d['x4_ds']  = m['qxa_ua'][3]
+        return pd.Series(d)
     else:
-        return l
+        return dq
 
-def getDict():
-    return {'value':None, 'label':'', 'isComment':False, 'descr':'', 'tabType':TABTYPE_NOT_A_TAB}
+def defaultParams(sx=None, ds=None, di=None, 
+        chord=np.nan, rho=np.nan,  # aero
+        M=None, C=None, K=None # system matrices
+        ):
+    # --- Dictionary
+    p ={}
+    # --- Aero
+    p['chord'] = chord   # section chord [m]
+    p['rho']   = rho     # air density [kg/m^3]
+    p['beta'] = 0        # Section twist "beta" [rad] (negative about z), typically positive
+    p['x_AQ']   = np.nan # x coordinate of aerodynamic center from airfoil origin
+    p['y_AQ']   = np.nan # y coordinate of aerodynamic center from airfoil origin
+    p['x_AT']   = np.nan # x coordinate of 3/4 point from airfoil origin
+    p['y_AT']   = np.nan # y coordinate of 3/4 point from airfoil origin
+    # Polar
+    p['fPolar']   = None   # Interpolant for polar data fPolar(alpha_rad) = 0:Cl, 1:Cd, 2:Cm, 3:Fs, 4:Cl_inv, 5:Cl_fs
+    p['alpha_0']  = np.nan
+    p['Cl_slope'] = np.nan
+    p['drag']     = None   # Include drag in calculation of aerodynamic force 
+    p['moment']   = None   # Include moment in calculation of aerodynamic force
+    p['alpha_range']     = None
+    p['alpha_range_lin'] = None
+    # --- Dynamic stall
+    p['dynamicStallModel'] = ds
+    p['ds_inflow_point'] = 'T' # Where is the inflow taken for dynamic stall T: 3/4 , Q:1/4 chord
+    # Dynamic stall Oye
+    p['tau']          = np.nan  # Time constant Oye dynamic stall
+    # Dynamic stall MHH
+    # Airfoil parameters
+    p['alpha0']     = None
+    p['Cla']        = None
+    # Polar functions
+    p['F_st']  = None
+    p['Cl_fs'] = None
+    p['Cl']    = None
+    p['Cd']    = None
+    p['Cm']    = None
+    # Dynamics constants
+    p['Tf0'] = None
+    p['Tp0'] = None
+    p['A1']  = None
+    p['A2']  = None
+    p['b1']  = None
+    p['b2']  = None
+    p['alpha0_in_x1x2']  = None
+    p['U_in_x1x2']       = None
+    p['scale_x1_x2']     = None
+    p['old_ClCd_dyn']    = None
+
+    # --- Dynamic inflow model
+    p['dynamicInflowModel'] = di
+    p['a0']  = 0    # baseline axial induction
+    p['ap0'] = 0    # baseline tangential induction
+    p['di_tau1'] = 0    # 
+    p['di_tau2'] = 0    # 
+    p['di_k']    = 0.6  # 
+
+    # --- Structural dynamics
+    #p['x_G']   = np.nan # x coordinate of center of mass from airfoil origin
+    #p['y_G']   = np.nan # y coordinate of center of mass from airfoil origin
+    #p['J_xx_A'] = np.nan # Torsional inertia  TODO where
+    #p['m']     = np.nan # airfoil (generalized) mass [kg] 
+    p['M']    = None
+    p['K']    = None
+    p['C']    = None
+    p['invM'] = None
+
+    p['sq'] = None # List of degrees of freedom including derivatives
+
+    # Options for non linear model only
+    p['linModel'] = None
+
+
+    # --- DOF
+    nMax = 3
+    if sx is None:
+        sx='x,y,th'
+    p['sx']  = sx.strip().strip(',').strip()
+    if len(sx)>0:
+        p['sq']  = p['sx'] + ',' + ','.join([s+'d' for s in p['sx'].split(',')])
+    else:
+        p['sq']  = ''
 
-def _merge_value(splits):
+    p['sua'] = '' 
+    if ds is not None:
+        if ds.lower()=='oye':
+            p['sua'] = 'fs'
+            nMax += 1
+        elif ds.lower()=='mhh':
+            p['sua'] = 'x1,x2,x3,x4'
+            nMax += 4
+        else:
+            raise NotImplementedError()
+        p['sq']  += ',' +p['sua']
 
-    merged = splits.pop(0)
-    if merged[0] == '"':
-        while merged[-1] != '"':
-            merged += " "+splits.pop(0)
-    splits.insert(0, merged)
-
-
-
-
-def parseFASTInputLine(line_raw,i,allowSpaceSeparatedList=False):
-    d = getDict()
-    #print(line_raw)
-    try:
-        # preliminary cleaning (Note: loss of formatting)
-        line = cleanLine(line_raw)
-        # Comment
-        if any(line.startswith(c) for c in ['#','!','--','==']) or len(line)==0:
-            d['isComment']=True
-            d['value']=line_raw
-            return d
-        if line.lower().startswith('end'):
-            sp =line.split()
-            if len(sp)>2 and sp[1]=='of':
-                d['isComment']=True
-                d['value']=line_raw
-
-        # Detecting lists
-        List=[];
-        iComma=line.find(',')
-        if iComma>0 and iComma<30:
-            fakeline=line.replace(' ',',')
-            fakeline=re.sub(',+',',',fakeline)
-            csplits=fakeline.split(',')
-            # Splitting based on comma and looping while it's numbers of booleans
-            ii=0
-            s=csplits[ii]
-            #print(csplits)
-            while strIsFloat(s) or strIsBool(s) and ii<len(csplits):
-                if strIsInt(s):
-                    List.append(int(s))
-                elif strIsFloat(s):
-                    List.append(float(s))
-                elif strIsBool(s):
-                    List.append(strToBool(s))
-                else:
-                    raise WrongFormatError('Lists of strings not supported.')
-                ii =ii+1
-                if ii>=len(csplits):
-                    raise WrongFormatError('Wrong number of list values')
-                s = csplits[ii]
-            #print('[INFO] Line {}: Found list: '.format(i),List)
-        # Defining value and remaining splits
-        if len(List)>=2:
-            d['value']=List
-            line_remaining=line
-            # eating line, removing each values
-            for iii in range(ii):
-                sValue=csplits[iii]
-                ipos=line_remaining.find(sValue)
-                line_remaining = line_remaining[ipos+len(sValue):]
-            splits=line_remaining.split()
-            iNext=0
+    p['sdi'] = ''
+    if di is not None:
+        if di.lower()=='oye':
+            p['sdi'] = 'wxr,wx,wyr,wy'
+            nMax += 0
         else:
-            # It's not a list, we just use space as separators
-            splits=line.split(' ')
-            _merge_value(splits)
-            s=splits[0]
-
-            if strIsInt(s):
-                d['value']=int(s)
-                if allowSpaceSeparatedList and len(splits)>1:
-                    if strIsInt(splits[1]):
-                        d['value']=splits[0]+ ' '+splits[1]
-            elif strIsFloat(s):
-                d['value']=float(s)
-            elif strIsBool(s):
-                d['value']=strToBool(s)
-            else:
-                d['value']=s
-            iNext=1
-            #import pdb  ; pdb.set_trace();
-
-        # Extracting label (TODO, for now only second split)
-        bOK=False
-        while (not bOK) and iNext<len(splits):
-            # Nasty handling of !XXX: comments
-            if splits[iNext][0]=='!' and splits[iNext][-1]==':': 
-                iNext=iNext+2
-                continue
-            # Nasty handling of the fact that sometimes old values are repeated before the label
-            if strIsFloat(splits[iNext]):
-                iNext=iNext+1
-                continue
-            else:
-                bOK=True
-        if bOK:
-            d['label']= splits[iNext].strip()
-            iNext = iNext+1
+            raise NotImplementedError()
+        p['sq']  += ',' +p['sdi']
+    p['sq'] = p['sq'].strip(',').replace(',,',',')
+
+    p['Iq'] = sq2I(p['sq'], di=di, ds=ds)
+    p['Ix'] = sx2I(p['sx'])
+    p['Iqxs'], p['Iqxsd'], p['Iqxa_ua'], p['Iqxa_di'] = s2Iq(sq=p['sq'], sxs=p['sx'], sdi=p['sdi'], sua=p['sua'])
+    p['nMax'] = nMax
+
+
+
+    # --- System matrices
+    if len(sx)>0:
+        p['m'] = M[0,0]
+        p['x_AG'] = M[1,2]/p['m'] # TODO TODO TODO
+        p['y_AG'] =-M[0,2]/p['m'] # TODO TODO TODO
+    else:
+        p['m'] = 0
+        p['x_AG'] = 0
+        p['y_AG'] = 0
+    p['M'] = massMatrix(M33=M, sx=sx)
+    p['C'] = dampMatrix(C33=C, sx=sx)
+    p['K'] = stifMatrix(K33=K, sx=sx)
+    invM = np.linalg.inv(p['M'])
+    p['invM'] = invM
+
+    return p
+
+# --------------------------------------------------------------------------------}
+# --- Structural dynamics 
+# --------------------------------------------------------------------------------{
+def massMatrix(m=0, J_zz=0, x_G=0, y_G=0, sx='x,y,th', M33=None):
+    if M33 is not None:
+        M = M33.copy()
+    else:
+        M = np.zeros((3,3))
+        M[0,0] = m
+        M[1,1] = m
+        M[2,2] = J_zz
+        if 'th' in sx:
+            M[0,2] =  m*y_G
+            M[1,2] = -m*x_G
+            M[2,0] =  m*y_G
+            M[2,1] = -m*x_G
         else:
-            #print('[WARN] Line {}: No label found -> comment assumed'.format(i+1))
-            d['isComment']=True
-            d['value']=line_raw
-            iNext = len(splits)+1
-        
-        # Recombining description
-        if len(splits)>=iNext+1:
-            d['descr']=' '.join(splits[iNext:])
-    except WrongFormatError as e:
-        raise WrongFormatError('Line {}: '.format(i+1)+e.args[0])
-    except Exception as e:
-        raise Exception('Line {}: '.format(i+1)+e.args[0])
-
-    return d
-
-def parseFASTOutList(lines,iStart):
-    OutList=[]
-    i = iStart
-    MAX=200
-    while i<len(lines) and lines[i].upper().find('END')!=0:
-        OutList.append(lines[i]) #TODO better parsing
-        #print('OutList',lines[i])
-        i += 1
-        if i-iStart>MAX :
-            raise Exception('More that 200 lines found in outlist')
-        if i>=len(lines):
-            print('[WARN] End of file reached while reading Outlist')
-    #i=min(i+1,len(lines))
-    return OutList,iStart+len(OutList)
-
-
-def extractWithinParenthesis(s):
-    mo = re.search(r'\((.*)\)', s)
-    if mo:
-        return mo.group(1)
-    return ''
-
-def extractWithinBrackets(s):
-    mo = re.search(r'\((.*)\)', s)
-    if mo:
-        return mo.group(1)
-    return ''
-
-def detectUnits(s,nRef):
-    nPOpen=s.count('(')
-    nPClos=s.count(')')
-    nBOpen=s.count('[')
-    nBClos=s.count(']')
-
-    sep='!#@#!'
-    if (nPOpen == nPClos) and (nPOpen>=nRef):
-        #that's pretty good
-        Units=s.replace('(','').replace(')',sep).split(sep)[:-1]
-    elif (nBOpen == nBClos) and (nBOpen>=nRef):
-        Units=s.replace('[','').replace(']',sep).split(sep)[:-1]
+            M[0,2] = -m*y_G
+            M[1,2] =  m*x_G
+            M[2,0] = -m*y_G
+            M[2,1] =  m*x_G
+    I = sx2I(sx)
+    M = M[np.ix_(I,I)]
+    return M
+
+def stifMatrix(kxx=0, kyy=0, kzz=0, kxy=0, kxz=0, kyz=0, sx='x,y,th', K33=None):
+    """ Return stiffness matrix, based on individual coefficients, and degrees of freedom selected `sx``"""
+    if K33 is not None:
+        K = K33.copy()
     else:
-        Units=s.split()
-    return Units
+        K = np.zeros((3,3))
+        kyx = kxy
+        kzx = kxz
+        kzy = kyz
+        K[0,:] = [kxx, kxy, kxz]
+        K[1,:] = [kyx, kyy, kyz]
+        K[2,:] = [kzx, kzy, kzz]
+    I = sx2I(sx)
+    K = K[np.ix_(I,I)]
+    return K
+
+def dampMatrix(cxx=0, cyy=0, czz=0, cxy=0, cxz=0, cyz=0, sx='x,y,th', C33=None):
+    if C33 is not None:
+        C = C33.copy()
+    else:
+        C = np.zeros((3,3))
+        cyx = cxy
+        czx = cxz
+        czy = cyz
+        C[0,:] = [cxx, cxy, cxz]
+        C[1,:] = [cyx, cyy, cyz]
+        C[2,:] = [czx, czy, czz]
+    I = sx2I(sx)
+    C = C[np.ix_(I,I)]
+    return C
+
+def dxd_dt(t, x, xd, F, p, m=None):
+    # Structure acceleration
+    RHS = - np.dot(p['C'], xd) - np.dot(p['K'], x) + F
+    xdd = np.dot(p['invM'], RHS)
+    return xdd
+
+def calcMisc(t, q, u, p):
+    """ Compute useful variables used by many subfunctions 
+    In particular, split the state vector into structural states and aero states
+    """
+    m=dict()
+    # Split state into positions and speeds (qx, qxd), uaero states (qxa_ua), dynamic inflow states (qxa_di)
+    m['qx'], m['qxd'], m['qxa_ua'], m['qxa_di'] = split_q(q, p['Iqxs'], p['Iqxsd'], p['Iqxa_ua'], p['Iqxa_di'])
+
+    # Structural states (length 3, even if not all DOFs are actice)
+    m['q_full'], m['x'], m['xd'] = inflate_q(q, Iq=p['Iq'])
+
+    # Orientation of the section
+    m['Ux'], m['Uy'], m['theta_p'] = inputsAtTime(t, u)
+    th  = m['x'][2]
+    m['omega'] = m['xd'][2]
+    m['theta'] = th + m['theta_p'] + p['beta'] 
+    m['rho_x'] = (-p['x_AG']* np.sin(m['theta']) + p['y_AG']*np.cos(m['theta']) )
+    m['rho_y'] = (-p['x_AG']* np.sin(m['theta']) + p['y_AG']*np.cos(m['theta']) )
+    return m
 
 
-def parseFASTNumTable(filename,lines,n,iStart,nHeaders=2,tableType='num',nOffset=0, varNumLines=''):
+# --------------------------------------------------------------------------------}
+# --- Aerodynamics 
+# --------------------------------------------------------------------------------{
+def dxa_dt(t, x, xd, xa_ua, xa_di, p, u):
     """ 
-    First lines of data starts at: nHeaders+nOffset
+    Return time derivative of aerodynamic states dxa/dt based on dynamic stall and dynamic inflow model 
+    The aerodynamic states are assumed to be ordered as: [xa_ua, xa_ui]
+
+    INPUTS:
+     - x :  3-array of structural states    , x,  y , theta
+     - xd:  3-array of structural velocities, xd, yd, thetad
+     - xa_ua: array of unsteady aerodynamic states
+     - xa_di: array of dynamic inflow states
+     - p    : dictionary of parameters
+     - u    : inputs, dictionary of function of time <<< Some work needed
+    """
+
+
+    dxa_ua = xa_ua*0
+    dxa_di = xa_di*0
+
+    omega = xd[2]
+
+    # Inputs
+    Ux, Uy, _ = inputsAtTime(t, u)
+
+    # Main inflow variables at dynamic stall point 
+    V_rel2_AC, phi_AC, alpha_AC, Vrel_AC, Uw_AC, Vel_AC, Wqs_AC, W_AC = aeroVarsSS(t, x, xd, xa_di, p, u, point='Q')
+    V_rel2_ds, phi_ds, alpha_ds, Vrel_ds, Uw_ds, Vel_ds, Wqs_ds, W_ds = aeroVarsSS(t, x, xd, xa_di, p, u, point=p['ds_inflow_point'])
+
+    # --- Dynamic stall (unsteady airfoil aerodynamics)
+    if p['dynamicStallModel'] is None:
+        pass
+
+    elif p['dynamicStallModel']=='oye':    
+        afCoef = p['fPolar'](alpha_ds) # 0:Cl, 1:Cd, 2:Cm, 3:Fs, 4:Cl_inv, 5:Cl_fs
+        fs_st  = afCoef[3]
+        fs = xa_ua[0]
+        dxa_ua[0] = dynstall_oye_dxdt_simple(fs, fs_st, p['tau'])
+
+    elif p['dynamicStallModel']=='mhh':    
+        U_AC     = np.sqrt(V_rel2_AC)
+        U_dot    = 0
+        dxa_ua =  dynstall_mhh_dxdt_simple(t, xa_ua, U_AC, U_dot, omega, alpha_ds, p)
+
+    else: 
+        raise NotImplementedError('Dynamic stall model: {}'.format(p['dynamicStallModel']))
+
+
+    # --- Dynamic inflow 
+    if p['dynamicInflowModel'] is None:
+        pass
+    elif p['dynamicInflowModel']=='oye':
+        if len(xa_di)==4:
+            xa_di_x = xa_di[:2]
+            xa_di_y = xa_di[2:]
+            dxa_di_x = dynflow_oye_dxdt_simple(xa_di_x, Wqs_AC[0], p['di_tau1'], p['di_tau2'], k=p['di_k'])
+            dxa_di_y = dynflow_oye_dxdt_simple(xa_di_y, Wqs_AC[1], p['di_tau1'], p['di_tau2'], k=p['di_k'])
+            dxa_di[:2] =dxa_di_x
+            dxa_di[2:] =dxa_di_y
+        elif len(xa_di)==2:
+            raise NotImplementedError()
+        else:
+            raise NotImplementedError()
+
+    else: 
+        raise NotImplementedError('Dynamic inflow model: {}'.format(p['dynamicInflowModel']))
+
     
+    dxa = np.concatenate((dxa_ua, dxa_di)) # NOTE: assumed order
+
+    return dxa
+
+
+def inputsAtTime(t, u):
+    """ Return inputs at given time """
+    if u is None:
+        raise Exception('u is None')
+    theta_p = 0
+    Ux      = 0
+    Uy      = 0
+    if hasattr(u,'keys'):
+        if 'pitch' in u.keys():
+            theta_p = u['pitch'](t)
+        if 'Ux' in u.keys():
+            Ux      = u['Ux'](t)
+        if 'Uy' in u.keys():
+            Uy      = u['Uy'](t)
+    else:
+        try:
+            Ux, Uy, theta_p = u(t) 
+        except:
+            Ux, Uy, theta_p = u
+    return Ux, Uy, theta_p
+
+def polarParams(pol, chord, cl_lin_method='leastsquare', DS_constants='OpenFAST', tau=None):
+    """ 
+    Set aerodynamic parameters related to polars
+    """
+    # Return interpolant
+    fPolar = pol.interpolant(variables=['cl','cd','cm','fs','cl_inv','cl_fs'], radians=True)
+
+    p=dict()
+    p['Polar'] = pol # backup
+    p['fPolar'] = fPolar
+
+    # Linear region
+    linear_region = np.array([-5, 10])*np.pi/180
+    Cl_slope, alpha_0 = pol.cl_linear_slope(window=linear_region, method=cl_lin_method, radians=True)
+    #print('Cl_slope',Cl_slope, '[1/rad]  -    alpha_0', alpha_0*180/np.pi,'[deg]')
+
+    p['alpha_0']  = alpha_0  # TODO HARMONIZATION WITH DS
+    p['Cl_slope'] = Cl_slope  # TODO HARMONIZATION WITH DS
+    p['alpha_range']     = None
+    p['alpha_range_lin'] = None
+
+    # Dynamic stall
+    p.update(dynstall_mhh_param_from_polar(pol, chord, constants=DS_constants))
+    p.update(dynstall_oye_param_from_polar(pol, tau=tau)) # TODO
+    return p
+
+
+def aeroVarsSS(t, x, xd, xa_di, p, u, point='Q'):
+    """ 
+    Returns main aerodynamic variables based on state space inputs
+
+    INPUTS:
+     - x  : full structural motions    (x , y , t )
+     - xd : full structural velocities (xd, yd, td)
+     - xa_di : aerodynamic states for dynamic inflow
+     - u  : dictionary of inputs at time t, keys: Ux, Uy, theta_p
+     - p: parameters, dictionnary with keys:
+           rho, c,
+           fPolar, dynamicStall
+    OUTPUTS:
+     - F: aerodynamic force in each structural DOF
+    """
+    # From states to local variables
+    x, y ,th  = x
+    xd_A, yd_A, omega = xd
+
+    # Inputs
+    Ux, Uy, theta_p = inputsAtTime(t, u)
+    U = [Ux, Uy]
+
+    # Total torsion of the section (typically negative)
+    theta = th + theta_p + p['beta'] 
+
+    # --- Structural velocities at point of interest (Q, or T)
+    if point == 'Q':
+        x_AP=p['x_AQ']
+        y_AP=p['y_AQ']
+    elif point == 'T':
+        x_AP=p['x_AT']
+        y_AP=p['y_AT']
+    else:
+        raise NotImplementedError()
+    # Velocity at point P
+    xd_P = xd_A + omega * (-x_AP* np.sin(theta) + y_AP*np.cos(theta) )
+    yd_P = yd_A - omega * ( x_AP* np.cos(theta) + y_AP*np.sin(theta) )
+    Vel = [xd_P, yd_P]
+
+    # Induction 
+    W, Wqs = inducedVelocities(xa_di, U[0], U[1], Vel[0], Vel[1], p)
+
+    Vrel, Vrel2, phi, alpha =  aeroTriangle(U[0], U[1], W[0], W[1], Vel[0], Vel[1], theta, smallAngles=False)
+
+    return Vrel2, phi, alpha, Vrel, U, Vel, Wqs, W
+
+
+def inducedVelocities(xa_di, Ux, Uy, Velx, Vely, p):
+    # Inflow without induction
+    Vx = Ux - Velx
+    Vy = Uy - Vely
+    # Induced velocities
+    Wqs = [-p['a0']* Vx,  p['ap0'] * Vy ]
+    if len(xa_di)==0:
+        W = Wqs
+    elif len(xa_di)==2:
+        raise NotImplementedError()
+    elif len(xa_di)==4:
+        W = [xa_di[1], xa_di[3]]
+    else:
+        raise NotImplementedError()
+    return W, Wqs
+
+
+def Fstruct(t, q, u, p, calcOutput=False, m=None):
+    if m is None:
+        m = calcMisc(t, q, u, p)
+    Fs = np.zeros(3)
+    Fs[0] = p['m'] * m['omega']**2 * m['rho_x']
+    Fs[1] = p['m'] * m['omega']**2 * m['rho_y']
+    #print(Fs)
+    return Fs
+
+def Faero(t, q, u, p, calcOutput=False, m=None):
+    """ 
+    Returns aerodynamic force (in inertial frame) based on states 
+
+    INPUTS:
+     - x  : structural motions   : e.g. (x , y , t )
+     - xd : structural velocities: e.g. (xd, yd, td)
+     - xa : aerodynamic states: e.g. (separation state for dynamic stall)
+     - u: Input dictionary, function of times: u[key](t) with key in 'V0','pitch'
+     - p: parameters, dictionnary with keys:
+           rho, c,
+           fPolar, dynamicStall
+    OUTPUTS:
+     - F: aerodynamic force in each structural DOF
+     - aeroOut: dictionary of additional outputs
     """
-    Tab = None
-    ColNames = None
-    Units = None
+    if m is None:
+        m = calcMisc(t, q, u, p)
+    x, xd, qxa_ua, qxa_di = m['x'], m['xd'], m['qxa_ua'], m['qxa_di'] 
+
+
+    # Inputs
+    Ux, Uy, theta_p = inputsAtTime(t, u)
+    omega = xd[2]
     
+    # Inflow
+    V_rel2_AC, phi_AC, alpha_AC, Vrel_AC, Uw_AC, Vel_AC, Wqs_AC, W_AC = aeroVarsSS(t, x, xd, qxa_di, p, u, point='Q')
+    V_rel2_ds, phi_ds, alpha_ds, Vrel_ds, Uw_ds, Vel_ds, Wqs_ds, W_ds = aeroVarsSS(t, x, xd, qxa_di, p, u, point=p['ds_inflow_point'])
+    U_AC = np.sqrt(V_rel2_AC)
+
+    # Quasi-steady Polar data at ds_inflow_point for now
+    Cl_qs, Cd_qs, Cm_qs, fs_qs, Cl_inv, Cl_fs = aeroCoef(alpha_ds, p['fPolar'], drag=p['drag'], moment=p['moment'])
+
+    # TODO TODO DS Wrapper
+    if p['dynamicStallModel'] is None:
+        Cl_dyn, Cd_dyn, Cm_dyn = Cl_qs, Cd_qs, Cm_qs
+
+    elif p['dynamicStallModel']=='oye':
+        # From states to local variables
+        fs = qxa_ua[0]
+        Cl_dyn, Cd_dyn, Cm_dyn = dynstall_oye_output_simple(fs, Cl_fs, Cl_inv, Cl_qs, Cd_qs, Cm_qs)
+
+    elif p['dynamicStallModel']=='mhh':
+        U_dot    = 0
+        Cl_dyn, Cd_dyn, Cm_dyn = dynstall_mhh_outputs_simple(t, qxa_ua, U_AC, U_dot, omega, alpha_ds, p, calcOutput=False)
+    else:
+        raise NotImplementedError(p['dynamicStallModel'])
 
-    if len(lines)!=n+nHeaders+nOffset:
-        raise BrokenFormatError('Not enough lines in table: {} lines instead of {}\nFile:{}'.format(len(lines)-nHeaders,n,filename))
-    try:
-        if nHeaders==0:
-            # Extract number of values from number of numerical values on first line
-            numeric_const_pattern = r'[-+]? (?: (?: \d* \. \d+ ) | (?: \d+ \.? ) )(?: [Ee] [+-]? \d+ ) ?'
-            rx = re.compile(numeric_const_pattern, re.VERBOSE)
-            header = cleanAfterChar(lines[nOffset], '!')
-            if tableType=='num':
-                dat= np.array(rx.findall(header)).astype(float)
-                ColNames=['C{}'.format(j) for j in range(len(dat))]
-            else:
-                raise NotImplementedError('Reading FAST tables with no headers for type different than num not implemented yet')
+    # 
+    if p['linModel']:
+        Cl_lin = p['Cl_slope'] *(alpha_ds - p['alpha_0']) # TODO which alpha..
+        Cl_dyn = Cl_lin
+    
+    # Compute aerodynamic loads at airfoil Origin (point A)
+    # NOTE: we can use alpha_AC or theta, this is used to transfer the moment from Q to A
+    #       the alpha used here needs to be consistent with phi. We need phi_X = theta + alpha_X
+    F_A, F_Q = aeroLoads(p['rho'], p['chord'], V_rel2_AC, phi_AC, Cl_dyn, Cd_dyn, Cm_dyn, alpha_AC, x_AC=p['x_AQ'], y_AC=p['y_AQ'], smallAngles=p['linModel'])
+
+    if p['linModel']:
+        print('>>> Clqs:{:.2f} Cl:{:.2f} Cllin{:.2f} - phi:{:.1f} alpha:{:.1f}'.format(afCoef[0],Cl_dyn, Cl_lin,phi_AC*180/np.pi,alpha_ds*180/np.pi))
+    #, alpha, Cl_dyn, fs_st
+
+    aeroOut = None
+    if calcOutput:
+        # Inflow without induction
+        Vx = Uw_AC[0] - Vel_AC[0]
+        Vy = Uw_AC[1] - Vel_AC[1]
+        if Vx==0:
+            Vx=1e6
+        if Vy==0:
+            Vy=1e6
+        aqs = -Wqs_AC[0]/Vx
+        a   =   -W_AC[0]/Vx
+        apqs = Wqs_AC[1]/Vy
+        ap   =   W_AC[1]/Vy
+        aeroOut  = {'alpha_AC':alpha_AC, 'U_AC':U_AC}
+        aeroOut.update({'alpha_ds':alpha_ds, 'omega':omega})
+        aeroOut.update({'Cl_qs':Cl_qs, 'Cd_qs':Cd_qs, 'Cm_qs':Cm_qs})
+        aeroOut.update({'Cl_dyn':Cl_dyn, 'Cd_dyn':Cd_dyn, 'Cm_dyn':Cm_dyn})
+        aeroOut.update({'Vrel_x_AC': Vrel_AC[0], 'Vrel_y_AC': Vrel_AC[1]})
+        aeroOut.update({'Vrel_x_ds': Vrel_ds[0], 'Vrel_y_ds': Vrel_ds[1]})
+        aeroOut.update({'Uw_x_AC': Uw_AC[0]  , 'Uw_y_AC':Uw_AC[1]})
+        aeroOut.update({'Vel_x_AC':Vel_AC[0], 'Vel_y_AC':Vel_AC[1]})
+        aeroOut.update({'Vel_x_ds':Vel_ds[0], 'Vel_y_ds':Vel_ds[1]})
+        aeroOut.update({'Wqs_x_AC':Wqs_AC[0], 'Wqs_y_AC':Wqs_AC[1]})
+        aeroOut.update({'Wdyn_x_AC':W_AC[0], 'Wdyn_y_AC':  W_AC[1]})
+        aeroOut.update({'a':a, 'ap':ap})
+        aeroOut.update({'aqs':aqs, 'apqs':apqs})
+        aeroOut.update({'L': F_Q[0], 'D': F_Q[1], 'M': F_Q[2]})
+        aeroOut.update({'Fx':F_A[0], 'Fy':F_Q[1], 'Mz':F_A[2]})
+    return F_A, aeroOut
+
+
+# --------------------------------------------------------------------------------}
+# --- Aerodynamic, low level functions 
+# --------------------------------------------------------------------------------{
+def aeroLoads(rho, c, Vrel2, phi, Cl, Cd, Cm, alpha=None, theta=None, x_AC=0, y_AC=0, smallAngles=False):
+    """ 
+    Return Aerodynamic loads at airfoil origin
+    low level function 
+
+    NOTE: Vrel, phi need to be at the same point
+          if alpha is provided it also need to be at the same point! 
+    """
+    L = 1/2*rho*c   *Vrel2*Cl
+    D = 1/2*rho*c   *Vrel2*Cd
+    M = 1/2*rho*c**2*Vrel2*Cm
+    if smallAngles:
+        Fx =   L       + D * phi
+        Fy =  -L * phi + D
+        Mz = 1/2*rho*c*Vrel2*( c*Cm -Cl*(y_AC + x_AC*alpha) + Cd*(x_AC-y_AC*alpha ))
+    else:
+        Fx =  L*np.cos(phi)+D*np.sin(phi)
+        Fy = -L*np.sin(phi)+D*np.cos(phi)
+        if theta is not None:
+            Mz = M - Fx * (-x_AC * np.sin(theta)+y_AC*np.cos(theta)) + Fy * (x_AC*np.cos(theta) + y_AC*np.sin(theta))
+        elif alpha is not None:
+            Mz = 1/2*rho*c*Vrel2*( c*Cm -Cl*(y_AC*np.cos(alpha) + x_AC*np.sin(alpha)) + Cd*(x_AC*np.cos(alpha)-y_AC*np.sin(alpha) ))
+        else:
+            raise NotImplementedError('Provide alpha or theta')
+    return np.array([Fx, Fy, Mz]), np.array([L,D,M])
+
+def aeroTriangle(Ux, Uy, Wx, Wy, Velx, Vely, theta, smallAngles=False):
+    """ 
+    Return velocity triangle variables Vrel2, phi, alpha
+    low level function
+    Inputs may be at the aerodynamic center of three quarter point.
+
+    INPUTS:
+     - U: (disturbed) inflow/wind
+     - W: induced velocities
+     - Vel: elastic velocities
+     - theta : total pitch angle (negative about z) [rad]
+              theta = theta_t + theta_p + Beta
+                      theta_t: torsion
+                      theta_p: pitch angle
+                      Beta: twist angle
+              
+    """
+    # Relative velocity
+    Vrelx = Ux - Velx + Wx
+    Vrely = Uy - Vely + Wy
+    Vrel2 = Vrelx**2 + Vrely**2
+    # Flow angle
+    if smallAngles:
+        phi = Vrelx/Vrely
+    else:
+        phi = np.arctan2(Vrelx, Vrely) # [rad]
+    # Angle of attack
+    alpha = phi - theta    # [rad]
+
+    # TODO
+    if smallAngles:
+        alpha_deg = alpha*180/np.pi # [deg]
+        if alpha_deg>15 or alpha_deg<-15:
+            print('>>> Alpha is beyond linear region {:.2f} deg'.format(alpha_deg))
+    if alpha > np.pi:
+        alpha = alpha-2*np.pi
+    if alpha < -np.pi:
+        alpha = alpha+2*np.pi
+    # TODO TODO TODO
+    # input polar doesn't not have data from -180 180..
+    if alpha>np.pi/2:
+        alpha=np.pi/2
+    if alpha<-np.pi/2:
+        alpha=-np.pi/2
 
-        elif nHeaders>=1:
-            # Extract column names
-            i = 0
-            sTmp = cleanLine(lines[i])
-            sTmp = cleanAfterChar(sTmp,'[')
-            sTmp = cleanAfterChar(sTmp,'(')
-            sTmp = cleanAfterChar(sTmp,'!')
-            sTmp = cleanAfterChar(sTmp,'#')
-            if sTmp.startswith('!'):
-                sTmp=sTmp[1:].strip()
-            ColNames=sTmp.split()
-        if nHeaders>=2:
-            # Extract units
-            i = 1
-            sTmp = cleanLine(lines[i])
-            sTmp = cleanAfterChar(sTmp,'!')
-            sTmp = cleanAfterChar(sTmp,'#')
-            if sTmp.startswith('!'):
-                sTmp=sTmp[1:].strip()
-
-            Units = detectUnits(sTmp,len(ColNames))
-            Units = ['({})'.format(u.strip()) for u in Units]
-            # Forcing user to match number of units and column names
-            if len(ColNames) != len(Units):
-                print(ColNames)
-                print(Units)
-                print('[WARN] {}: Line {}: Number of column names different from number of units in table'.format(filename, iStart+i+1))
-
-        nCols=len(ColNames)
-
-        if tableType=='num':
-            if n==0:
-                Tab = np.zeros((n, nCols))
-            for i in range(nHeaders+nOffset,n+nHeaders+nOffset):
-                l = cleanAfterChar(lines[i].lower(),'!')
-                l = cleanAfterChar(l,'#')
-                v = l.split()
-                if len(v) != nCols:
-                    # Discarding SubDyn special cases
-                    if ColNames[-1].lower() not in ['nodecnt']:
-                        print('[WARN] {}: Line {}: number of data different from number of column names. ColumnNames: {}'.format(filename, iStart+i+1, ColNames))
-                if i==nHeaders+nOffset:
-                    # Node Cnt
-                    if len(v) != nCols:
-                        if ColNames[-1].lower()== 'nodecnt':
-                            ColNames = ColNames+['Col']*(len(v)-nCols)
-                            Units    = Units+['Col']*(len(v)-nCols)
-
-                    nCols=len(v)
-                    Tab = np.zeros((n, nCols))
-                # Accounting for TRUE FALSE and converting to float
-                v = [s.replace('true','1').replace('false','0').replace('noprint','0').replace('print','1') for s in v]
-                v = [float(s) for s in v[0:nCols]]
-                if len(v) < nCols:
-                    raise Exception('Number of data is lower than number of column names')
-                Tab[i-nHeaders-nOffset,:] = v
-        elif tableType=='mix':
-            # a mix table contains a mixed of strings and floats
-            # For now, we are being a bit more relaxed about the number of columns
-            if n==0:
-                Tab = np.zeros((n, nCols)).astype(object)
-            for i in range(nHeaders+nOffset,n+nHeaders+nOffset):
-                l = lines[i]
-                l = cleanAfterChar(l,'!')
-                l = cleanAfterChar(l,'#')
-                v = l.split()
-                if l.startswith('---'):
-                    raise BrokenFormatError('Error reading line {} while reading table. Is the variable `{}` set correctly?'.format(iStart+i+1, varNumLines))
-                if len(v) != nCols:
-                    # Discarding SubDyn special cases
-                    if ColNames[-1].lower() not in ['cosmid', 'ssifile']:
-                        print('[WARN] {}: Line {}: Number of data is different than number of column names. Column Names: {}'.format(filename,iStart+1+i, ColNames))
-                if i==nHeaders+nOffset:
-                    if len(v)>nCols:
-                        ColNames = ColNames+['Col']*(len(v)-nCols)
-                        Units    = Units+['Col']*(len(v)-nCols)
-                    nCols=len(v)
-                    Tab = np.zeros((n, nCols)).astype(object)
-                v=v[0:min(len(v),nCols)]
-                Tab[i-nHeaders-nOffset,0:len(v)] = v
-            # If all values are float, we convert to float
-            if all([strIsFloat(x) for x in Tab.ravel()]):
-                Tab=Tab.astype(float)
+    return [Vrelx, Vrely], Vrel2, phi, alpha
+
+def polarInterpolant(filename, fformat=None, variables='cl,cd,cm,fs,cl_inv,cl_fs'):
+    """ 
+    Return a polar interpolant `fPolar` from a polar input file
+    The function `fPolar` has the interface:
+        afCoef = fPolar(alpha) 
+    where afCoef is defined by the list of `variables` given as argument.
+    By Default:
+        # 0:Cl, 1:Cd, 2:Cm, 3:Fs, 4:Cl_inv, 5:Cl_fs
+        Cl_qs, Cd_qs, Cm_qs, fs_qs, Cl_inv, Cl_fs = afCoef
+    """
+    pol = Polar(filename, fformat=fformat)
+    fPolar = pol.interpolant(variables=variables.split(','), radians=True)
+    return pol, fPolar
+
+def aeroCoef(alpha, fPolar, drag=True, moment=True):
+    """ 
+    Return quasi steady aerodynamic coefficients for a given angle of attack
+    INPUTS:
+     - alpha : angle of attack [rad]
+     - fPolar: interpolant function as returned by function polarInterpolant
+    """
+    # TODO Re interpolation
+    afCoef = fPolar(alpha) # 0:Cl, 1:Cd, 2:Cm, 3:Fs, 4:Cl_inv, 5:Cl_fs
+    # NOTE: order here depends on "variables" provided when generating the interpolant
+    Cl_qs, Cd_qs, Cm_qs, fs_qs, Cl_inv, Cl_fs = afCoef
+    if not drag:
+        Cd_qs =0
+    if not moment:
+        Cm_qs = 0
+    return Cl_qs, Cd_qs, Cm_qs, fs_qs, Cl_inv, Cl_fs 
+
+
+
+# --------------------------------------------------------------------------------}
+# --- Setup simulation
+# --------------------------------------------------------------------------------{
+def setup_nonlinear_model_p(M, C, K, sx='x,y,th', 
+        rho=1.225, chord=0.2, polarFilename='tjaere11_ds.csv', drag=False,  # Aero options
+        y_AQ=0, y_AT=None, x_AQ=0, x_AT=0,
+        ds='oye', tau=0.08,  # tau: used for Oye, but should be taken from Polar!
+        di=None):
+    """ setup parameters for the non linear model"""
+    # 
+    p = defaultParams(chord=chord, rho=rho, sx=sx, ds=ds, di=di,
+            M=M, C=C, K=K)
+
+    # --- Aerodynamic parameters
+    if y_AQ>0: 
+        print('[WARN] y_AQ positive is unconventional')
+    p['y_AQ'] = y_AQ
+    if y_AT is None:
+        p['y_AT'] = y_AQ+chord/2 # default is approximatively half a chord behind
+    else:
+        p['y_AT'] = y_AT
+    p['x_AQ'] = x_AQ
+    p['x_AT'] = x_AT
+
+    # Read polar
+    pol = Polar(polarFilename, fformat=None, radians=True, compute_params=True) # compute_params for DS
+    ppol = polarParams(pol, chord=p['chord'], tau=tau)
+    p.update(ppol)
+
+#     # --- Dictionary
+#     p.update({'linModel':False, 'drag':drag})
+    return p
+
+
+def setup_nonlinear_model_u_cst(Ux, Uy, theta_p):
+    """ setup inputs for the non linear model, constant inputs with time """
+    u = OrderedDict()
+    u['Ux']    = lambda t: Ux
+    u['Uy']    = lambda t: Uy
+    u['pitch'] = lambda t: theta_p
+    return u
+
+def setup_nonlinear_model_x0(x=0, y=0, th=0, xd=0, yd=0, thd=0, fs=None, x_mhh=None, wx=0, wy=0, wxr=0, wyr=0, p=None):
+    """ setup initial conditions for the non linear model"""
+    xs  = np.array([x, y, th])
+    xsd = np.array([xd, yd, thd])
+
+    if p['dynamicStallModel'] is None:
+        xua = np.array([])
+    elif p['dynamicStallModel'].lower() == 'oye':
+            if fs is None:
+                # TODO
+                print('TODO figure out angle of attack')
+                # fs_i  = p['fPolar'](alphai*np.pi/180)[3] # initial position
+                xua = np.array([0])
+            else:
+                xua = np.array([fs])
+    elif p['dynamicStallModel'].lower() == 'mhh':
+        if x_mhh is None:
+            xua = np.array([0, 0, 0, 0])
         else:
-            raise Exception('Unknown table type')
+            raise NotImplementedError()
+    else:
+        NotImplementedError()
+
+    if p['dynamicInflowModel'] is None:
+        xdi = np.array([])
+    elif p['dynamicInflowModel'].lower() == 'oye':
+        # TODO
+        xdi = np.array([wxr,wx,wyr,wy]) # Whatch out for order here
+    else:
+        NotImplementedError()
+    q_full = np.concatenate((xs,xsd,xdi,xua))
+    state0 = q_full[p['Iq']]
+    return state0
+
 
-        ColNames = ColNames[0:nCols]
-        if Units is not None:
-            Units    = Units[0:nCols]
-            Units    = ['('+u.replace('(','').replace(')','')+')' for u in Units]
-        if nHeaders==0:
-            ColNames=None
-            
-    except Exception as e:    
-        raise BrokenFormatError('Line {}: {}'.format(iStart+i+1,e.args[0]))
-    return Tab, ColNames, Units
-
-
-def parseFASTFilTable(lines,n,iStart):
-    Tab = []
-    try:
-        i=0
-        if len(lines)!=n:
-            raise WrongFormatError('Not enough lines in table: {} lines instead of {}'.format(len(lines),n))
-        for i in range(n):
-            l = lines[i].split()
-            #print(l[0].strip())
-            Tab.append(l[0].strip())
-            
-    except Exception as e:    
-        raise Exception('Line {}: '.format(iStart+i+1)+e.args[0])
-    return Tab
-
-
-if __name__ == "__main__":
-    pass
-    #B=FASTIn('Turbine.outb')
 
+def setup_nonlinear_model_dx(p):
+    nFull = max(6,np.max(p['Iq']))
+    dq_full = np.zeros(nFull+1) 
+    c = p['chord']
+
+    dq_full[:3]  = [0.001*c,0.001*c,0.001]   # x,y,th
+    dq_full[3:6] = [0.001,  0.001,  0.001]   # xd,yd,thd
+    dq_full[6:]  = 0.001  #... TODO
+
+    dq_full[:3]  = [0.01*c,0.01*c,0.01]   # x,y,th
+    dq_full[3:6] = [0.01,  0.01,  0.01]   # xd,yd,thd
+    dq_full[6:]  = 0.01  #... TODO
+    #####
+    dq_full[:3]  = [0.1*c,0.1*c, 1*np.pi/180]   # x,y,th
+    dq_full[3:6] = [5. *c,5. *c, 40.]   # xd,yd,thd # TODO
+    dq_full[6:]  =  0.1  #... TODO
+    dx = dq_full[p['Iq']]
+    return dx
+
+def setup_nonlinear_model_du(*args, **kwargs):
+    du = np.array((0.01,0.01,0.001)) # Ux, Uy, theta_p
+    #du = np.array((0.05,0.05, 1*np.pi/180)) # Ux, Uy, theta_p
+    return du
+
+
+if __name__ == '__main__':
+    #M = massMatrix(10,100,1,2,sx='x,y,th')
+    #print(M)
+#     polarInterpolant('data/tjaere11_ds.csv')
+
+    Ix, Ixd, Ixa_ua, Ixa_di = s2Iq(sq='x,xd,fs,wxr', sx='x', sdi='', sua='fs')
+    print('Ix    ',Ix)
+    print('Ixd   ',Ixd   )
+    print('Ixa_ua',Ixa_ua)
+    print('Ixa_di',Ixa_di)
```

### Comparing `welib-0.0.2/welib/weio/fast_input_file_graph.py` & `welib-1.0.0/welib/weio/fast_input_file_graph.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,32 +8,35 @@
 # except ImportError:
 from welib.FEM.graph import *
 
 
 # --------------------------------------------------------------------------------}
 # --- Wrapper to convert a "fast" input file dictionary into a graph
 # --------------------------------------------------------------------------------{
-def fastToGraph(data):
+def fastToGraph(data, **kwargs):
     if 'BeamProp' in data.keys():
-        return subdynToGraph(data)
+        return subdynToGraph(data, **kwargs)
     
     if 'SmplProp' in data.keys():
-        return hydrodynToGraph(data)
+        return hydrodynToGraph(data, **kwargs)
 
     if 'DOF2Nodes' in data.keys():
-        return subdynSumToGraph(data)
+        return subdynSumToGraph(data, **kwargs)
 
     raise NotImplementedError('Graph for object with keys: {}'.format(data.keys()))
 
 # --------------------------------------------------------------------------------}
 # --- SubDyn
 # --------------------------------------------------------------------------------{
-def subdynToGraph(sd):
+def subdynToGraph(sd, propToNodes=False, propToElem=False):
     """
     sd: dict-like object as returned by weio
+
+    -propToNodes: if True, the element properties are also transferred to the nodes for convenience.
+                 NOTE: this is not the default because a same node can have two different diameters in SubDyn (it's by element)
     """
     type2Color=[
             (0.1,0.1,0.1), # Watchout based on background
             (0.753,0.561,0.05),  # 1 Beam
             (0.541,0.753,0.05),  # 2 Cable
             (0.753,0.05,0.204),  # 3 Rigid
             (0.918,0.702,0.125), # 3 Rigid
@@ -77,15 +80,19 @@
         Type=1 if len(E)==5 else E[5]
         #elem= Element(E[0], E[1:3], propset=PropSets[Type-1], propIDs=E[3:5])
         elem= Element(E[0], E[1:3], Type=PropSets[Type-1], propIDs=E[3:5], propset=PropSets[Type-1])
         elem.data['object']='cylinder'
         elem.data['color'] = type2Color[Type]
         Graph.addElement(elem)
         # Nodal prop data
-        #Graph.setElementNodalProp(elem, propset=PropSets[Type-1], propIDs=E[3:5])
+        if propToNodes:
+            # NOTE: this is disallowed by default because a same node can have two different diameters in SubDyn (it's by element)
+            Graph.setElementNodalProp(elem, propset=PropSets[Type-1], propIDs=E[3:5])
+        if propToElem:
+            Graph.setElementNodalPropToElem(elem) # TODO, this shouldn't be needed
 
     # --- Concentrated Masses (in global coordinates), node data
     for iC, CM in enumerate(sd['ConcentratedMasses']):
         #CMJointID, JMass, JMXX, JMYY, JMZZ, JMXY, JMXZ, JMYZ, MCGX, MCGY, MCGZ   
         nodeID = CM[0]
         n = Graph.getNode(nodeID)
         M66 = np.zeros((6,6))
@@ -123,17 +130,22 @@
 
 
 
 
 # --------------------------------------------------------------------------------}
 # --- HydroDyn
 # --------------------------------------------------------------------------------{
-def hydrodynToGraph(hd):
+def hydrodynToGraph(hd, propToNodes=False, propToElem=False):
     """
      hd: dict-like object as returned by weio
+
+    -propToNodes: if True, the element properties are also transferred to the nodes for convenience.
+                 NOTE: this is not the default because a same node can have two different diameters in SubDyn (it's by element)
+
+    - propToElem: This might be due to misunderstanding of graph..
     """
     def type2Color(Pot):
         if Pot:
             return (0.753,0.05,0.204),  # Pot flow
         else:
             return (0.753,0.561,0.05),  # Morison
 
@@ -168,31 +180,31 @@
             Graph.addNodeProperty('SimpleCoefs',prop)
     if 'DpthProp' in hd.keys():
         Graph.addMiscPropertySet('DepthCoefs')
         for ip,P in enumerate(hd['DpthProp']):
             # Dpth      DpthCd   DpthCdMG   DpthCa   DpthCaMG       DpthCp   DpthCpMG   DpthAxCd   DpthAxCdMG   DpthAxCa   DpthAxCaMG   DpthAxCp   DpthAxCpMG
             prop= Property(ID=ip+1, Dpth=P[0], Cd=P[1], CdMG=P[2], Ca=P[3], CaMG=P[4], Cp=P[5], CpMG=P[6], AxCd=P[7], AxCdMG=P[8], AxCa=P[9], AxCaMG=P[10], AxCp=P[11], AxCpMG=P[12])
             Graph.addMiscProperty('DepthCoefs',prop)
-
     if 'MemberProp' in hd.keys():
         # Member-based hydro coefficinet
         Graph.addMiscPropertySet('MemberCoefs')
         for ip,P in enumerate(hd['MemberProp']):
             # MemberID    MemberCd1     MemberCd2    MemberCdMG1   MemberCdMG2    MemberCa1     MemberCa2    MemberCaMG1   MemberCaMG2    MemberCp1     MemberCp2    MemberCpMG1   MemberCpMG2   MemberAxCd1   MemberAxCd2  MemberAxCdMG1 MemberAxCdMG2  MemberAxCa1   MemberAxCa2  MemberAxCaMG1 MemberAxCaMG2  MemberAxCp1  MemberAxCp2   MemberAxCpMG1   MemberAxCpMG2
-            prop = Property(ID=ip+1, MemberID=P[0], Cd1=P[1], Cd2=P[2], CdMG1=P[3], CdMG2=P[4], Ca1=P[5], Ca2=P[6], CaMG1=P[7], CaMG2=P[8], Cp1=P[9], Cp2=P[10], CpMG1=P[11], CpMG2=P[12], AxCd1=P[14], AxCd2=P[15], axCdMG1=P[16], axCdMG2=P[17], AxCa1=P[18], AxCa2=P[19], AxCaMG1=P[20], AxCaMG2=P[21], AxCp1=P[22], AxCp2=P[23])
+            prop = ElemProperty(ID=ip+1, MemberID=P[0], Cd1=P[1], Cd2=P[2], CdMG1=P[3], CdMG2=P[4], Ca1=P[5], Ca2=P[6], CaMG1=P[7], CaMG2=P[8], Cp1=P[9], Cp2=P[10], CpMG1=P[11], CpMG2=P[12], AxCd1=P[14], AxCd2=P[15], axCdMG1=P[16], axCdMG2=P[17], AxCa1=P[18], AxCa2=P[19], AxCaMG1=P[20], AxCaMG2=P[21], AxCp1=P[22], AxCp2=P[23])
             Graph.addMiscProperty('MemberCoefs',prop)
     # ---
     if 'FillGroups' in hd.keys():
         # Filled members
         Graph.addMiscPropertySet('FillGroups')
-        for ip,P in enumerate(hd['FillGroups']):
-            #                       FillNumM FillMList             FillFSLoc     FillDens
-            raise NotImplementedError('hydroDynToGraph, Fill List might not be properly set, verify below')
-            prop = MiscProperty(ID=ip+1, FillNumM=P[0], FillMList=P[1],  FillFSLoc=P[2], FillDens=P[3])
-            Graph.addMiscProperty('FillGroups',prop)
+        print('>>> TODO Filled Groups')
+        #for ip,P in enumerate(hd['FillGroups']):
+        #    #                       FillNumM FillMList             FillFSLoc     FillDens
+        #    raise NotImplementedError('hydroDynToGraph, Fill List might not be properly set, verify below')
+        #    prop = MiscProperty(ID=ip+1, FillNumM=P[0], FillMList=P[1],  FillFSLoc=P[2], FillDens=P[3])
+        #    Graph.addMiscProperty('FillGroups',prop)
 
     if 'MGProp' in hd.keys():
         # Marine Growth
         Graph.addMiscPropertySet('MG')
         for ip,P in enumerate(hd['MGProp']):
             # MGDpth     MGThck       MGDens
             # (m)        (m)         (kg/m^3)
@@ -215,28 +227,35 @@
         Type = int(E[6]) # MCoefMod
         Pot  = E[7].lower()[0]=='t'
         elem= Element(ID=EE[0], nodeIDs=EE[1:3], propIDs=EE[3:5], propset='Section', CoefMod=PropSets[Type-1], DivSize=float(E[5]), Pot=Pot)
         elem.data['object']='cylinder'
         elem.data['color'] = type2Color(Pot)
         Graph.addElement(elem)
         # Nodal prop data NOTE: can't do that anymore for memebrs with different diameters at the same node
-        #Graph.setElementNodalProp(elem, propset='Section', propIDs=EE[3:5])
+        if propToNodes:
+            # NOTE: not by default because of feature with members with different diameters at the same node
+            Graph.setElementNodalProp(elem, propset='Section', propIDs=EE[3:5])
+        if propToElem:
+            Graph.setElementNodalPropToElem(elem) # TODO, this shouldn't be needed
+
         if Type==1:
             # Simple
             Graph.setElementNodalProp(elem, propset='SimpleCoefs', propIDs=[1,1])
         else:
             print('>>> TODO type DepthCoefs and MemberCoefs')
+            # NOTE: this is disallowed by default because a same node can have two different diameters in SubDyn (it's by element)
+            #Graph.setElementNodalProp(elem, propset=PropSets[Type-1], propIDs=E[3:5])
 
     return Graph
 
 
 # --------------------------------------------------------------------------------}
 # --- SubDyn Summary file 
 # --------------------------------------------------------------------------------{
-def subdynSumToGraph(data):
+def subdynSumToGraph(data, Graph=None):
     """ 
      data: dict-like object as returned by weio
     """
     type2Color=[
             (0.1,0.1,0.1), # Watchout based on background
             (0.753,0.561,0.05),  # 1 Beam
             (0.541,0.753,0.05),  # 2 Cable
@@ -244,15 +263,16 @@
             (0.918,0.702,0.125), # 3 Rigid
         ]
 
     #print(data.keys())
     DOF2Nodes = data['DOF2Nodes']
     nDOF      = data['nDOF_red']
 
-    Graph = GraphModel()
+    if Graph is None:
+        Graph = GraphModel()
 
     # --- Nodes and DOFs
     Nodes = data['Nodes']
     for iNode,N in enumerate(Nodes):
         if len(N)==9: # Temporary fix
             #N[4]=np.float(N[4].split()[0])
             N=N.astype(np.float32)
@@ -288,20 +308,20 @@
 
 
     return Graph
 
 
 
 if __name__ == '__main__':
-    import welib.weio as weio
+    from .fast_input_file import FASTInputFile
 
     filename='../../_data/Monopile/MT100_SD.dat'
     # filename='../../_data/Monopile/TetraSpar_SubDyn_v3.dat'
 
-    sd = weio.FASTInputFile(filename)
+    sd = FASTInputFile(filename)
 #     sd.write('OutMT.dat')
     Graph = sd.toGraph()
     Graph.divideElements(2)
     print(Graph)
     print(Graph.sortNodesBy('z'))
     # print(Graph.nodalDataFrame(sortBy='z'))
     print(Graph.points)
```

### Comparing `welib-0.0.2/welib/weio/fast_linearization_file.py` & `welib-1.0.0/welib/weio/fast_linearization_file.py`

 * *Files 6% similar despite different names*

```diff
@@ -1,15 +1,16 @@
-from __future__ import division
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from .file import File, isBinary, WrongFormatError, BrokenFormatError
-import pandas as pd
 import numpy as np
+import pandas as pd
 import re
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 class FASTLinearizationFile(File):
     """ 
     Read/write an OpenFAST linearization file. The object behaves like a dictionary.
 
     Main keys
     ---------
@@ -111,15 +112,15 @@
             except:
                 self['RotSpeed'] = None
             try:
                 self['WindSpeed'] = float(extractVal(self['header'],'Wind Speed:'))
             except:
                 self['WindSpeed'] = None
 
-            KEYS=['Order of','A:','B:','C:','D:','ED M:']
+            KEYS=['Order of','A:','B:','C:','D:','ED M:', 'dUdu','dUdy']
 
             for i, line in enumerate(f):
                 line = line.strip()
                 KeyFound=any([line.find(k)>=0 for k in KEYS])
                 if KeyFound:
                     if line.find('Order of continuous states:')>=0:
                         self['x'], self['x_info'] = readOP(f, nx)
@@ -133,14 +134,18 @@
                         self['A'] = readMat(f, nx, nx)
                     elif line.find('B:')>=0:
                         self['B'] = readMat(f, nx, nu)
                     elif line.find('C:')>=0:
                         self['C'] = readMat(f, ny, nx)
                     elif line.find('D:')>=0:
                         self['D'] = readMat(f, ny, nu)
+                    elif line.find('dUdu:')>=0:
+                        self['dUdu'] = readMat(f, nu, nu)
+                    elif line.find('dUdy:')>=0:
+                        self['dUdy'] = readMat(f, nu, ny)
                     elif line.find('ED M:')>=0:
                         self['EDDOF'] = line[5:].split()
                         self['M']     = readMat(f, 24, 24)
 
     def toString(self):
         s=''
         return s
@@ -156,39 +161,50 @@
             s = s.replace('(kW)'    , '_[kW]'   );
             s = s.replace('(deg)'   , '_[deg]'  );
             s = s.replace('(N)'     , '_[N]'    );
             s = s.replace('(kN-m)'  , '_[kNm]' );
             s = s.replace('(N-m)'  , '_[Nm]' );
             s = s.replace('(kN)'  , '_[kN]' );
             s = s.replace('(rpm)'   , '_[rpm]'  );
+            s = s.replace('(rad)'   , '_[rad]'  );
+            s = s.replace('(rad/s)' , '_[rad/s]'  );
+            s = s.replace('(rad/s^2)', '_[rad/s^2]'  );
             s = s.replace('(m/s^2)' , '_[m/s^2]');
             s = s.replace('(deg/s^2)','_[deg/s^2]');
             s = s.replace('(m)'     , '_[m]'    );
+            s = s.replace(', m/s/s','_[m/s^2]');
             s = s.replace(', m/s^2','_[m/s^2]');
             s = s.replace(', m/s','_[m/s]');
             s = s.replace(', m','_[m]');
+            s = s.replace(', rad/s/s','_[rad/s^2]');
             s = s.replace(', rad/s^2','_[rad/s^2]');
             s = s.replace(', rad/s','_[rad/s]');
             s = s.replace(', rad','_[rad]');
             s = s.replace(', -','_[-]');
             s = s.replace(', Nm/m','_[Nm/m]');
             s = s.replace(', Nm','_[Nm]');
             s = s.replace(', N/m','_[N/m]');
             s = s.replace(', N','_[N]');
             s = s.replace('(1)','1')
             s = s.replace('(2)','2')
             s = s.replace('(3)','3')
             s= re.sub(r'\([^)]*\)','', s) # remove parenthesis
             s = s.replace('ED ','');
+            s = s.replace('BD_','BD_B');
             s = s.replace('IfW ','');
             s = s.replace('Extended input: ','')
             s = s.replace('1st tower ','qt1');
-            if s.find('First time derivative of ')>=0:
+            s = s.replace('2nd tower ','qt2');
+            nd = s.count('First time derivative of ')
+            if nd>=0:
                 s = s.replace('First time derivative of '     ,'');
-                s = 'd_'+s.strip()
+                if nd==1:
+                    s = 'd_'+s.strip()
+                elif nd==2:
+                    s = 'dd_'+s.strip()
             s = s.replace('Variable speed generator DOF ','psi_rot'); # NOTE: internally in FAST this is the azimuth of the rotor
             s = s.replace('fore-aft bending mode DOF '    ,'FA'     );
             s = s.replace('side-to-side bending mode DOF','SS'     );
             s = s.replace('bending-mode DOF of blade '    ,''     );
             s = s.replace(' rotational-flexibility DOF, rad','-ROT'   );
             s = s.replace('rotational displacement in ','rot'   );
             s = s.replace('Drivetrain','DT'   );
@@ -196,26 +212,26 @@
             s = s.replace('finite element node ','N'   );
             s = s.replace('-component position of node ','posN')
             s = s.replace('-component inflow on tower node','TwrN')
             s = s.replace('-component inflow on blade 1, node','Bld1N')
             s = s.replace('-component inflow on blade 2, node','Bld2N')
             s = s.replace('-component inflow on blade 3, node','Bld3N')
             s = s.replace('-component inflow velocity at node','N')
-            s = s.replace('X translation displacement, node','XN')
-            s = s.replace('Y translation displacement, node','YN')
-            s = s.replace('Z translation displacement, node','ZN')
-            s = s.replace('X translation velocity, node','VxN')
-            s = s.replace('Y translation velocity, node','VyN')
-            s = s.replace('Z translation velocity, node','VzN')
-            s = s.replace('X translation acceleration, node','AxN')
-            s = s.replace('Y translation acceleration, node','AyN')
-            s = s.replace('Z translation acceleration, node','AzN')
-            s = s.replace('X orientation angle, node'  ,'XorN')
-            s = s.replace('Y orientation angle, node'  ,'YorN')
-            s = s.replace('Z orientation angle, node'  ,'ZorN')
+            s = s.replace('X translation displacement, node','TxN')
+            s = s.replace('Y translation displacement, node','TyN')
+            s = s.replace('Z translation displacement, node','TzN')
+            s = s.replace('X translation velocity, node','TVxN')
+            s = s.replace('Y translation velocity, node','TVyN')
+            s = s.replace('Z translation velocity, node','TVzN')
+            s = s.replace('X translation acceleration, node','TAxN')
+            s = s.replace('Y translation acceleration, node','TAyN')
+            s = s.replace('Z translation acceleration, node','TAzN')
+            s = s.replace('X orientation angle, node'  ,'RxN')
+            s = s.replace('Y orientation angle, node'  ,'RyN')
+            s = s.replace('Z orientation angle, node'  ,'RzN')
             s = s.replace('X rotation velocity, node'  ,'RVxN')
             s = s.replace('Y rotation velocity, node'  ,'RVyN')
             s = s.replace('Z rotation velocity, node'  ,'RVzN')
             s = s.replace('X rotation acceleration, node'  ,'RAxN')
             s = s.replace('Y rotation acceleration, node'  ,'RAyN')
             s = s.replace('Z rotation acceleration, node'  ,'RAzN')
             s = s.replace('X force, node','FxN')
@@ -274,53 +290,63 @@
             s = s.replace(',','');
             s = s.replace(' ','');
             s=s.strip()
             return s
         return [shortname(s) for s in slist]
 
     def xdescr(self):
-        return self.short_descr(self['x_info']['Description'])
+        if 'x_info' in self.keys():
+            return self.short_descr(self['x_info']['Description'])
+        else:
+            return []
+
+    def xdotdescr(self):
+        if 'xdot_info' in self.keys():
+            return self.short_descr(self['xdot_info']['Description'])
+        else:
+            return []
+
     def ydescr(self):
-        return self.short_descr(self['y_info']['Description'])
+        if 'y_info' in self.keys():
+            return self.short_descr(self['y_info']['Description'])
+        else:
+            return []
     def udescr(self):
-        return self.short_descr(self['u_info']['Description'])
+        if 'u_info' in self.keys():
+            return self.short_descr(self['u_info']['Description'])
+        else:
+            return []
 
     def _toDataFrame(self):
         dfs={}
-        try:
-            xdescr_short=self.xdescr()
+
+        xdescr_short    = self.xdescr()
+        xdotdescr_short = self.xdotdescr()
+        ydescr_short    = self.ydescr()
+        udescr_short    = self.udescr()
+
+        if 'A' in self.keys():
             dfs['A'] = pd.DataFrame(data = self['A'], index=xdescr_short, columns=xdescr_short)
-        except:
-            pass
-        try:
-            udescr_short=self.udescr()
+        if 'B' in self.keys():
             dfs['B'] = pd.DataFrame(data = self['B'], index=xdescr_short, columns=udescr_short)
-        except:
-            pass
-        try:
-            ydescr_short=self.ydescr()
+        if 'C' in self.keys():
             dfs['C'] = pd.DataFrame(data = self['C'], index=ydescr_short, columns=xdescr_short)
-        except:
-            pass
-        try:
+        if 'D' in self.keys():
             dfs['D'] = pd.DataFrame(data = self['D'], index=ydescr_short, columns=udescr_short)
-        except:
-            pass
-        try:
+        if 'x' in self.keys():
             dfs['x'] = pd.DataFrame(data = np.asarray(self['x']).reshape((1,-1)), columns=xdescr_short)
-        except:
-            pass
-        try:
+        if 'xdot' in self.keys():
+            dfs['xdot'] = pd.DataFrame(data = np.asarray(self['xdot']).reshape((1,-1)), columns=xdotdescr_short)
+        if 'u' in self.keys():
             dfs['u'] = pd.DataFrame(data = np.asarray(self['u']).reshape((1,-1)), columns=udescr_short)
-        except:
-            pass
-        try:
+        if 'y' in self.keys():
             dfs['y'] = pd.DataFrame(data = np.asarray(self['y']).reshape((1,-1)), columns=ydescr_short)
-        except:
-            pass
-        try:
+        if 'M' in self.keys():
             dfs['M'] = pd.DataFrame(data = self['M'], index=self['EDDOF'], columns=self['EDDOF'])
-        except:
-            pass
+        if 'dUdu' in self.keys():
+            dfs['dUdu'] = pd.DataFrame(data = self['dUdu'], index=udescr_short, columns=udescr_short)
+        if 'dUdy' in self.keys():
+            dfs['dUdy'] = pd.DataFrame(data = self['dUdy'], index=udescr_short, columns=ydescr_short)
+
         return dfs
```

### Comparing `welib-0.0.2/welib/weio/fast_output_file.py` & `welib-1.0.0/welib/weio/fast_output_file.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,89 +1,113 @@
-from __future__ import absolute_import
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
+""" 
+Tools to read/write OpenFAST output files
 
-from itertools import takewhile
+Main content:
 
-# try:
-from .csv_file import CSVFile
-from .file import File, WrongFormatError, BrokenReaderError, EmptyFileError
-# except:
-#     # --- Allowing this file to be standalone..
-#     class WrongFormatError(Exception):
-#         pass
-#     class WrongReaderError(Exception):
-#         pass
-#     class EmptyFileError(Exception):
-#         pass
-#     File = dict
-try:
-    from .csv_file import CSVFile
-except:
-    print('CSVFile not available')
+- class FASTOutputFile()
+- data, info = def load_output(filename)
+- data, info = def load_ascii_output(filename)
+- data, info = def load_binary_output(filename, use_buffer=True)
+- def writeDataFrame(df, filename, binary=True)
+- def writeBinary(fileName, channels, chanNames, chanUnits, fileID=2, descStr='')
+"""
+from itertools import takewhile
 import numpy as np
 import pandas as pd
 import struct
 import os
 import re
+try:
+    from .file import File, WrongFormatError, BrokenReaderError, EmptyFileError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class WrongReaderError(Exception): pass
+    class BrokenFormatError(Exception): pass
+    class EmptyFileError(Exception): pass
+try:
+    from .csv_file import CSVFile
+except:
+    print('CSVFile not available')
+
+
+
+FileFmtID_WithTime              = 1 # File identifiers used in FAST
+FileFmtID_WithoutTime           = 2
+FileFmtID_NoCompressWithoutTime = 3
+FileFmtID_ChanLen_In            = 4 # Channel length included in file
 
 
 # --------------------------------------------------------------------------------}
 # --- OUT FILE 
 # --------------------------------------------------------------------------------{
 class FASTOutputFile(File):
     """ 
     Read an OpenFAST ouput file (.out, .outb, .elev).
 
     Main methods
     ------------
-    - read, toDataFrame
+    - read, write, toDataFrame
 
     Examples
     --------
 
-        # read an output file and convert it to pandas dataframe
-        df = FASTOutputFile('5MW.outb').toDataFrame()
+        # read an output file, convert it to pandas dataframe, modify it, write it back
+        f = FASTOutputFile('5MW.outb')
+        df=f.toDataFrame()
         time  = df['Time_[s]']
-        Omega = df['RotSpeed_[rpm]']
+        Omega = df['RotSpeed_[rpm]'] 
+        df['Time_[s]'] -=100
+        f.writeDataFrame(df, '5MW_TimeShifted.outb')
 
     """
 
     @staticmethod
     def defaultExtensions():
-        return ['.out','.outb','.elm','.elev']
+        return ['.out','.outb','.elm','.elev','.dbg','.dbg2']
 
     @staticmethod
     def formatName():
         return 'FAST output file'
 
+    def __init__(self, filename=None, **kwargs):
+        """ Class constructor. If a `filename` is given, the file is read. """
+        self.filename = filename
+        if filename:
+            self.read(**kwargs)
+
+    def read(self, filename=None, **kwargs):
+        """ Reads the file self.filename, or `filename` if provided """
+        
+        # --- Standard tests and exceptions (generic code)
+        if filename:
+            self.filename = filename
+        if not self.filename:
+            raise Exception('No filename provided')
+        if not os.path.isfile(self.filename):
+            raise OSError(2,'File not found:',self.filename)
+        if os.stat(self.filename).st_size == 0:
+            raise EmptyFileError('File is empty:',self.filename)
+        # --- Calling (children) function to read
+        self._read(**kwargs)
+
     def _read(self):
         def readline(iLine):
             with open(self.filename) as f:
                 for i, line in enumerate(f):
                     if i==iLine-1:
                         return line.strip()
                     elif i>=iLine:
                         break
 
-
-
         ext = os.path.splitext(self.filename.lower())[1]
         self.info={}
         self['binary']=False
         try:
-            if ext in ['.out','.elev']:
+            if ext in ['.out','.elev','.dbg','.dbg2']:
                 self.data, self.info = load_ascii_output(self.filename)
             elif ext=='.outb':
                 self.data, self.info = load_binary_output(self.filename)
                 self['binary']=True
             elif ext=='.elm':
                 F=CSVFile(filename=self.filename, sep=' ', commentLines=[0,2],colNamesLine=1)
                 self.data = F.data
@@ -114,30 +138,46 @@
             # ascii output
             with open(self.filename,'w') as f:
                 f.write('\t'.join(['{:>10s}'.format(c)         for c in self.info['attribute_names']])+'\n')
                 f.write('\t'.join(['{:>10s}'.format('('+u+')') for u in self.info['attribute_units']])+'\n')
                 # TODO better..
                 f.write('\n'.join(['\t'.join(['{:10.4f}'.format(y[0])]+['{:10.3e}'.format(x) for x in y[1:]]) for y in self.data]))
 
-    def _toDataFrame(self):
+    def toDataFrame(self):
+        """ Returns object into one DataFrame, or a dictionary of DataFrames"""
+        # --- Example (returning one DataFrame):
+        #  return pd.DataFrame(data=np.zeros((10,2)),columns=['Col1','Col2'])
         if self.info['attribute_units'] is not None:
-            cols=[n+'_['+u.replace('sec','s')+']' for n,u in zip(self.info['attribute_names'],self.info['attribute_units'])]
+            if len(self.info['attribute_names'])!=len(self.info['attribute_units']):
+                cols=self.info['attribute_names']
+                print('[WARN] not all columns have units! Skipping units')
+            else:
+                cols=[n+'_['+u.replace('sec','s')+']' for n,u in zip(self.info['attribute_names'],self.info['attribute_units'])]
         else:
             cols=self.info['attribute_names']
         if isinstance(self.data, pd.DataFrame):
             df= self.data
             df.columns=cols
         else:
+            if len(cols)!=self.data.shape[1]:
+                raise BrokenFormatError('Inconstistent number of columns between headers ({}) and data ({}) for file {}'.format(len(cols), self.data.shape[1], self.filename))
             df = pd.DataFrame(data=self.data,columns=cols)
 
         return df
 
     def writeDataFrame(self, df, filename, binary=True):
         writeDataFrame(df, filename, binary=binary)
 
+    def __repr__(self):
+        s='<{} object> with attributes:\n'.format(type(self).__name__)
+        s+=' - info ({})\n'.format(type(self.info))
+        s+=' - data ({})\n'.format(type(self.data))
+        s+='and keys: {}\n'.format(self.keys())
+        return s
+
 # --------------------------------------------------------------------------------
 # --- Helper low level functions 
 # --------------------------------------------------------------------------------
 def load_output(filename):
     """Load a FAST binary or ascii output file
 
     Parameters
@@ -172,15 +212,16 @@
         # Header is whatever is before the keyword `time`
         in_header = True
         header = []
         while in_header:
             l = f.readline()
             if not l:
                 raise Exception('Error finding the end of FAST out file header. Keyword Time missing.')
-            in_header= (l+' dummy').lower().split()[0] != 'time'
+            first_word = (l+' dummy').lower().split()[0]
+            in_header=  (first_word != 'time') and  (first_word != 'alpha')
             if in_header:
                 header.append(l)
             else:
                 info['description'] = header
                 info['attribute_names'] = l.split()
                 info['attribute_units'] = [unit[1:-1] for unit in f.readline().split()]
         # ---
@@ -241,20 +282,14 @@
                 data[ nLinesRead:(nLinesRead+nLinesToRead),  nOff:(nOff+nCols)  ] = Buffer
                 nLinesRead = nLinesRead + nLinesToRead
                 nIntRead   = nIntRead   + nIntToRead
         except:
             raise Exception('Read only %d of %d values in file:' % (nIntRead, n, filename))
         return data
 
-
-    FileFmtID_WithTime              = 1 # File identifiers used in FAST
-    FileFmtID_WithoutTime           = 2
-    FileFmtID_NoCompressWithoutTime = 3
-    FileFmtID_ChanLen_In            = 4
-
     with open(filename, 'rb') as fid:
         #----------------------------        
         # get the header information
         #----------------------------
 
         FileID = fread(fid, 1, 'int16')[0]  #;             % FAST output file format, INT(2)
 
@@ -354,48 +389,15 @@
             'description': DescStr,
             'fileID': FileID,
             'attribute_names': ChanName,
             'attribute_units': ChanUnit}
     return data, info
 
 
-def writeDataFrame(df, filename, binary=True):
-    channels  = df.values
-    # attempt to extract units from channel names
-    chanNames=[]
-    chanUnits=[]
-    for c in df.columns:
-        c     = c.strip()
-        name  = c
-        units = ''
-        if c[-1]==']':
-            chars=['[',']']
-        elif c[-1]==')':
-            chars=['(',')']
-        else:
-            chars=[]
-        if len(chars)>0:
-            op,cl = chars
-            iu=c.rfind(op)
-            if iu>1:
-                name = c[:iu]
-                unit = c[iu+1:].replace(cl,'')
-                if name[-1]=='_':
-                    name=name[:-1]
-                
-        chanNames.append(name)
-        chanUnits.append(unit)
-
-    if binary:
-        writeBinary(filename, channels, chanNames, chanUnits)
-    else:
-        NotImplementedError()
-
-
-def writeBinary(fileName, channels, chanNames, chanUnits, fileID=2, descStr=''):
+def writeBinary(fileName, channels, chanNames, chanUnits, fileID=4, descStr=''):
     """
     Write an OpenFAST binary file.
 
     Based on contributions from
         Hugo Castro, David Schlipf, Hochschule Flensburg
     
     Input:
@@ -441,58 +443,102 @@
     mins   = np.min(dataWithoutTime, axis=0)
     ranges = np.single(np.max(dataWithoutTime, axis=0) - mins)
     ranges[ranges==0]=1  # range set to 1 for constant channel. In OpenFAST: /sqrt(epsilon(1.0_SiKi))
     ColScl  = np.single(int16Rng/ranges)
     ColOff  = np.single(int16Min - np.single(mins)*ColScl)
     
     #Just available for fileID 
-    if fileID != 2:
-        print("current version just works with FileID = 2")
+    if fileID not in [2,4]:
+        print("current version just works with fileID = 2 or 4")
 
     else:
         with open(fileName,'wb') as fid:
             # Notes on struct:
             # @ is used for packing in native byte order
             #  B - unsigned integer 8 bits
             #  h - integer 16 bits
             #  i - integer 32 bits
             #  f - float 32 bits
             #  d - float 64 bits
 
             # Write header informations
             fid.write(struct.pack('@h',fileID))
+            if fileID == FileFmtID_ChanLen_In: 
+                maxChanLen = np.max([len(s) for s in chanNames])
+                maxUnitLen = np.max([len(s) for s in chanUnits])
+                nChar = max(maxChanLen, maxUnitLen)
+                fid.write(struct.pack('@h',nChar))
+            else:
+                nChar = 10
+
             fid.write(struct.pack('@i',nChannels))
             fid.write(struct.pack('@i',nT))
             fid.write(struct.pack('@d',timeStart))
             fid.write(struct.pack('@d',timeIncr))
             fid.write(struct.pack('@{}f'.format(nChannels), *ColScl))
             fid.write(struct.pack('@{}f'.format(nChannels), *ColOff))
             descStrASCII = [ord(char) for char in descStr]
             fid.write(struct.pack('@i',len(descStrASCII)))
             fid.write(struct.pack('@{}B'.format(len((descStrASCII))), *descStrASCII))
 
             # Write channel names
             for chan in chanNames:
-                ordchan = [ord(char) for char in chan]+ [32]*(10-len(chan))
-                fid.write(struct.pack('@10B', *ordchan))
+                chan = chan[:nChar]
+                ordchan = [ord(char) for char in chan] + [32]*(nChar-len(chan))
+                fid.write(struct.pack('@'+str(nChar)+'B', *ordchan))
 
             # Write channel units
             for unit in chanUnits:
-                ordunit = [ord(char) for char in unit]+ [32]*(10-len(unit))
-                fid.write(struct.pack('@10B', *ordunit))
+                unit = unit[:nChar]
+                ordunit = [ord(char) for char in unit] + [32]*(nChar-len(unit))
+                fid.write(struct.pack('@'+str(nChar)+'B', *ordunit))
 
             # Pack data
             packedData=np.zeros((nT, nChannels), dtype=np.int16)
             for iChan in range(nChannels):
                 packedData[:,iChan] = np.clip( ColScl[iChan]*dataWithoutTime[:,iChan]+ColOff[iChan], int16Min, int16Max)
 
             # Write data
             fid.write(struct.pack('@{}h'.format(packedData.size), *packedData.flatten()))
             fid.close()
 
+def writeDataFrame(df, filename, binary=True):
+    """ write a DataFrame to OpenFAST output format"""
+    channels  = df.values
+    # attempt to extract units from channel names
+    chanNames=[]
+    chanUnits=[]
+    for c in df.columns:
+        c     = c.strip()
+        name  = c
+        unit = ''
+        if c[-1]==']':
+            chars=['[',']']
+        elif c[-1]==')':
+            chars=['(',')']
+        else:
+            chars=[]
+        if len(chars)>0:
+            op,cl = chars
+            iu=c.rfind(op)
+            if iu>1:
+                name = c[:iu]
+                unit = c[iu+1:].replace(cl,'')
+                if name[-1]=='_':
+                    name=name[:-1]
+                
+        chanNames.append(name)
+        chanUnits.append(unit)
+
+    if binary:
+        writeBinary(filename, channels, chanNames, chanUnits, fileID=FileFmtID_ChanLen_In)
+    else:
+        NotImplementedError()
+
+
 
 if __name__ == "__main__":
     B=FASTOutputFile('tests/example_files/FASTOutBin.outb')
     df=B.toDataFrame()
     B.writeDataFrame(df, 'tests/example_files/FASTOutBin_OUT.outb')
```

### Comparing `welib-0.0.2/welib/weio/fast_summary_file.py` & `welib-1.0.0/welib/weio/fast_summary_file.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,15 +1,13 @@
 import numpy as np
 import pandas as pd
-from io import open
 import os
 # Local 
 from .mini_yaml import yaml_read
 
-
 try:
     from .file import File, EmptyFileError
 except:
     EmptyFileError = type('EmptyFileError', (Exception,),{})
     File=dict
 
 # --------------------------------------------------------------------------------}
@@ -147,15 +145,15 @@
         if sortDim is not None: 
             I=np.argsort(pos[:,sortDim])
             INodes = np.array(INodes)[I]
             disp   = disp[I,:,:]
             pos    = pos[I,:]
         return disp, pos, INodes
 
-    def getModes(data, maxDisp=None, sortDim=2):
+    def getModes(data, maxDisp=None, sortDim=None):
         """ return Guyan and CB modes"""
         if maxDisp is None:
             #compute max disp such as it's 10% of maxdimension
             dx = np.max(self['X'])-np.min(self['X'])
             dy = np.max(self['Y'])-np.min(self['Y'])
             dz = np.max(self['Z'])-np.min(self['Z'])
             maxDisp = np.max([dx,dy,dz])*0.1
@@ -179,19 +177,20 @@
 
     def subDynToJson(data, outfile=None):
         """ Convert to a "JSON" format
 
         TODO: convert to graph and use graph.toJSON
 
         """
+        #return data.toGraph().toJSON(outfile)
 
-        dispGy, posGy, _, dispCB, posCB, _ = data.getModes()
+        dispGy, posGy, _, dispCB, posCB, _ = data.getModes(sortDim=None) # Sorting mess things up
 
-        Nodes    = self['Nodes']
-        Elements = self['Elements']
+        Nodes    = self['Nodes'].copy()
+        Elements = self['Elements'].copy()
         Elements[:,0]-=1
         Elements[:,1]-=1
         Elements[:,2]-=1
         CB_freq   = data['CB_frequencies'].ravel()
 
         d=dict();
         d['Connectivity']=Elements[:,[1,2]].astype(int).tolist();
@@ -219,35 +218,36 @@
                 try:
                     f.write(unicode(json.dumps(d, ensure_ascii=False))) #, indent=2)
                 except:
                     json.dump(d, f, indent=2) 
         return d
 
 
-    def subDynToDataFrame(data):
+    def subDynToDataFrame(data, sortDim=2, removeZero=True):
         """ Convert to DataFrame containing nodal displacements """
         def toDF(pos,disp,preffix=''):
             disp[np.isnan(disp)]=0
             disptot=disp.copy()
             columns=[]
             for ishape in np.arange(disp.shape[2]):
                 disptot[:,:,ishape]= pos + disp[:,:,ishape]
                 sMode=preffix+'Mode{:d}'.format(ishape+1)
                 columns+=[sMode+'x_[m]',sMode+'y_[m]',sMode+'z_[m]']
             disptot= np.moveaxis(disptot,2,1).reshape(disptot.shape[0],disptot.shape[1]*disptot.shape[2])
             disp   = np.moveaxis(disp,2,1).reshape(disp.shape[0],disp.shape[1]*disp.shape[2])
             df= pd.DataFrame(data = disptot ,columns = columns)
-            # remove zero 
             dfDisp= pd.DataFrame(data = disp ,columns = columns)
-            df     = df.loc[:,     (dfDisp != 0).any(axis=0)]
-            dfDisp = dfDisp.loc[:, (dfDisp != 0).any(axis=0)]
+            # remove mode components that are fully zero 
+            if removeZero:
+                df     = df.loc[:,     (dfDisp != 0).any(axis=0)]
+                dfDisp = dfDisp.loc[:, (dfDisp != 0).any(axis=0)]
             dfDisp.columns = [c.replace('Mode','Disp') for c in dfDisp.columns.values]
             return df, dfDisp
 
-        dispGy, posGy, _, dispCB, posCB, _ = data.getModes()
+        dispGy, posGy, _, dispCB, posCB, _ = data.getModes(sortDim=sortDim)
 
         columns = ['z_[m]','x_[m]','y_[m]']
         dataZXY = np.column_stack((posGy[:,2],posGy[:,0],posGy[:,1]))
         dfZXY   = pd.DataFrame(data = dataZXY, columns=columns)
         df1, df1d = toDF(posGy, dispGy,'Guyan')
         df2, df2d = toDF(posCB, dispCB,'CB')
         df = pd.concat((dfZXY, df1, df2, df1d, df2d), axis=1)
```

### Comparing `welib-0.0.2/welib/weio/file.py` & `welib-1.0.0/welib/weio/file.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,8 +1,9 @@
 import os
+from collections import OrderedDict
 
 class WrongFormatError(Exception):
     pass
 
 class EmptyFileError(Exception):
     pass
 
@@ -13,15 +14,15 @@
     pass
 
 try: #Python3
     FileNotFoundError=FileNotFoundError
 except NameError: # Python2
     FileNotFoundError = IOError
 
-class File(dict):
+class File(OrderedDict):
     def __init__(self,filename=None,**kwargs):
         if filename:
             self.read(filename, **kwargs)
         else:
             self.filename = None
 
     def read(self, filename=None, **kwargs):
@@ -151,15 +152,14 @@
         else:
             raise Exception('The ascii content of {} and {} are different'.format(f1,f2))
 
 # --------------------------------------------------------------------------------}
 # --- Helper functions
 # --------------------------------------------------------------------------------{
 def isBinary(filename):
-    from io import open
     with open(filename, 'r') as f:
         try:
             # first try to read as string
             l = f.readline()
             # then look for weird characters
             for c in l:
                 code = ord(c)
```

### Comparing `welib-0.0.2/welib/weio/file_formats.py` & `welib-1.0.0/welib/weio/file_formats.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/flex_blade_file.py` & `welib-1.0.0/welib/weio/flex_blade_file.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,20 +1,17 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError, BrokenFormatError
 import numpy as np
 import pandas as pd
 import os
 
-#from .wetb.fast import fast_io
-
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 class FLEXBladeFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.bld','.bla','.00X'] #'.001 etc..'
```

### Comparing `welib-0.0.2/welib/weio/flex_doc_file.py` & `welib-1.0.0/welib/weio/flex_doc_file.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,18 +1,17 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError, BrokenFormatError
 import numpy as np
 import pandas as pd
 import os
 import re
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 class FLEXDocFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.out','doc']
```

### Comparing `welib-0.0.2/welib/weio/flex_out_file.py` & `welib-1.0.0/welib/weio/flex_out_file.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,16 @@
-from __future__ import absolute_import
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError, BrokenFormatError
 import numpy as np
 import pandas as pd
 import os
-
-#from .wetb.fast import fast_io
-
-
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 # --------------------------------------------------------------------------------}
 # --- OUT FILE 
 # --------------------------------------------------------------------------------{
 class FLEXOutFile(File):
 
     @staticmethod
@@ -40,22 +29,38 @@
         except WrongFormatError as e:    
             raise WrongFormatError('FLEX File {}: '.format(self.filename)+'\n'+e.args[0])
         self.nt       = np.size(self.data,0)
         self.nSensors = np.size(self.data,1)
         self.time = np.arange(self.tmin, self.tmin +  self.nt * self.dt, self.dt).reshape(self.nt,1).astype(dtype)
 
         # --- Then the sensor file
-        sensor_filename = os.path.join(os.path.dirname(self.filename), "sensor")
-        if not os.path.isfile(sensor_filename):
+        parentdir = os.path.dirname(self.filename)
+        basename = os.path.splitext(os.path.basename(self.filename))[0]
+        #print(parentdir)
+        #print(basename)
+        PossibleFiles=[]
+        PossibleFiles+=[os.path.join(parentdir, basename+'.Sensor')]
+        PossibleFiles+=[os.path.join(parentdir, 'Sensor_'+basename)]
+        PossibleFiles+=[os.path.join(parentdir, 'sensor')]
+        # We try allow for other files
+        Found =False
+        for sf in PossibleFiles:
+            if os.path.isfile(sf):
+                self.sensors=read_flex_sensor(sf)
+                if len(self.sensors['ID'])!=self.nSensors:
+                    Found = False
+                else:
+                    Found = True
+                    break
+        if not Found:
             # we are being nice and create some fake sensors info
             self.sensors=read_flex_sensor_fake(self.nSensors)
-        else:
-            self.sensors=read_flex_sensor(sensor_filename)
-            if len(self.sensors['ID'])!=self.nSensors:
-                raise BrokenFormatError('Inconsistent number of sensors: {} (sensor file) {} (out file), for file: {}'.format(len(self.sensors['ID']),self.nSensors,self.filename))
+
+        if len(self.sensors['ID'])!=self.nSensors:
+            raise BrokenFormatError('Inconsistent number of sensors: {} (sensor file) {} (out file), for file: {}'.format(len(self.sensors['ID']),self.nSensors,self.filename))
 
     #def _write(self): # TODO
     #    pass
 
     def __repr__(self):
         return 'Flex Out File: {}\nVersion:{} - DateID:{} - Title:{}\nSize:{}x{} - tmin:{} - dt:{}]\nSensors:{}'.format(self.filename,self.Version,self.DateID,self.title,self.nt,self.nSensors,self.tmin,self.dt,self.sensors['Name'])
```

### Comparing `welib-0.0.2/welib/weio/flex_profile_file.py` & `welib-1.0.0/welib/weio/flex_profile_file.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,19 +1,16 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError, BrokenFormatError
 import numpy as np
 import pandas as pd
 import os
-
-#from .wetb.fast import fast_io
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 class ProfileSet():
     def __init__(self,header,thickness,polars,polar_headers):
         self.header      = header
         self.polars      = polars
         self.thickness   = thickness
         self.polar_headers = polar_headers
```

### Comparing `welib-0.0.2/welib/weio/flex_wavekin_file.py` & `welib-1.0.0/welib/weio/flex_wavekin_file.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,21 +1,18 @@
-from __future__ import division,unicode_literals,print_function,absolute_import
-from builtins import map, range, chr, str
-from io import open
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError, BrokenFormatError
-from .csv_file import CSVFile
 import numpy as np
 import pandas as pd
 import os
 import re
-
-#from .wetb.fast import fast_io
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
+from .csv_file import CSVFile
 
 
 class FLEXWaveKinFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.wko'] #'.001 etc..'
```

### Comparing `welib-0.0.2/welib/weio/hawc2_dat_file.py` & `welib-1.0.0/welib/weio/hawc2_dat_file.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,24 +1,12 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-import os 
 import numpy as np
-
-from .file import File, WrongFormatError, FileNotFoundError
 import pandas as pd
+import os 
 
+from .file import File, WrongFormatError, FileNotFoundError
 from .wetb.hawc2.Hawc2io import ReadHawc2
 
 
 class HAWC2DatFile(File):
 
     @staticmethod
     def defaultExtensions():
```

### Comparing `welib-0.0.2/welib/weio/hawc2_htc_file.py` & `welib-1.0.0/welib/weio/hawc2_htc_file.py`

 * *Files 13% similar despite different names*

```diff
@@ -19,34 +19,49 @@
 
     @staticmethod
     def formatName():
         return 'HAWC2 htc file'
 
     def _read(self):
         self.data = HTCFile(self.filename)
-        self.data.contents # trigger read
 
     def _write(self):
         self.data.save(self.filename)
 
     def __repr__(self):
-        s='<{} object> with attribute `data`\n'.format(type(self).__name__)
+        s='<{} object>\n'.format(type(self).__name__)
+        s+='| Attributes:\n'
+        s+='| - data: HTCFile with keys: {}`\n'.format(list(self.data.keys()))
+        s+='| Derived attributes:\n'
+        s+='| * bodyNames: {}\n'.format(self.bodyNames)
+        s+='| * bodyDict: dict with keys bodyNames\n'
+        s+='| Methods: bodyByName, bodyC2, setBodyC2\n'
         return s
 
-    def bodyByName(self, bodyname):
-        """ return body inputs given a body name"""
+    @property
+    def bodyNames(self):
+        return list(self.bodyDict.keys())
+
+    @property
+    def bodyDict(self):
         struct = self.data.new_htc_structure
         bodyKeys = [k for k in struct.keys() if k.startswith('main_body')]
-        bdies = [struct[k] for k in bodyKeys if struct[k].name[0]==bodyname]
-        if len(bdies)==1:
-            return bdies[0]
-        elif len(bdies)==0:
+        #print('>>> keys', struct.keys())
+        bdDict={}
+        for k in bodyKeys:
+            bodyName = struct[k].name[0]
+            bdDict[bodyName] = struct[k]
+        return bdDict
+
+    def bodyByName(self, bodyname):
+        """ return body inputs given a body name"""
+        bodyDict= self.bodyDict
+        if bodyname not in bodyDict.keys():
             raise Exception('No body found with name {} in file {}'.format(bodyname,self.filename))
-        else:
-            raise Exception('Several bodies found with name {} in file {}'.format(bodyname,self.filename))
+        return bodyDict[bodyname]
 
     def bodyC2(self, bdy):
         """ return body C2_def given body inputs"""
         try:
             nsec = bdy.c2_def.nsec[0]
         except:
             raise Exception('body has no c2_def section')
@@ -95,17 +110,21 @@
             val = val[:,[3,1,2,4]]
             dfs[name+'_c2'] = pd.DataFrame(data=val, columns=['z_[m]', 'x_[m]', 'y_[m]','twist_[deg]'])
             # potentially open st files..
             if "timoschenko_input" in bdy:
                 tim = bdy.timoschenko_input
                 H2_stfile = os.path.join(simdir, tim.filename[0])
                 if not os.path.exists(H2_stfile):
-                    print('[WARN] st file referenced in htc file was not found. St file: {}, htc file {}'.format(H2_stfile, self.filename))
+                    # Try with a parent directory..
+                    H2_stfile = os.path.join(simdir, '../',tim.filename[0])
+
+                if not os.path.exists(H2_stfile):
+                    print('[WARN] st file referenced in htc file was not found for body {}.\nSt file: {}\nhtc file {}'.format(name, H2_stfile, self.filename))
                 else:
-                    dfs_st = HAWC2StFile(H2_stfile).toDataFrame()
+                    dfs_st = HAWC2StFile(H2_stfile).toDataFrame(extraCols=False)
                     if 'set' in tim.keys():
                         mset = tim.set[0]
                         iset = tim.set[1]
                         sSet = '{}_{}'.format(mset,iset)
                     else:
                         sSet = '1_1'
                     if sSet not in dfs_st:
```

### Comparing `welib-0.0.2/welib/weio/hawcstab2_cmb_file.py` & `welib-1.0.0/welib/weio/hawcstab2_cmb_file.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/hawcstab2_ind_file.py` & `welib-1.0.0/welib/weio/hawcstab2_ind_file.py`

 * *Files 15% similar despite different names*

```diff
@@ -1,24 +1,16 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-import os
-import re
-
-from .file import File, WrongFormatError
 import numpy as np
 import pandas as pd
+import os
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 
 class HAWCStab2IndFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.ind', '.txt']
```

### Comparing `welib-0.0.2/welib/weio/hawcstab2_pwr_file.py` & `welib-1.0.0/welib/weio/hawcstab2_pwr_file.py`

 * *Files 23% similar despite different names*

```diff
@@ -1,22 +1,15 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError
 import numpy as np
 import pandas as pd
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 
 class HAWCStab2PwrFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.pwr', '.txt']
```

### Comparing `welib-0.0.2/welib/weio/mannbox_file.py` & `welib-1.0.0/welib/weio/mannbox_file.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,23 +1,11 @@
 """ 
-Read/Write Mann Box
+Read/Write Mann Box file
 
 Part of weio library: https://github.com/ebranlard/weio
-
-Mann box: 
-  - z is the fast index, then y, then x
-  - y from from  ly/2 to -ly/2  !<<<<<<< IMPORTANT, we will flip it 
-  - z from from -lz/2 to  lz/2 
-  - ix==1..nx corresponds to it = nt..1
-
-The field stored in this class has the following properties:
-  - shape: nx x ny x nz
-  - y: goes from -ly/2 to ly/2  ! <<<<< IMPORTANT subtlety, it has been flipped
-  - z: goes from -lz/2 to lz/2  
-  - ix==1..nx corresponds to it = nt..1 (it has not been flipped)
 """
 import pandas as pd
 import numpy as np
 import os
 import re
 import struct
 
@@ -25,32 +13,95 @@
     from .file import File, EmptyFileError, BrokenFormatError
 except:
     EmptyFileError = type('EmptyFileError', (Exception,),{})
     BrokenFormatError = type('BrokenFormatError', (Exception,),{})
     File=dict
 
 class MannBoxFile(File):
+    """
+    Read/Write Mann Box file
+
+    Main keys
+    ---------
+    - 'field': velocity field, shape (nx x ny x nz)
+
+    Main properties
+    ---------
+    - 'y', 'z': space coordinates 
+
+    Main methods
+    ------------
+
+    - read, write, toDataFrame, keys, valuesAt, vertProfile, fromTurbSim
+
+
+    Examples
+    --------
+
+        # Open a box
+        mb = MannBoxFile('Turb.u', N = (1024, 16, 16))
+            OR 
+        mb = MannBoxFile('Turb_1024x16x16.u')
+
+        # Show info
+        print(mb)
+        print(mb['field'].shape)  
+
+        # Use methods to extract relevant values
+        u,v,w = my.valuesAt(y=10.5, z=90)
+        z, means, stds = mb.vertProfile()
+
+        # Write to a new file
+        mb.write('Output_1024x16x16.u')
+
+    Notes
+    --------
+
+    Mann box: 
+      - z is the fast index, then y, then x
+      - y from from  ly/2 to -ly/2  !<<<<<<< IMPORTANT, we will flip it 
+      - z from from -lz/2 to  lz/2 
+      - ix==1..nx corresponds to it = nt..1
+
+    The field stored in this class has the following properties:
+      - shape: nx x ny x nz
+      - y: goes from -ly/2 to ly/2  ! <<<<< IMPORTANT subtlety, it has been flipped
+      - z: goes from -lz/2 to lz/2  
+      - ix==1..nx corresponds to it = nt..1 (it has not been flipped)
+    """
+
 
     @staticmethod
     def defaultExtensions():
         return ['.u','.v','.w','.bin']
 
     @staticmethod
     def formatName():
         return 'HAWC2 Turbulence box'
 
     def __init__(self,filename=None,**kwargs):
+        """ Initialize the class, if a filename is provided, the box is read. 
+        See the method `read` for  keywords arguments.
+        """
         self.filename = None
         if filename:
             self.read(filename=filename,**kwargs)
 
     def read(self, filename=None, N=None, dy=1, dz=1, y0=None, z0=0, zMid=None):
         """ read MannBox
-             field (nx x ny x nz)
-             NOTE: y-coord in Mann Box goes from Ly/2 -> -Ly/2 but we flip this to -Ly/2 -> Ly/2
+        INPUTS (all optional):
+        - filename: name of input file to be read
+        - N: tuple (nx x ny x nz) of box dimension. If None, dimensions are inferred from filename
+        - y0: minimum value of the y vector (default is -ly/2 where ly = ny x dy)
+        - z0: minimum value of the z vector (default is 0)
+        - zMid: mid value of the z vector (default it lz/2 where lz= nz x dz )
+
+        SET:
+         - the keys 'field', array of shape (nx x ny x nz)
+        NOTE: y-coord in Mann Box goes from Ly/2 -> -Ly/2 but we flip this to -Ly/2 -> Ly/2
         """
         if filename:
             self.filename = filename
         if not self.filename:
             raise Exception('No filename provided')
         if not os.path.isfile(self.filename):
             raise OSError(2,'File not found:',self.filename)
@@ -64,14 +115,15 @@
             temp = re.findall(r'\d+', basename)
             res = list(map(int, temp))
             if len(res)>=3:
                 N=res[-3:]
             else:
                 raise BrokenFormatError('Reading a Mann box requires the knowledge of the dimensions. The dimensions can be inferred from the filename, for instance: `filebase_1024x32x32.u`. Try renaming your file such that the three last digits are the dimensions in x, y and z.')
         nx,ny,nz=N
+
         def _read_buffered():
             data=np.zeros((nx,ny,nz),dtype=np.float32)
             with open(self.filename, mode='rb') as f:            
                 for ix in range(nx):
                     Buffer = np.frombuffer(f.read(4*ny*nz), dtype=np.float32) # 4-bytes
                     data[ix,:,:] =  np.flip(Buffer.reshape((ny,nz)),0)
             return data
@@ -114,19 +166,21 @@
     def __repr__(self):
         s='<{} object> with keys:\n'.format(type(self).__name__)
         s+='| - filename: {}\n'.format(self.filename)
         s+='| - field:  shape {}x{}x{}\n'.format(self['field'].shape[0],self['field'].shape[1],self['field'].shape[2])
         s+='|   min: {}, max: {}, mean: {} \n'.format(np.min(self['field']), np.max(self['field']), np.mean(self['field']))
         s+='| - dy, dz:  {}, {}\n'.format(self['dy'], self['dz'])
         s+='| - y0, z0 zMid:  {}, {}, {}\n'.format(self['y0'], self['z0'], self['zMid'])
-        s+='|useful getters: y, z, _iMid, fromTurbSim\n'
         z=self.z
         y=self.y
-        s+='|   y: [{} ... {}],  dy: {}, n: {} \n'.format(y[0],y[-1],self['dy'],len(y))
-        s+='|   z: [{} ... {}],  dz: {}, n: {} \n'.format(z[0],z[-1],self['dz'],len(z))
+        s+='| * y: [{} ... {}],  dy: {}, n: {} \n'.format(y[0],y[-1],self['dy'],len(y))
+        s+='| * z: [{} ... {}],  dz: {}, n: {} \n'.format(z[0],z[-1],self['dz'],len(z))
+        s+='|useful functions:\n'
+        s+='| - t(dx, U)\n'
+        s+='| - valuesAt(y,z), vertProfile(), fromTurbSim(*), _iMid()\n'
         return s
 
 
     @property
     def z(self):
         zmax = self['z0'] + (self['field'].shape[2]-1+0.1)*self['dz']
         z = np.arange(self['z0'], zmax, self['dz'])
```

### Comparing `welib-0.0.2/welib/weio/netcdf_file.py` & `welib-1.0.0/welib/weio/netcdf_file.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,23 +1,15 @@
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from builtins import map
-from builtins import range
-from builtins import chr
-from builtins import str
-from future import standard_library
-standard_library.install_aliases()
-
-from .file import File, WrongFormatError
 import pandas as pd
 
-#import xarray as xr  # 
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 class NetCDFFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.nc']
 
@@ -40,11 +32,9 @@
         dfs={}
         for k in self.data.keys():
             # Not pretty...
             if len(self.data[k].shape)==2:
                 dfs[k]=pd.DataFrame(data=self.data[k].values)
             elif len(self.data[k].shape)==1:
                 dfs[k]=pd.DataFrame(data=self.data[k].values)
-            #import pdb
-            #pdb.set_trace()
         return dfs
```

### Comparing `welib-0.0.2/welib/weio/parquet_file.py` & `welib-1.0.0/welib/weio/parquet_file.py`

 * *Files 8% similar despite different names*

```diff
@@ -28,14 +28,17 @@
         self.data.to_parquet(path=self.filename)
 
     def toDataFrame(self):
         #already stored as a data frame in self.data
         #just return self.data
         return self.data
 
+    def fromDataFrame(self, df):
+        #data already in dataframe
+        self.data = df
 
     def toString(self):
         """ use pandas DataFrame.to_string method to convert to a string """
         s=self.data.to_string()
         return s
 
     def __repr__(self):
```

### Comparing `welib-0.0.2/welib/weio/raawmat_file.py` & `welib-1.0.0/welib/weio/raawmat_file.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/tecplot_file.py` & `welib-1.0.0/welib/weio/tecplot_file.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/tools/graph.py` & `welib-1.0.0/welib/weio/tools/graph.py`

 * *Files 2% similar despite different names*

```diff
@@ -123,14 +123,21 @@
         
     @property
     def length(self):
         n1=self.nodes[0]
         n2=self.nodes[1]
         return np.sqrt((n1.x-n2.x)**2+(n1.y-n2.y)**2+(n1.z-n2.z)**2)
 
+    def setData(self, data_dict):
+        """ set or add data"""
+        for k,v in data_dict.items():
+            #if k in self.data.keys():
+            #    print('Warning overriding key {} for node {}'.format(k,self.ID))
+            self.data[k]=v
+
     def __repr__(self):
         s='<Elem{:4d}> NodeIDs: {} {}'.format(self.ID, self.nodeIDs, self.data)
         if self.propIDs is not None:
             s+=' {'+'propIDs:{} propset:{}'.format(self.propIDs, self.propset)+'}'
         if self.nodes is not None:
             s+=' l={:.2f}'.format(self.length)
         return s
@@ -295,14 +302,25 @@
     def setElementNodalProp(self, elem, propset, propIDs):
         """ 
         Set Nodal Properties to each node of an element
         """
         for node, pID in zip(elem.nodes, propIDs):
             node.setData(self.getNodeProperty(propset, pID).data)
 
+    def setElementNodalPropToElem(self, elem):
+        """ 
+        Set Element Properties to an element
+        TODO: this seems to be a hack. It should be automatic I think...
+        """
+        propset=elem.propset
+        propIDs=elem.propIDs
+        # USING PROPID 0!!!
+        elem.setData(self.getNodeProperty(propset, propIDs[0]).data)
+        # TODO average the two maybe..
+
     def setNodeNodalProp(self, node, propset, propID):
         """ 
         Set Nodal Properties to a node
         """
         node.setData(self.getNodeProperty(propset, propID).data)
 
     def setNodalData(self, nodeID, **data_dict):
@@ -597,15 +615,14 @@
                     'omega':self.Modes[iMode]['freq']*2*np.pi, #in [rad/s]
                     'Displ':self.Modes[iMode]['data'].tolist()
                 }  for iMode,mode in enumerate(self.Modes)]
         d['groundLevel']=np.min(Points[:,2]) # TODO
 
         if outfile is not None:
             import json
-            from io import open
             jsonFile=outfile
             with open(jsonFile, 'w', encoding='utf-8') as f:
                 #f.write(to_json(d))
                 try:
                     #f.write(unicode(json.dumps(d, ensure_ascii=False))) #, indent=2)
                     #f.write(json.dumps(d, ensure_ascii=False)) #, indent=2)
                     f.write(json.dumps(d, ensure_ascii=False))
```

### Comparing `welib-0.0.2/welib/weio/turbsim_file.py` & `welib-1.0.0/welib/yams/yams_sympy_tools.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,714 +1,770 @@
-"""Read/Write TurbSim File
-
-Part of weio library: https://github.com/ebranlard/weio
-
+""" 
+Tools for yams_sympy
 """
-import pandas as pd
+
 import numpy as np
 import os
-import struct
-import time
-
+import sympy
+from sympy import latex, python, symarray, diff
+from sympy import Symbol, Matrix, collect
+from sympy import Function, DeferredVector, Derivative
+import sympy.physics.mechanics as me
+from sympy.physics.vector import dynamicsymbols
+from sympy.physics.mechanics.functions import find_dynamicsymbols
+from sympy import sin, cos, exp, sqrt
+
+
+# --------------------------------------------------------------------------------}
+# --- Basic math 
+# --------------------------------------------------------------------------------{
+def colvec(v): 
+    return Matrix([[v[0]],[v[1]],[v[2]]])
+def cross(V1,V2):
+    return [V1[1]*V2[2]-V1[2]*V2[1], V1[2]*V2[0]-V1[0]*V2[2], (V1[0]*V2[1]-V1[1]*V2[0]) ]
+def eye(n): 
+    return Matrix( np.eye(n).astype(int) )
+
+
+def skew(x):
+    """ Returns the skew symmetric matrix M, such that: cross(x,v) = M v """
+    #S = Matrix(np.zeros((3,3)).astype(int))
+    if hasattr(x,'shape') and len(x.shape)==2:
+        if x.shape[0]==3:
+            return Matrix(np.array([[0, -x[2,0], x[1,0]],[x[2,0],0,-x[0,0]],[-x[1,0],x[0,0],0]]))
+        else:
+            raise Exception('fSkew expect a vector of size 3 or matrix of size 3x1, got {}'.format(x.shape))
+    else:
+        return Matrix(np.array([[0, -x[2], x[1]],[x[2],0,-x[0]],[-x[1],x[0],0]]))
+
+# --------------------------------------------------------------------------------}
+# --- PYDY VIZ related...
+# --------------------------------------------------------------------------------{
 try:
-    from .file import File, EmptyFileError
+    import pydy.viz.scene 
+    from pydy.viz.scene import Scene
+    from pydy.viz.shapes import Shape
+    MyScene=Scene
 except:
-    EmptyFileError = type('EmptyFileError', (Exception,),{})
-    File=dict
+    Scene=object
+class MyScene(Scene):
+    def __init__(self, reference_frame, origin, *visualization_frames,
+                 **kwargs):
+        Scene.__init__(self, reference_frame, origin, *visualization_frames,
+                 **kwargs)
+        self.pydy_directory = "yams-viz-resources"
+    def create_static_html(self, overwrite=False, silent=False, prefix=None):
+        import distutils
+        import os
+        cur_dir=os.getcwd()
+        base = os.path.basename(cur_dir)
+        while base== self.pydy_directory:
+            parent = os.path.dirname(cur_dir)
+            os.chdir(parent)
+            print('>>>> CHANGING DIRECTORY')
+            cur_dir=os.getcwd()
+            base = os.path.basename(cur_dir)
+        Scene.create_static_html(self, overwrite=overwrite, silent=silent, prefix=prefix)
 
-class TurbSimFile(File):
-    """ 
-    Read/write a TurbSim turbulence file (.bts). The object behaves as a dictionary.
 
-    Main keys
-    ---------
-    - 'u': velocity field, shape (3 x nt x ny x nz)
-    - 'y', 'z', 't': space and time coordinates 
-    - 'dt', 'ID', 'info'
-    - 'zTwr', 'uTwr': tower coordinates and field if present (3 x nt x nTwr)
-    - 'zHub', 'uHub': height and velocity at a reference point (usually not hub)
-
-    Main methods
-    ------------
-    - read, write, toDataFrame, keys, valuesAt, makePeriodic, checkPeriodic, closestPoint
-
-    Examples
-    --------
-
-        ts = TurbSimFile('Turb.bts')
-        print(ts.keys())
-        print(ts['u'].shape)  
-        u,v,w = ts.valuesAt(y=10.5, z=90)
-
-
-    """
-
-    @staticmethod
-    def defaultExtensions():
-        return ['.bts']
-
-    @staticmethod
-    def formatName():
-        return 'TurbSim binary'
-
-    def __init__(self,filename=None, **kwargs):
-        self.filename = None
-        if filename:
-            self.read(filename, **kwargs)
-
-    def read(self, filename=None, header_only=False):
-        """ read BTS file, with field: 
-                     u    (3 x nt x ny x nz)
-                     uTwr (3 x nt x nTwr)
-        """
-        if filename:
-            self.filename = filename
-        if not self.filename:
-            raise Exception('No filename provided')
-        if not os.path.isfile(self.filename):
-            raise OSError(2,'File not found:',self.filename)
-        if os.stat(self.filename).st_size == 0:
-            raise EmptyFileError('File is empty:',self.filename)
-
-        scl = np.zeros(3, np.float32); off = np.zeros(3, np.float32)
-        with open(self.filename, mode='rb') as f:            
-            # Reading header info
-            ID, nz, ny, nTwr, nt                      = struct.unpack('<h4l', f.read(2+4*4))
-            dz, dy, dt, uHub, zHub, zBottom           = struct.unpack('<6f' , f.read(6*4)  )
-            scl[0],off[0],scl[1],off[1],scl[2],off[2] = struct.unpack('<6f' , f.read(6*4))
-            nChar, = struct.unpack('<l',  f.read(4))
-            info = (f.read(nChar)).decode()
-            # Reading turbulence field
-            if not header_only: 
-                u    = np.zeros((3,nt,ny,nz))
-                uTwr = np.zeros((3,nt,nTwr))
-                # For loop on time (acts as buffer reading, and only possible way when nTwr>0)
-                for it in range(nt):
-                    Buffer = np.frombuffer(f.read(2*3*ny*nz), dtype=np.int16).astype(np.float32).reshape([3, ny, nz], order='F')
-                    u[:,it,:,:]=Buffer
-                    Buffer = np.frombuffer(f.read(2*3*nTwr), dtype=np.int16).astype(np.float32).reshape([3, nTwr], order='F')
-                    uTwr[:,it,:]=Buffer
-                u -= off[:, None, None, None]
-                u /= scl[:, None, None, None]
-                self['u']    = u
-                uTwr -= off[:, None, None]
-                uTwr /= scl[:, None, None]
-                self['uTwr'] = uTwr
-        self['info'] = info
-        self['ID']   = ID
-        self['dt']   = dt
-        self['y']    = np.arange(ny)*dy 
-        self['y']   -= np.mean(self['y']) # y always centered on 0
-        self['z']    = np.arange(nz)*dz +zBottom
-        self['t']    = np.arange(nt)*dt
-        self['zTwr'] =-np.arange(nTwr)*dz + zBottom
-        self['zHub'] = zHub
-        self['uHub'] = uHub
-
-    def write(self, filename=None):
-        """ 
-        write a BTS file, using the following keys: 'u','z','y','t','uTwr'
-                     u    (3 x nt x ny x nz)
-                     uTwr (3 x nt x nTwr)
-        """
-        if filename:
-            self.filename = filename
-        if not self.filename:
-            raise Exception('No filename provided')
-
-        nDim, nt, ny, nz = self['u'].shape
-        if 'uTwr' not in self.keys() :
-            self['uTwr']=np.zeros((3,nt,0))
-        if 'ID' not in self.keys() :
-            self['ID']=7
-
-        _, _, nTwr = self['uTwr'].shape
-        tsTwr  = self['uTwr']
-        ts     = self['u']
-        intmin = -32768
-        intrng = 65535
-        off    = np.empty((3), dtype    = np.float32)
-        scl    = np.empty((3), dtype    = np.float32)
-        info = 'Generated by TurbSimFile on {:s}.'.format(time.strftime('%d-%b-%Y at %H:%M:%S', time.localtime()))
-        # Calculate scaling, offsets and scaling data
-        out    = np.empty(ts.shape, dtype=np.int16)
-        outTwr = np.empty(tsTwr.shape, dtype=np.int16)
-        for k in range(3):
-            all_min, all_max = ts[k].min(), ts[k].max()
-            if nTwr>0:
-                all_min=min(all_min, tsTwr[k].min())
-                all_max=max(all_max, tsTwr[k].max())
-            if all_min == all_max:
-                scl[k] = 1
-            else:
-                scl[k] = intrng / (all_max-all_min)
-            off[k]    = intmin - scl[k] * all_min
-            out[k]    = (ts[k]    * scl[k] + off[k]).astype(np.int16)
-            outTwr[k] = (tsTwr[k] * scl[k] + off[k]).astype(np.int16)
-        z0 = self['z'][0]
-        dz = self['z'][1]- self['z'][0]
-        dy = self['y'][1]- self['y'][0]
-        dt = self['t'][1]- self['t'][0]
-
-        # Providing estimates of uHub and zHub even if these fields are not used
-        zHub,uHub, bHub = self.hubValues()
-
-        with open(self.filename, mode='wb') as f:            
-            f.write(struct.pack('<h4l', self['ID'], nz, ny, nTwr, nt))
-            f.write(struct.pack('<6f', dz, dy, dt, uHub, zHub, z0)) # NOTE uHub, zHub maybe not used
-            f.write(struct.pack('<6f', scl[0],off[0],scl[1],off[1],scl[2],off[2]))
-            f.write(struct.pack('<l' , len(info)))
-            f.write(info.encode())
-            try:
-                for it in np.arange(nt):
-                    f.write(out[:,it,:,:].tobytes(order='F'))
-                    f.write(outTwr[:,it,:].tobytes(order='F'))
-            except:
-                for it in np.arange(nt):
-                    f.write(out[:,it,:,:].tostring(order='F'))
-                    f.write(outTwr[:,it,:].tostring(order='F'))
-
-    # --------------------------------------------------------------------------------}
-    # --- Convenient properties (matching Mann Box interface as well)
-    # --------------------------------------------------------------------------------{
-    @property
-    def z(self): return self['z']
-
-    @property
-    def y(self): return self['y']
-
-    @property
-    def t(self): return self['t']
-
-    # --------------------------------------------------------------------------------}
-    # --- Extracting relevant data 
-    # --------------------------------------------------------------------------------{
-    def valuesAt(self, y, z, method='nearest'):
-        """ return wind speed time series at a point """
-        if method == 'nearest':
-            iy, iz = self.closestPoint(y, z)
-            u = self['u'][0,:,iy,iz]
-            v = self['u'][0,:,iy,iz]
-            w = self['u'][0,:,iy,iz]
-        else:
-            raise NotImplementedError()
-        return u, v, w
+def frame_viz(Origin, frame, l=1, r=0.08, name=''):
+    """
+    Generate visualization objects for a frame, i.e. three axes, represented by cylinders 
+      x: red
+      y: green
+      z: blue
+
+    """
+    from pydy.viz.shapes import Cylinder
+    from pydy.viz.visualization_frame import VisualizationFrame
+    from sympy.physics.mechanics import Point
+
+    #
+    X_frame  = frame.orientnew('ffx', 'Axis', (-np.pi/2, frame.z) ) # Make y be x
+    Z_frame  = frame.orientnew('ffz', 'Axis', (+np.pi/2, frame.x) ) # Make y be z
+    
+    X_shape   = Cylinder(radius=r, length=l, color='red') # Cylinder are along y
+    Y_shape   = Cylinder(radius=r, length=l, color='green')
+    Z_shape   = Cylinder(radius=r, length=l, color='blue')
+    
+    X_center=Point('X'); X_center.set_pos(Origin, l/2 * X_frame.y)
+    Y_center=Point('Y'); Y_center.set_pos(Origin, l/2 *   frame.y)
+    Z_center=Point('Z'); Z_center.set_pos(Origin, l/2 * Z_frame.y)
+    X_viz_frame = VisualizationFrame(name+'_xaxis',X_frame, X_center, X_shape)
+    Y_viz_frame = VisualizationFrame(name+'_yaxis',  frame, Y_center, Y_shape)
+    Z_viz_frame = VisualizationFrame(name+'_zaxis',Z_frame, Z_center, Z_shape)
+    return X_viz_frame, Y_viz_frame, Z_viz_frame
 
-    def closestPoint(self, y, z):
-        iy = np.argmin(np.abs(self['y']-y))
-        iz = np.argmin(np.abs(self['z']-z))
-        return iy,iz
-
-    def hubValues(self, zHub=None):
-        if zHub is None:
-            try:
-                zHub=float(self['zHub'])
-                bHub=True
-            except:
-                bHub=False
-                iz = np.argmin(np.abs(self['z']-(self['z'][0]+self['z'][-1])/2))
-                zHub = self['z'][iz]
+def body_viz(b, vo):
+    """ 
+    Return a "vizualization" of a body, based on options 
+    For "pydy" viz for now
+    
+    - b: YAMSBody
+    - vo: dictionary of options
+    """
+    from pydy.viz.shapes import Cylinder, Sphere, Cube, Box
+    from pydy.viz.visualization_frame import VisualizationFrame
+    from sympy.physics.mechanics import Point
+    # NOTE: rememeber that cylinders are along "y" by default and about their center
+    X_frame  = b.frame.orientnew('ffx', 'Axis', (-np.pi/2, b.frame.z) ) # Make y be x
+    Z_frame  = b.frame.orientnew('ffz', 'Axis', (+np.pi/2, b.frame.x) ) # Make y be z
+    vo = b.viz_opts
+    if 'type' in vo:
+        if vo['type']=='cylinder':
+            l = vo['length']
+            cyl = Cylinder(radius=vo['radius'], length=l, color=vo['color'])
+            C_center=Point('C'); 
+            if vo['normal'] == 'y':
+                C_center.set_pos(b.origin, l/2 * b.frame.y)
+                bod_viz = VisualizationFrame(b.name+'_body',b.frame, C_center, cyl)
+            elif vo['normal'] == 'z':
+                C_center.set_pos(b.origin, l/2 * Z_frame.y)
+                bod_viz = VisualizationFrame(b.name+'_body',Z_frame, C_center, cyl)
+            elif vo['normal'] == 'x':
+                C_center.set_pos(b.origin, l/2 * X_frame.y)
+                bod_viz = VisualizationFrame(b.name+'_body',X_frame, C_center, cyl)
+            return [bod_viz]
+        elif vo['type']=='three-blades':
+            l = vo['radius']
+            blade_shape = Cylinder(radius=0.03*vo['radius'] , length=l, color=vo['color'])
+            # TODO might need to be thought again
+            if vo['normal'] == 'z':
+                B1_frame  = b.frame.orientnew('b1', 'Axis', (np.pi/2+0 ,        b.frame.z) ) # Y pointing along blade-Z
+                B2_frame  = b.frame.orientnew('b2', 'Axis', (np.pi/2+2*np.pi/3, b.frame.z) )
+                B3_frame  = b.frame.orientnew('b3', 'Axis', (np.pi/2+4*np.pi/3, b.frame.z) )
+                B1_center=Point('B1'); B1_center.set_pos(b.origin, l/2 * B1_frame.y)
+                B2_center=Point('B2'); B2_center.set_pos(b.origin, l/2 * B2_frame.y)
+                B3_center=Point('B3'); B3_center.set_pos(b.origin, l/2 * B3_frame.y)
+            B1_viz = VisualizationFrame(b.name+'_body_blade1',B1_frame, B1_center, blade_shape)
+            B2_viz = VisualizationFrame(b.name+'_body_blade2',B2_frame, B2_center, blade_shape)
+            B3_viz = VisualizationFrame(b.name+'_body_blade3',B3_frame, B3_center, blade_shape)
+            return [B1_viz, B2_viz, B3_viz]
+        elif vo['type']=='cube':
+            cube = Cube(length=vo['length'], color=vo['color'], name=b.name+'_body')
+            return [VisualizationFrame(b.name+'_body', b.frame, b.origin, cube)]
+        elif vo['type']=='box':
+            box = Box(width=vo['width'], height=vo['height'], depth=vo['depth'], color=vo['color'], name=b.name+'_body')
+            return [VisualizationFrame(b.name+'_body', b.frame, b.origin, box)]
         else:
-            bHub=True
-        try:
-            uHub=float(self['uHub'])
-        except:
-            iz = np.argmin(np.abs(self['z']-zHub))
-            iy = np.argmin(np.abs(self['y']-(self['y'][0]+self['y'][-1])/2))
-            uHub = np.mean(self['u'][0,:,iy,iz])
-        return zHub, uHub, bHub
-
-    def midValues(self):
-        iy,iz = self._iMid()
-        zMid = self['z'][iz]
-        #yMid = self['y'][iy] # always 0
-        uMid = np.mean(self['u'][0,:,iy,iz])
-        return zMid, uMid
-
-    def _iMid(self):
-        iy = np.argmin(np.abs(self['y']-(self['y'][0]+self['y'][-1])/2))
-        iz = np.argmin(np.abs(self['z']-(self['z'][0]+self['z'][-1])/2))
-        return iy,iz
-
-    def closestPoint(self, y, z):
-        iy = np.argmin(np.abs(self['y']-y))
-        iz = np.argmin(np.abs(self['z']-z))
-        return iy,iz
-
-    def _longiline(ts, iy0=None, iz0=None, mean=True):
-        """ return velocity components on a longitudinal line
-        If no index is provided, computed at mid box 
-        """
-        if iy0 is None:
-            iy0,iz0 = ts._iMid()
-        u = ts['u'][0,:,iy0,iz0]
-        v = ts['u'][1,:,iy0,iz0]
-        w = ts['u'][2,:,iy0,iz0]
-        if not mean:
-            u -= np.mean(u)
-            v -= np.mean(v)
-            w -= np.mean(w)
-        return u, v, w
-
-    def _latline(ts, ix0=None, iz0=None, mean=True):
-        """ return velocity components on a lateral line
-        If no index is provided, computed at mid box 
-        """
-        if ix0 is None:
-            iy0,iz0 = ts._iMid()
-            ix0=int(len(ts['t'])/2)
-        u = ts['u'][0,ix0,:,iz0]
-        v = ts['u'][1,ix0,:,iz0]
-        w = ts['u'][2,ix0,:,iz0]
-        if not mean:
-            u -= np.mean(u)
-            v -= np.mean(v)
-            w -= np.mean(w)
-        return u, v, w
-
-    def _vertline(ts, ix0=None, iy0=None, mean=True):
-        """ return velocity components on a vertical line
-        If no index is provided, computed at mid box 
-        """
-        if ix0 is None:
-            iy0,iz0 = ts._iMid()
-            ix0=int(len(ts['t'])/2)
-        u = ts['u'][0,ix0,iy0,:]
-        v = ts['u'][1,ix0,iy0,:]
-        w = ts['u'][2,ix0,iy0,:]
-        if not mean:
-            u -= np.mean(u)
-            v -= np.mean(v)
-            w -= np.mean(w)
-        return u, v, w
-
-    @property
-    def vertProfile(self):
-        iy, iz = self._iMid()
-        m = np.mean(self['u'][:,:,iy,:], axis=1)
-        s = np.std( self['u'][:,:,iy,:], axis=1)
-        return self.z, m, s
-
-
-    # --------------------------------------------------------------------------------}
-    # --- Computation of useful quantities
-    # --------------------------------------------------------------------------------{
-    def crosscorr_y(ts, iy0=None, iz0=None):
-        """ Cross correlation along y
-        If no index is provided, computed at mid box 
-        """
-        y = ts['y']
-        if iy0 is None:
-            iy0,iz0 = ts._iMid()
-        u, v, w = ts._longiline(iy0=iy0, iz0=iz0, mean=False)
-        rho_uu_y=np.zeros(len(y))
-        rho_vv_y=np.zeros(len(y))
-        rho_ww_y=np.zeros(len(y))
-        for iy,_ in enumerate(y):
-            ud, vd, wd = ts._longiline(iy0=iy, iz0=iz0, mean=False)
-            rho_uu_y[iy] = np.mean(u*ud)/(np.std(u)*np.std(ud))
-            rho_vv_y[iy] = np.mean(v*vd)/(np.std(v)*np.std(vd))
-            rho_ww_y[iy] = np.mean(w*wd)/(np.std(w)*np.std(wd))
-        return y, rho_uu_y, rho_vv_y, rho_ww_y
-
-    def crosscorr_z(ts, iy0=None, iz0=None):
-        """ 
-        Cross correlation along z, mid box
-        If no index is provided, computed at mid box 
-        """
-        z = ts['z']
-        if iy0 is None:
-            iy0,iz0 = ts._iMid()
-        u, v, w = ts._longiline(iy0=iy0, iz0=iz0, mean=False)
-        rho_uu_z = np.zeros(len(z))
-        rho_vv_z = np.zeros(len(z))
-        rho_ww_z = np.zeros(len(z))
-        for iz,_ in enumerate(z):
-            ud, vd, wd = ts._longiline(iy0=iy0, iz0=iz, mean=False)
-            rho_uu_z[iz] = np.mean(u*ud)/(np.std(u)*np.std(ud))
-            rho_vv_z[iz] = np.mean(v*vd)/(np.std(v)*np.std(vd))
-            rho_ww_z[iz] = np.mean(w*wd)/(np.std(w)*np.std(wd))
-        return z, rho_uu_z, rho_vv_z, rho_ww_z
-
-
-    def csd_longi(ts, iy0=None, iz0=None):
-        """ Compute cross spectral density
-        If no index is provided, computed at mid box 
-        """
-        import scipy.signal as sig
-        u, v, w = ts._longiline(iy0=iy0, iz0=iz0, mean=False)
-        t       = ts['t']
-        dt      = t[1]-t[0]
-        fs      = 1/dt
-        fc, chi_uu = sig.csd(u, u, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_vv = sig.csd(v, v, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_ww = sig.csd(w, w, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        return fc, chi_uu, chi_vv, chi_ww
-
-    def csd_lat(ts, ix0=None, iz0=None):
-        """ Compute lateral cross spectral density
-        If no index is provided, computed at mid box 
-        """
-        import scipy.signal as sig
-        u, v, w = ts._latline(ix0=ix0, iz0=iz0, mean=False)
-        t       = ts['t']
-        dt      = t[1]-t[0]
-        fs      = 1/dt
-        fc, chi_uu = sig.csd(u, u, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_vv = sig.csd(v, v, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_ww = sig.csd(w, w, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        return fc, chi_uu, chi_vv, chi_ww
-
-    def csd_vert(ts, ix0=None, iy0=None):
-        """ Compute vertical cross spectral density
-        If no index is provided, computed at mid box 
-        """
-        import scipy.signal as sig
-        t       = ts['t']
-        dt      = t[1]-t[0]
-        fs      = 1/dt
-        u, v, w = ts._vertline(ix0=ix0, iy0=iy0, mean=False)
-        u= u-np.mean(u)
-        v= v-np.mean(v)
-        w= w-np.mean(w)
-        fc, chi_uu = sig.csd(u, u, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_vv = sig.csd(v, v, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        fc, chi_ww = sig.csd(w, w, fs=fs, scaling='density') #nperseg=4096, noverlap=2048, detrend='constant')
-        return fc, chi_uu, chi_vv, chi_ww
-
-
-    def coherence_longi(ts, iy0=None, iz0=None):
-        """ Coherence on a longitudinal line for different delta y and delta z
-        compared to a given point with index iy0,iz0
-        """
-        import scipy.signal as sig
-        if iy0 is None:
-            iy0,iz0 = ts._iMid()
-        u, v, w = ts._longiline(iy0=iy0, iz0=iz0, mean=False)
-        y = ts['y']
-        z = ts['z']
-        diy=1
-        dy=y[iy]-y[iy0]
-        # TODO
-        iy = iy0+diy
-        ud, vd, wd = ts._longiline(iy0=iy, iz0=iz0, mean=False)
-        fc, coh_uu_y1 = sig.coherence(u,ud, fs=fs)
-        _ , coh_vv_y1 = sig.coherence(v,vd, fs=fs)
-        _ , coh_ww_y1 = sig.coherence(w,wd, fs=fs)
-
-        iy = iy+diy
-        ud, vd, wd = ts._longiline(iy0=iy, iz0=iz0, mean=False)
-        _ , coh_uu_y2 = sig.coherence(u,ud, fs=fs)
-        _ , coh_vv_y2 = sig.coherence(v,vd, fs=fs)
-        _ , coh_ww_y2 = sig.coherence(w,wd, fs=fs)
-
-
-    # --------------------------------------------------------------------------------}
-    # --- Modifierss
-    # --------------------------------------------------------------------------------{
-    def scale(self, new_mean=None, new_std=None, component=0, reference='mid', y_ref=0, z_ref=None):
-        """ 
-        TODO needs more thinking
-        """
-        # mean/std values for each points in the plane (averaged with time)
-        old_plane_mean = np.mean(self['u'][component,:,:,:],axis=0)
-        old_plane_std  = np.std( self['u'][component,:,:,:],axis=0)
-        if reference=='mid':
-            iy,iz = self._iMid()
-            old_mean = np.mean(self['u'][component,:,iy,iz])
-            old_std  = np.std (self['u'][component,:,iy,iz])
-        elif reference=='point':
-            iy, iz = self.closestPoint(y_ref, z_ref)
-            old_mean = np.mean(self['u'][component,:,iy,iz])
-            old_std  = np.std (self['u'][component,:,iy,iz])
+            raise NotImplementedError('Type, ',vo['type'])
+
+
+# --------------------------------------------------------------------------------}
+# --- Tools
+# --------------------------------------------------------------------------------{
+def exprHasFunction(expr):
+    """ return True if a sympy expression contains a function"""
+    if hasattr(expr, 'atoms'): 
+        return len(expr.atoms(Function))>0
+    else:
+        return False
+
+
+def subs_no_diff(expr, subslist):
+    """ 
+    Perform substitution in an expression, but not in the time derivatives
+    Only works if Subslist is a simple lists of ( var, value) 
+
+
+    see also: sympy.physics.mechanics.functions.msubs
+
+    TODO extend to matrix
+
+    """
+
+
+    # Set mapping between time derivatives and dummy variables
+    time=dynamicsymbols._t
+    Dummys=symarray('DUM', len(subslist))
+    DT2Dummy=[]
+    for i, (var,b) in enumerate(subslist):
+        if len(var.atoms())!=1:
+            print(var)
+            print(type(var))
+            raise Exception('subs_no_diff only works for simple (atomic) substitution')
+        if exprHasFunction(var):
+            dvar = diff(var,time)
+            DT2Dummy.append((dvar,Dummys[i]))
+    Dummy2DT=[(b,a) for a,b in DT2Dummy]
+
+    # Remove time derivative
+    expr_clean = expr.subs(DT2Dummy)
+
+    # Perform user substitution
+    expr_new = expr_clean.subs(subslist)
+
+    # Reinsert time derivatives
+    return expr_new.subs(Dummy2DT)
+
+def mycollect(expr, var_list, evaluate=True, **kwargs):
+    """ Acts as collect but substitute the symbols with dummy symbols first so that it can work with partial derivatives. 
+        Matrix expressions are also supported. 
+    """
+    if not hasattr(var_list, '__len__'):
+        var_list=[var_list]
+    # Mapping Var -> Dummy, and Dummy-> Var
+    Dummies=symarray('DUM', len(var_list))
+    Var2Dummy=[(var, Dummies[i]) for i,var in enumerate(var_list)]
+    Dummy2Var=[(b,a) for a,b in Var2Dummy]
+    # Replace var with dummies and apply collect
+    expr = expr.expand().doit()
+    expr = expr.subs(Var2Dummy)
+    if hasattr(expr, '__len__'):
+        expr = expr.applyfunc(lambda ij: collect(ij, Dummies, **kwargs))
+    else:
+        expr = collect(expr, Dummies, evaluate=evaluate, **kwargs)
+    # Substitute back
+    if evaluate:
+        return expr.subs(Dummy2Var)
+    d={}
+    for k,v in expr.items():
+        k=k.subs(Dummy2Var)
+        v=v.subs(Dummy2Var)
+        d[k]=v
+    return d
+
+def myjacobian(expr, var_list, value_list=None):
+    """ Compute jacobian of expression, matrix or not. 
+    Perform symbol substitution first to have support for derivatives
+
+    J = [ \partial fi / \partial_xj ]_x0
+
+    Inputs:
+      - expr:  (f_i) expression to compute the jacobian of. Scalar, list or matrix,
+      - var_list: (x_j) list of variables 
+    Optional:
+      - value_list: (x0): values at operating point (same length as var_list)
+    
+    Examples:
+        x,y = symbols('x, y')
+        a,b = symbols('a, b')
+        f1  = a*x + b*y**2
+        f2  = a*y + b*x**2
+        f = Matrix([[f1],[f2]])
+        J = myjacobian(f, [x,y])
+
+    """
+    if not hasattr(var_list, '__len__'):
+        var_list=[var_list]
+    # Mapping Var -> Dummy, and Dummy-> Var
+    Dummies=symarray('DUM', len(var_list))
+    Var2Dummy=[(var, Dummies[i]) for i,var in enumerate(var_list)]
+    Dummy2Var=[(b,a) for a,b in Var2Dummy]
+    if isinstance(expr, list):
+        expr = Matrix(expr)
+    expr = expr.expand().doit()
+    expr = expr.subs(Var2Dummy)
+    if hasattr(expr, '__len__'):
+        jac = expr.jacobian(Dummies)
+    else:
+        jac = Matrix([expr]).jacobian(Dummies)
+    jac = jac.subs(Dummy2Var)
+    if value_list is not None:
+        sub_list = [(var,val) for var,val in zip(var_list, value_list)]
+        jac = jac.subs(sub_list)
+    return jac
+
+def linearize(expr, x0, order=1, sym=False, doSimplifyIfDeriv=True):
+    """ 
+    Return a Taylor expansion of the expression at the operating point x0
+    INPUTS:
+        expr: expression to be linearized
+        x0: operating point [(x,0),(y,0),...]
+        order: order of Taylor expansion
+        sym: If sym is true and expr is an array of dimension 2, symmetry is assumed to avoid computing the linearization of symmetric elements
+    OUTPUTS:
+       linearized expression
+
+    Basically computes:
+      f(x,y) = f(x0,y0) + df/dx_0 (x-x0) + df/dy_0 (y-y0)
+
+    if y=dx/dt, y is considered to be an independent variable (dxdt is substituted for a dummy variable y)
+
+
+    Examples: 
+        linearize(Function('f')(x,y), [(x, x0),(y, y0)], order=1)
+
+
+
+
+    """
+    time=dynamicsymbols._t
+    x0_bkp = x0
+    # --- First protect variables that are derivatives
+    # TODO We really need to do something cleaner for that. Consider using:
+    #    qd.is_Derivative
+    #    qd.variables
+    #    qd.variable_count
+    #    qd.free_symbols
+    #    qd._vwr_variables
+    #    qd.expr
+    DummysXD=symarray('DUMQD', len(x0))
+    xd_2_dum=[]
+    x0_new=[]
+    for i,(q,q0) in enumerate(x0):
+        if q.is_Derivative:
+            xd_dum = DummysXD[i]
+            x0_new.append((xd_dum, q0))
+            xd_2_dum=[(q, xd_dum)]
         else:
-            raise NotImplementedError(reference)
-        # Scaling standard deviation without affecting the mean
-        self['u'][component,:,:,:] -= old_plane_mean
-        if new_std is not None:
-            self['u'][component,:,:,:] *= new_std/old_std
-        self['u'][component,:,:,:] += old_plane_mean
-
-        # Scaling mean
-        if new_mean is not None:
-            self['u'][component,:,:,:] += -old_mean+new_mean
-
-        # Sanity check
-        new_mean2= np.mean(self['u'][component,:,iy,iz])
-        new_std2 = np.std(self['u'][component,:,iy,iz])
-        if new_mean is not None:
-            print('New mean: {:7.3f}  (target: {:7.3f}, old: {:7.3f})'.format(new_mean2, new_mean, old_mean))
-        if new_std is not None:
-            print('New std : {:7.3f}  (target: {:7.3f}, old: {:7.3f})'.format(new_std2 , new_std , old_std))
-
-    def makePeriodic(self):
-        """ Make the box periodic by mirroring it """
-        nDim, nt0, ny, nz = self['u'].shape
-        u = self['u'].copy()
-        del self['u']
-
-        nt = 2*len(self['t'])-2
-        dt = self['t'][1]- self['t'][0]
-        self['u']  = np.zeros((nDim,nt,ny,nz))
-        self['u'][:,:nt0,:,:] = u
-        self['u'][:,nt0:,:,:] = np.flip(u[:,1:-1,:,:],axis=1)
-        self['t'] = np.arange(nt)*dt
-        if 'uTwr' in self.keys():
-            _, _, nTwr = self['uTwr'].shape
-            uTwr = self['uTwr'].copy()
-            del self['uTwr']
-            # empty tower for now
-            self['uTwr'] = np.zeros((nDim,nt,nTwr))
-            self['uTwr'][:,:nt0,:] = uTwr
-            self['uTwr'][:,nt0:,:] = np.flip(uTwr[:,1:-1,:],axis=1)
-
-        self['ID']=8 # Periodic
-
-
-    def checkPeriodic(self, sigmaTol=1.5, aTol=0.5):
-        """ Check periodicity in u """
-        ic=0
-        sig  = np.std(self['u'][ic,:,:,:],axis=0)
-        mean = np.mean(self['u'][ic,:,:,:],axis=0)
-        u_first= self['u'][ic,0 ,:,:]
-        u_last = self['u'][ic,-1,:,:]
-        relSig = np.abs(u_first-u_last)/sig
-        compPeriodic = (np.max(relSig) < sigmaTol) and (np.mean(np.abs(u_first-u_last))<aTol)
-        return compPeriodic
-
-
-    def __repr__(self):
-        s='<{} object> with keys:\n'.format(type(self).__name__)
-        s+=' - filename: {}\n'.format(self.filename)
-        s+=' - ID: {}\n'.format(self['ID'])
-        s+=' - z: [{} ... {}],  dz: {}, n: {} \n'.format(self['z'][0],self['z'][-1],self['z'][1]-self['z'][0],len(self['z']))
-        s+=' - y: [{} ... {}],  dy: {}, n: {} \n'.format(self['y'][0],self['y'][-1],self['y'][1]-self['y'][0],len(self['y']))
-        s+=' - t: [{} ... {}],  dt: {}, n: {} \n'.format(self['t'][0],self['t'][-1],self['t'][1]-self['t'][0],len(self['t']))
-        s+=' - u: ({} x {} x {} x {}) \n'.format(*(self['u'].shape))
-        ux,uy,uz=self['u'][0], self['u'][1], self['u'][2]
-        s+='    ux: min: {}, max: {}, mean: {} \n'.format(np.min(ux), np.max(ux), np.mean(ux))
-        s+='    uy: min: {}, max: {}, mean: {} \n'.format(np.min(uy), np.max(uy), np.mean(uy))
-        s+='    uz: min: {}, max: {}, mean: {} \n'.format(np.min(uz), np.max(uz), np.mean(uz))
-
-        # Mid of box, nearest neighbor
-        iy,iz = self._iMid()
-        zMid=self['z'][iz]
-        yMid=self['y'][iy]
-        uMid = np.mean(self['u'][0,:,iy,iz])
-        s+='    yMid: {} - zMid: {} - iy: {} - iz: {} - uMid: {} (nearest neighbor))\n'.format(yMid, zMid, iy, iz, uMid)
-
-#         zMid, uMid, bHub = self.hubValues()
-#         if bHub:
-#             s+='    z"Hub": {} - u"Hub": {} (NOTE: values at TurbSim "hub")\n'.format(zMid, uMid)
-
-        # Tower
-        if 'zTwr' in self.keys() and len(self['zTwr'])>0:
-            s+=' - zTwr: [{} ... {}],  dz: {}, n: {} \n'.format(self['zTwr'][0],self['zTwr'][-1],self['zTwr'][1]-self['zTwr'][0],len(self['zTwr']))
-        if 'uTwr' in self.keys() and self['uTwr'].shape[2]>0:
-            s+=' - uTwr: ({} x {} x {} ) \n'.format(*(self['uTwr'].shape))
-            ux,uy,uz=self['uTwr'][0], self['uTwr'][1], self['uTwr'][2]
-            s+='    ux: min: {}, max: {}, mean: {} \n'.format(np.min(ux), np.max(ux), np.mean(ux))
-            s+='    uy: min: {}, max: {}, mean: {} \n'.format(np.min(uy), np.max(uy), np.mean(uy))
-            s+='    uz: min: {}, max: {}, mean: {} \n'.format(np.min(uz), np.max(uz), np.mean(uz))
-            
+            x0_new.append((q,q0))
+    x0 = x0_new
+    dum_2_xd = [(b,a) for a,b in xd_2_dum]
+
+    # --- Then protect expression from derivatives
+    # Mapping derivative -> Dummy
+    Dummys=symarray('DUM', len(x0))
+    DT2Dummy=[]
+    for i,(v,x) in enumerate(x0):
+        dv = diff(v,time)
+        if dv.is_Derivative:
+            DT2Dummy.append( (dv, Dummys[i])  )
+    Dummy2DT=[(b,a) for a,b in DT2Dummy]
+
+    # --- Remove Dummys
+    RemoveDummy = dum_2_xd + Dummy2DT
+    #print('RemoveDummy',RemoveDummy)
+    #print('x0',x0)
+
+    # Helper function, linearizes one expression (for matrices and lists..)
+    def __linearize_one_expr(myexpr):
+        # backup myexpr
+        myexpr0=myexpr
+        # Make operating point derivatives "dummy"
+        myexpr = myexpr.subs(xd_2_dum)
+        # Make other derivatives of states "dummy"
+        myexpr = myexpr.subs(DT2Dummy)
+
+        if myexpr.has(Derivative) and doSimplifyIfDeriv:
+            print('[WARN] Yams sympy linearize: Expression still contains derivative. Behavior might not be the right one. To be safe, we are running simplify on the expression.')
+            #NOTE: if expressions contains diff(-x,t) it won't work (for instance after a substitution). We need it simplified to -diff(x,t)
+            # We simplify expression
+            myexpr0=myexpr0.simplify()
+            # Make operating point derivatives "dummy"
+            myexpr = myexpr0.subs(xd_2_dum)
+            # Make other derivatives of states "dummy"
+            myexpr = myexpr.subs(DT2Dummy)
+        # --- Order 0
+        flin=myexpr.subs(x0)  # Order 0
+        # --- Order 1
+        if order>=1:
+            df = [(myexpr.diff(v1).subs(x0))*(v1-v10) for v1,v10 in x0]
+            df = sum(df)
+            flin += df
+        # --- Order 2
+        if order>=2:
+            df2 = [ (myexpr.diff(v1)).diff(v2).subs(x0)*(v1-v10)*(v2-v20) for v1,v10 in x0 for v2,v20 in x0]
+            df2 = sum(df2)/2
+            flin+=df2
+        # --- Order 3
+        if order>=3:
+            df3 = [ (myexpr.diff(v1)).diff(v2).diff(v3).subs(x0)*(v1-v10)*(v2-v20)*(v3-v30) for v1,v10 in x0 for v2,v20 in x0 for v3,v30 in x0]
+            df3 = sum(df3)/6
+            flin+=df3
+
+        if order>3:
+            raise NotImplementedError('Higher order')
+        return flin.subs(RemoveDummy)
+    
+    # --- Hanlde inputs of multiple dimension, scalar, vectors, matrices
+    try:
+        ndim=len(expr.shape)
+    except:
+        ndim=0
+
+    expr_lin=expr*0
+
+    if ndim==0:
+        expr_lin = __linearize_one_expr(expr)
+
+    elif ndim==1:
+        for i in range(expr.shape[0]):
+            expr_lin[i] = __linearize_one_expr(expr[i])
+
+    elif ndim==2:
+        if expr.shape[0] != expr.shape[1]:
+            sym=False
+
+        for i in range(expr.shape[0]):
+            for j in range(expr.shape[1]):
+                if (j<=i and sym) or (not sym):
+                    expr_lin[i,j] = __linearize_one_expr(expr[i,j])
+                if sym:
+                    expr_lin[j,i] = expr_lin[i,j]
+    else:
+        raise NotImplementedError()
+
+    return expr_lin
+
+
+
+def smallAngleApprox(expr, angle_list, order=1, sym=True):
+    """ 
+    Perform small angle approximation of an expression by linearizing about the "0" operating point of each angle
+
+    INPUTS:
+        expr: expression to be linearized
+        angle_list: list of angle to be considered small:  [phi,alpha,...]
+        order: order of Taylor expansion
+        sym: If sym is true and expr is an array of dimension 2, symmetry is assumed to avoid computing the linearization of symmetric elements
+    OUTPUTS:
+       linearized expression
+    """
+    # operating point
+    x0=[(angle,0) for angle in angle_list]
+    return linearize(expr, x0, order=order, sym=sym, doSimplifyIfDeriv=False)
+
+
+
+# --------------------------------------------------------------------------------}
+# --- Misc sympy utils 
+# --------------------------------------------------------------------------------{
+def cleantex(expr):
+    """ clean a latex expression 
+    
+    Example:
+        print( cleantex( vlatex(MM, symbol_names={Jxx:'J_{xx}'})))
+    """
+    s=latex(expr)
+    D_rep={
+        '\\operatorname{sin}':'\\sin',
+        '\\operatorname{cos}':'\\cos',
+        '\\left(\\theta\\right)':'\\theta',
+        '\\left[\\begin{matrix}':'\\begin{bmatrix}\n', 
+        '\\end{matrix}\\right]':'\n\\end{bmatrix}\n' ,
+        '\\operatorname{q_{T1}}':'q_{T1}',
+        '\\operatorname{q_{T2}}':'q_{T2}',
+        '\operatorname{T_{a}}'  : 'T_a',
+        '\\left(t \\right)'    : '(t)',
+        '{(t)}': '(t)',
+        '{d t}': '{dt}',
+        'L_{T}':'L_T',
+        'M_{N}':'M_N',
+        '_{x}':'_x',
+        '_{y}':'_y',
+        '_{z}':'_z',
+        'x(t)':'x',
+        'y(t)':'y',
+        'z(t)':'z',
+        'T_a(t)': 'T_a',
+        'g(t)'  : 'g',
+        'phi_x(t)':'phi_x',
+        'phi_y(t)':'phi_y',
+        'phi_z(t)':'phi_z',
+        'psi(t)'  :'psi',
+        'q_{T1}(t)': 'q_{T1}',
+        'q_{T2}(t)': 'q_{T2}',
+        'frac{d}{dt} q_{T1}':'dot{q}_{T1}',
+        'frac{d}{dt} \\phi_x':'dot{\\phi}_x',
+        'frac{d}{dt} \\phi_y':'dot{\\phi}_y',
+        'frac{d}{dt} \\phi_z':'dot{\\phi}_z',
+        'frac{d}{dt} \\psi':'dot{\\psi}',
+        'frac{d}{dt} q_{T2}':'dot{q}_{T2}',
+#         '{RNA}':'{N}',
+#         'RNA':'N',
+        'x_{NG}^{2} + z_{NG}^{2}':'r_{NG}^2',
+        'M_N x_{NG}^{2} + M_N z_{NG}^{2}':'M_N r_{NG}^{2}',
+        'M_{R} x_{NR}^{2} + M_{R} z_{NR}^{2}':'M_{R} r_{NR}^{2}',
+        '\\theta_{tilt}':'\\theta_t',
+        '\\cos{\\left(\\theta_t \\right)}':'\\cos\\theta_t',
+        '\\sin{\\left(\\theta_t \\right)}':'\\sin\\theta_t',
+        '\\sin{\\left(\\phi_x \\right)}':'\\sin\\phi_x',
+        '\\sin{\\left(\\phi_y \\right)}':'\\sin\\phi_y',
+        '\\sin{\\left(\\phi_z \\right)}':'\\sin\\phi_z',
+        '\\cos{\\left(\\phi_x \\right)}':'\\cos\\phi_x',
+        '\\cos{\\left(\\phi_y \\right)}':'\\cos\\phi_y',
+        '\\cos{\\left(\\phi_z \\right)}':'\\cos\\phi_z',
+        '\\left(\\dot{\\phi}_x\\right)^{2}':'\dot{\\phi}_x^2',
+        '\\left(\\dot{\\phi}_y\\right)^{2}':'\dot{\\phi}_y^2',
+        '\\left(\\dot{\\phi}_z\\right)^{2}':'\dot{\\phi}_z^2',
+        '\\\\':'\\\\ \n' 
+        }
+    for k in D_rep.keys():
+        s=s.replace(k,D_rep[k])
+    return s
+
+
+def saveTex(expr, filename):
+    print('Exporting to {}'.format(filename))
+    with open(filename,'w') as f:
+        f.write(cleantex(expr))
+    print('Done')
+
+def cleanPySmallMat(expr, varname='R', indent=0, replDict=None, noTimeDep=True): 
+    """ Export a "small" matrix to python (row by row) """
+    def cleanPyAtom(atom):
+        s=repr(atom).replace(' ','')
+        if replDict is not None:
+            for k,v in replDict.items():
+                if s.find(k)>=0:
+                    s=s.replace(k,v)
+        if noTimeDep:
+            s=s.replace('(t)','',)
         return s
+    s=''
+    indent =''.join([' ']*indent)
+    dims=expr.shape
+    s+='{}{} = np.zeros(({},{}))\n'.format(indent,varname, dims[0],dims[1])
+    for i in np.arange(dims[0]):
+        s+='{}{}[{},:] = ['.format(indent,varname,i) + ','.join([cleanPyAtom(expr[i,j]) for j in np.arange(dims[1])]) +']\n' 
+    return s
+
+def cleanPySimple(expr, varname='R', indent=0, replDict=None, noTimeDep=False):
+    """ 
+    Clean a python sympy expression 
+    """
+    def cleanPyAtom(atom):
+        s=repr(atom)
+        # Replace
+        if replDict is not None:
+            for k,v in replDict.items():
+                if s.find(k)>=0:
+                    s=s.replace(k,v)
+        s=s.replace(' ','')
+        if noTimeDep:
+            s=s.replace('(t)','',)
+        return s
+    try:
+        dims=expr.shape
+    except:
+        dims=0
+        return '{}{} = '.format(indent,varname) + cleanPyAtom(expr), list(set(parameters)), list(set(inputs)), sdofs
+
+    indent =''.join([' ']*indent)
+    s=''
+    if len(dims)==1:
+        s+='{}{} = np.zeros({})\n'.format(indent,varname,dims[0])
+        for i in np.arange(dims[0]):
+            s+='{}{}[{}] = '.format(indent,varname,i) + cleanPyAtom(expr[i]) +'\n'
+    elif len(dims)==2:
+        s+='{}{} = np.zeros(({},{}))\n'.format(indent,varname, dims[0],dims[1])
+        for i in np.arange(dims[0]):
+            for j in np.arange(dims[1]):
+                s+='{}{}[{},{}] = '.format(indent,varname,i,j) + cleanPyAtom(expr[i,j])+'\n'
+    return s
+
 
-    def toDataFrame(self):
-        dfs={}
 
-        ny = len(self['y'])
-        nz = len(self['y'])
-        # Index at mid box
-        iy,iz = self._iMid()
-
-        # Mean vertical profile
-        z, m, s = self.vertProfile
-        ti = s/m*100
-        cols=['z_[m]','u_[m/s]','v_[m/s]','w_[m/s]','sigma_u_[m/s]','sigma_v_[m/s]','sigma_w_[m/s]','TI_[%]']
-        data = np.column_stack((z, m[0,:],m[1,:],m[2,:],s[0,:],s[1,:],s[2,:],ti[0,:]))
-        dfs['VertProfile'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid time series
-        u = self['u'][:,:,iy,iz]
-        cols=['t_[s]','u_[m/s]','v_[m/s]','w_[m/s]']
-        data = np.column_stack((self['t'],u[0,:],u[1,:],u[2,:]))
-        dfs['ZMidLine'] = pd.DataFrame(data = data ,columns = cols)
-
-
-        # ZMid YStart time series
-        u = self['u'][:,:,0,iz]
-        cols=['t_[s]','u_[m/s]','v_[m/s]','w_[m/s]']
-        data = np.column_stack((self['t'],u[0,:],u[1,:],u[2,:]))
-        dfs['ZMidYStartLine'] = pd.DataFrame(data = data ,columns = cols)
-
-        # ZMid YEnd time series
-        u = self['u'][:,:,-1,iz]
-        cols=['t_[s]','u_[m/s]','v_[m/s]','w_[m/s]']
-        data = np.column_stack((self['t'],u[0,:],u[1,:],u[2,:]))
-        dfs['ZMidYEndLine'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid crosscorr y
-        y, rho_uu_y, rho_vv_y, rho_ww_y = self.crosscorr_y()
-        cols = ['y_[m]', 'rho_uu_[-]','rho_vv_[-]','rho_ww_[-]']
-        data = np.column_stack((y, rho_uu_y, rho_vv_y, rho_ww_y))
-        dfs['Mid_xcorr_y'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid crosscorr z
-        z, rho_uu_z, rho_vv_z, rho_ww_z = self.crosscorr_z()
-        cols = ['z_[m]', 'rho_uu_[-]','rho_vv_[-]','rho_ww_[-]']
-        data = np.column_stack((z, rho_uu_z, rho_vv_z, rho_ww_z))
-        dfs['Mid_xcorr_z'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid csd
-        fc, chi_uu, chi_vv, chi_ww = self.csd_longi()
-        cols = ['f_[Hz]','chi_uu_[-]', 'chi_vv_[-]','chi_ww_[-]']
-        data = np.column_stack((fc, chi_uu, chi_vv, chi_ww))
-        dfs['Mid_csd_longi'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid csd
-        fc, chi_uu, chi_vv, chi_ww = self.csd_lat()
-        cols = ['f_[Hz]','chi_uu_[-]', 'chi_vv_[-]','chi_ww_[-]']
-        data = np.column_stack((fc, chi_uu, chi_vv, chi_ww))
-        dfs['Mid_csd_lat'] = pd.DataFrame(data = data ,columns = cols)
-
-        # Mid csd
-        fc, chi_uu, chi_vv, chi_ww = self.csd_vert()
-        cols = ['f_[Hz]','chi_uu_[-]', 'chi_vv_[-]','chi_ww_[-]']
-        data = np.column_stack((fc, chi_uu, chi_vv, chi_ww))
-        dfs['Mid_csd_vert'] = pd.DataFrame(data = data ,columns = cols)
-
-
-        # Hub time series
-        #try:
-        #    zHub = self['zHub']
-        #    iz = np.argmin(np.abs(self['z']-zHub))
-        #    u = self['u'][:,:,iy,iz]
-        #    Cols=['t_[s]','u_[m/s]','v_[m/s]','w_[m/s]']
-        #    data = np.column_stack((self['t'],u[0,:],u[1,:],u[2,:]))
-        #    dfs['TSHubLine'] = pd.DataFrame(data = data ,columns = Cols)
-        #except:
-        #    pass
-        return dfs
-
-
-    # Useful converters
-    def fromMannBox(self, u, v, w, dx, U, y, z, addU=None):
-        """ 
-        Convert current TurbSim file into one generated from MannBox
-        Assumes: 
-             u, v, w (nt x ny x nz)
-
-             y: goes from -ly/2 to ly/2  this is an IMPORTANT subtlety
-                The field u needs to respect this convention!
-                (fields from weio.mannbox_file do respect this convention
-                but when exported to binary files, the y axis is flipped again)
-        
-        INPUTS:
-          - u, v, w : mann box fields
-          - dx: axial spacing of mann box (to compute time)
-          - U: reference speed of mann box (to compute time)
-          - y: y coords of mann box
-          - z: z coords of mann box
-        """
-        nt,ny,nz = u.shape
-        dt       = dx/U
-        t        = np.arange(0, dt*(nt-0.5), dt)
-        nt       = len(t)
-        if y[0]>y[-1]:
-            raise Exception('y is assumed to go from - to +')
-
-        self['u']=np.zeros((3, nt, ny, nz))
-        self['u'][0,:,:,:] = u 
-        self['u'][1,:,:,:] = v
-        self['u'][2,:,:,:] = w
-        if addU is not None:
-            self['u'][0,:,:,:] += addU
-        self['t']  = t
-        self['y']  = y
-        self['z']  = z
-        self['dt'] = dt
-        # TODO
-        self['ID'] = 7 # ...
-        self['info'] = 'Converted from MannBox fields {:s}.'.format(time.strftime('%d-%b-%Y at %H:%M:%S', time.localtime()))
-#         self['zTwr'] = np.array([])
-#         self['uTwr'] = np.array([])
-        self['zHub'] = None
-        self['uHub'] = None
-        self['zHub'], self['uHub'], bHub = self.hubValues()
-
-    def toMannBox(self, base=None, removeUConstant=None, removeAllUMean=False):
-        """ 
-        removeUConstant: float,  will be removed from all values of the U box
-        removeAllUMean: If true, the time-average of each y-z points will be substracted
-        """
+# TODO TODO TODO
+def insertQQd(expr, dofs):
+    #syms = [phi_x(t), phi_y(t), phi_z(t)]
+    # See pydy.codegen.ode_function_generator _lambdaify
+    subs = {}
+    vec_name = 'q'
+
+    q   = DeferredVector('q')
+    qd  = DeferredVector('qd')
+    for i, sym in enumerate(dofs):
+        dsym = diff(sym, dynamicsymbols._t)
+        subs[sym]  = q[i]
+        subs[dsym] = qd[i]
+    print(subs)
+    if hasattr(expr, '__len__'):
+        print(expr.shape)
+        return Matrix([me.msubs(e, subs) for e in expr]).reshape(expr.shape[0],expr.shape[1])
+    else:
+        return me.msubs(expr, subs)
+
+
+def cleanPy(expr, dofs=None, varname='R', indent=0, replDict=None, noTimeDep=False, method='subs'):
+    """ 
+    Clean a python sympy expression and perform replacements:
+      - DOFs       -> q[i]
+      - Velocities -> qd[i]
+      - Constants ->  p['name']
+      - Inputs    ->  u['name']
+    INPUTS:
+       - replDict: a dictionary of replacements, where the key define the expression to be replaced.
+                the value is either a replacement string, or a tuple (for matrices), for instance::
+                     replDict['M_B'] = 'Mass'
+                     replDict['M_T'] = ('MM_T', [0,0])
+                      
+    """
+    # list of parameters inputs and dofs
+    parameters = []
+    inputs     = []
+    sdofs      = []
+    sdofsDeriv = []
+    parametersProblem = []
+    if dofs is not None:
+        for idof,dof in enumerate(dofs):
+            s=repr(dof)
+            sdofs.append(s)
+            sdofsDeriv.append('Derivative({},t)'.format(s))
+            #sdofsDeriv.append('Derivative({}(t),t)'.format(s))
+        # sorting dofs by decreasing string length to avoid replacements (=> phi_y before y)
+        IDOF = np.argsort([len(s) for s in sdofs])[-1::-1]
+        dofs=np.array(dofs)[IDOF]
+
+
+    d_dofs     = [d.diff(dynamicsymbols._t) for d in dofs]
+    dd_dofs    = [d.diff(dynamicsymbols._t,2)   for d in dofs]
+    all_dofs   = list(dofs) + list(d_dofs) + list(dd_dofs)
+    all_dofs_s = [repr(s) for s in all_dofs] 
+
+
+
+    def cleanPyAtom(atom, dofs=None):
+        symbols     = list(atom.free_symbols)
         try:
-            from weio.mannbox_file import MannBoxFile
+            symbols.remove(Symbol('t'))
         except:
-            try:
-                from .mannbox_file import MannBoxFile
-            except:
-                from mannbox_file import MannBoxFile
-        # filename
-        if base is None:
-            base = os.path.splitext(self.filename)[0]
-        base = base+'_{}x{}x{}'.format(*self['u'].shape[1:])
-
-        mn = MannBoxFile()
-        mn.fromTurbSim(self['u'], 0, removeConstant=removeUConstant, removeAllMean=removeAllUMean)
-        mn.write(base+'.u')
-
-        mn.fromTurbSim(self['u'], 1)
-        mn.write(base+'.v')
-
-        mn.fromTurbSim(self['u'], 2)
-        mn.write(base+'.w')
-
-    # --- Useful IO
-    def writeInfo(ts, filename):
-        """ Write info to txt """
-        import scipy.optimize as so
-        def fit_powerlaw_u_alpha(x, y, z_ref=100, p0=(10,0.1)):
-            """ 
-            p[0] : u_ref
-            p[1] : alpha
-            """
-            pfit, _ = so.curve_fit(lambda x, *p : p[0] * (x / z_ref) ** p[1], x, y, p0=p0)
-            y_fit = pfit[0] * (x / z_ref) ** pfit[1]
-            coeffs_dict={'u_ref':pfit[0],'alpha':pfit[1]}
-            formula = '{u_ref} * (z / {z_ref}) ** {alpha}'
-            fitted_fun = lambda xx: pfit[0] * (xx / z_ref) ** pfit[1]
-            return y_fit, pfit, {'coeffs':coeffs_dict,'formula':formula,'fitted_function':fitted_fun}
-        infofile = filename
-        with open(filename,'w') as f:
-            f.write(str(ts))
-            zMid =(ts['z'][0]+ts['z'][-1])/2
-            f.write('Middle height of box: {:.3f}\n'.format(zMid))
-
-            iy,_ = ts._iMid()
-            u = np.mean(ts['u'][0,:,iy,:], axis=0)
-            z=ts['z']
-            f.write('\n')
-            y_fit, pfit, model =  fit_powerlaw_u_alpha(z, u, z_ref=zMid, p0=(10,0.1))
-            f.write('Power law: alpha={:.5f}  -  u={:.5f}  at z={:.5f}\n'.format(pfit[1],pfit[0],zMid))
-            f.write('Periodic: {}\n'.format(ts.checkPeriodic(sigmaTol=1.5, aTol=0.5)))
-
-
-
-    def writeProbes(ts, probefile, yProbe, zProbe):
-        # Creating csv file with data at some probe locations
-        Columns=['Time_[s]']
-        Data   = ts['t']
-        for y in yProbe:
-            for z in zProbe:
-                iy = np.argmin(np.abs(ts['y']-y))
-                iz = np.argmin(np.abs(ts['z']-z))
-                lbl = '_y{:.0f}_z{:.0f}'.format(ts['y'][iy], ts['z'][iz])
-                Columns+=['{}{}_[m/s]'.format(c,lbl) for c in['u','v','w']]
-                DataSub = np.column_stack((ts['u'][0,:,iy,iz],ts['u'][1,:,iy,iz],ts['u'][2,:,iy,iz]))
-                Data    = np.column_stack((Data, DataSub))
-        np.savetxt(probefile, Data, header=','.join(Columns), delimiter=',')
-
+            pass
+        symbols_s   = [repr(s) for s in symbols]
+        dyn_symbols = find_dynamicsymbols(atom)
+        dyn_symbols_u  = [symb for symb in dyn_symbols if repr(symb) not in all_dofs_s]
+        functions   = list(atom.atoms(Function))
+        functions   = [f for f in functions if f.args != (dynamicsymbols._t,) ] # remove functions of time only ("dyn_symbols")
+        functions   = [f for f in functions if f.func not in [sin, cos, exp, sqrt] ] # remove usual math functions
+        functions_symb = [f.func for f in functions]
+        functions_args = [f.args for f in functions]
+        #print('>>> symbols       ', symbols)
+        #print('>>> dyn_symbols   ', dyn_symbols)
+        #print('>>> dyn_symbols_u ', dyn_symbols_u)
+        #print('>>> functions     ', functions)
+        #print('>>> functions_symb', functions_symb)
+        #print('>>> functions_args', functions_args)
+        if method=='subs':
+            # States: accelerations, derivatives, position
+            for idof, dof, ddof, dddof in zip(IDOF, dofs, d_dofs, dd_dofs):
+                sdof=repr(dof).replace('(t)','')
+                atom = atom.subs([(dddof, 'qqdd__'+ str(idof) + '___')])
+                atom = atom.subs([(ddof , 'qqd__' + str(idof) + '___')])
+                atom = atom.subs([(dof  , 'qq__'  + str(idof) + '___')])
+            # Functions (like inputs but have specific arguments)
+            for symb, args in zip(functions_symb, functions_args):
+                ssymb=repr(symb)
+                atom = atom.subs([(symb  , 'uu__' + ssymb + '___')])
+                inputs.append(ssymb)
+            # Inputs
+            for symb in dyn_symbols_u:
+                ssymb=repr(symb).replace('(t)','')
+                atom = atom.subs([(symb  , 'uu__' + ssymb + '__u')])
+                inputs.append(ssymb)
+
+            if replDict is not None:
+                for k,v in replDict.items():
+                    if k in symbols_s:
+                        i = symbols_s.index(k)
+                        if len(v)==2:
+                            symbols.pop(i)
+                            symbols_s.pop(i)
+                        else:
+                            print('yams: cleanPy, TODO replace dict: {} {}'.format(k,v) )
+                            raise Exception()
+            # Parameters
+            for symb in symbols:
+                ssymb=repr(symb)
+                atom = atom.subs([(symb  , 'pp__' + ssymb + '__p')])
+                parameters.append(ssymb)
+
+            s= repr(atom).replace(' ','')
+            s = s.replace('qqdd__','qdd[')
+            s = s.replace('qqd__' ,'qd[')
+            s = s.replace('qq__'  ,'q[')
+            s = s.replace('uu__'  ,'u[\'')
+            s = s.replace('pp__'  ,'p[\'')
+            s = s.replace('___', ']')
+            s = s.replace('__p', '\']')
+            if noTimeDep:
+                s = s.replace('__u', '\']')
+            else:
+                s = s.replace('__u', '\'](t,q,qd)')
 
+            # User overrides
+            if replDict is not None:
+                for k,v in replDict.items():
+                    if len(v)==2:
+                        if s.find(k)>=0:
+                            if v[1] is not None:
+                                s=s.replace(k, 'p[\'{}\'][{}]'.format(v[0],','.join([str(ii) for ii in v[1]]) ) )
+                                parameters.append(v[0])
+                            else:
+                                s=s.replace(k, 'p[\'{}\']'.format(v[0]))
+                                parameters.append(v[0])
+                    else:
+                        if s.find(k)>=0:
+                            s=s.replace(k,v)
+
+
+        elif method=='string':
+            s=repr(atom).replace(' ','')
+            # Replace parameters provide in replDict, as priority
+            if replDict is not None:
+                for k,v in replDict.items():
+                    if len(v)==2:
+                        if s.find(k)>=0:
+                            if v[1] is not None:
+                                s=s.replace(k, 'p[\'{}\'][{}]'.format(v[0],','.join([str(ii) for ii in v[1]]) ) )
+                                parameters.append(v[0])
+                            else:
+                                s=s.replace(k, 'p[\'{}\']'.format(v[0]))
+                                parameters.append(v[0])
+                    else:
+                        if s.find(k)>=0:
+                            s=s.replace(k,v)
+
+            if dofs is not None:
+                # time derivatives first!!! important
+                for idof,dof in zip(IDOF,dofs):
+                    sdof=repr(dof)
+                    #s=s.replace('Derivative({}(t),t)'.format(sdof),'qd[{}]'.format(idof))
+                    s=s.replace('Derivative({},t)'.format(sdof),'qd[{}]'.format(idof))
+                # then Dof
+                for idof,dof in zip(IDOF,dofs):
+                    sdof=repr(dof)
+                    s=s.replace(sdof+'(t)','q[{}]'.format(idof))
+                    s=s.replace(sdof,'q[{}]'.format(idof))
+            for symb in symbols:
+                ssymb=repr(symb)
+                if not any([p.find(ssymb)>0 for p in parameters]):
+                    if s.find(ssymb)>=0:
+                        s=s.replace(ssymb,'p[\'{}\']'.format(ssymb))
+                        parameters.append(ssymb)
+                else:
+                    parametersProblem.append(ssymb)
+
+            for symb in dyn_symbols:
+                ssymb=repr(symb).replace(' ','')
+                if ssymb not in sdofsDeriv and ssymb not in sdofs:
+                    ssymb=ssymb.replace('(t)','')
+                    if noTimeDep:
+                        s=s.replace(ssymb+'(t)','u[\'{}\']'.format(ssymb)) # When linearizing, the "u" is a u0
+                    else:
+                        s=s.replace(ssymb,'u[\'{}\']'.format(ssymb))
+                    inputs.append(ssymb)
+        else:
+            raise NotImplementedError()
+        return s
 
 
-if __name__=='__main__':
-    ts = TurbSimFile('../_tests/TurbSim.bts')
+    try:
+        dims=expr.shape
+    except:
+        dims=0
+        return '{}{} = '.format(indent,varname) + cleanPyAtom(expr,dofs=dofs), list(set(parameters)), list(set(inputs)), sdofs
+
+    indent =''.join([' ']*indent)
+
+    s=''
+    if len(dims)==1:
+        s+='{}{} = np.zeros({})\n'.format(indent,varname,dims[0])
+        for i in np.arange(dims[0]):
+            s+='{}{}[{}] = '.format(indent,varname,i) + cleanPyAtom(expr[i], dofs=dofs) +'\n'
+    elif len(dims)==2:
+        s+='{}{} = np.zeros(({},{}))\n'.format(indent,varname, dims[0],dims[1])
+        for i in np.arange(dims[0]):
+            for j in np.arange(dims[1]):
+                s+='{}{}[{},{}] = '.format(indent,varname,i,j) + cleanPyAtom(expr[i,j], dofs=dofs)+'\n'
+    # removing duplicates
+    parameters = list(set(parameters))
+    inputs     = list(set(inputs))
+    #print('parameters',parameters)
+    #print('inputs    ',inputs)
+    #print('sdofs     ',sdofs)
+    parameters.sort()
+    inputs.sort()
+    parametersProblem = list(set(parametersProblem))
+    if len(parametersProblem)>0:
+        print('>>> Parameters not replaced for python: ', parametersProblem)
+    return s, parameters, inputs, sdofs
```

### Comparing `welib-0.0.2/welib/weio/turbsim_ts_file.py` & `welib-1.0.0/welib/weio/turbsim_ts_file.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,15 +1,16 @@
-from __future__ import division
-from __future__ import print_function
-from __future__ import absolute_import
-from io import open
-from .file import File, isBinary, WrongFormatError, BrokenFormatError
+from itertools import takewhile
 import pandas as pd
 import numpy as np
-from itertools import takewhile
+try:
+    from .file import File, WrongFormatError, BrokenFormatError
+except:
+    File = dict
+    class WrongFormatError(Exception): pass
+    class BrokenFormatError(Exception): pass
 
 
 class TurbSimTSFile(File):
 
     @staticmethod
     def defaultExtensions():
         return ['.txt']
```

### Comparing `welib-0.0.2/welib/weio/vtk_file.py` & `welib-1.0.0/welib/weio/vtk_file.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/ae_file.py` & `welib-1.0.0/welib/weio/wetb/hawc2/ae_file.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,18 +1,8 @@
-from __future__ import print_function
-from __future__ import unicode_literals
-from __future__ import division
-from __future__ import absolute_import
-from io import open
-from builtins import range
-from builtins import int
-from future import standard_library
 import os
-standard_library.install_aliases()
-
 import numpy as np
 
 
 class AEFile(object):
 
     """Read and write the HAWC2 AE (aerodynamic blade layout) file
 
@@ -73,17 +63,24 @@
         else:
             return radii
 
     def pc_set_nr(self, radius, set_nr=1):
         ae_data = self.ae_sets[set_nr]
         index = np.searchsorted(ae_data[:, 0], radius)
         index = max(1, index)
+        # --- Emmanuel's addition
+        maxRad = np.max(ae_data[:,0])
+        index2 = np.argmin(np.abs(ae_data[:, 0]-radius))
+        if abs(ae_data[index2,0]-radius)<1e-4*maxRad:
+            # We are very close to an ae location, we use this set
+            return ae_data[index2, 3]
+        # Otherwise we look at index before or after
         setnrs = ae_data[index - 1:index + 1, 3]
         if setnrs[0] != setnrs[-1]:
-            raise NotImplementedError
+            print('[WARN] AE file, at radius {}, should return a set between {}. Using first one.'.format(radius,setnrs))
         return setnrs[0]
 
     def add_set(self, radius, chord, thickness, pc_set_id, set_id=None):
         '''This method will add another set to the ae data'''
         if set_id is None:
             set_id = 1
             while set_id in self.ae_sets.keys():
@@ -99,15 +96,17 @@
             retval += str(st_idx) + ' ' + str(len(st)) + '\n'
             for line in st:
                 retval += '%25.17e %25.17e %25.17e %5d\n' % (line[0], line[1], line[2], line[3])
         return retval
 
     def save(self, filename):
         if not os.path.isdir(os.path.dirname(filename)):
-            os.makedirs(os.path.dirname(filename))
+            # fails if dirname is empty string
+            if len(os.path.dirname(filename)) > 0:
+                os.makedirs(os.path.dirname(filename))
         with open(filename, 'w') as fid:
             fid.write(str(self))
 
     def _read_file(self, filename):
         ''' This method will read in the ae data from a HAWC2 ae file'''
         with open(filename) as fid:
             lines = fid.readlines()
@@ -118,15 +117,22 @@
             set_nr, n_rows = [int(v) for v in lines[lptr].split()[:2]]
             lptr += 1
             data = np.array([[float(v) for v in l.split()[:4]] for l in lines[lptr:lptr + n_rows]])
             self.ae_sets[set_nr] = data
             lptr += n_rows
 
 
+def main():
+    if __name__ == "__main__":
+        ae = AEFile(os.path.dirname(__file__) + "/tests/test_files/NREL_5MW_ae.txt")
+        print(ae.radius_ae(36))
+        print(ae.thickness())
+        print(ae.chord(36))
+        print(ae.pc_set_nr(36))
+        ae.add_set(radius=[0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],
+                   chord=[1.1, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1],
+                   thickness=[100.0, 100.0, 90.0, 80.0, 70.0, 60.0, 50.0, 40.0, 30.0, 20.0, 10.0],
+                   pc_set_id=[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0])
+        print(str(ae))
 
 
-if __name__ == "__main__":
-    ae = AEFile(r"tests/test_files/NREL_5MW_ae.txt")
-    print (ae.radius_ae(36))
-    print (ae.thickness())
-    print (ae.chord(36))
-    print (ae.pc_set_nr(36))
+main()
```

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/htc_contents.py` & `welib-1.0.0/welib/weio/wetb/hawc2/htc_contents.py`

 * *Files 8% similar despite different names*

```diff
@@ -2,24 +2,15 @@
 Created on 20/01/2014
 
 @author: MMPE
 
 See documentation of HTCFile below
 
 '''
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from builtins import zip
-from builtins import int
-from builtins import str
-from future import standard_library
 import os
-standard_library.install_aliases()
 from collections import OrderedDict
 import collections
 
 
 class OrderedDict(collections.OrderedDict):
     pass
 
@@ -41,17 +32,14 @@
         if int(float(v)) == float(v):
             return int(float(v))
         return float(v)
     except ValueError:
         return v.replace("\\", "/")
 
 
-c = 0
-
-
 class HTCContents(object):
     lines = []
     contents = None
     name_ = ""
     parent = None
 
     def __getitem__(self, key):
@@ -91,15 +79,14 @@
             v = [fmt_value(v) for v in v.split()]
         if not isinstance(v, HTCContents):
             if not isinstance(v, (list, tuple)):
                 v = [v]
             if k in self.contents:
                 self.contents[k].values = v
                 return
-
             v = HTCLine(k, v, "")
         self.contents[k] = v
         v.parent = self
 
     def __delattr__(self, *args, **kwargs):
         k, = args
         if k in self:
@@ -204,18 +191,19 @@
 
 
 class HTCSection(HTCContents):
     end_comments = ""
     begin_comments = ""
 
     def __init__(self, name, begin_comments="", end_comments=""):
-        self.name_ = name
+        self.name_ = name.strip() # strip if tabs in name somehow 
         self.begin_comments = begin_comments.strip(" \t")
         self.end_comments = end_comments.strip(" \t")
         self.contents = OrderedDict()
+        self.parent = None
 
     @property
     def section_name(self):
         return self.name_
 
     @section_name.setter
     def section_name(self, value):
@@ -242,20 +230,22 @@
         if name == "output":
             section = HTCOutputSection(name, begin_comments)
         elif name.startswith("output_at_time"):
             section = HTCOutputAtTimeSection(name, begin_comments)
         else:
             section = HTCSection(name, begin_comments)
         while lines:
+            if lines[0].strip() == "":
+                lines.pop(0)
             if lines[0].lower().startswith("begin"):
                 section._add_contents(HTCSection.from_lines(lines))
             elif lines[0].lower().startswith("end"):
                 line, section.end_comments = parse_next_line(lines)
                 break
-            else:
+            elif lines:
                 section._add_contents(section.line_from_line(lines))
         else:
             raise Exception("Section '%s' has not end" % section.name_)
         return section
 
     def line_from_line(self, lines):
         return HTCLine.from_lines(lines)
@@ -308,14 +298,15 @@
 
     def __init__(self, name, values, comments):
         if "__" in name:
             name = name[:name.index("__")]
         self.name_ = name
         self.values = list(values)
         self.comments = comments.strip(" \t")
+        self.parent = None
 
     def __repr__(self):
         return str(self)
 
     def __str__(self, level=0):
         if self.name_ == "":
             return ""
@@ -377,17 +368,16 @@
     def _add_sensor(self, htcSensor, nr=None):
         if nr is None:
             nr = len(self.sensors)
         self.sensors.insert(nr, htcSensor)
         htcSensor.parent = self
 
     def line_from_line(self, lines):
-        while len(lines) and lines[0].strip() == "":
-            lines.pop(0)
         name = lines[0].split()[0].strip()
+
         if name in ['filename', 'data_format', 'buffer', 'time']:
             return HTCLine.from_lines(lines)
         else:
             return HTCSensor.from_lines(lines)
 
     def _add_contents(self, contents):
         if isinstance(contents, HTCSensor):
```

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/htc_extensions.py` & `welib-1.0.0/welib/weio/wetb/hawc2/htc_extensions.py`

 * *Files 10% similar despite different names*

```diff
@@ -2,26 +2,17 @@
 Created on 20/01/2014
 
 @author: MMPE
 
 See documentation of HTCFile below
 
 '''
-from __future__ import division
-from __future__ import unicode_literals
-from __future__ import print_function
-from __future__ import absolute_import
-from builtins import zip
-from builtins import int
-from builtins import str
-from future import standard_library
 import os
 
 
-standard_library.install_aliases()
 
 
 class HTCDefaults(object):
 
     empty_htc = """begin simulation;
         time_stop 600;
         solvertype    2;    (newmark)
```

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/htc_file.py` & `welib-1.0.0/welib/weio/wetb/hawc2/htc_file.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,32 +1,27 @@
 '''
 Created on 20/01/2014
 
-@author: MMPE
-
 See documentation of HTCFile below
 
 '''
-from __future__ import print_function
-from __future__ import unicode_literals
-from __future__ import division
-from __future__ import absolute_import
-from builtins import str
-from future import standard_library
 # from wetb.utils.process_exec import pexec
 # from wetb.hawc2.hawc2_pbs_file import HAWC2PBSFile
-# from wetb.utils.cluster_tools.os_path import fixcase, abspath, pjoin
 # import jinja2
-standard_library.install_aliases()
+# from wetb.utils.cluster_tools.os_path import fixcase, abspath, pjoin
+
 from collections import OrderedDict
 from .htc_contents import HTCContents, HTCSection, HTCLine
 from .htc_extensions import HTCDefaults, HTCExtensions
 import os
 
 # --- cluster_tools/os_path
+def fmt_path(path):
+    return path.lower().replace("\\", "/")
+
 def repl(path):
     return path.replace("\\", "/")
 
 def abspath(path):
     return repl(os.path.abspath(path))
 
 def relpath(path, start=None):
@@ -103,26 +98,24 @@
 
     filename = None
     jinja_tags = {}
     htc_inputfiles = []
     level = 0
     modelpath = "../"
     initial_comments = None
-    _contents = None
 
     def __init__(self, filename=None, modelpath=None, jinja_tags={}):
         """
         Parameters
         ---------
         filename : str
             Absolute filename of htc file
         modelpath : str
             Model path relative to htc file
         """
-
         if filename is not None:
             try:
                 filename = fixcase(abspath(filename))
                 with self.open(str(filename)):
                     pass
             except Exception:
                 pass
@@ -134,15 +127,15 @@
 
         if filename and self.modelpath != "unknown" and not os.path.isabs(self.modelpath):
             drive, p = os.path.splitdrive(os.path.join(os.path.dirname(str(self.filename)), self.modelpath))
             self.modelpath = os.path.join(drive, os.path.splitdrive(os.path.realpath(p))[1]).replace("\\", "/")
         if self.modelpath != 'unknown' and self.modelpath[-1] != '/':
             self.modelpath += "/"
 
-            #assert 'simulation' in self.contents, "%s could not be loaded. 'simulation' section missing" % filename
+        self.load()
 
     def auto_detect_modelpath(self):
         if self.filename is None:
             return "../"
 
         #print (["../"*i for i in range(3)])
         import numpy as np
@@ -163,19 +156,18 @@
         if max(found) > 0:
             relpath = "../" * np.argmax(found)
             return abspath(pjoin(os.path.dirname(self.filename), relpath))
         else:
             raise ValueError(
                 "Modelpath cannot be autodetected for '%s'.\nInput files not found near htc file" % self.filename)
 
-    def _load(self):
-        self.reset()
+    def load(self):
+        self.contents = OrderedDict()
         self.initial_comments = []
         self.htc_inputfiles = []
-        self.contents = OrderedDict()
         if self.filename is None:
             lines = self.empty_htc.split("\n")
         else:
             lines = self.readlines(self.filename)
 
         lines = [l.strip() for l in lines]
 
@@ -187,29 +179,16 @@
                 self._add_contents(HTCSection.from_lines(lines))
             else:
                 line = HTCLine.from_lines(lines)
                 if line.name_ == "exit":
                     break
                 self._add_contents(line)
 
-    def reset(self):
-        self._contents = None
-
-    @property
-    def contents(self):
-        if self._contents is None:
-            self._load()
-        return self._contents
-
-    @contents.setter
-    def contents(self, value):
-        self._contents = value
-
     def readfilelines(self, filename):
-        with self.open(self.unix_path(filename), encoding='cp1252') as fid:
+        with self.open(self.unix_path(os.path.abspath(filename.replace('\\', '/'))), encoding='cp1252') as fid:
             txt = fid.read()
         if txt[:10].encode().startswith(b'\xc3\xaf\xc2\xbb\xc2\xbf'):
             txt = txt[3:]
         if self.jinja_tags:
             template = jinja2.Template(txt)
             txt = template.render(**self.jinja_tags)
         return txt.replace("\r", "").split("\n")
@@ -221,65 +200,94 @@
         lines = self.readfilelines(filename)
         for l in lines:
             if l.lower().lstrip().startswith('continue_in_file'):
                 filename = l.lstrip().split(";")[0][len("continue_in_file"):].strip().lower()
 
                 if self.modelpath == 'unknown':
                     p = os.path.dirname(self.filename)
-                    lu = [os.path.isfile(os.path.join(p, "../" * i, filename)) for i in range(4)].index(True)
-                    filename = os.path.join(p, "../" * lu, filename)
+                    try:
+                        lu = [os.path.isfile(os.path.abspath(os.path.join(p, "../" * i, filename.replace("\\", "/"))))
+                              for i in range(4)].index(True)
+                        filename = os.path.join(p, "../" * lu, filename)
+                    except ValueError:
+                        print('[FAIL] Cannot continue in file: {}'.format(filename))
+                        filename = None
                 else:
                     filename = os.path.join(self.modelpath, filename)
-                for line in self.readlines(filename):
-                    if line.lstrip().lower().startswith('exit'):
-                        break
-                    htc_lines.append(line)
+                    if not os.path.isfile(filename):
+                        print('[FAIL] Cannot continue in file: {}'.format(filename))
+                        filename=None
+                if filename is not None:
+                    #print('[INFO] Continuing in file: {}'.format(filename))
+                    for line in self.readlines(filename):
+                        if line.lstrip().lower().startswith('exit'):
+                            break
+                        htc_lines.append(line)
             else:
                 htc_lines.append(l)
         return htc_lines
 
     def __setitem__(self, key, value):
         self.contents[key] = value
 
     def __str__(self):
         self.contents  # load
         return "".join(self.initial_comments + [c.__str__(1) for c in self] + ["exit;"])
 
     def save(self, filename=None):
+        """Saves the htc object to an htc file.
+
+        Args:
+            filename (str, optional): Specifies the filename of the htc file to be saved. 
+            If the value is none, the filename attribute of the object will be used as the filename. 
+            Defaults to None.
+        """
         self.contents  # load if not loaded
         if filename is None:
             filename = self.filename
         else:
             self.filename = filename
         # exist_ok does not exist in Python27
         if not os.path.exists(os.path.dirname(filename)) and os.path.dirname(filename) != "":
             os.makedirs(os.path.dirname(filename))  # , exist_ok=True)
         with self.open(filename, 'w', encoding='cp1252') as fid:
             fid.write(str(self))
 
     def set_name(self, name, subfolder=''):
+        """Sets the base filename of the simulation files. 
+
+        Args:
+            name (str): Specifies name of the log file, dat file (for animation), hdf5 file (for visualization) and htc file.
+            subfolder (str, optional): Specifies the name of a subfolder to place the files in. 
+                If the value is an empty string, no subfolders will be created. 
+                Defaults to ''.
+
+        Returns:
+            None
+        """
         # if os.path.isabs(folder) is False and os.path.relpath(folder).startswith("htc" + os.path.sep):
         self.contents  # load if not loaded
 
         def fmt_folder(folder, subfolder): return "./" + \
             os.path.relpath(os.path.join(folder, subfolder)).replace("\\", "/")
 
         self.filename = os.path.abspath(os.path.join(self.modelpath, fmt_folder(
             'htc', subfolder), "%s.htc" % name)).replace("\\", "/")
         if 'simulation' in self and 'logfile' in self.simulation:
             self.simulation.logfile = os.path.join(fmt_folder('log', subfolder), "%s.log" % name).replace("\\", "/")
             if 'animation' in self.simulation:
                 self.simulation.animation = os.path.join(fmt_folder(
                     'animation', subfolder), "%s.dat" % name).replace("\\", "/")
             if 'visualization' in self.simulation:
-                self.simulation.visualization = os.path.join(fmt_folder(
-                    'visualization', subfolder), "%s.hdf5" % name).replace("\\", "/")
+                f = os.path.join(fmt_folder('visualization', subfolder), "%s.hdf5" % name).replace("\\", "/")
+                self.simulation.visualization[0] = f
         elif 'test_structure' in self and 'logfile' in self.test_structure:  # hawc2aero
             self.test_structure.logfile = os.path.join(fmt_folder('log', subfolder), "%s.log" % name).replace("\\", "/")
-        self.output.filename = os.path.join(fmt_folder('res', subfolder), "%s" % name).replace("\\", "/")
+        if 'output' in self:
+            self.output.filename = os.path.join(fmt_folder('res', subfolder), "%s" % name).replace("\\", "/")
 
     def set_time(self, start=None, stop=None, step=None):
         self.contents  # load if not loaded
         if stop is not None:
             self.simulation.time_stop = stop
         else:
             stop = self.simulation.time_stop[0]
@@ -462,26 +470,34 @@
     def simulate(self, exe, skip_if_up_to_date=False):
         errorcode, stdout, stderr, cmd = self._simulate(exe, skip_if_up_to_date)
         if ('simulation' in self.keys() and "logfile" in self.simulation and
                 os.path.isfile(os.path.join(self.modelpath, self.simulation.logfile[0]))):
             with self.open(os.path.join(self.modelpath, self.simulation.logfile[0])) as fid:
                 log = fid.read()
         else:
-            log = stderr
+            log = "%s\n%s" % (str(stdout), str(stderr))
 
         if errorcode or 'Elapsed time' not in log:
             log_lines = log.split("\n")
             error_lines = [i for i, l in enumerate(log_lines) if 'error' in l.lower()]
             if error_lines:
-                i = error_lines[0]
-                error_log = "\n".join(log_lines[i - 3:i + 3])
+                import numpy as np
+                line_i = np.r_[np.array([error_lines + i for i in np.arange(-3, 4)]).flatten(),
+                               np.arange(-5, 0) + len(log_lines)]
+                line_i = sorted(np.unique(np.maximum(np.minimum(line_i, len(log_lines) - 1), 0)))
+
+                lines = ["%04d %s" % (i, log_lines[i]) for i in line_i]
+                for jump in np.where(np.diff(line_i) > 1)[0]:
+                    lines.insert(jump, "...")
+
+                error_log = "\n".join(lines)
             else:
                 error_log = log
-            raise Exception("\nstdout:\n%s\n--------------\nstderr:\n%s\n--------------\nlog:\n%s\n--------------\ncmd:\n%s" %
-                            (str(stdout), str(stderr), error_log, cmd))
+            raise Exception("\nError code: %s\nstdout:\n%s\n--------------\nstderr:\n%s\n--------------\nlog:\n%s\n--------------\ncmd:\n%s" %
+                            (errorcode, str(stdout), str(stderr), error_log, cmd))
         return str(stdout) + str(stderr), log
 
     def simulate_hawc2stab2(self, exe):
         errorcode, stdout, stderr, cmd = self._simulate(exe, skip_if_up_to_date=False)
 
         if errorcode:
             raise Exception("\nstdout:\n%s\n--------------\nstderr:\n%s\n--------------\ncmd:\n%s" %
@@ -571,15 +587,14 @@
             path = os.path.realpath(path).replace("\\", "/")
             return os.path.join(drive, os.path.splitdrive(path)[1])
 
 
 if "__main__" == __name__:
     f = HTCFile(r"C:/Work/BAR-Local/Hawc2ToBeamDyn/sim.htc", ".")
     print(f.input_files())
-    import pdb; pdb.set_trace()
 #     f.save(r"C:\mmpe\HAWC2\models\DTU10MWRef6.0\htc\DTU_10MW_RWT_power_curve.htc")
 #
 #     f = HTCFile(r"C:\mmpe\HAWC2\models\DTU10MWRef6.0\htc\DTU_10MW_RWT.htc", "../")
 #     f.set_time = 0, 1, .1
 #     print(f.simulate(r"C:\mmpe\HAWC2\bin\HAWC2_12.8\hawc2mb.exe"))
 #
 #     f.save(r"C:\mmpe\HAWC2\models\DTU10MWRef6.0\htc\DTU_10MW_RWT.htc")
```

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/htc_file_set.py` & `welib-1.0.0/welib/weio/wetb/hawc2/htc_file_set.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/pc_file.py` & `welib-1.0.0/welib/weio/wetb/hawc2/pc_file.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,21 +1,12 @@
 '''
 Created on 24/04/2014
 
 @author: MMPE
 '''
-from __future__ import division
-from __future__ import print_function
-from __future__ import unicode_literals
-from __future__ import absolute_import
-from io import open
-from builtins import range
-from builtins import int
-from future import standard_library
-standard_library.install_aliases()
 
 import os
 import numpy as np
 
 class PCFile(object):
     """Read HAWC2 PC (profile coefficients) file
 
@@ -149,15 +140,17 @@
                 retval += '%i %i %1.08f\n' % (i+1, nr, tc)
                 for line in pc:
                     retval += linefmt.format(*line) + '\n'
         return retval
 
     def save(self, filename):
         if not os.path.isdir(os.path.dirname(filename)):
-            os.makedirs(os.path.dirname(filename))
+            # fails if dirname is empty string
+            if len(os.path.dirname(filename)) > 0:
+                os.makedirs(os.path.dirname(filename))
         with open(filename, 'w') as fid:
             fid.write(str(self))
         self.filename = filename
 
 
 if __name__ == "__main__":
     pcfile = PCFile("tests/test_files/NREL_5MW_pc.txt")
```

### Comparing `welib-0.0.2/welib/weio/wetb/hawc2/st_file.py` & `welib-1.0.0/welib/weio/wetb/hawc2/st_file.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,28 +1,20 @@
 '''
 Created on 24/04/2014
 
 @author: MMPE
 '''
-from __future__ import print_function
-from __future__ import unicode_literals
-from __future__ import division
-from __future__ import absolute_import
-from io import open
-from builtins import range
-from builtins import int
-from future import standard_library
 import types
-standard_library.install_aliases()
 import os
 import numpy as np
 
 
 stc = "r m x_cg y_cg ri_x ri_y x_sh y_sh E G I_x I_y I_p k_x k_y A pitch x_e y_e"
-
+fpm = 'r m x_cg y_cg ri_x ri_y pitch x_e y_e K_11 K_12 K_13 K_14 K_15 K_16 K_22'
+fpm += ' K_23 K_24 K_25 K_26 K_33 K_34 K_35 K_36 K_44 K_45 K_46 K_55 K_56 K_66'
 
 class StFile(object):
     """Read HAWC2 St (beam element structural data) file
 
     Methods are autogenerated for:
 
     - r : curved length distance from main_body node 1 [m]
@@ -67,16 +59,14 @@
     [ 1189.51054664  1191.64291781  1202.76694262  ... 15.42438683]
     >>> print (st.E(radius=36, mset=1, set=1))  # Elasticity interpolated to radius 36m
     8722924514.652649
     >>> print (st.E(radius=36, mset=1, set=2))  # Same for stiff blade set
     8.722924514652648e+17
     """
 
-    cols = stc.split()
-
     def __init__(self, filename=None):
 
         # in case the user wants to create a new non-existing st file
         if filename is None:
             self.main_data_sets = {}
             return
 
@@ -90,17 +80,32 @@
             mset_nr = int(mset.strip().split()[0])
             set_data_dict = {}
 
             for set_txt in mset.split("$")[1:]:
                 set_lines = set_txt.split("\n")
                 set_nr, no_rows = map(int, set_lines[0].split()[:2])
                 assert set_nr not in set_data_dict
-                set_data_dict[set_nr] = np.array([set_lines[i].split() for i in range(1, no_rows + 1)], dtype=float)
+                try:
+                    # HAWC2 will ignore everything after the 19th element,
+                    # some users have placed comments here after a ;
+                    linelst = [set_lines[i].split(';')[0].split() for i in range(1, no_rows + 1)]
+                except Exception as e:
+                    print('it went wrong at (set/subset):', mset_nr, set_nr,
+                          'with', no_rows, 'rows')
+                    raise e
+                set_data_dict[set_nr] = np.array(linelst, dtype=float)
             self.main_data_sets[mset_nr] = set_data_dict
 
+        if len(linelst[0])==len(stc.split()):
+            self.cols = stc.split()
+        elif len(linelst[0])==len(fpm.split()):
+            self.cols = fpm.split()
+        else:
+            raise TypeError('wrong number of columns in st file')
+
         for i, name in enumerate(self.cols):
             setattr(self, name, lambda radius=None, mset=1, set=1,
                     column=i: self._value(radius, column, mset, set))
 
     def _value(self, radius, column, mset_nr=1, set_nr=1):
         st_data = self.main_data_sets[mset_nr][set_nr]
         if radius is None:
@@ -121,20 +126,33 @@
         for k, v in kwargs.items():
             column = self.cols.index(k)
             self.main_data_sets[mset_nr][set_nr][:, column] = v
 
     def save(self, filename, precision='%15.07e', encoding='utf-8'):
         """Save all data defined in main_data_sets to st file.
         """
+
+        # when creating empty st object, cols is not set yet
+        if not hasattr(self, 'cols'):
+            if self.main_data_sets[1][1].shape[1]==19:
+                self.cols = stc.split()
+            elif self.main_data_sets[1][1].shape[1]==30:
+                self.cols = fpm.split()
+            else:
+                c = self.main_data_sets[1][1].shape[1]
+                raise TypeError(f'St input needs 19 (iso) or 30 (aniso/fpm) cols, not {c}')
+
         colwidth = len(precision % 1)
         sep = '=' * colwidth * len(self.cols) + '\n'
         colhead = ''.join([k.center(colwidth) for k in self.cols]) + '\n'
 
         nsets = len(self.main_data_sets)
-        os.makedirs(os.path.dirname(filename), exist_ok=True)
+        # fails if dirname is empty string
+        if len(os.path.dirname(filename)) > 0:
+            os.makedirs(os.path.dirname(filename), exist_ok=True)
         with open(filename, 'w', encoding=encoding) as fid:
             fid.write('%i ; number of sets, Nset\n' % nsets)
             for mset, set_data_dict in self.main_data_sets.items():
                 fid.write('#%i ; set number\n' % mset)
                 for set, set_array in set_data_dict.items():
                     dstr = self.to_str(mset=mset, set=set, precision=precision)
                     npoints = self.main_data_sets[mset][set].shape[0]
@@ -148,14 +166,19 @@
         Parameters
         ----------
         radius : float
             radius of element (used of obtain element properties
         length : float
             eleement length
         """
+
+        # not supported for FPM format
+        if len(self.cols)==30:
+            return
+
         K = np.zeros((13, 13))
         "r m x_cg y_cg ri_x ri_y x_sh y_sh E G I_x I_y I_p k_x k_y A pitch x_e y_e"
         ES1, ES2, EMOD, GMOD, IX, IY, IZ, KX, KY, A = [getattr(self, n)(radius, mset_nr, set_nr)
                                                        for n in "x_sh,y_sh,E,G,I_x,I_y,I_p,k_x,k_y,A".split(",")]
         ELLGTH = length
 
         ETAX = EMOD * IX / (KY * GMOD * A * ELLGTH**2)
@@ -206,14 +229,19 @@
         K[11, 12] = -K[5, 6]
         K[12, 12] = K[6, 6]
         K = K[1:, 1:]
         K = K + K.T - np.eye(12) * K
         return K
 
     def shape_function_ori(self, radius, mset_nr, set_nr, length, z):
+
+        # not supported for FPM format
+        if len(self.cols)==30:
+            return
+
         XSC, YSC, EMOD, GMOD, IX, IY, IZ, KX, KY, AREA = [getattr(self, n)(radius, mset_nr, set_nr)
                                                           for n in "x_sh,y_sh,E,G,I_x,I_y,I_p,k_x,k_y,A".split(",")]
 
         etax = EMOD * IX / KY / GMOD / AREA / (length**2)
         etay = EMOD * IY / KX / GMOD / AREA / (length**2)
         rhox = 1 / (1 + 12 * etax)
         rhoy = 1 / (1 + 12 * etay)
```

### Comparing `welib-0.0.2/welib/wind/examples/WindGenerationAtPoint.py` & `welib-1.0.0/welib/wind/examples/WindGenerationAtPoint.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/matlab/fStocWind.m` & `welib-1.0.0/welib/wind/matlab/fStocWind.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy01.m` & `welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy01.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy02.m` & `welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy02.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/matlab/getPointIncomingWindLegacy03.m` & `welib-1.0.0/welib/wind/matlab/getPointIncomingWindLegacy03.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/spectra.py` & `welib-1.0.0/welib/wind/spectra.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wind/tests/test_run_Examples.py` & `welib-1.0.0/welib/system/tests/test_run_Examples.py`

 * *Files 8% similar despite different names*

```diff
@@ -15,19 +15,22 @@
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
         files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z]*.py'))
-        import matplotlib.pyplot as plt
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/wind/windsim.py` & `welib-1.0.0/welib/wind/windsim.py`

 * *Files 1% similar despite different names*

```diff
@@ -119,14 +119,15 @@
     return t, u, f, S
 
 if __name__ == '__main__':
 
     from welib.tools.spectral import fft_wrap
     from welib.tools.tictoc import Timer
 
+    from numpy.random import seed 
     seed(11)
 
     U0    = 8      # Wind speed [m/s], for Kaimal spectrum
     I     = 0.14   # Turbulence intensity [-], for Kaimal spectrum
     L     = 340.2  # Length scale [m], for Kaimal spectrum
     tMax  = 800    # Maximum time for time series [s]
     dt    = 0.01   # Time step [s]
```

### Comparing `welib-0.0.2/welib/windwave/Main_Calls.m` & `welib-1.0.0/welib/windwave/Main_Calls.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/Main_Elast.m` & `welib-1.0.0/welib/windwave/Main_Elast.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/Main_WindWaves.m` & `welib-1.0.0/welib/windwave/Main_WindWaves.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fHydroCalcFinal.m` & `welib-1.0.0/welib/windwave/fHydroCalcFinal.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fJonswap.m` & `welib-1.0.0/welib/windwave/fJonswap.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fPlotCompare.m` & `welib-1.0.0/welib/windwave/fPlotCompare.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fSpectrum.m` & `welib-1.0.0/welib/windwave/fSpectrum.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fSpectrumAvg.m` & `welib-1.0.0/welib/windwave/fSpectrumAvg.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fSpectrumCalc.m` & `welib-1.0.0/welib/windwave/fSpectrumCalc.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fStocWind.m` & `welib-1.0.0/welib/windwave/fStocWind.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fWaveKin.m` & `welib-1.0.0/welib/windwave/fWaveKin.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fWindCalc.m` & `welib-1.0.0/welib/windwave/fWindCalc.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fgetDispersion.m` & `welib-1.0.0/welib/windwave/fgetDispersion.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/windwave/fqPrime.m` & `welib-1.0.0/welib/windwave/fqPrime.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/AxialInduction-CT.m` & `welib-1.0.0/welib/wt_theory/AxialInduction-CT.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/AxialInductionCT.m` & `welib-1.0.0/welib/wt_theory/AxialInductionCT.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Dates.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Dates.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Plots.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Plots.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SQL.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SQL.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Stats.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Stats.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/MainGoldsteinPlots.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/MainGoldsteinPlots.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/__main__/PrandtlTheory.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__main__/PrandtlTheory.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/__tests__/testCompareGoldstein.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__tests__/testCompareGoldstein.m`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,62 +1,62 @@
-function testCompareOneRing
-% purely an exercise of testing
-global PATH
-global VERSIONNUM
-global VERSION
-global DEBUG
-global PLOT
-global STOP
-if(DEBUG)
-    fprintf('--- testCompareGoldstein --- Version: %s %d \n',VERSION,VERSIONNUM );
-end
-
-verref=0; VERSIONREF='v00';
-vermax=[];
-%% some checks
-if isempty(vermax) vermax=max([VERSIONNUM verref])+1; end
-if(VERSIONNUM == verref) fprintf('S'); return; end
-if(max(VERSIONNUM)>vermax) fprintf('S'); return; end
-if(min(VERSIONNUM)<verref) fprintf('S'); return; end
-if(length(VERSIONNUM)==1) % we will compare with verref
-    vers=[VERSIONNUM verref]; versname={VERSION,VERSIONREF};
-else
-    vers=VERSIONNUM; versname=VERSION;
-end
-
-%% now the test
-
-% init that are not version specific
-Vl_bar_inv=[2 15];
-vl_bar=1./Vl_bar_inv/(2*pi);
-VB=[3];
-VN=[100 100 100 100 100];
-s=-1; % s=-1: WT - s=+1: Propellers
-for iB=1:length(VB)
-    B=VB(iB);
-    Vr=linspace(0,1,VN(iB)); 
-    for il=1:length(Vl_bar_inv)
-        l_bar=vl_bar(il);        
-        % loop on versions
-        for iv=1:length(vers)
-            nver=vers(iv);
-            require('OPTIMCIRC',versname{iv},~DEBUG);
-            %version specific stuff if any
-            G(iv,:)=fGoldsteinFactor( l_bar,B,Vr );
-        end
-        assertElementsAlmostEqual(G(1,:) ,G(2,:) , 'relative',10^-14);
-        if(PLOT)
-            figure(121212),clf,hold all, plot(Vr,G(1,:),'b-',Vr,G(2,:),'k+')
-        end
-    end
-end
-
-
-
-%%
-if(DEBUG)
-    fprintf('--- End of test ---\n');
-end
-
-if(STOP)
-    keyboard
-end
+function testCompareOneRing
+% purely an exercise of testing
+global PATH
+global VERSIONNUM
+global VERSION
+global DEBUG
+global PLOT
+global STOP
+if(DEBUG)
+    fprintf('--- testCompareGoldstein --- Version: %s %d \n',VERSION,VERSIONNUM );
+end
+
+verref=0; VERSIONREF='v00';
+vermax=[];
+%% some checks
+if isempty(vermax) vermax=max([VERSIONNUM verref])+1; end
+if(VERSIONNUM == verref) fprintf('S'); return; end
+if(max(VERSIONNUM)>vermax) fprintf('S'); return; end
+if(min(VERSIONNUM)<verref) fprintf('S'); return; end
+if(length(VERSIONNUM)==1) % we will compare with verref
+    vers=[VERSIONNUM verref]; versname={VERSION,VERSIONREF};
+else
+    vers=VERSIONNUM; versname=VERSION;
+end
+
+%% now the test
+
+% init that are not version specific
+Vl_bar_inv=[2 15];
+vl_bar=1./Vl_bar_inv/(2*pi);
+VB=[3];
+VN=[100 100 100 100 100];
+s=-1; % s=-1: WT - s=+1: Propellers
+for iB=1:length(VB)
+    B=VB(iB);
+    Vr=linspace(0,1,VN(iB)); 
+    for il=1:length(Vl_bar_inv)
+        l_bar=vl_bar(il);        
+        % loop on versions
+        for iv=1:length(vers)
+            nver=vers(iv);
+            require('OPTIMCIRC',versname{iv},~DEBUG);
+            %version specific stuff if any
+            G(iv,:)=fGoldsteinFactor( l_bar,B,Vr );
+        end
+        assertElementsAlmostEqual(G(1,:) ,G(2,:) , 'relative',10^-14);
+        if(PLOT)
+            figure(121212),clf,hold all, plot(Vr,G(1,:),'b-',Vr,G(2,:),'k+')
+        end
+    end
+end
+
+
+
+%%
+if(DEBUG)
+    fprintf('--- End of test ---\n');
+end
+
+if(STOP)
+    keyboard
+end
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/__tests__/testGoldstein.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/__tests__/testGoldstein.m`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,57 +1,57 @@
-function testGoldstein
-global PATH
-global VERSIONNUM
-global VERSION
-global DEBUG
-global PLOT
-global STOP
-if(DEBUG)
-    fprintf('--- testGoldstein --- Version: %s %d \n',VERSION,VERSIONNUM );
-end
-
-
-require('OPTIMCIRC',VERSION,~DEBUG);
-
-% should be a line vector
-vx=[0 0.1 0.5 0.9 1];
-G=fGoldsteinFactor(1/12,3,vx);
-assertEqual(G(:)',G);
-
-% zeros at extremities
-vx=[0 0.1 0.5 0.9 1];
-G=fGoldsteinFactor(1/12,3,vx);
-assertEqual([G(1) G(end)],[0 0]);
-
-
-%% test vs Tibery
-vlbar=[1 1/2 1/4 1/8];
-vB=[4 3 2];
-N=100;  % Number of helical vortex per blade
-% vx=(1/N:1/N:1);   % [.] 
-vx=linspace(0,1,N);
-R=1;
-for il=1:length(vlbar)
-    l_bar=vlbar(il);
-    h=2*pi*R*l_bar;
-    for iB=1:length(vB)
-        B=vB(iB);
-%         fprintf('B %d - 1/l %d\n',B,1/l_bar);
-        GammaGoldstein(iB,:) = fGoldsteinFactor( l_bar,B,vx);
-        [rt kt] = fTiberyWrench( l_bar , B );
-        G=interp1(vx,GammaGoldstein(iB,:),rt); % interpolate on points where tibery is known
-        assertElementsAlmostEqual(G,kt,'relative',0.07); % 7% error that's not the best...
-
-    end  
-end
-
-
-
-
-%%
-if(DEBUG)
-    fprintf('--- End of test ---\n');
-end
-
-if(STOP)
-    keyboard
-end
+function testGoldstein
+global PATH
+global VERSIONNUM
+global VERSION
+global DEBUG
+global PLOT
+global STOP
+if(DEBUG)
+    fprintf('--- testGoldstein --- Version: %s %d \n',VERSION,VERSIONNUM );
+end
+
+
+require('OPTIMCIRC',VERSION,~DEBUG);
+
+% should be a line vector
+vx=[0 0.1 0.5 0.9 1];
+G=fGoldsteinFactor(1/12,3,vx);
+assertEqual(G(:)',G);
+
+% zeros at extremities
+vx=[0 0.1 0.5 0.9 1];
+G=fGoldsteinFactor(1/12,3,vx);
+assertEqual([G(1) G(end)],[0 0]);
+
+
+%% test vs Tibery
+vlbar=[1 1/2 1/4 1/8];
+vB=[4 3 2];
+N=100;  % Number of helical vortex per blade
+% vx=(1/N:1/N:1);   % [.] 
+vx=linspace(0,1,N);
+R=1;
+for il=1:length(vlbar)
+    l_bar=vlbar(il);
+    h=2*pi*R*l_bar;
+    for iB=1:length(vB)
+        B=vB(iB);
+%         fprintf('B %d - 1/l %d\n',B,1/l_bar);
+        GammaGoldstein(iB,:) = fGoldsteinFactor( l_bar,B,vx);
+        [rt kt] = fTiberyWrench( l_bar , B );
+        G=interp1(vx,GammaGoldstein(iB,:),rt); % interpolate on points where tibery is known
+        assertElementsAlmostEqual(G,kt,'relative',0.07); % 7% error that's not the best...
+
+    end  
+end
+
+
+
+
+%%
+if(DEBUG)
+    fprintf('--- End of test ---\n');
+end
+
+if(STOP)
+    keyboard
+end
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor.mexa64` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor.mexa64`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinFarWakeParams.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m`

 * *Files 17% similar despite different names*

```diff
@@ -1,57 +1,48 @@
-function [ w_bar l_bar CT_out G] = fGoldsteinFarWakeParams(CT,lambda,nB,varargin)
-if nB==3
-    load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
-else
-    error('dsf');
-end
-bGoOptimal=0;
-n=100;
-if(isempty(varargin))
-    bGoOptimal=0;
-elseif nargin==4
-    bGoOptimal=varargin{1};
-elseif nargin==5
-    bGoOptimal=varargin{1};
-    n=varargin{2};
-end
-if(n>3000)
-    error('Mex file only for n<3000')
-end
-
-
-CT_opt=interp1(vLambda,vCT,lambda);
-if CT > CT_opt
-    warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
-    bGoOptimal=1;
-end
-
-if bGoOptimal
-    w_bar=interp1(vLambda,[1 vw],lambda);
-    CP_out=interp1(vLambda,[0 vCP],lambda);
-    CT_out=CT_opt;
-    l_bar=(1-w_bar/2)/lambda;
-    vr=linspace(0,1,100);  
-    G=fGoldsteinFactor( l_bar,nB,vr);
-else
-    w_bar0=1-sqrt(1-CT);  %1D momentum result used as a first guess
-    opts=optimset('TolX',1e-3);
-    tic(); 
-    fprintf('Iterating to find Goldstein far wake parameters ...');
-%     w_bar=fzero(@(w) CT-fCT(w,lambda,nB),[0 1.5],opts);
-    w_bar=fzero(@(w) CT-fCT(w,lambda,nB,n),w_bar0,opts);
-    fprintf('Done,\t'),toc();
-    [CT_out CP_out l_bar G]=fCT(w_bar, lambda,nB,n);
-end
-
-
-
-
-function [CT CP l_bar G]= fCT(w_bar,lambda,nB,n)
-vr=linspace(0,1,n);  
-l_bar=(1-w_bar/2)/lambda;  % that's the link given by Okulov and Sorensen.
-G=fGoldsteinFactor( l_bar,nB,vr);
-I1=2*trapz(vr,G.*vr);
-%I2=2*trapz(vr,G*l_bar.*vr.^2./(l_bar^2+vr.^2));
-I3=2*trapz(vr,G.*vr.^3./(l_bar^2+vr.^2));
-CP=2*w_bar*(1-w_bar/2)*(I1-w_bar/2*I3);
-CT=2*w_bar*(I1-w_bar/2*I3);
+function [ w_bar l_bar CT G] = fGoldsteinFarWakeParams(CT,lambda,nB,varargin)
+if nB==3
+    load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
+else
+    error('dsf');
+end
+bGoOptimal=0;
+if(~isempty(varargin))
+    bGoOptimal=1;
+end
+
+
+CT_opt=interp1(vLambda,vCT,lambda);
+if CT > CT_opt
+    warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
+    bGoOptimal=1;
+end
+
+if bGoOptimal
+    w_bar=interp1(vLambda,[1 vw],lambda);
+    CP_out=interp1(vLambda,[0 vCP],lambda);
+    CT_out=CT_opt;
+    l_bar=(1-w_bar/2)/lambda;
+    vr=linspace(0,1,100);  
+    G=fGoldsteinFactor( l_bar,nB,vr);
+else
+    w_bar0=1-sqrt(1-CT);  %1D momentum result used as a first guess
+    opts=optimset('TolX',1e-3);
+    tic(); 
+    fprintf('Iterating to find Goldstein far wake parameters ...');
+%     w_bar=fzero(@(w) CT-fCT(w,lambda,nB),[0 1.5],opts);
+    w_bar=fzero(@(w) CT-fCT(w,lambda,nB),w_bar0,opts);
+    fprintf('Done,\t'),toc();
+    [CT_out CP_out l_bar G]=fCT(w_bar, lambda,nB);
+end
+
+
+
+
+function [CT CP l_bar G]= fCT(w_bar,lambda,nB)
+vr=linspace(0,1,100);  
+l_bar=(1-w_bar/2)/lambda;  % that's the link given by Okulov and Sorensen.
+G=fGoldsteinFactor( l_bar,nB,vr);
+I1=2*trapz(vr,G.*vr);
+%I2=2*trapz(vr,G*l_bar.*vr.^2./(l_bar^2+vr.^2));
+I3=2*trapz(vr,G.*vr.^3./(l_bar^2+vr.^2));
+CP=2*w_bar*(1-w_bar/2)*(I1-w_bar/2*I3);
+CT=2*w_bar*(I1-w_bar/2*I3);
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fGoldsteinOkulovF.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinOkulovF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01/fTiberyWrench.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fTiberyWrench.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFarWakeParams.m`

 * *Files 16% similar despite different names*

```diff
@@ -1,48 +1,57 @@
-function [ w_bar l_bar CT G] = fGoldsteinFarWakeParams(CT,lambda,nB,varargin)
-if nB==3
-    load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
-else
-    error('dsf');
-end
-bGoOptimal=0;
-if(~isempty(varargin))
-    bGoOptimal=1;
-end
-
-
-CT_opt=interp1(vLambda,vCT,lambda);
-if CT > CT_opt
-    warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
-    bGoOptimal=1;
-end
-
-if bGoOptimal
-    w_bar=interp1(vLambda,[1 vw],lambda);
-    CP_out=interp1(vLambda,[0 vCP],lambda);
-    CT_out=CT_opt;
-    l_bar=(1-w_bar/2)/lambda;
-    vr=linspace(0,1,100);  
-    G=fGoldsteinFactor( l_bar,nB,vr);
-else
-    w_bar0=1-sqrt(1-CT);  %1D momentum result used as a first guess
-    opts=optimset('TolX',1e-3);
-    tic(); 
-    fprintf('Iterating to find Goldstein far wake parameters ...');
-%     w_bar=fzero(@(w) CT-fCT(w,lambda,nB),[0 1.5],opts);
-    w_bar=fzero(@(w) CT-fCT(w,lambda,nB),w_bar0,opts);
-    fprintf('Done,\t'),toc();
-    [CT_out CP_out l_bar G]=fCT(w_bar, lambda,nB);
-end
-
-
-
-
-function [CT CP l_bar G]= fCT(w_bar,lambda,nB)
-vr=linspace(0,1,100);  
-l_bar=(1-w_bar/2)/lambda;  % that's the link given by Okulov and Sorensen.
-G=fGoldsteinFactor( l_bar,nB,vr);
-I1=2*trapz(vr,G.*vr);
-%I2=2*trapz(vr,G*l_bar.*vr.^2./(l_bar^2+vr.^2));
-I3=2*trapz(vr,G.*vr.^3./(l_bar^2+vr.^2));
-CP=2*w_bar*(1-w_bar/2)*(I1-w_bar/2*I3);
-CT=2*w_bar*(I1-w_bar/2*I3);
+function [ w_bar l_bar CT_out G] = fGoldsteinFarWakeParams(CT,lambda,nB,varargin)
+if nB==3
+    load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
+else
+    error('dsf');
+end
+bGoOptimal=0;
+n=100;
+if(isempty(varargin))
+    bGoOptimal=0;
+elseif nargin==4
+    bGoOptimal=varargin{1};
+elseif nargin==5
+    bGoOptimal=varargin{1};
+    n=varargin{2};
+end
+if(n>3000)
+    error('Mex file only for n<3000')
+end
+
+
+CT_opt=interp1(vLambda,vCT,lambda);
+if CT > CT_opt
+    warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
+    bGoOptimal=1;
+end
+
+if bGoOptimal
+    w_bar=interp1(vLambda,[1 vw],lambda);
+    CP_out=interp1(vLambda,[0 vCP],lambda);
+    CT_out=CT_opt;
+    l_bar=(1-w_bar/2)/lambda;
+    vr=linspace(0,1,100);  
+    G=fGoldsteinFactor( l_bar,nB,vr);
+else
+    w_bar0=1-sqrt(1-CT);  %1D momentum result used as a first guess
+    opts=optimset('TolX',1e-3);
+    tic(); 
+    fprintf('Iterating to find Goldstein far wake parameters ...');
+%     w_bar=fzero(@(w) CT-fCT(w,lambda,nB),[0 1.5],opts);
+    w_bar=fzero(@(w) CT-fCT(w,lambda,nB,n),w_bar0,opts);
+    fprintf('Done,\t'),toc();
+    [CT_out CP_out l_bar G]=fCT(w_bar, lambda,nB,n);
+end
+
+
+
+
+function [CT CP l_bar G]= fCT(w_bar,lambda,nB,n)
+vr=linspace(0,1,n);  
+l_bar=(1-w_bar/2)/lambda;  % that's the link given by Okulov and Sorensen.
+G=fGoldsteinFactor( l_bar,nB,vr);
+I1=2*trapz(vr,G.*vr);
+%I2=2*trapz(vr,G*l_bar.*vr.^2./(l_bar^2+vr.^2));
+I3=2*trapz(vr,G.*vr.^3./(l_bar^2+vr.^2));
+CP=2*w_bar*(1-w_bar/2)*(I1-w_bar/2*I3);
+CT=2*w_bar*(I1-w_bar/2*I3);
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalCirculation/v01_nomex/fTiberyWrench.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTiberyWrench.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,25 @@
-%%
-InitClear
+%% Documentation   
+% Contact: E. Branlard 
+% 
+% Used to generate figures 9.8 of [1]
+
+% Reference:
+%  [1]  Branlard 2017 Wind turbine aerodynamics and vorticity-based methods
+% 
+%% Initialization
+clear all; close all; clc; % addpath()
+restoredefaultpath;
+addpath(genpath('C:/Config/path/MatlabPath/libs/')) % http://github.com/ebranlard/matlab-path.git
+
+%% Parameters
+
 % setFigurePath('/work/publications/book/figsdump/')
-setFigurePath('/home/manu/Dropbox/springer-book/figs_ad/')
-setFigureFont('14')
+% setFigurePath('/home/manu/Dropbox/springer-book/figs_ad/')
+% setFigureFont('14')
 % I explain this a bit in my book section Maximum Power extraction 1D momentum+rotation
 
 
 %
 R=100;
 nr=200;
 
@@ -87,15 +100,15 @@
 % CP
 figure,hold on,grid,box
 plot(vlambda,vlambda*0+16/27 ,'k--')
 plot(vlambda2,CP2 ,'k-')
 % plot(vlambda,CP,'b+')
 % plot(vlambda3,CP3,'r--')
 % plot(vlambdaRef,CPRef,'ko')
-legend('Betz limit','Ideal rotor with wake rotation',0)
+legend('Betz limit','Ideal rotor with wake rotation')
 % ,'Same but different way of thinking it','Same but deterministic','Wilson Lissaman',0)
 xlim([0 10])
 ylim([0 0.62])
 xlabel('Tip speed ratio \lambda [-]')
 ylabel('C_P [-]')
 title('MomentumTheoryActuatorDiskOptimalCP')
 
@@ -103,49 +116,49 @@
 
 % CT
 figure,hold on,grid,box
 plot(vlambda,vlambda*0+8/9 ,'k--')
 plot(vlambda2,CT2 ,'k-')
 % plot(vlambda,CT,'b+')
 % plot(vlambda3,CT3,'r--')
-legend('Betz limit','Ideal rotor with wake rotation',0)
+legend('Betz limit','Ideal rotor with wake rotation')
 % ,'Same but different way of thinking it','Same but deterministic',0)
 xlim([0 10])
 xlabel('Tip speed ratio \lambda [-]')
 ylabel('C_T [.]')
 title('MomentumTheoryActuatorDiskOptimalCT')
 
 % a
 figure,hold on,grid,box
 plot(vlambda,vlambda*0+1/3 ,'k--')
 plot(vlambda2,a2 ,'k-')
 % plot(vlambda3,a3,'r--')
-legend('Betz limit','Ideal rotor with wake rotation',0)
+legend('Betz limit','Ideal rotor with wake rotation')
 % ,'Same but deterministic',0)
 xlim([0 10])
 ylim([0 0.35])
 xlabel('Local tip speed ratio \lambda_r [-]')
 ylabel('Axial induction factor a [-]')
 title('MomentumTheoryActuatorDiskOptimala')
 
 % aprime
 figure,hold on,grid,box
 plot(vlambda2,aprime2 ,'k-')
 % plot(vlambda3,aprime3,'r--')
 ylim([0 0.1])
-legend('Ideal rotor with wake rotation',0)
+legend('Ideal rotor with wake rotation')
 % ,'Same but deterministic',0)
 xlim([0 10])
 title('MomentumTheoryActuatorDiskOptimalaprime')
 xlabel('Local tip speed ratio \lambda_r [-]')
 ylabel('Tangential induction factor a'' [-]')
 
 
 %% 
-I=whichvalue(vlambda2,vlambdaRef);
+I =whichvalue(vlambda2,vlambdaRef);
 I2=whichvalue(vlambda,vlambdaRef);
 I3=whichvalue(vlambda3,vlambdaRef);
 
 [vlambda3(I3)' CP2(I)' CP(I2)' CP3(I3)' CPRef' CPMartin']
 
 fprintf('\n\nlambda\t CP2\t CPref CPMartin\n');
 fprintf('%.3f\t %.4f\t %.4f %.3f\n', [vlambda2(I)' CP2(I)' CPRef' CPMartin']');
@@ -154,10 +167,13 @@
 vaAD=interp1(vlambda3(1:end-2),a3(1:end-2),vlambdaAD);
 vaprimeAD=interp1(vlambda3(1:end-2),aprime3(1:end-2),vlambdaAD);
 vCPAD=interp1(vlambda3(1:end-2),CP3(1:end-2),vlambdaAD);
 vCTAD=interp1(vlambda3(1:end-2),CT3(1:end-2),vlambdaAD);
 vCPAD(1)=0;
 vCTAD(1)=0;
 vaAD(1)=0.25;
-save([PATH.DATA_OUT '/WTTheory/MomentumTheoryActuatorDisk.mat'],'vlambdaAD','vCPAD','vCTAD','vaAD','vaprimeAD');
+
+
+
+% save([./MomentumTheoryActuatorDisk.mat'],'vlambdaAD','vCPAD','vCTAD','vaAD','vaprimeAD');
 
 %%
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/OptiminumParam.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/OptiminumParam.m`

 * *Files 16% similar despite different names*

```diff
@@ -1,150 +1,157 @@
-%% Question 1
-InitClear
-InitDefault
-path(path,'f_optimal')
-
-Algo.ClOverCd=100;
-Algo.Cl2piAlpha=1;
-
-%% rotor design
-Rotor.r=1:0.1:10;
-Rotor.nB=3;
-Rotor.rhub=min(Rotor.r);
-Rotor.R=max(Rotor.r);
-Rotor.ne=length(Rotor.r);
-lambda=7;
-alpha_d=6;  % alpha(17)=6 deg
-
-Cl=2*pi*alpha_d*pi/180;
-Cd=Cl/Algo.ClOverCd;
-
-[a aprime phi c]=getOptimizedParametersClCd(Cl,Cd,lambda,Rotor.nB);
-[a2 aprime2 phi2 c2]=getOptimizedParametersClCd(Cl,Cd,lambda-1,Rotor.nB);
-[a3 aprime3 phi3 c3]=getOptimizedParametersClCd(Cl,Cd,lambda+1,Rotor.nB);
-% phi=(phi+phi2+phi3)/3;
-% c=(c+c2+3)/3;
-
-
-twist=phi-alpha_d;
-Rotor.twist=twist';
-Rotor.chord=c';
-
-r=Rotor.r;
-R=Rotor.R;
-
-%%
-rhub=Rotor.rhub;
-c0=max(c);
-rbar=(r(:)-rhub)/(R-rhub);
-
-options=optimset('Display','iter');
-FittedParams=fminsearch(@fFitChord,[0.5 0.5 1 0.05 0.5],options,rbar,c(:)/max(c));
-
-[sse fit]=fFitChord(FittedParams,rbar,c(:)/max(c));
-FittedParams
-% To check the fit
-figure(11)
-hold all
-plot(rbar,c(:),'*')
-plot(rbar,fit*2.2,'r')
-%%
-options=optimset('Display','iter');
-FittedParams=fminsearch(@fFitTwist,[0.5 0.5 1],options,rbar,twist);
-[sse fit]=fFitTwist(FittedParams,rbar,c(:)/max(c));
-FittedParams
-
-figure(22)
-hold all
-plot(rbar,twist,'*')
-plot(rbar,fit,'r')
-
-%% plotting
-figure(14)
-hold on
-plot([0.1 1], [0.3333 0.3333],'r-.')
-plot(r/R,a,'r');
-plot(r/R,aprime);
-
-xlabel('r/R')
-grid()
-box()
-
-legend('Axial induction factor without wake rotation (a=1/3)','Axial induction factor (a)','Tangential induction factor (a`)')
-ylabel('Induction factors')
-%%
-Algo.Ngrid=36;
-rfull = linspace(Rotor.rhub,Rotor.R,Algo.Ngrid+1)'; % could be change for more fancy cos
-r_mid = (rfull(1:end-1)+rfull(2:end))/2; 
-Rotor.r=r_mid;
-Rotor.rfull=sort(unique([Rotor.r(:)' Rotor.rhub Rotor.R]));
-Rotor.chord         = interp1(r,Rotor.chord,Rotor.r) ;
-Rotor.twist         = interp1(r,Rotor.twist,Rotor.r);
-Rotor.ne=length(Rotor.r);
-Rotor.dr=Rotor.r*0;
-Rotor.dr(1)=2*(Rotor.r(1)-Rotor.rhub);
-for i=2:length(Rotor.r)
-    Rotor.dr(i)=2*(Rotor.r(i)-Rotor.r(i-1)-Rotor.dr(i-1)*0.5);
-end
-
-
-%%
-Algo.ClOverCd=100;
-Algo.Cl2piAlpha=1;
-Algo.TipLoss=1;
-Algo.HubLoss=1;
-Algo.nbIt=500;
-% Algo.Correction='SperaCT';
-
-omega=lambda*6/Rotor.R;
-
-vWS=4:1:12;
-vlambda=omega*(Rotor.R)./vWS;
-
-Rotor.SweptArea=pi*(Rotor.R^2-Rotor.rhub^2)
-Rotor.twist=Rotor.twist;
-Rotor.chord=Rotor.chord;
-
-Cases=zeros(length(vWS),3);
-Cases(:,1)=vWS;
-Cases(:,2)=Cases(:,2)*0+omega;
-Cases(:,3)=Cases(:,3);
-
-Simulation.CombinedCase.n=length(vWS);
-Simulation.CombinedCase.Cases=Cases;
-
-Algo.TipLoss=1;
-Algo.TipLossMethod='Glauert';
-BEMSimulation
-BEMGl=BEM;
-
-r=Rotor.r;
-
-%%
-figure(3)
-clf
-hold all
-for i=1:length(vWS)
-    plot(r/Rotor.R,vBEM(i).Cl)
-    plot(r/Rotor.R,vBEM(i).Cd)    
-end
-
-figure(2)
-clf
-hold all
-for i=1:length(vWS)
-    plot(r/Rotor.R,vBEM(i).a)
-end
-figure(1)
-clf
-hold all
-for i=1:length(vWS)
-    plot(r/Rotor.R,vBEM(i).alpha)
-end
-
-
-figure(4)
-clf
-hold all
-for i=1:length(vWS)
-    plot(r/Rotor.R,vBEM(i).Pn)
-end
+%% Documentation   
+% Contact: E. Branlard 
+
+%% Initialization
+clear all; close all; clc; 
+restoredefaultpath;
+% addpath(genpath('wtta1'));
+addpath('../../BEM/matlab/f_optimal/');
+
+%% Parameters
+global Rotor
+global Algo
+Algo.ClOverCd=100;
+Algo.Cl2piAlpha=1;
+
+%% rotor design
+Rotor.r=1:0.1:10;
+Rotor.nB=3;
+Rotor.rhub=min(Rotor.r);
+Rotor.R=max(Rotor.r);
+Rotor.ne=length(Rotor.r);
+lambda=7;
+alpha_d=6;  % alpha(17)=6 deg
+
+Cl=2*pi*alpha_d*pi/180;
+Cd=Cl/Algo.ClOverCd;
+
+[a aprime phi c]=getOptimizedParametersClCd(Cl,Cd,lambda,Rotor.nB);
+[a2 aprime2 phi2 c2]=getOptimizedParametersClCd(Cl,Cd,lambda-1,Rotor.nB);
+[a3 aprime3 phi3 c3]=getOptimizedParametersClCd(Cl,Cd,lambda+1,Rotor.nB);
+% phi=(phi+phi2+phi3)/3;
+% c=(c+c2+3)/3;
+
+
+twist=phi-alpha_d;
+Rotor.twist=twist';
+Rotor.chord=c';
+
+r=Rotor.r;
+R=Rotor.R;
+
+%%
+rhub=Rotor.rhub;
+c0=max(c);
+rbar=(r(:)-rhub)/(R-rhub);
+
+options=optimset('Display','iter');
+FittedParams=fminsearch(@fFitChord,[0.5 0.5 1 0.05 0.5],options,rbar,c(:)/max(c));
+
+[sse fit]=fFitChord(FittedParams,rbar,c(:)/max(c));
+FittedParams
+% To check the fit
+figure(11)
+hold all
+plot(rbar,c(:),'*')
+plot(rbar,fit*2.2,'r')
+%%
+options=optimset('Display','iter');
+FittedParams=fminsearch(@fFitTwist,[0.5 0.5 1],options,rbar,twist);
+[sse fit]=fFitTwist(FittedParams,rbar,c(:)/max(c));
+FittedParams
+
+figure(22)
+hold all
+plot(rbar,twist,'*')
+plot(rbar,fit,'r')
+
+%% plotting
+figure(14)
+hold on
+plot([0.1 1], [0.3333 0.3333],'r-.')
+plot(r/R,a,'r');
+plot(r/R,aprime);
+
+xlabel('r/R')
+grid()
+box()
+
+legend('Axial induction factor without wake rotation (a=1/3)','Axial induction factor (a)','Tangential induction factor (a`)')
+ylabel('Induction factors')
+%%
+Algo.Ngrid=36;
+rfull = linspace(Rotor.rhub,Rotor.R,Algo.Ngrid+1)'; % could be change for more fancy cos
+r_mid = (rfull(1:end-1)+rfull(2:end))/2; 
+Rotor.r=r_mid;
+Rotor.rfull=sort(unique([Rotor.r(:)' Rotor.rhub Rotor.R]));
+Rotor.chord         = interp1(r,Rotor.chord,Rotor.r) ;
+Rotor.twist         = interp1(r,Rotor.twist,Rotor.r);
+Rotor.ne=length(Rotor.r);
+Rotor.dr=Rotor.r*0;
+Rotor.dr(1)=2*(Rotor.r(1)-Rotor.rhub);
+for i=2:length(Rotor.r)
+    Rotor.dr(i)=2*(Rotor.r(i)-Rotor.r(i-1)-Rotor.dr(i-1)*0.5);
+end
+
+
+%%
+Algo.ClOverCd=100;
+Algo.Cl2piAlpha=1;
+Algo.TipLoss=1;
+Algo.HubLoss=1;
+Algo.nbIt=500;
+% Algo.Correction='SperaCT';
+
+omega=lambda*6/Rotor.R;
+
+vWS=4:1:12;
+vlambda=omega*(Rotor.R)./vWS;
+
+Rotor.SweptArea=pi*(Rotor.R^2-Rotor.rhub^2)
+Rotor.twist=Rotor.twist;
+Rotor.chord=Rotor.chord;
+
+Cases=zeros(length(vWS),3);
+Cases(:,1)=vWS;
+Cases(:,2)=Cases(:,2)*0+omega;
+Cases(:,3)=Cases(:,3);
+
+Simulation.CombinedCase.n=length(vWS);
+Simulation.CombinedCase.Cases=Cases;
+
+Algo.TipLoss=1;
+Algo.TipLossMethod='Glauert';
+BEMSimulation
+BEMGl=BEM;
+
+r=Rotor.r;
+
+%%
+figure(3)
+clf
+hold all
+for i=1:length(vWS)
+    plot(r/Rotor.R,vBEM(i).Cl)
+    plot(r/Rotor.R,vBEM(i).Cd)    
+end
+
+figure(2)
+clf
+hold all
+for i=1:length(vWS)
+    plot(r/Rotor.R,vBEM(i).a)
+end
+figure(1)
+clf
+hold all
+for i=1:length(vWS)
+    plot(r/Rotor.R,vBEM(i).alpha)
+end
+
+
+figure(4)
+clf
+hold all
+for i=1:length(vWS)
+    plot(r/Rotor.R,vBEM(i).Pn)
+end
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Exercise4bnew.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Exercise4bnew.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test1OptiminumParam.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test1OptiminumParam.m`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-%% Question 1
-InitClear
-InitRotor
-InitSystemProperties
-R=Rotor.R;
-r=Rotor.r;
-
-lambda=8;
-alpha_d=6;  % alpha(17)=6 deg
-[a aprime phi c beta]=getOptimizedParameters(alpha_d,lambda,3);
-
-
-%% table
-[r/R a aprime c phi beta]
-
-
-
-%% plotting
-figure(14)
-hold on
-plot([0.1 1], [0.3333 0.3333],'r-.')
-plot(r/R,a,'r');
-plot(r/R,aprime);
-
-xlabel('r/R')
-grid()
-box()
-
-legend('Axial induction factor without wake rotation (a=1/3)','Axial induction factor (a)','Tangential induction factor (a`)')
-ylabel('Induction factors')
-%%
-figure(15)
-hold on
-plot(r/R,phi);
-grid()
-box()
-xlabel('r/R [.]')
-ylabel('Flow angle phi [deg]')
-
-figure(17)
-hold on
-grid()
-box()
-plot(r/R,c);
-xlabel('r/R [.]')
-ylabel('Chord [m]')
-%ylim([0 0.14])
-
-
-%aa=0:0.01:0.5;plot(aa,getRelationAX(aa,x(1)))
+%% Question 1
+InitClear
+InitRotor
+InitSystemProperties
+R=Rotor.R;
+r=Rotor.r;
+
+lambda=8;
+alpha_d=6;  % alpha(17)=6 deg
+[a aprime phi c beta]=getOptimizedParameters(alpha_d,lambda,3);
+
+
+%% table
+[r/R a aprime c phi beta]
+
+
+
+%% plotting
+figure(14)
+hold on
+plot([0.1 1], [0.3333 0.3333],'r-.')
+plot(r/R,a,'r');
+plot(r/R,aprime);
+
+xlabel('r/R')
+grid()
+box()
+
+legend('Axial induction factor without wake rotation (a=1/3)','Axial induction factor (a)','Tangential induction factor (a`)')
+ylabel('Induction factors')
+%%
+figure(15)
+hold on
+plot(r/R,phi);
+grid()
+box()
+xlabel('r/R [.]')
+ylabel('Flow angle phi [deg]')
+
+figure(17)
+hold on
+grid()
+box()
+plot(r/R,c);
+xlabel('r/R [.]')
+ylabel('Chord [m]')
+%ylim([0 0.14])
+
+
+%aa=0:0.01:0.5;plot(aa,getRelationAX(aa,x(1)))
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test3OptimumLambda.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambda.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test3OptimumLambdaClCd.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambdaClCd.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/Test5PowerCurve.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/Test5PowerCurve.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/old/fBEM_backup.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/old/fBEM_backup.m`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,215 +1,215 @@
-function [BEM]=fBEM(x,v,update)
-global Aero Rotor Angles Controller Nacelle Algo Shaft Environment Tower
-nB=Rotor.nB;
-ne=Rotor.ne;
-r=Rotor.r;
-R=Rotor.R;
-rho=Environment.rho;
-%% Initializations
-% normal vectors
-n_thrust_in3=[0; 0; -1];       %vector along the thrust in system 3
-n_rotor_in4=[0; 0; 1];         %normal vector to the rotor plan in 4
-n_rotor_in2=[0; 0; 1];         %normal vector to the rotor plan in 2
-% induced velocities
-W0=ones(3,nB,ne);            %induced velocity without yaw/tilt
-W=zeros(3,nB,ne);            %induced velocity
-W_qs=zeros(3,nB,ne);        %quasistatic induced velocities
-W_int=zeros(3,nB,ne);        %intermediate induced velocity (used for filtering)
-
-% Forces and Power
-BEM.BladeTorque=zeros(1,nB);
-BEM.BladeThurst=zeros(1,nB);
-BEM.BladeEdge=zeros(1,nB);
-BEM.BladeFlap=zeros(1,nB);
-
-
-%aero force on element
-Pn=zeros(ne,1);
-Pt=zeros(ne,1);
-%weight force on elements
-Py=zeros(ne,1);
-Pz=zeros(ne,1);
-%Generalized force on each blade
-BEM.GF=zeros(nB,3);
-
-
-
-%% Preliminary calculations
-
-
-% yaw model initialization
-khi=max([Controller.yaw; Nacelle.tilt]);
-psi0=0;
-
-%% Elasticity dependence
-% Angles between blades updated depending on Dynamic degree of freedom 2
-Vpsi0=mod([0:(360/nB):(360/nB)*(nB-1)],360);
-Vpsi= mod(Vpsi0 + x(2)*180/pi,360); % [deg]
-omega=v(2);
-
-% Transformation matrices
-[a12 a23 a34]=getTransfoMatrices(Controller.yaw, Nacelle.tilt, 0, Rotor.cone);
-% Shaft vector coordinates
-rs_in1=a12'*Shaft.rs_in2;
-
-%%% Loop on blades
-for idB=1:nB
-    psi=Vpsi(idB);  %azimutal position of the blade
-    % Transformation matrix
-    a23=[cosd(psi) sind(psi) 0;  -sind(psi) cosd(psi) 0;  0 0 1];
-    % transformation of coordinates
-    a41=a12'*a23'*a34';
-    a31=a12'*a23';
-    
-    % loop on elements
-    for e=1:ne
-        %%% Step1 : Relative wind estimate
-        rb_in4=[r(e); 0; 0];
-        rb_in1=a41*rb_in4;
-        r_position(e,:)=Tower.rt_in1+rs_in1+rb_in1;
-        % Incoming wind
-        V0_in1=getPointIncomingWind(r_position(e,:),psi);
-        V0_in4=a41'*V0_in1;
-        V0_in3=a31'*V0_in1;
-        % Neglecting component on x ?????
-        V0_in4=[0 ; V0_in4(2) ; V0_in4(3) ];
-        V0_in3=[0 ; V0_in3(2) ; V0_in3(3) ];
-        % Velocity seen by the blade
-        Vb_in4=[0;  -omega*r(e)*cosd(Rotor.cone); 0]; %blade speed
-        % Velocity of the blade from elasticity
-        Velast_in4=[0;0;0];
-        ee=Rotor.ee(e);
-        Velast_in4(2)=v(idB*3+1)*Rotor.Blade.eigen1f(ee,1)+v(idB*3+2)*Rotor.Blade.eigen1e(ee,2)+v(idB*3+3)*Rotor.Blade.eigen2f(ee,2);
-        Velast_in4(3)=v(idB*3+1)*Rotor.Blade.eigen1f(ee,2)+v(idB*3+2)*Rotor.Blade.eigen1e(ee,3)+v(idB*3+3)*Rotor.Blade.eigen2f(ee,3);
-        Velasicity_in4=a41'*[0;0; v(1)];
-        Vrel_in4=V0_in4+Aero.last.W(:,idB,e)+Vb_in4 - Velasicity_in4-Velast_in4;    %relative speed
-        
-        %%% Step 2 : flow angle
-        phi=atan2(Vrel_in4(3),-Vrel_in4(2))*180/pi;
-        if(sind(phi)<0.01)
-            % To avoid complex values
-            BEM.F=1;
-        else
-            %prandtl tip correction
-            f = (3*(R-r(e)))/(2*r(e)*sind(phi));
-            BEM.F = (2/pi)*(acos(exp(-f)));
-        end
-        %%% Step 3 : angle of attack
-        alpha=phi-(Rotor.beta(e)+Controller.pitch);  %[deg]
-        %%% Step 4 : profiles data
-        BEM.Cd= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cd(e,:)  , alpha);
-        fs=0;
-        if(Algo.dynastall)
-            % dynamic stall
-            % interpolation from data
-            f_st=interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.f_st(e,:) , alpha);
-            Clinv=interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl_inv(e,:) , alpha);
-            Clfs= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl_fs(e,:)  , alpha);
-            % dynamic stall model
-            tau=4 * Rotor.chord(e) / norm(Vrel_in4);            
-            fs=f_st + ( Aero.last.fs-f_st )*exp(- Algo.dt / tau);
-            BEM.Cl=fs*Clinv+(1-f_st)*Clfs;
-            
-        else
-            % static aerodynamic coefficients
-            BEM.Cl= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl(e,:)  , alpha);
-        end        
-        
-        
-        
-        %%% Step 5 : Aerodynamic forces
-        BEM.L=0.5*rho*norm(Vrel_in4).^2*Rotor.chord(e)*BEM.Cl;
-        BEM.D=0.5*rho*norm(Vrel_in4).^2*Rotor.chord(e)*BEM.Cd;
-        Pn(e) = BEM.L*cosd(phi) + BEM.D*sind(phi);   %load normal to the rotor plane
-        Pt(e) = BEM.L*sind(phi) - BEM.D*cosd(phi);   %load tangential to the rotor plane
-        
-        %%% Weight
-        P_in1=[-9.81*Rotor.Blade.Mass(e);0;0];
-        P_in4=a41'*P_in1;
-        Py(e)=P_in4(2);
-        Pz(e)=P_in4(3);
-        
-        %%% Induction factor
-        Wn_in4=[0 ; 0 ; Aero.last.W(3,idB,e) ];
-        Wn_in3=a34'*Wn_in4;
-        nnW_in3=n_thrust_in3.*(n_thrust_in3.*Wn_in3);
-        nnW_in4=Wn_in4;
-        V_prime_induction_in3=V0_in3+nnW_in3;
-        BEM.a=(norm(V0_in3)-norm(V_prime_induction_in3))/norm(V0_in3);   %induction factor
-        %%% Glauert correction
-        if BEM.a<=0.2
-            fg=1;
-        elseif BEM.a>0.2
-            fg=0.2/BEM.a*(2-0.2/BEM.a);
-        end
-        %%% Dynamic wake model
-        % quastistatic induced velocity
-        W_z_qs=-nB*BEM.L*cosd(phi)/(4*pi*rho*r(e)*BEM.F*norm(V0_in4+fg*nnW_in4 ));
-        W_y_qs=-nB*BEM.L*sind(phi)/(4*pi*rho*r(e)*BEM.F*norm(V0_in4+fg*nnW_in4 ));
-        W_qs(:,idB,e)=[0 ; W_y_qs; W_z_qs];
-        % dynamic wake
-        tau1=1.1/(1-1.3*min(BEM.a,0.5))*R/norm(V0_in4);      %time constant 1
-        tau2=(0.39-0.26*(r(e)/R)^2)*tau1;           %time constant 2
-        H=W_qs(:,idB,e)+0.6*tau1*(W_qs(:,idB,e)-Aero.last.W_qs(:,idB,e))/Algo.dt;
-        W_int(:,idB,e)=H+(Aero.last.W_int(:,idB,e)-H)*exp(-Algo.dt/tau1);  %intermediate W
-        W0(:,idB,e)=W_int(:,idB,e)+(Aero.last.W0(:,idB,e)-W_int(:,idB,e))*exp(-Algo.dt/tau2);  %W without yaw/tilt
-        
-        %%% Yaw model, Skew angle and psi0
-        if(e==Rotor.e_ref_for_khi)
-            %%% Determination of psi0
-            r_hub=Tower.rt_in1+rs_in1;
-            % Incoming wind at hub
-            V0_in1=getPointIncomingWind(r_hub,psi);
-            V0_in2=a12*V0_in1;
-            % psi0
-            psi0=atan2(V0_in2(2),V0_in2(1))*180/pi;
-            %%% Determination of skew angle
-            % Averaging Wn on each blade
-            meanWn_in4=[0;0;mean(W0(3,:,Rotor.e_ref_for_khi)) ];
-            meanWn_in2=a34'*meanWn_in4;
-            V_prime_for_khi_in2=V0_in2+meanWn_in2;
-            khi=acosd(dot(n_rotor_in2,V_prime_for_khi_in2)/norm(V_prime_for_khi_in2));
-        end
-        %%% Yaw model, repartition of the induced velocity
-        if(Algo.YawModel)
-            W(:,idB,e)=W0(:,idB,e)*(1+r(e)/R *tand(khi/2)*cosd(Vpsi(idB)-psi0));
-        else
-            W(:,idB,e)=W0(:,idB,e);
-        end
-    end %loop on elements
-    if(Algo.Weight==0)
-      Pz=0;
-      Py=0;
-    end
-    BEM.GF(idB,1)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen1f(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen1f(Rotor.ee,2);0]);
-    BEM.GF(idB,2)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen1e(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen1e(Rotor.ee,2);0]);
-    BEM.GF(idB,3)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen2f(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen2f(Rotor.ee,2);0]);
-    
-    %%% Torque momentum at hub
-    BEM.BladeTorque(idB)=getTorqueFromBlade(r,(Py+Pt),R);
-    BEM.BladeThrust(idB)=getThrustFromBlade(r,(Pz+Pn),R);
-    %%%
-    BEM.BladeFlap(idB)=trapz([Rotor.r;R],[Rotor.r.*(Pz+Pn);0]);
-end %loop on blades
-
-
-%%%% Returning Aerodynamic Forces
-BEM.Torque = sum(BEM.BladeTorque);  %Rotor shaft torque at t in N
-BEM.Thrust = sum(BEM.BladeThrust);   %Rotor shaft thrust at t in N
-BEM.Flap = sum(BEM.BladeFlap);
-BEM.Power=omega*BEM.Torque;
-
-%%% updating the aero values
-if(update)
-    Aero.last.W_qs=W_qs;      % quasistatic induced velocity
-    Aero.last.W=W;            % induced velocity
-    Aero.last.W0=W0;          % induced velocity
-    Aero.last.W_int=W_int;    % intermediate induced velocity
-    Aero.last.fs=fs;
-    Aero.Torque=BEM.Torque;
-    Aero.Thrust=BEM.Thrust;
-    Aero.Power=BEM.Power;
-    Aero.Flap=BEM.BladeFlap;
-    Aero.Edge=BEM.BladeTorque;
-end
-
+function [BEM]=fBEM(x,v,update)
+global Aero Rotor Angles Controller Nacelle Algo Shaft Environment Tower
+nB=Rotor.nB;
+ne=Rotor.ne;
+r=Rotor.r;
+R=Rotor.R;
+rho=Environment.rho;
+%% Initializations
+% normal vectors
+n_thrust_in3=[0; 0; -1];       %vector along the thrust in system 3
+n_rotor_in4=[0; 0; 1];         %normal vector to the rotor plan in 4
+n_rotor_in2=[0; 0; 1];         %normal vector to the rotor plan in 2
+% induced velocities
+W0=ones(3,nB,ne);            %induced velocity without yaw/tilt
+W=zeros(3,nB,ne);            %induced velocity
+W_qs=zeros(3,nB,ne);        %quasistatic induced velocities
+W_int=zeros(3,nB,ne);        %intermediate induced velocity (used for filtering)
+
+% Forces and Power
+BEM.BladeTorque=zeros(1,nB);
+BEM.BladeThurst=zeros(1,nB);
+BEM.BladeEdge=zeros(1,nB);
+BEM.BladeFlap=zeros(1,nB);
+
+
+%aero force on element
+Pn=zeros(ne,1);
+Pt=zeros(ne,1);
+%weight force on elements
+Py=zeros(ne,1);
+Pz=zeros(ne,1);
+%Generalized force on each blade
+BEM.GF=zeros(nB,3);
+
+
+
+%% Preliminary calculations
+
+
+% yaw model initialization
+khi=max([Controller.yaw; Nacelle.tilt]);
+psi0=0;
+
+%% Elasticity dependence
+% Angles between blades updated depending on Dynamic degree of freedom 2
+Vpsi0=mod([0:(360/nB):(360/nB)*(nB-1)],360);
+Vpsi= mod(Vpsi0 + x(2)*180/pi,360); % [deg]
+omega=v(2);
+
+% Transformation matrices
+[a12 a23 a34]=getTransfoMatrices(Controller.yaw, Nacelle.tilt, 0, Rotor.cone);
+% Shaft vector coordinates
+rs_in1=a12'*Shaft.rs_in2;
+
+%%% Loop on blades
+for idB=1:nB
+    psi=Vpsi(idB);  %azimutal position of the blade
+    % Transformation matrix
+    a23=[cosd(psi) sind(psi) 0;  -sind(psi) cosd(psi) 0;  0 0 1];
+    % transformation of coordinates
+    a41=a12'*a23'*a34';
+    a31=a12'*a23';
+    
+    % loop on elements
+    for e=1:ne
+        %%% Step1 : Relative wind estimate
+        rb_in4=[r(e); 0; 0];
+        rb_in1=a41*rb_in4;
+        r_position(e,:)=Tower.rt_in1+rs_in1+rb_in1;
+        % Incoming wind
+        V0_in1=getPointIncomingWind(r_position(e,:),psi);
+        V0_in4=a41'*V0_in1;
+        V0_in3=a31'*V0_in1;
+        % Neglecting component on x ?????
+        V0_in4=[0 ; V0_in4(2) ; V0_in4(3) ];
+        V0_in3=[0 ; V0_in3(2) ; V0_in3(3) ];
+        % Velocity seen by the blade
+        Vb_in4=[0;  -omega*r(e)*cosd(Rotor.cone); 0]; %blade speed
+        % Velocity of the blade from elasticity
+        Velast_in4=[0;0;0];
+        ee=Rotor.ee(e);
+        Velast_in4(2)=v(idB*3+1)*Rotor.Blade.eigen1f(ee,1)+v(idB*3+2)*Rotor.Blade.eigen1e(ee,2)+v(idB*3+3)*Rotor.Blade.eigen2f(ee,2);
+        Velast_in4(3)=v(idB*3+1)*Rotor.Blade.eigen1f(ee,2)+v(idB*3+2)*Rotor.Blade.eigen1e(ee,3)+v(idB*3+3)*Rotor.Blade.eigen2f(ee,3);
+        Velasicity_in4=a41'*[0;0; v(1)];
+        Vrel_in4=V0_in4+Aero.last.W(:,idB,e)+Vb_in4 - Velasicity_in4-Velast_in4;    %relative speed
+        
+        %%% Step 2 : flow angle
+        phi=atan2(Vrel_in4(3),-Vrel_in4(2))*180/pi;
+        if(sind(phi)<0.01)
+            % To avoid complex values
+            BEM.F=1;
+        else
+            %prandtl tip correction
+            f = (3*(R-r(e)))/(2*r(e)*sind(phi));
+            BEM.F = (2/pi)*(acos(exp(-f)));
+        end
+        %%% Step 3 : angle of attack
+        alpha=phi-(Rotor.beta(e)+Controller.pitch);  %[deg]
+        %%% Step 4 : profiles data
+        BEM.Cd= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cd(e,:)  , alpha);
+        fs=0;
+        if(Algo.dynastall)
+            % dynamic stall
+            % interpolation from data
+            f_st=interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.f_st(e,:) , alpha);
+            Clinv=interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl_inv(e,:) , alpha);
+            Clfs= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl_fs(e,:)  , alpha);
+            % dynamic stall model
+            tau=4 * Rotor.chord(e) / norm(Vrel_in4);            
+            fs=f_st + ( Aero.last.fs-f_st )*exp(- Algo.dt / tau);
+            BEM.Cl=fs*Clinv+(1-f_st)*Clfs;
+            
+        else
+            % static aerodynamic coefficients
+            BEM.Cl= interp1(Rotor.Profiles.alpha(e,:) , Rotor.Profiles.Cl(e,:)  , alpha);
+        end        
+        
+        
+        
+        %%% Step 5 : Aerodynamic forces
+        BEM.L=0.5*rho*norm(Vrel_in4).^2*Rotor.chord(e)*BEM.Cl;
+        BEM.D=0.5*rho*norm(Vrel_in4).^2*Rotor.chord(e)*BEM.Cd;
+        Pn(e) = BEM.L*cosd(phi) + BEM.D*sind(phi);   %load normal to the rotor plane
+        Pt(e) = BEM.L*sind(phi) - BEM.D*cosd(phi);   %load tangential to the rotor plane
+        
+        %%% Weight
+        P_in1=[-9.81*Rotor.Blade.Mass(e);0;0];
+        P_in4=a41'*P_in1;
+        Py(e)=P_in4(2);
+        Pz(e)=P_in4(3);
+        
+        %%% Induction factor
+        Wn_in4=[0 ; 0 ; Aero.last.W(3,idB,e) ];
+        Wn_in3=a34'*Wn_in4;
+        nnW_in3=n_thrust_in3.*(n_thrust_in3.*Wn_in3);
+        nnW_in4=Wn_in4;
+        V_prime_induction_in3=V0_in3+nnW_in3;
+        BEM.a=(norm(V0_in3)-norm(V_prime_induction_in3))/norm(V0_in3);   %induction factor
+        %%% Glauert correction
+        if BEM.a<=0.2
+            fg=1;
+        elseif BEM.a>0.2
+            fg=0.2/BEM.a*(2-0.2/BEM.a);
+        end
+        %%% Dynamic wake model
+        % quastistatic induced velocity
+        W_z_qs=-nB*BEM.L*cosd(phi)/(4*pi*rho*r(e)*BEM.F*norm(V0_in4+fg*nnW_in4 ));
+        W_y_qs=-nB*BEM.L*sind(phi)/(4*pi*rho*r(e)*BEM.F*norm(V0_in4+fg*nnW_in4 ));
+        W_qs(:,idB,e)=[0 ; W_y_qs; W_z_qs];
+        % dynamic wake
+        tau1=1.1/(1-1.3*min(BEM.a,0.5))*R/norm(V0_in4);      %time constant 1
+        tau2=(0.39-0.26*(r(e)/R)^2)*tau1;           %time constant 2
+        H=W_qs(:,idB,e)+0.6*tau1*(W_qs(:,idB,e)-Aero.last.W_qs(:,idB,e))/Algo.dt;
+        W_int(:,idB,e)=H+(Aero.last.W_int(:,idB,e)-H)*exp(-Algo.dt/tau1);  %intermediate W
+        W0(:,idB,e)=W_int(:,idB,e)+(Aero.last.W0(:,idB,e)-W_int(:,idB,e))*exp(-Algo.dt/tau2);  %W without yaw/tilt
+        
+        %%% Yaw model, Skew angle and psi0
+        if(e==Rotor.e_ref_for_khi)
+            %%% Determination of psi0
+            r_hub=Tower.rt_in1+rs_in1;
+            % Incoming wind at hub
+            V0_in1=getPointIncomingWind(r_hub,psi);
+            V0_in2=a12*V0_in1;
+            % psi0
+            psi0=atan2(V0_in2(2),V0_in2(1))*180/pi;
+            %%% Determination of skew angle
+            % Averaging Wn on each blade
+            meanWn_in4=[0;0;mean(W0(3,:,Rotor.e_ref_for_khi)) ];
+            meanWn_in2=a34'*meanWn_in4;
+            V_prime_for_khi_in2=V0_in2+meanWn_in2;
+            khi=acosd(dot(n_rotor_in2,V_prime_for_khi_in2)/norm(V_prime_for_khi_in2));
+        end
+        %%% Yaw model, repartition of the induced velocity
+        if(Algo.YawModel)
+            W(:,idB,e)=W0(:,idB,e)*(1+r(e)/R *tand(khi/2)*cosd(Vpsi(idB)-psi0));
+        else
+            W(:,idB,e)=W0(:,idB,e);
+        end
+    end %loop on elements
+    if(Algo.Weight==0)
+      Pz=0;
+      Py=0;
+    end
+    BEM.GF(idB,1)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen1f(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen1f(Rotor.ee,2);0]);
+    BEM.GF(idB,2)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen1e(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen1e(Rotor.ee,2);0]);
+    BEM.GF(idB,3)=trapz([Rotor.r;R],[(Pz+Pn).*Rotor.Blade.eigen2f(Rotor.ee,3)+(Py+Pt).*Rotor.Blade.eigen2f(Rotor.ee,2);0]);
+    
+    %%% Torque momentum at hub
+    BEM.BladeTorque(idB)=getTorqueFromBlade(r,(Py+Pt),R);
+    BEM.BladeThrust(idB)=getThrustFromBlade(r,(Pz+Pn),R);
+    %%%
+    BEM.BladeFlap(idB)=trapz([Rotor.r;R],[Rotor.r.*(Pz+Pn);0]);
+end %loop on blades
+
+
+%%%% Returning Aerodynamic Forces
+BEM.Torque = sum(BEM.BladeTorque);  %Rotor shaft torque at t in N
+BEM.Thrust = sum(BEM.BladeThrust);   %Rotor shaft thrust at t in N
+BEM.Flap = sum(BEM.BladeFlap);
+BEM.Power=omega*BEM.Torque;
+
+%%% updating the aero values
+if(update)
+    Aero.last.W_qs=W_qs;      % quasistatic induced velocity
+    Aero.last.W=W;            % induced velocity
+    Aero.last.W0=W0;          % induced velocity
+    Aero.last.W_int=W_int;    % intermediate induced velocity
+    Aero.last.fs=fs;
+    Aero.Torque=BEM.Torque;
+    Aero.Thrust=BEM.Thrust;
+    Aero.Power=BEM.Power;
+    Aero.Flap=BEM.BladeFlap;
+    Aero.Edge=BEM.BladeTorque;
+end
+
```

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/BEMfunction.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/BEMfunction.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/Exercise2new.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise2new.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/Exercise3new.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise3new.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/fakeBEM.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/fakeBEM.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/getOptimizedParameters.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/getOptimizedParameters.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/OptimalTurbine/wtta1/loading.m` & `welib-1.0.0/welib/wt_theory/matlab/OptimalTurbine/wtta1/loading.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/wt_theory/Theodorsen/TheodorsenTheory.m` & `welib-1.0.0/welib/wt_theory/matlab/Theodorsen/TheodorsenTheory.m`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,347 +1,347 @@
-%%
-InitClear
-require('OPTIMCIRC','v01');  % v00 is slower but maybe better for small values of lbar
-% setFigurePath({'./figs/' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
-setFigurePath({'./figs/' , '/work/publications/phdthesis/figsdump/'});
-setFigureTitle(0);
-setMatFigure(1);
-setFigureLatex(0);
-%%
-%% verification of the Goldsetin's function - theodorsen page 18 figure 5  - See script Main Goldstein for plot for different l_bar
-Rw=10;
-l_bar=1/2;
-l=l_bar*Rw;
-B=2;
-
-nr=100;
-vx=linspace(0,1,nr);
-[ G ] = fGoldsteinFactor( l_bar,B,vx );
-xi=2*trapz(vx,G.*vx);
-figure
-plot(vx,G)
-ylim([0 0.75])
-xlabel('r/R [.]')
-ylabel('Goldstein Factor K')
-title('TheodorsenGoldsteinFactor')  
-
-
-
-
-%% Verification of the mass coefficient - Theodorsen p25 Fig 7 
-Rw=10;
-l_bar=1/2;
-l=l_bar*Rw;
-B=2;
-nr=20;
-nl_bar=20;
-vx=linspace(0,1,nr);
-vhweird=linspace(0.1,7,nl_bar);
-xi=zeros(1,length(vhweird));
-for ilb=1:length(vhweird)
-    fprintf('.');
-    l_bar=vhweird(ilb)/(pi);
-    [ G ] = fGoldsteinFactor( l_bar,B,vx );
-    xi(ilb)=2*trapz(vx,G.*vx);
-end
-figure
-plot([0 vhweird],[1 xi])
-grid on
-xlabel('$(U_0+w)/(nD_w) = h/(2R) = \bar{l}/2$ [.]')
-ylabel('Mass coefficient $\kappa$ [.]')
-title('TheodorsenMassCoefficientB2')
-
-
-
-%% Verification of the mass coefficient for different B- Theodorsen p133 -------------------------------- Report plot
-Rw=10;
-vB=[2 3 4 6 20];
-nr=100;
-nl_bar=50;
-vx=linspace(0,1,nr);
-vhweird=linspace(0.01,5,nl_bar); %if too small it collapses
-xi=zeros(length(vB),length(vhweird));
-for ib=1:length(vB)
-    for ilb=1:length(vhweird)
-        fprintf('.');
-        l_bar=vhweird(ilb)/(pi);
-        [ G ] = fGoldsteinFactor( l_bar,vB(ib),vx );
-%         if(ilb==1)
-%             keyboard
-%         end
-        xi(ib,ilb)=2*trapz(vx,G.*vx);
-    end
-end
-%
-
-figure,hold all, grid on,box on,legds={};
-for ib=1:length(vB)
-%      plot([0 vhweird],[1 xi(ib,:)+(1-xi(ib,1))-0.0005],'-','Color',fColrs(length(vB)-ib+1,length(vB)))
-     plot([0 vhweird],[1 xi(ib,:)+(1-xi(ib,1))-0.0005],'-','Color',fColrs(ib));
-%      plot([0 vhweird],[1 xi(ib,:)])
-    legds{end+1}=sprintf('B=%d',vB(ib));
-end
-warning('Rememebr I''m a little bit cheating here due to umerical integration offset')
-l_bar=vhweird/(pi);
-xi_inf=1-l_bar.^2.*log(1+1./l_bar.^2);
-plot([0 vhweird],[1 xi_inf],'k','LineWidth',2)
-xlim([0 5])
-legds{end+1}='B=\infty';
-xlabel('(U_0+w)/(nD_w) = h/(2R) = l/2 [.]')
-ylabel('Mass coefficient \kappa [.]')
-title('TheodorsenMassCoefficient')
-legend(legds)
-% legend(legds,'Location','NorthEast')
-
-
-%% Tricky Plot - K for different l_bar at different position - Theodorsen p135 B=2 - 136 B=4
-Rw=10;
-nB=4;
-nl_bar=20;
-vx=[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.95];
-vl_bar=linspace(0.1,1,nl_bar);
-G=zeros(nl_bar,length(vx));
-for ilb=1:length(vl_bar)
-    fprintf('.');
-    vxx=linspace(0,1,100);
-    GG=fGoldsteinFactor( vl_bar(ilb),nB,vxx);
-    figure(12),hold all,grid on
-    plot(vxx,GG)
-    G(ilb,:)  = interp1(vxx,GG,vx);
-end
-%%
-figure,box on,hold all, grid on
-mx=repmat(vx,nl_bar,1);
-ml=repmat(vl_bar,length(vx),1)';
-Ip=1:6;
-Id=7:length(vx);
-plot(ml(:,Ip),G(:,Ip),'k');
-plot(ml(:,Id),G(:,Id),'k--');
-xlim([0 1])
-xlabel('l_{bar}' )
-ylabel('Godstein factor K(x) [.]')
-title('GoldsteinFactorDifferentRadialPos')
-
-
-
-%% Ideal efficiency against w_bar -Theodorsen p 140
-
-vek=[0 1/10 1/5 2/5 3/5 1];
-vw_bar=linspace(0,0.2,50);
-figure,hold all,grid on , box on
-for ie=1:length(vek)
-    eta(ie,:)=(1+vw_bar*(0.5+vek(ie)))./((1+vw_bar).*(1+vek(ie)*vw_bar));
-    plot(vw_bar,eta(ie,:),'k')
-end
-xlim([0 0.225])
-ylim([0.9 1])
-
-
-
-
-%% Energy losses - Theodorsen p33 fig 8/
-close all
-require('VC_LIB_MAT','v02');
-require('VC_LIB_C','v03');
-Rw=10;
-l_bar=1/2;
-l=l_bar*Rw;
-nB=2;
-w=2.4673; % !! Useless but required
-w=1;
-
-nhelix=80;
-nl_bar=20;
-nr=nhelix-1;
-npsi=30;
-
-% radial position of helix and CP
-vx_helix=linspace(0,1,nhelix);
-vx=diff(vx_helix); %!!! Dimension
-vx=vx_helix(1:end-1)+vx-vx(1)/2; %CP in between helixes
-rhelix=vx_helix*Rw;
-% Goldstein Factor
-[ K ] = fGoldsteinFactor( l_bar,nB,vx_helix );
-xi=2*trapz(vx_helix,K.*vx_helix);
-
-
-GammaBound=K/nB*w*2*pi*Rw*l_bar;
-GammaTrailed=-diff(GammaBound);
-
-% we will consider the difference of gamma to be at the middle points and then will add the smae derivative at the extremity points
-% GammaHelix=[GammaTrailed GammaTrailed(end) ];
-GammaHelix=[GammaTrailed(1)/2 GammaTrailed ];
-figure,plot(vx_helix,K),figure,plot(vx_helix,GammaHelix)
-
-%pitch of the helixes
-h=2*pi*l_bar*Rw;
-
-% that's for theoretical solutions where symetry of the rotor is already assumed
-vh=repmat(h,1,nhelix); 
-vpsi_helix=zeros(1,nhelix);
-N=nB; % trick because this code is nasty and need a version 2
-
-Algo = fInitVFilAlgo();
-Algo.Method='okulov';
-% Algo.Method='line_c';
-if(Algo.Method(end)~='N')
-    % The computation is done for each blade, so one needs to provided all info for all blades
-    vGammaTrailed=repmat(GammaHelix,1,nB); 
-    vh=repmat(vh,1,nB); 
-    vpsi_helix=reshape(repmat((0:nB-1)'*2*pi/nB,1,nhelix)',1,nB*nhelix);
-    vrhelix=repmat(rhelix,1,nB); 
-    N=nB*nhelix;
-else
-    % that's for theoretical solutions where symetry of the rotor is already assumed
-    vGammaTrailed=GammaHelix; 
-    vh=vh; 
-    vpsi_helix=zeros(1,nhelix);
-    vrhelix=rhelix; 
-    N=nB; % trick because this code is nasty and need a version 2
-end
-Algo.Helix.bInf=1;
-Algo.Helix.nRev=150;
-Algo.ntot=10000;
-vpsi_CP=linspace(-pi/nB,pi/nB,npsi); %I only take the sector I need, I know it's symetric. Also if npsi is even, I avoid the singularity, if odd then I'm on it and by symmetry it will be everywhere accounted for
-% the simulation
-vx_CP=[10^-3 vx vx+1]*Rw; % !!! Dimension
-% vx_CP=5
-% N=2
-vz=(Algo.Helix.nRev/2+0.0000)*h;
-[ui Xcp Ycp Zcp Helix]=fUi_HelixN(N,vx_CP,vpsi_CP,vz,vGammaTrailed,vrhelix,vh,vpsi_helix,Algo); % the z position doesnot matter since we are dealing with an infinite helix here
-ui
-%%
-% figure(12),hold all
-% for ih=1:length(Helix)
-%     plot3(Helix{ih}{1}(:,1), Helix{ih}{1}(:,2), Helix{ih}{1}(:,3)) 
-% end
-
-% ui goes length(vx) length(vpsi) 1 [r theta z]
-Rmax=max(vx_CP);
-  figure
-    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
-    hold on
-    contourf(Xcp,Ycp,squeeze(ui(:,:,1,3)),30,'LineStyle','none')
-    colorbar
-    title('ax')
-  figure
-    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
-    hold on
-    contourf(Xcp,Ycp,squeeze(ui(:,:,1,2)),30,'LineStyle','none')
-    colorbar
-    title('tan')
-  figure
-    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
-    hold on
-    contourf(Xcp,Ycp,squeeze(ui(:,:,1,1)),30,'LineStyle','none')
-    colorbar
-title('rad')
-%%
-% Area far wake
-Ir=1:sum(vx_CP<Rw);
-
-F=pi*Rw^2 /nB  %!!! By symmetry, since I use symmetry for integration, I divide by B
-inte=repmat(vx_CP(Ir),length(vpsi_CP),1)';
-F=trapz(vpsi_CP,trapz(vx_CP(Ir),inte))
-
-% quad dlbquad
-%
-ur2=squeeze(ui(:,:,:,1)).^2;
-ut2=squeeze(ui(:,:,:,2)).^2;
-uz2=squeeze(ui(:,:,:,3)).^2;
-
-
-% trying to add some point to make integration better
-vr0=[0 vx_CP(Ir) Rw];
-uz20=[repmat(0,1,length(vpsi_CP));uz2(Ir,:); repmat(0,1,length(vpsi_CP))];
-epsz0=1/(2*F)*trapz(vpsi_CP,trapz(vr0,uz20.*repmat(vr0,length(vpsi_CP),1)'))
-
-epsr=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),ur2(Ir,:).*inte))
-epst=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),ut2(Ir,:).*inte))
-epsz=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),uz2(Ir,:).*inte))
-fprintf('Sum eps: %.4f xi: %.4f\n',epsr+epst+epsz,xi);
-
-depsr=1/(w^2*F)*trapz(vpsi_CP,ur2')/2*Rw^2;  % depsilon/d(x^) = depsilon/dr * R^2 /(2r)   but the r cancels out due to the expression r dr dtheta
-depst=1/(w^2*F)*trapz(vpsi_CP,ut2')/2*Rw^2;
-depsz=1/(w^2*F)*trapz(vpsi_CP,uz2')/2*Rw^2;
-
-
-depst2=[depst(1:length(vx)+1) 0 depst(length(vx)+2:end)];
-
-vx_CP2=[vx_CP(1:length(vx)+1) Rw vx_CP(length(vx)+2:end)];
-depst2=[depst(1:length(vx)+1) 0 depst(length(vx)+2:end)];
-depsz2=[depsz(1:length(vx)+1) 0 depsz(length(vx)+2:end)];
-
-%%
-figure,hold all,grid on,box on
-plot(vx_CP.^2./Rw^2,depsr,'k-','LineWidth',2.2)
-plot(vx_CP.^2./Rw^2,depst,'k:','LineWidth',1.5)
-plot(vx_CP.^2./Rw^2,depsz,'k--','LineWidth',1.5)
-xlim([0 3])
-ylim([0 0.36])
-set(gca,'ytick',0:0.04:0.36)
-legend('r','t','z')
-%% testint
-vx=[0 vx 1]
-inte=repmat(vx*Rw,length(vpsi_CP),1)';
-trapz(vpsi_CP,trapz(vx*Rw,inte))
-trapz(vx*Rw,trapz(vpsi_CP,inte'))
-%%
-
-a_ll=squeeze(-ui(:,1,:,3))'/V0;
-
-
-
-[ ui ] = fUi_HelixNTheories( 'okulov',Gamma,r,r0 ,l,psih,nB, bWT,bHalf);
-
-
-%% Loss function epsilon/xi for an infinite number of blades - Thodorsen p34
-l_bar=linspace(0,2,100);
-epsz=1+l_bar.^2./(1+l_bar.^2)-2*l_bar.^2.*log(1+1./l_bar.^2);
-epst=-l_bar.^2./(1+l_bar.^2)+l_bar.^2.*log(1+1./l_bar.^2);
-xi_inf=1-l_bar.^2.*log(1+1./l_bar.^2);
-epsoverxi=epsz./xi_inf;
-figure,hold on,box on,grid on
-plot(l_bar,epsz,'k')
-plot(l_bar,epst,'k')
-plot(l_bar,xi_inf,'k')
-plot(l_bar,epsoverxi,'k')
-legend('\epsilon','\epsilon_t','\kappa','\epsilon/\kappa')
-
-
-%% Loss function estimate - Theodorsen p37  --------------------------------------Report plot
-Rw=10;
-l=l_bar*Rw;
-nB=4; % B=2 or B4
-nB=3; % for report
-nr=100;
-nl_bar=100;
-vx=linspace(0,1,nr);
-vl_bar=linspace(0.01/pi,5/pi,nl_bar);  % the new algo does not support small values as well
-xi=zeros(1,length(vl_bar));
-for ilb=1:length(vl_bar)
-    fprintf('.');
-    [ G ] = fGoldsteinFactor( vl_bar(ilb),nB,vx );
-    xi(ilb)=2*trapz(vx,G.*vx);
-end
-dxidl=diff(xi)./diff(vl_bar);  % slope for B=2 around 3pi/5 and pi/25 for B=4 at 0
-% dxidl=[dxidl(1) dxidl];
-dxidl=[0 dxidl];
-epsoverxi=1+0.5*vl_bar./xi.*dxidl;
-epsz=epsoverxi.*xi;
-
-
-figure, grid on, box on, hold all
-plot([0 vl_bar*pi],[1 xi],'k-','LineWidth',2)
-plot([0 vl_bar*pi],[1 epsz],'k-')
-plot([0 vl_bar*pi],[1 epsoverxi],'k--')
-xlim([0 5])
-ylim([0 1])
-legend('\kappa','\epsilon','\epsilon/\kappa')
-grid on
-xlabel('(U_0+w)/(nD_w) = h/(2R) = l\pi [.]')
-ylabel('[.]')
-title(['TheodorsenLossEstimateB' num2str(nB)])
-
-%%
-
-
+%%
+InitClear
+require('OPTIMCIRC','v01');  % v00 is slower but maybe better for small values of lbar
+% setFigurePath({'./figs/' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
+setFigurePath({'./figs/' , '/work/publications/phdthesis/figsdump/'});
+setFigureTitle(0);
+setMatFigure(1);
+setFigureLatex(0);
+%%
+%% verification of the Goldsetin's function - theodorsen page 18 figure 5  - See script Main Goldstein for plot for different l_bar
+Rw=10;
+l_bar=1/2;
+l=l_bar*Rw;
+B=2;
+
+nr=100;
+vx=linspace(0,1,nr);
+[ G ] = fGoldsteinFactor( l_bar,B,vx );
+xi=2*trapz(vx,G.*vx);
+figure
+plot(vx,G)
+ylim([0 0.75])
+xlabel('r/R [.]')
+ylabel('Goldstein Factor K')
+title('TheodorsenGoldsteinFactor')  
+
+
+
+
+%% Verification of the mass coefficient - Theodorsen p25 Fig 7 
+Rw=10;
+l_bar=1/2;
+l=l_bar*Rw;
+B=2;
+nr=20;
+nl_bar=20;
+vx=linspace(0,1,nr);
+vhweird=linspace(0.1,7,nl_bar);
+xi=zeros(1,length(vhweird));
+for ilb=1:length(vhweird)
+    fprintf('.');
+    l_bar=vhweird(ilb)/(pi);
+    [ G ] = fGoldsteinFactor( l_bar,B,vx );
+    xi(ilb)=2*trapz(vx,G.*vx);
+end
+figure
+plot([0 vhweird],[1 xi])
+grid on
+xlabel('$(U_0+w)/(nD_w) = h/(2R) = \bar{l}/2$ [.]')
+ylabel('Mass coefficient $\kappa$ [.]')
+title('TheodorsenMassCoefficientB2')
+
+
+
+%% Verification of the mass coefficient for different B- Theodorsen p133 -------------------------------- Report plot
+Rw=10;
+vB=[2 3 4 6 20];
+nr=100;
+nl_bar=50;
+vx=linspace(0,1,nr);
+vhweird=linspace(0.01,5,nl_bar); %if too small it collapses
+xi=zeros(length(vB),length(vhweird));
+for ib=1:length(vB)
+    for ilb=1:length(vhweird)
+        fprintf('.');
+        l_bar=vhweird(ilb)/(pi);
+        [ G ] = fGoldsteinFactor( l_bar,vB(ib),vx );
+%         if(ilb==1)
+%             keyboard
+%         end
+        xi(ib,ilb)=2*trapz(vx,G.*vx);
+    end
+end
+%
+
+figure,hold all, grid on,box on,legds={};
+for ib=1:length(vB)
+%      plot([0 vhweird],[1 xi(ib,:)+(1-xi(ib,1))-0.0005],'-','Color',fColrs(length(vB)-ib+1,length(vB)))
+     plot([0 vhweird],[1 xi(ib,:)+(1-xi(ib,1))-0.0005],'-','Color',fColrs(ib));
+%      plot([0 vhweird],[1 xi(ib,:)])
+    legds{end+1}=sprintf('B=%d',vB(ib));
+end
+warning('Rememebr I''m a little bit cheating here due to umerical integration offset')
+l_bar=vhweird/(pi);
+xi_inf=1-l_bar.^2.*log(1+1./l_bar.^2);
+plot([0 vhweird],[1 xi_inf],'k','LineWidth',2)
+xlim([0 5])
+legds{end+1}='B=\infty';
+xlabel('(U_0+w)/(nD_w) = h/(2R) = l/2 [.]')
+ylabel('Mass coefficient \kappa [.]')
+title('TheodorsenMassCoefficient')
+legend(legds)
+% legend(legds,'Location','NorthEast')
+
+
+%% Tricky Plot - K for different l_bar at different position - Theodorsen p135 B=2 - 136 B=4
+Rw=10;
+nB=4;
+nl_bar=20;
+vx=[0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.95];
+vl_bar=linspace(0.1,1,nl_bar);
+G=zeros(nl_bar,length(vx));
+for ilb=1:length(vl_bar)
+    fprintf('.');
+    vxx=linspace(0,1,100);
+    GG=fGoldsteinFactor( vl_bar(ilb),nB,vxx);
+    figure(12),hold all,grid on
+    plot(vxx,GG)
+    G(ilb,:)  = interp1(vxx,GG,vx);
+end
+%%
+figure,box on,hold all, grid on
+mx=repmat(vx,nl_bar,1);
+ml=repmat(vl_bar,length(vx),1)';
+Ip=1:6;
+Id=7:length(vx);
+plot(ml(:,Ip),G(:,Ip),'k');
+plot(ml(:,Id),G(:,Id),'k--');
+xlim([0 1])
+xlabel('l_{bar}' )
+ylabel('Godstein factor K(x) [.]')
+title('GoldsteinFactorDifferentRadialPos')
+
+
+
+%% Ideal efficiency against w_bar -Theodorsen p 140
+
+vek=[0 1/10 1/5 2/5 3/5 1];
+vw_bar=linspace(0,0.2,50);
+figure,hold all,grid on , box on
+for ie=1:length(vek)
+    eta(ie,:)=(1+vw_bar*(0.5+vek(ie)))./((1+vw_bar).*(1+vek(ie)*vw_bar));
+    plot(vw_bar,eta(ie,:),'k')
+end
+xlim([0 0.225])
+ylim([0.9 1])
+
+
+
+
+%% Energy losses - Theodorsen p33 fig 8/
+close all
+require('VC_LIB_MAT','v02');
+require('VC_LIB_C','v03');
+Rw=10;
+l_bar=1/2;
+l=l_bar*Rw;
+nB=2;
+w=2.4673; % !! Useless but required
+w=1;
+
+nhelix=80;
+nl_bar=20;
+nr=nhelix-1;
+npsi=30;
+
+% radial position of helix and CP
+vx_helix=linspace(0,1,nhelix);
+vx=diff(vx_helix); %!!! Dimension
+vx=vx_helix(1:end-1)+vx-vx(1)/2; %CP in between helixes
+rhelix=vx_helix*Rw;
+% Goldstein Factor
+[ K ] = fGoldsteinFactor( l_bar,nB,vx_helix );
+xi=2*trapz(vx_helix,K.*vx_helix);
+
+
+GammaBound=K/nB*w*2*pi*Rw*l_bar;
+GammaTrailed=-diff(GammaBound);
+
+% we will consider the difference of gamma to be at the middle points and then will add the smae derivative at the extremity points
+% GammaHelix=[GammaTrailed GammaTrailed(end) ];
+GammaHelix=[GammaTrailed(1)/2 GammaTrailed ];
+figure,plot(vx_helix,K),figure,plot(vx_helix,GammaHelix)
+
+%pitch of the helixes
+h=2*pi*l_bar*Rw;
+
+% that's for theoretical solutions where symetry of the rotor is already assumed
+vh=repmat(h,1,nhelix); 
+vpsi_helix=zeros(1,nhelix);
+N=nB; % trick because this code is nasty and need a version 2
+
+Algo = fInitVFilAlgo();
+Algo.Method='okulov';
+% Algo.Method='line_c';
+if(Algo.Method(end)~='N')
+    % The computation is done for each blade, so one needs to provided all info for all blades
+    vGammaTrailed=repmat(GammaHelix,1,nB); 
+    vh=repmat(vh,1,nB); 
+    vpsi_helix=reshape(repmat((0:nB-1)'*2*pi/nB,1,nhelix)',1,nB*nhelix);
+    vrhelix=repmat(rhelix,1,nB); 
+    N=nB*nhelix;
+else
+    % that's for theoretical solutions where symetry of the rotor is already assumed
+    vGammaTrailed=GammaHelix; 
+    vh=vh; 
+    vpsi_helix=zeros(1,nhelix);
+    vrhelix=rhelix; 
+    N=nB; % trick because this code is nasty and need a version 2
+end
+Algo.Helix.bInf=1;
+Algo.Helix.nRev=150;
+Algo.ntot=10000;
+vpsi_CP=linspace(-pi/nB,pi/nB,npsi); %I only take the sector I need, I know it's symetric. Also if npsi is even, I avoid the singularity, if odd then I'm on it and by symmetry it will be everywhere accounted for
+% the simulation
+vx_CP=[10^-3 vx vx+1]*Rw; % !!! Dimension
+% vx_CP=5
+% N=2
+vz=(Algo.Helix.nRev/2+0.0000)*h;
+[ui Xcp Ycp Zcp Helix]=fUi_HelixN(N,vx_CP,vpsi_CP,vz,vGammaTrailed,vrhelix,vh,vpsi_helix,Algo); % the z position doesnot matter since we are dealing with an infinite helix here
+ui
+%%
+% figure(12),hold all
+% for ih=1:length(Helix)
+%     plot3(Helix{ih}{1}(:,1), Helix{ih}{1}(:,2), Helix{ih}{1}(:,3)) 
+% end
+
+% ui goes length(vx) length(vpsi) 1 [r theta z]
+Rmax=max(vx_CP);
+  figure
+    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
+    hold on
+    contourf(Xcp,Ycp,squeeze(ui(:,:,1,3)),30,'LineStyle','none')
+    colorbar
+    title('ax')
+  figure
+    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
+    hold on
+    contourf(Xcp,Ycp,squeeze(ui(:,:,1,2)),30,'LineStyle','none')
+    colorbar
+    title('tan')
+  figure
+    h3 = polar([0 2*pi], [0 Rmax],'');delete(h3)
+    hold on
+    contourf(Xcp,Ycp,squeeze(ui(:,:,1,1)),30,'LineStyle','none')
+    colorbar
+title('rad')
+%%
+% Area far wake
+Ir=1:sum(vx_CP<Rw);
+
+F=pi*Rw^2 /nB  %!!! By symmetry, since I use symmetry for integration, I divide by B
+inte=repmat(vx_CP(Ir),length(vpsi_CP),1)';
+F=trapz(vpsi_CP,trapz(vx_CP(Ir),inte))
+
+% quad dlbquad
+%
+ur2=squeeze(ui(:,:,:,1)).^2;
+ut2=squeeze(ui(:,:,:,2)).^2;
+uz2=squeeze(ui(:,:,:,3)).^2;
+
+
+% trying to add some point to make integration better
+vr0=[0 vx_CP(Ir) Rw];
+uz20=[repmat(0,1,length(vpsi_CP));uz2(Ir,:); repmat(0,1,length(vpsi_CP))];
+epsz0=1/(2*F)*trapz(vpsi_CP,trapz(vr0,uz20.*repmat(vr0,length(vpsi_CP),1)'))
+
+epsr=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),ur2(Ir,:).*inte))
+epst=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),ut2(Ir,:).*inte))
+epsz=1/(w^2*F)*trapz(vpsi_CP,trapz(vx_CP(Ir),uz2(Ir,:).*inte))
+fprintf('Sum eps: %.4f xi: %.4f\n',epsr+epst+epsz,xi);
+
+depsr=1/(w^2*F)*trapz(vpsi_CP,ur2')/2*Rw^2;  % depsilon/d(x^) = depsilon/dr * R^2 /(2r)   but the r cancels out due to the expression r dr dtheta
+depst=1/(w^2*F)*trapz(vpsi_CP,ut2')/2*Rw^2;
+depsz=1/(w^2*F)*trapz(vpsi_CP,uz2')/2*Rw^2;
+
+
+depst2=[depst(1:length(vx)+1) 0 depst(length(vx)+2:end)];
+
+vx_CP2=[vx_CP(1:length(vx)+1) Rw vx_CP(length(vx)+2:end)];
+depst2=[depst(1:length(vx)+1) 0 depst(length(vx)+2:end)];
+depsz2=[depsz(1:length(vx)+1) 0 depsz(length(vx)+2:end)];
+
+%%
+figure,hold all,grid on,box on
+plot(vx_CP.^2./Rw^2,depsr,'k-','LineWidth',2.2)
+plot(vx_CP.^2./Rw^2,depst,'k:','LineWidth',1.5)
+plot(vx_CP.^2./Rw^2,depsz,'k--','LineWidth',1.5)
+xlim([0 3])
+ylim([0 0.36])
+set(gca,'ytick',0:0.04:0.36)
+legend('r','t','z')
+%% testint
+vx=[0 vx 1]
+inte=repmat(vx*Rw,length(vpsi_CP),1)';
+trapz(vpsi_CP,trapz(vx*Rw,inte))
+trapz(vx*Rw,trapz(vpsi_CP,inte'))
+%%
+
+a_ll=squeeze(-ui(:,1,:,3))'/V0;
+
+
+
+[ ui ] = fUi_HelixNTheories( 'okulov',Gamma,r,r0 ,l,psih,nB, bWT,bHalf);
+
+
+%% Loss function epsilon/xi for an infinite number of blades - Thodorsen p34
+l_bar=linspace(0,2,100);
+epsz=1+l_bar.^2./(1+l_bar.^2)-2*l_bar.^2.*log(1+1./l_bar.^2);
+epst=-l_bar.^2./(1+l_bar.^2)+l_bar.^2.*log(1+1./l_bar.^2);
+xi_inf=1-l_bar.^2.*log(1+1./l_bar.^2);
+epsoverxi=epsz./xi_inf;
+figure,hold on,box on,grid on
+plot(l_bar,epsz,'k')
+plot(l_bar,epst,'k')
+plot(l_bar,xi_inf,'k')
+plot(l_bar,epsoverxi,'k')
+legend('\epsilon','\epsilon_t','\kappa','\epsilon/\kappa')
+
+
+%% Loss function estimate - Theodorsen p37  --------------------------------------Report plot
+Rw=10;
+l=l_bar*Rw;
+nB=4; % B=2 or B4
+nB=3; % for report
+nr=100;
+nl_bar=100;
+vx=linspace(0,1,nr);
+vl_bar=linspace(0.01/pi,5/pi,nl_bar);  % the new algo does not support small values as well
+xi=zeros(1,length(vl_bar));
+for ilb=1:length(vl_bar)
+    fprintf('.');
+    [ G ] = fGoldsteinFactor( vl_bar(ilb),nB,vx );
+    xi(ilb)=2*trapz(vx,G.*vx);
+end
+dxidl=diff(xi)./diff(vl_bar);  % slope for B=2 around 3pi/5 and pi/25 for B=4 at 0
+% dxidl=[dxidl(1) dxidl];
+dxidl=[0 dxidl];
+epsoverxi=1+0.5*vl_bar./xi.*dxidl;
+epsz=epsoverxi.*xi;
+
+
+figure, grid on, box on, hold all
+plot([0 vl_bar*pi],[1 xi],'k-','LineWidth',2)
+plot([0 vl_bar*pi],[1 epsz],'k-')
+plot([0 vl_bar*pi],[1 epsoverxi],'k--')
+xlim([0 5])
+ylim([0 1])
+legend('\kappa','\epsilon','\epsilon/\kappa')
+grid on
+xlabel('(U_0+w)/(nD_w) = h/(2R) = l\pi [.]')
+ylabel('[.]')
+title(['TheodorsenLossEstimateB' num2str(nB)])
+
+%%
+
+
```

### Comparing `welib-0.0.2/welib/wt_theory/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m` & `welib-1.0.0/welib/wt_theory/matlab/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,205 +1,205 @@
-%% README
-% This script is a level Higher than the Expansion_DevPhase0 - It's usefull to investigate iteration, FarwakeParams etc
-% For more user friendly script, go to the dedicated WakeExpansion folder and FarWakeParams
-% 
-% TODO: this script should maybe use fTheodorsenFarWakeParam for the iterative procedure. 
-%       It's prbably this script which has been used to derive the iterative method in fTheodorsenFarWakeParam
-% The article plot for the torque conference wass done with this script (first part of the script)
-
-
-%% Init
-InitClear
-require('OPTIMCIRC','v00');  % v01 uses a mex, use v00 if it doesn't work
-
-setFigurePath({'./figs/' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
-setFigureLatex(1);
-R0=100;
-U0=10;
-nB=3;
-nr=100;
-ntheta=3000;
-z_inf=100;
-bWT=1;
-
-%% Standalone for Ewan test
-addpath('/work/lib/WTTheory/Expansion/'); 
-
-lambda=7.06;
-CT=0.737;
-nB=3;
-R0=27;
-U0=10
-a=1/2*(1-sqrt(1-CT));
- [ Expansion vz_bar R_over_RW_Wald] = fTheodorsenExpansionWrap(lambda,nB,U0,R0,a,CT );
- [ Expansion2 vz_bar2] = fExpansionVortexRings(CT );
-
-figure,hold all
-plot(vz_bar/2,Expansion)
-plot(vz_bar2/2,Expansion2)
-xlim([0 5])
-
-%% DONE AS A FUNCTION OF just l_bar, ct or cs not taken into account -> OF COURSE NOT ITERATIVE THEN
-vlbar=1./[10 4 2 1];
-w_bar=0.4;
-
-legds={};
-for il=1:length(vlbar)
-    l_bar=vlbar(il);
-    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
-    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
-
-    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlbar)),3,1)');
-%     hold all, grid on,box on,   plot(vz_bar,(1+ExpFactor)/(1+max(ExpFactor))),title('Expansion');
-    hold all, grid on,box on,   plot(vz_bar/2,1+cs*ExpFactor),title('Expansion');
-    xlim([0 10])
-    ylim([1 1.3])
-    [l_bar w_bar cs]
-
-    legds{end+1}=sprintf('$1/\\bar{l}=%d$ - $c_t=%.2f$',1/vlbar(il),cs);
-end
-figure(3)
-legend(legds)
-title('WakeExpansionTheodorsenLBAR')
-xlabel('$z/D$ [.]')
-ylabel('$R_w/R$ [.]')
-dispatchFigs(1)
-
-
-%% DONE AS A FUNCTION OF FAR WAKE PARAMS -> OF COURSE NOT ITERATIVE THEN
-vlbar=1./[8 8 3 3];
-vwbar=[0.6 0.4 0.4 0.2];
-
-legds={};
-for il=1:length(vlbar)
-    l_bar=vlbar(il);
-    w_bar=vwbar(il);
-
-    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
-    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
-
-    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlbar)),3,1)');
-    hold all, grid on,box on,   plot(vz_bar/2,1+cs*ExpFactor),title('Expansion');
-    xlim([0 10])
-    ylim([1 1.5])
-    [l_bar w_bar cs]
-    legds{end+1}=sprintf('$1/\\bar{l}=%d$ - $\\bar{w}=%0.2f$ - $c_t=%.2f$',1/vlbar(il),vwbar(il),cs);
-end
-
-
-%
-figure(3)
-legend(legds)
-title('WakeExpansionTheodorsenFarWakeParams')
-xlabel('$z/D$ [.]')
-ylabel('$R_w/R$ [.]')
-
-%% HERE THIS IS DONE WITH A WEIRD RELATION WITH RESPECT TO LAMBDA
-vlambda=[12 9 7 5 3];
-vCT=[1.1 0.8 0.6 0.3 0.1];
-va=[0.5 0.33 0.25 0.12 0.05];
-
-legds={};
-for il=1:length(vlambda)
-    U=U0*(1-va(il));
-    l_bar=(1-va(il))/vlambda(il);
-    CT=vCT(il);
-    w_bar=2*va(il);
-
-    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
-    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-
-    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
-
-    Rw=ExpFactor(end)*vCT(il)*R0+R0;
-
-    figure(1),hold all, grid on,box on,   plot(vx,K),title('K')
-    figure(2),hold all, grid on,box on,   plot(vz_bar,ExpFactor),title('ExpansionFactor');
-    xlim([0 10])
-    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlambda)),3,1)');
-    hold all, grid on,box on,   plot(vz_bar/2,1+ExpFactor*vCT(il)),title('Expansion');
-    xlim([0 10])
-
-    [l_bar w_bar CT cs Rw]
-
-    legds{end+1}=sprintf('\\lambda=%d - C_T=%0.2f',vlambda(il),vCT(il));
-    dispatchFigs(1)
-end
-
-dispatchFigs(1)
-
-%
-close(1:2)
-figure(3)
-legend(legds)
-title('WakeExpansionTheodorsenLambdaCTNotIterative')
-
-
-
-
-%%
-[ Expansion vz_bar] = fTheodorsenExpansionWrap(vlambda(1),nB,U0,R0,va(1),vCT(1));
-figure(4),hold all, grid on,   plot(vz_bar/2,Expansion),title('Expansion');
-
-
-
-%% The smae but iterative !!!!!!!!!!!!!!!!!!!!!!!!!!!! to be reviewed
-% This has been used to establish fTheodorsenFarWakeParams
-
-vlambda=[12 9 7 5 3];
-vCT=[1.1 0.8 0.6 0.3 0.1];
-va=[0.5 0.33 0.25 0.12 0.05];
-
-vlambda=[12];
-vCT=[1.1];
-va=[0.5];
-
-
-vlambda=[12];
-vCT=[1.1];
-va=[0.5];
-
-
-
-legds={};
-for il=1:length(vlambda)
-    U=U0*(1-va(il));
-    l_bar=(1-va(il))/vlambda(il);
-    lambda=vlambda(il);
-    CT=vCT(il);
-    w_bar=2*va(il);
-    
-    Rw=1.1*R0; % that's the approximation for first round
-   
-    cs=CT*R0^2/Rw^2;
-
-    while abs(cs-CT)/max(cs,CT)>10^-6
-        vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
-
-        
-        l_bar=(1-w_bar/2)/lambda;  % that's probably the link given by Okulov and Sorensen.
-
-        [ K kappa eps_over_k epsz cs] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-        [ vz_bar ExpFactor ] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
-
-
-        Rw=ExpFactor(end)*cs*R0+R0;
-        % for next round
-        cs_new=CT*R0^2/Rw^2
-        l_bar_new=l_bar
-        l_bar_sor=(1-w_bar/2)/lambda;  % that's probably the link given by Okulov and Sorensen.
-
-        figure(2),hold all, grid on,   plot(vz_bar/2,ExpFactor),title('ExpansionFactor');
-        xlim([0 10])
-        figure(3),hold all, grid on,   plot(vz_bar/2,1+ExpFactor*cs),title('Expansion');
-        xlim([0 10])
-        legds{end+1}=sprintf('\\lambda=%d - C_T=%0.2f',vlambda(il),vCT(il));
-        dispatchFigs(1)
-
-        [l_bar w_bar CT cs Rw]
-    end
-end
-legend(legds)
-dispatchFigs(1)
-%%
+%% README
+% This script is a level Higher than the Expansion_DevPhase0 - It's usefull to investigate iteration, FarwakeParams etc
+% For more user friendly script, go to the dedicated WakeExpansion folder and FarWakeParams
+% 
+% TODO: this script should maybe use fTheodorsenFarWakeParam for the iterative procedure. 
+%       It's prbably this script which has been used to derive the iterative method in fTheodorsenFarWakeParam
+% The article plot for the torque conference wass done with this script (first part of the script)
+
+
+%% Init
+InitClear
+require('OPTIMCIRC','v00');  % v01 uses a mex, use v00 if it doesn't work
+
+setFigurePath({'./figs/' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
+setFigureLatex(1);
+R0=100;
+U0=10;
+nB=3;
+nr=100;
+ntheta=3000;
+z_inf=100;
+bWT=1;
+
+%% Standalone for Ewan test
+addpath('/work/lib/WTTheory/Expansion/'); 
+
+lambda=7.06;
+CT=0.737;
+nB=3;
+R0=27;
+U0=10
+a=1/2*(1-sqrt(1-CT));
+ [ Expansion vz_bar R_over_RW_Wald] = fTheodorsenExpansionWrap(lambda,nB,U0,R0,a,CT );
+ [ Expansion2 vz_bar2] = fExpansionVortexRings(CT );
+
+figure,hold all
+plot(vz_bar/2,Expansion)
+plot(vz_bar2/2,Expansion2)
+xlim([0 5])
+
+%% DONE AS A FUNCTION OF just l_bar, ct or cs not taken into account -> OF COURSE NOT ITERATIVE THEN
+vlbar=1./[10 4 2 1];
+w_bar=0.4;
+
+legds={};
+for il=1:length(vlbar)
+    l_bar=vlbar(il);
+    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
+    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
+
+    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlbar)),3,1)');
+%     hold all, grid on,box on,   plot(vz_bar,(1+ExpFactor)/(1+max(ExpFactor))),title('Expansion');
+    hold all, grid on,box on,   plot(vz_bar/2,1+cs*ExpFactor),title('Expansion');
+    xlim([0 10])
+    ylim([1 1.3])
+    [l_bar w_bar cs]
+
+    legds{end+1}=sprintf('$1/\\bar{l}=%d$ - $c_t=%.2f$',1/vlbar(il),cs);
+end
+figure(3)
+legend(legds)
+title('WakeExpansionTheodorsenLBAR')
+xlabel('$z/D$ [.]')
+ylabel('$R_w/R$ [.]')
+dispatchFigs(1)
+
+
+%% DONE AS A FUNCTION OF FAR WAKE PARAMS -> OF COURSE NOT ITERATIVE THEN
+vlbar=1./[8 8 3 3];
+vwbar=[0.6 0.4 0.4 0.2];
+
+legds={};
+for il=1:length(vlbar)
+    l_bar=vlbar(il);
+    w_bar=vwbar(il);
+
+    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
+    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
+
+    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlbar)),3,1)');
+    hold all, grid on,box on,   plot(vz_bar/2,1+cs*ExpFactor),title('Expansion');
+    xlim([0 10])
+    ylim([1 1.5])
+    [l_bar w_bar cs]
+    legds{end+1}=sprintf('$1/\\bar{l}=%d$ - $\\bar{w}=%0.2f$ - $c_t=%.2f$',1/vlbar(il),vwbar(il),cs);
+end
+
+
+%
+figure(3)
+legend(legds)
+title('WakeExpansionTheodorsenFarWakeParams')
+xlabel('$z/D$ [.]')
+ylabel('$R_w/R$ [.]')
+
+%% HERE THIS IS DONE WITH A WEIRD RELATION WITH RESPECT TO LAMBDA
+vlambda=[12 9 7 5 3];
+vCT=[1.1 0.8 0.6 0.3 0.1];
+va=[0.5 0.33 0.25 0.12 0.05];
+
+legds={};
+for il=1:length(vlambda)
+    U=U0*(1-va(il));
+    l_bar=(1-va(il))/vlambda(il);
+    CT=vCT(il);
+    w_bar=2*va(il);
+
+    vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
+    [ K kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+
+    [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
+
+    Rw=ExpFactor(end)*vCT(il)*R0+R0;
+
+    figure(1),hold all, grid on,box on,   plot(vx,K),title('K')
+    figure(2),hold all, grid on,box on,   plot(vz_bar,ExpFactor),title('ExpansionFactor');
+    xlim([0 10])
+    figure(3),set(3,'DefaultAxesColorOrder',repmat(linspace(0,0.7,length(vlambda)),3,1)');
+    hold all, grid on,box on,   plot(vz_bar/2,1+ExpFactor*vCT(il)),title('Expansion');
+    xlim([0 10])
+
+    [l_bar w_bar CT cs Rw]
+
+    legds{end+1}=sprintf('\\lambda=%d - C_T=%0.2f',vlambda(il),vCT(il));
+    dispatchFigs(1)
+end
+
+dispatchFigs(1)
+
+%
+close(1:2)
+figure(3)
+legend(legds)
+title('WakeExpansionTheodorsenLambdaCTNotIterative')
+
+
+
+
+%%
+[ Expansion vz_bar] = fTheodorsenExpansionWrap(vlambda(1),nB,U0,R0,va(1),vCT(1));
+figure(4),hold all, grid on,   plot(vz_bar/2,Expansion),title('Expansion');
+
+
+
+%% The smae but iterative !!!!!!!!!!!!!!!!!!!!!!!!!!!! to be reviewed
+% This has been used to establish fTheodorsenFarWakeParams
+
+vlambda=[12 9 7 5 3];
+vCT=[1.1 0.8 0.6 0.3 0.1];
+va=[0.5 0.33 0.25 0.12 0.05];
+
+vlambda=[12];
+vCT=[1.1];
+va=[0.5];
+
+
+vlambda=[12];
+vCT=[1.1];
+va=[0.5];
+
+
+
+legds={};
+for il=1:length(vlambda)
+    U=U0*(1-va(il));
+    l_bar=(1-va(il))/vlambda(il);
+    lambda=vlambda(il);
+    CT=vCT(il);
+    w_bar=2*va(il);
+    
+    Rw=1.1*R0; % that's the approximation for first round
+   
+    cs=CT*R0^2/Rw^2;
+
+    while abs(cs-CT)/max(cs,CT)>10^-6
+        vx=linspace(0,1,nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
+
+        
+        l_bar=(1-w_bar/2)/lambda;  % that's probably the link given by Okulov and Sorensen.
+
+        [ K kappa eps_over_k epsz cs] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+        [ vz_bar ExpFactor ] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT );
+
+
+        Rw=ExpFactor(end)*cs*R0+R0;
+        % for next round
+        cs_new=CT*R0^2/Rw^2
+        l_bar_new=l_bar
+        l_bar_sor=(1-w_bar/2)/lambda;  % that's probably the link given by Okulov and Sorensen.
+
+        figure(2),hold all, grid on,   plot(vz_bar/2,ExpFactor),title('ExpansionFactor');
+        xlim([0 10])
+        figure(3),hold all, grid on,   plot(vz_bar/2,1+ExpFactor*cs),title('Expansion');
+        xlim([0 10])
+        legds{end+1}=sprintf('\\lambda=%d - C_T=%0.2f',vlambda(il),vCT(il));
+        dispatchFigs(1)
+
+        [l_bar w_bar CT cs Rw]
+    end
+end
+legend(legds)
+dispatchFigs(1)
+%%
```

### Comparing `welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenAtOperatingPoint.m` & `welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenAtOperatingPoint.m`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-function [ G kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar )
-% -- NOTES
-% Simple application of Theodorsen's theory - AS FUNCTION OF FAR WAKE PARAMETERS !!!
-% See fTheodorsenFarWakeParams to find those, and pplication scripts such as Expansion Comparisons and FarWake stuff (though they might be moved soon)
-% We need to get the derivative of the mass coefficient, for this we use two points surrounding l_bar
-
-% -- INPUT/OUTPUT
-% Usual Parameters and variable names according to Theodorsen
-
-
-[ G ] = fGoldsteinFactor( l_bar,nB,vx );
-kappa=2*trapz(vx,G.*vx);
-
-
-%% Loss function estimate - Theodorsen p37
-dl_bar=10^-3;
-vl_bar=l_bar+([-dl_bar dl_bar]); % we estimate the derivative at two points surrounding the operational point l_bar
-k=zeros(1,length(vl_bar));
-for ilb=1:length(vl_bar)
-    [ Gtmp ] = fGoldsteinFactor( vl_bar(ilb),nB,vx );
-    k(ilb)=2*trapz(vx,Gtmp.*vx); % mass coefficient
-end
-dkdl=diff(k)./diff(vl_bar); 
-k0=mean(k);
-eps_over_k=1+0.5*l_bar/k0*dkdl;
-epsz=eps_over_k*k0;
-
-
-% Now everything is known
-cs=2*kappa*w_bar*(1+w_bar*(1/2+eps_over_k));
-e=2*kappa*w_bar^2*(1/2+eps_over_k*w_bar);
-cp=2*kappa*w_bar*(1+w_bar)*(1+eps_over_k*w_bar);
-
-eta=(1+w_bar*(0.5+eps_over_k))./((1+w_bar).*(1+eps_over_k*w_bar));
-
-a0=(1/2*w_bar+eps_over_k*w_bar^2)/(1+w_bar*(1/2+eps_over_k));
-
-
-end
-
+function [ G kappa eps_over_k epsz cs cp e eta a0 ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar )
+% -- NOTES
+% Simple application of Theodorsen's theory - AS FUNCTION OF FAR WAKE PARAMETERS !!!
+% See fTheodorsenFarWakeParams to find those, and pplication scripts such as Expansion Comparisons and FarWake stuff (though they might be moved soon)
+% We need to get the derivative of the mass coefficient, for this we use two points surrounding l_bar
+
+% -- INPUT/OUTPUT
+% Usual Parameters and variable names according to Theodorsen
+
+
+[ G ] = fGoldsteinFactor( l_bar,nB,vx );
+kappa=2*trapz(vx,G.*vx);
+
+
+%% Loss function estimate - Theodorsen p37
+dl_bar=10^-3;
+vl_bar=l_bar+([-dl_bar dl_bar]); % we estimate the derivative at two points surrounding the operational point l_bar
+k=zeros(1,length(vl_bar));
+for ilb=1:length(vl_bar)
+    [ Gtmp ] = fGoldsteinFactor( vl_bar(ilb),nB,vx );
+    k(ilb)=2*trapz(vx,Gtmp.*vx); % mass coefficient
+end
+dkdl=diff(k)./diff(vl_bar); 
+k0=mean(k);
+eps_over_k=1+0.5*l_bar/k0*dkdl;
+epsz=eps_over_k*k0;
+
+
+% Now everything is known
+cs=2*kappa*w_bar*(1+w_bar*(1/2+eps_over_k));
+e=2*kappa*w_bar^2*(1/2+eps_over_k*w_bar);
+cp=2*kappa*w_bar*(1+w_bar)*(1+eps_over_k*w_bar);
+
+eta=(1+w_bar*(0.5+eps_over_k))./((1+w_bar).*(1+eps_over_k*w_bar));
+
+a0=(1/2*w_bar+eps_over_k*w_bar^2)/(1+w_bar*(1/2+eps_over_k));
+
+
+end
+
```

### Comparing `welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenExpansion.m` & `welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenExpansion.m`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-function [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT)
-% Compute expansion factor according to Theodorsen such that R/R_w = 1+ cs*ExpansionFactor where cs is the thrust coefficient in the far wake.. It can be obtained with fTheodorsenAtOperatingPoint
-%--- OUTPUT
-% ExpFactor: see above
-% vz_bar= z/R : downstream dimension
-% Y, Y1, Y2 : Intermediate variables, see Theodorsen's book
-% kappa (or xi) : mass coefficient, integral of Goldstein's circulations
-%--- INPUT
-% l_bar: l/R  l=h/(2 pi)  h:pitch of the helix in the far wake
-% vx: vector of dimensionless radius, e.g. linspace(0,1,100) on which K is known
-% K : goldstein factor
-% z_inf: location downstream that can be considered as infinity, typical value 100
-% ntheta: Number of points used to compute the integral over theta, typical value 3000
-% bWT : wind turbine (1) or propeller (0)
-
-kappa=trapz(vx,K.*vx);
-INFTY=z_inf/l_bar;
-
-% Compute Y1(theta) once and for all, that's the computational expensive part
-vtheta=linspace(0,INFTY,ntheta);
-Y1=zeros(1,ntheta);
-vB=1:nB;
-vtau=(vB-1)*(2*pi)/nB;
-for it=1:length(vtheta)
-    theta=vtheta(it);
-    y2=zeros(1,length(vx));
-    for ix=1:length(vx)
-        x=vx(ix);
-        sum_y1=0;
-        for ib=1:length(vB)
-            tau=vtau(ib);
-            % !!!! I added a +10^-32 to remove the singularity
-            y1=( theta*cos(theta+tau) -sin(theta+tau))*(1-2*x^2+l_bar^2*theta^2+ x*cos(theta+tau))/(1+x^2+l_bar^2*theta^2-2*x*cos(theta+tau)+10^-32)^(5/2);
-            sum_y1=sum_y1+y1;
-        end
-        y2(ix)=K(ix)/nB*sum_y1;
-    end
-    Y1(it)=trapz(vx,y2);
-end
-% Compute Y2(theta2) once and for all
-Y2=cumtrapz(vtheta,Y1)-trapz(vtheta,Y1);    
-Y=l_bar^3/4*trapz(vtheta,Y2);
-
-
-vz_bar=vtheta*l_bar;
-dY_fromInf=l_bar^3/4*cumtrapz(vtheta,-Y2); % for wind turbines we can go from 0 to infinity, no need to reverse
-Y=l_bar^3/4*trapz(vtheta,Y2);
-
-
-if(bWT)
-    ExpFactor=(l_bar^3)/4/kappa*cumtrapz(vtheta,-Y2); % for wind turbines we can go from 0 to infinity, no need to reverse
-    ExpFactor=ExpFactor;
-    vz_bar=vtheta*l_bar;
-else
-    ExpFactor=(l_bar^3)/4/kappa*cumtrapz(vtheta(end:-1:1),Y2(end:-1:1)); % for wind turbines we can go from 0 to infinity, no need to reverse
-    ExpFactor=ExpFactor;
-    vz_bar=vtheta*l_bar;
-end
-end
-
+function [ vz_bar ExpFactor Y Y1 Y2 kappa] = fTheodorsenExpansion(l_bar,vx,K,nB,z_inf,ntheta,bWT)
+% Compute expansion factor according to Theodorsen such that R/R_w = 1+ cs*ExpansionFactor where cs is the thrust coefficient in the far wake.. It can be obtained with fTheodorsenAtOperatingPoint
+%--- OUTPUT
+% ExpFactor: see above
+% vz_bar= z/R : downstream dimension
+% Y, Y1, Y2 : Intermediate variables, see Theodorsen's book
+% kappa (or xi) : mass coefficient, integral of Goldstein's circulations
+%--- INPUT
+% l_bar: l/R  l=h/(2 pi)  h:pitch of the helix in the far wake
+% vx: vector of dimensionless radius, e.g. linspace(0,1,100) on which K is known
+% K : goldstein factor
+% z_inf: location downstream that can be considered as infinity, typical value 100
+% ntheta: Number of points used to compute the integral over theta, typical value 3000
+% bWT : wind turbine (1) or propeller (0)
+
+kappa=trapz(vx,K.*vx);
+INFTY=z_inf/l_bar;
+
+% Compute Y1(theta) once and for all, that's the computational expensive part
+vtheta=linspace(0,INFTY,ntheta);
+Y1=zeros(1,ntheta);
+vB=1:nB;
+vtau=(vB-1)*(2*pi)/nB;
+for it=1:length(vtheta)
+    theta=vtheta(it);
+    y2=zeros(1,length(vx));
+    for ix=1:length(vx)
+        x=vx(ix);
+        sum_y1=0;
+        for ib=1:length(vB)
+            tau=vtau(ib);
+            % !!!! I added a +10^-32 to remove the singularity
+            y1=( theta*cos(theta+tau) -sin(theta+tau))*(1-2*x^2+l_bar^2*theta^2+ x*cos(theta+tau))/(1+x^2+l_bar^2*theta^2-2*x*cos(theta+tau)+10^-32)^(5/2);
+            sum_y1=sum_y1+y1;
+        end
+        y2(ix)=K(ix)/nB*sum_y1;
+    end
+    Y1(it)=trapz(vx,y2);
+end
+% Compute Y2(theta2) once and for all
+Y2=cumtrapz(vtheta,Y1)-trapz(vtheta,Y1);    
+Y=l_bar^3/4*trapz(vtheta,Y2);
+
+
+vz_bar=vtheta*l_bar;
+dY_fromInf=l_bar^3/4*cumtrapz(vtheta,-Y2); % for wind turbines we can go from 0 to infinity, no need to reverse
+Y=l_bar^3/4*trapz(vtheta,Y2);
+
+
+if(bWT)
+    ExpFactor=(l_bar^3)/4/kappa*cumtrapz(vtheta,-Y2); % for wind turbines we can go from 0 to infinity, no need to reverse
+    ExpFactor=ExpFactor;
+    vz_bar=vtheta*l_bar;
+else
+    ExpFactor=(l_bar^3)/4/kappa*cumtrapz(vtheta(end:-1:1),Y2(end:-1:1)); % for wind turbines we can go from 0 to infinity, no need to reverse
+    ExpFactor=ExpFactor;
+    vz_bar=vtheta*l_bar;
+end
+end
+
```

### Comparing `welib-0.0.2/welib/wt_theory/Theodorsen/fTheodorsenFarWakeParams.m` & `welib-1.0.0/welib/wt_theory/matlab/Theodorsen/fTheodorsenFarWakeParams.m`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,112 +1,112 @@
-function [ w_bar l_bar Rw Expansion vz_bar ] = fTheodorsenFarWakeParams(CT,lambda,nB,varargin)
-% -- NOTES
-% Find farwake parameters that correspond to a set of rotor parameter
-% See also fGoldsteinFarWakeParams
-% As far as I remember they give quite different results
-% Most of the stuff commented below are from the goldstein equivalent function
-
-% -- Usage
-% See in CirculationForCanonicalWTSimulation....
-% Should be as well in CompareWakeShape..
-
-% -- INPUT/OUTPUT
-% Remember vz_bar and ExpFactor are given relative to Radius!
-% varargin is for Algo used in Expansion factor
-
-
-% if nB==3
-%     load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
-% else
-%     error('dsf');
-% end
-bGoOptimal=0;
-% if(~isempty(varargin))
-%     bGoOptimal=1;
-% end
-% CT_opt=interp1(vLambda,vCT,lambda);
-% if CT > CT_opt
-%     warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
-%     bGoOptimal=1;
-% end
-% 
-% if bGoOptimal
-%     w_bar=interp1(vLambda,[1 vw],lambda);
-%     CP_out=interp1(vLambda,[0 vCP],lambda);
-%     CT_out=CT_opt;
-%     l_bar=(1-w_bar/2)/lambda;
-%     vr=linspace(0,1,100);  
-%     G=fGoldsteinFactor( l_bar,nB,vr);
-% else
-if isempty(varargin)
-    Algo.nr=100;
-    Algo.ntheta=3000;
-    Algo.z_inf=100;
-    Algo.bWT=1;
-else
-    Algo=varargin{1};
-end
-
-% initial guess
-R=1;
-Rw=1.01;
-
-
-w_bar0=(1-sqrt(1-CT))*0.6;  %1D momentum result used as a first guess with a 0.6 factor as rule of thumb..
-cs_new=CT*R^2/Rw^2;
-cs_old=0;
-tic(); 
-fprintf('Iterating till converging on right expansion...\n');
-cpt=0;
-while abs(cs_old-cs_new)/max(cs_old,cs_new) >5*10^-3
-    opts=optimset('TolX',1e-3);
-%     opts=optimset('TolX',1e-3,'Display','iter');
-    tic(); 
-    fprintf('Iterating to find Theodorsen far wake parameters...');
-    % find the w_bar which gives the right cs
-    % the if below is useless if the optimization help is commented
-    if(cpt==0)
-        [w_bar,~,~,Output]=fzero(@(w) cs_new-fcs(w,lambda,nB,R,Rw),w_bar0,opts);
-    else
-        %let's try to help the optimzation
-%          s=Output.message;
-%          keyboard
-% %          [~,xstart,xend]=strread(s,'%s[%f,%f]');
-%         [xstart,xend]=strread(s,'Zero found in the interval [%f, %f]');
-%          if(Rw_old<Rw)
-%              %the lower bound will be smaller
-% %              xstart=xstart-0.05*xstart*Rw_old/Rw;
-%              xstart=xstart*Rw_old/Rw*0.99;
-%          else
-%              %the upper bound should probably be increase
-%             xend=xend*Rw/Rw_old*1.01;
-%         end
-%         disp([xstart xend]);
-        [w_bar,~,~,Output]=fzero(@(w) cs_new-fcs(w,lambda,nB,R,Rw),w_bar0,opts);
-    end
-    l_bar=1/lambda*(1-w_bar)*R/Rw;
-    fprintf('Done,w_bar: %.3f  - l_bar %.3f \t',w_bar,l_bar),toc();
-    % now find the expansion....
-    vx=linspace(0,1,Algo.nr); 
-    [ K kappa eps_over_k epsz cs cp ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-    [ vz_bar ExpFactor ] = fTheodorsenExpansion(l_bar,vx,K,nB,Algo.z_inf,Algo.ntheta,Algo.bWT );
-    Rw_old=Rw;
-    Rw=ExpFactor(end)*cs*R+R;
-    cs_new=CT*R^2/Rw^2;
-    cs_old=cs;
-    w_bar0=w_bar;
-    
-    Expansion=1+ExpFactor*CT;
-
-    fprintf('CT design %.2f - cs found %.3f - following cs %.3f - Rw found %.3f\n',CT,cs_old,cs_new,Rw); 
-    cpt=cpt+1;
-end
-fprintf('Done after %d iterations:\t',cpt),toc();
-
-
-
-function [cs  l_bar G]= fcs(w_bar,lambda,nB,R,Rw)
-vx=linspace(0,1,100);  
-l_bar=1/lambda*(1-w_bar)*R/Rw;
-[ G kappa eps_over_k epsz cs ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
-
-
+function [ w_bar l_bar Rw Expansion vz_bar ] = fTheodorsenFarWakeParams(CT,lambda,nB,varargin)
+% -- NOTES
+% Find farwake parameters that correspond to a set of rotor parameter
+% See also fGoldsteinFarWakeParams
+% As far as I remember they give quite different results
+% Most of the stuff commented below are from the goldstein equivalent function
+
+% -- Usage
+% See in CirculationForCanonicalWTSimulation....
+% Should be as well in CompareWakeShape..
+
+% -- INPUT/OUTPUT
+% Remember vz_bar and ExpFactor are given relative to Radius!
+% varargin is for Algo used in Expansion factor
+
+
+% if nB==3
+%     load('OptimalCTGoldsteinB3.mat');% vw vCP vCT -> values obtained by iteration such that w_bar = 2/3
+% else
+%     error('dsf');
+% end
+bGoOptimal=0;
+% if(~isempty(varargin))
+%     bGoOptimal=1;
+% end
+% CT_opt=interp1(vLambda,vCT,lambda);
+% if CT > CT_opt
+%     warning(sprintf('there is no hope to reach this CT ofr this lambda, the max CT is %.2f',CT_opt));
+%     bGoOptimal=1;
+% end
+% 
+% if bGoOptimal
+%     w_bar=interp1(vLambda,[1 vw],lambda);
+%     CP_out=interp1(vLambda,[0 vCP],lambda);
+%     CT_out=CT_opt;
+%     l_bar=(1-w_bar/2)/lambda;
+%     vr=linspace(0,1,100);  
+%     G=fGoldsteinFactor( l_bar,nB,vr);
+% else
+if isempty(varargin)
+    Algo.nr=100;
+    Algo.ntheta=3000;
+    Algo.z_inf=100;
+    Algo.bWT=1;
+else
+    Algo=varargin{1};
+end
+
+% initial guess
+R=1;
+Rw=1.01;
+
+
+w_bar0=(1-sqrt(1-CT))*0.6;  %1D momentum result used as a first guess with a 0.6 factor as rule of thumb..
+cs_new=CT*R^2/Rw^2;
+cs_old=0;
+tic(); 
+fprintf('Iterating till converging on right expansion...\n');
+cpt=0;
+while abs(cs_old-cs_new)/max(cs_old,cs_new) >5*10^-3
+    opts=optimset('TolX',1e-3);
+%     opts=optimset('TolX',1e-3,'Display','iter');
+    tic(); 
+    fprintf('Iterating to find Theodorsen far wake parameters...');
+    % find the w_bar which gives the right cs
+    % the if below is useless if the optimization help is commented
+    if(cpt==0)
+        [w_bar,~,~,Output]=fzero(@(w) cs_new-fcs(w,lambda,nB,R,Rw),w_bar0,opts);
+    else
+        %let's try to help the optimzation
+%          s=Output.message;
+%          keyboard
+% %          [~,xstart,xend]=strread(s,'%s[%f,%f]');
+%         [xstart,xend]=strread(s,'Zero found in the interval [%f, %f]');
+%          if(Rw_old<Rw)
+%              %the lower bound will be smaller
+% %              xstart=xstart-0.05*xstart*Rw_old/Rw;
+%              xstart=xstart*Rw_old/Rw*0.99;
+%          else
+%              %the upper bound should probably be increase
+%             xend=xend*Rw/Rw_old*1.01;
+%         end
+%         disp([xstart xend]);
+        [w_bar,~,~,Output]=fzero(@(w) cs_new-fcs(w,lambda,nB,R,Rw),w_bar0,opts);
+    end
+    l_bar=1/lambda*(1-w_bar)*R/Rw;
+    fprintf('Done,w_bar: %.3f  - l_bar %.3f \t',w_bar,l_bar),toc();
+    % now find the expansion....
+    vx=linspace(0,1,Algo.nr); 
+    [ K kappa eps_over_k epsz cs cp ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+    [ vz_bar ExpFactor ] = fTheodorsenExpansion(l_bar,vx,K,nB,Algo.z_inf,Algo.ntheta,Algo.bWT );
+    Rw_old=Rw;
+    Rw=ExpFactor(end)*cs*R+R;
+    cs_new=CT*R^2/Rw^2;
+    cs_old=cs;
+    w_bar0=w_bar;
+    
+    Expansion=1+ExpFactor*CT;
+
+    fprintf('CT design %.2f - cs found %.3f - following cs %.3f - Rw found %.3f\n',CT,cs_old,cs_new,Rw); 
+    cpt=cpt+1;
+end
+fprintf('Done after %d iterations:\t',cpt),toc();
+
+
+
+function [cs  l_bar G]= fcs(w_bar,lambda,nB,R,Rw)
+vx=linspace(0,1,100);  
+l_bar=1/lambda*(1-w_bar)*R/Rw;
+[ G kappa eps_over_k epsz cs ] = fTheodorsenAtOperatingPoint( l_bar, nB, vx ,w_bar );
+
+
```

### Comparing `welib-0.0.2/welib/wt_theory/VortexCylinder/VortexCylinder.m` & `welib-1.0.0/welib/wt_theory/matlab/VortexCylinder/VortexCylinder.m`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,181 +1,181 @@
-InitClear
-%% for r=0
-U0=10;
-Uw=0.5*U0;
-gamma=U0-Uw;
-R=10;
-D=2*R;
-nD=2.5;
-r=0;
-x=linspace(-nD*D,nD*D,100);
-ui=x*0;
-for i=1:length(x)
-    F = @(z0,psi)R*gamma/(4*pi)*(R-r*cos(psi))./((x(i)-z0).^2 + R^2+r^2-2*r*R*cos(psi)).^(3/2);
-    ui(i) = dblquad(F,0,100*D,0,2*pi);
-end
-U=U0-ui;
-
-
-
-
-figure
-subplot(2,1,1)
-hold on
-ylim([0,2])
-plot(x/D,ui/((U0-Uw)/2),'k','LineWidth',2)
-plot([0 0],[0 2] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
-set(gca,'YTick',0:1:2)
-[~,~] = format_ticks(gca,'',{'0','U_i','2U_i'})
-%set(gca,'YTickLabel',{'0','Ui','2Ui'})
-xlim([-2.5 2.5])
-grid on 
-box on
-%xlabel('z/D [.]')
-%ylabel('u_i(z) [m/s]')
-
-% 
- subplot(2,1,2)
-hold on
-ylim([0,1])
-xlim([-2.5 2.5])
-plot(x/D,(U-Uw)/(U0-Uw),'k','LineWidth',2)
-plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
-set(gca,'YTick',0:0.5:1)
-set(gca,'YTickLabel',{'U_w','U','U_0'});
-grid on 
-box on
-[~,~] = format_ticks(gca,'',{'U_w','U','U_0'});
-text(-0.1,-0.2,'z/D [.]')
-%xlabel('')
-%ylabel('U [m/s]')
-title('VortexCylinderUUi')
-
-
-
-%% For one r
-U0=10;
-Uw=1/3*U0;
-gamma=U0-Uw;
-R=40;
-D=2*R;
-nD=2.5;
-r=0*R;
-z=linspace(-nD*D,nD*D,20);
-ui=z*0;
-
-
-for i=1:length(z)
-    F = @(z0,psi)R*gamma/(4*pi)*(R-r*cos(psi))./((z(i)-z0).^2 + R^2+r^2-2*r*R*cos(psi)).^(3/2);
-    ui(i) = dblquad(F,0,100*D,0,2*pi);
-end
-U=U0-ui;
-
-
-figure
-hold on
-ylim([0,1])
-plot(z/D,U/U0,'k','LineWidth',2)
-plot([min(z) max(z)]/D,[2/3 2/3] ,'k-.')
-plot([min(z) max(z)]/D,[1/3 1/3] ,'k-.')
-plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
-grid on 
-box on
-xlabel('z/D [.]')
-ylabel('U/U_0 [.]')
-title('VortexCylinderU')
-
-%% For lot's of r 3D
-U0=10;
-Uw=1/3*U0;
-gamma=U0-Uw;
-R=40;
-D=2*R;
-nD=2.5;
-r=0*R;
-z=linspace(-nD*D,nD*D,40);
-r=linspace(0,2*R,30);
-ui=zeros(length(r),length(z));
-
-for k=1:length(r)
-    for i=1:length(z)
-        F = @(z0,psi)R*gamma/(4*pi)*(R-r(k)*cos(psi))./((z(i)-z0).^2 + R^2+r(k)^2-2*r(k)*R*cos(psi)).^(3/2);
-        ui(k,i) = dblquad(F,0,100*D,0,2*pi);
-    end
-end
-U=U0-ui;
-%%
-[X,Y]=meshgrid(z/D,r/R);
-surf(X,Y,U/U0,'FaceColor','none')
-xlabel('z/D [.]')
-ylabel('r/R [.]')
-zlabel('U/U_0 [.]')
-xlim([-2.5 2.5])
-zlim([-0 1.5])
-ylim([0 2])
-title('Vortex Cylinder 3D')
-setFigureTitle(0)
-%% for  3r in  2D
-U0=10;
-Uw=1/3*U0;
-gamma=U0-Uw;
-R=40;
-D=2*R;
-nD=2.5;
-r=0*R;
-z=linspace(-nD*D,nD*D,40);
-r=[0 0.5 0.9]*R;
-ui=zeros(length(r),length(z));
-
-for k=1:length(r)
-    for i=1:length(z)
-        F = @(z0,psi)R*gamma/(4*pi)*(R-r(k)*cos(psi))./((z(i)-z0).^2 + R^2+r(k)^2-2*r(k)*R*cos(psi)).^(3/2);
-        ui(k,i) = dblquad(F,0,100*D,0,2*pi);
-    end
-end
-U=U0-ui;
-
-figure
-hold on
-ylim([0,1])
-plot(z/D,U(1,:)/U0,'k','LineWidth',2)
-plot(z/D,U(2,:)/U0,'k--','LineWidth',2)
-plot(z/D,U(3,:)/U0,'k-.','LineWidth',2)
-plot([min(z) max(z)]/D,[2/3 2/3] ,'k-.')
-plot([min(z) max(z)]/D,[1/3 1/3] ,'k-.')
-plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
-grid on 
-box on
-legend('r/R=0','r/R=0.5','r/R=0.9')
-xlabel('z/D [.]')
-ylabel('U/U_0 [.]')
-title('VortexCylinderU')
-
-
-%% At the rotor (z=0)
-U0=10;
-Uw=1/3*U0;
-gamma=U0-Uw;
-R=40;
-D=2*R;
-nD=2.5;
-r=linspace(0,0.8*R,20);
-z=0
-ui=r*0;
-
-
-for i=1:length(r)
-    F = @(z0,psi)R*gamma/(4*pi)*(R-r(i)*cos(psi))./((z0).^2 + R^2+r(i)^2-2*r(i)*R*cos(psi)).^(3/2);
-    ui(i) = dblquad(F,0,100*D,0,2*pi);
-end
-U=U0-ui;
-
-
-figure
-hold on
-%ylim([0,1])
-plot(r/R,U/U0,'k','LineWidth',2)
-grid on 
-box on
-xlabel('r/R [.]')
-ylabel('U/U_0 [.]')
+InitClear
+%% for r=0
+U0=10;
+Uw=0.5*U0;
+gamma=U0-Uw;
+R=10;
+D=2*R;
+nD=2.5;
+r=0;
+x=linspace(-nD*D,nD*D,100);
+ui=x*0;
+for i=1:length(x)
+    F = @(z0,psi)R*gamma/(4*pi)*(R-r*cos(psi))./((x(i)-z0).^2 + R^2+r^2-2*r*R*cos(psi)).^(3/2);
+    ui(i) = dblquad(F,0,100*D,0,2*pi);
+end
+U=U0-ui;
+
+
+
+
+figure
+subplot(2,1,1)
+hold on
+ylim([0,2])
+plot(x/D,ui/((U0-Uw)/2),'k','LineWidth',2)
+plot([0 0],[0 2] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
+set(gca,'YTick',0:1:2)
+[~,~] = format_ticks(gca,'',{'0','U_i','2U_i'})
+%set(gca,'YTickLabel',{'0','Ui','2Ui'})
+xlim([-2.5 2.5])
+grid on 
+box on
+%xlabel('z/D [.]')
+%ylabel('u_i(z) [m/s]')
+
+% 
+ subplot(2,1,2)
+hold on
+ylim([0,1])
+xlim([-2.5 2.5])
+plot(x/D,(U-Uw)/(U0-Uw),'k','LineWidth',2)
+plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
+set(gca,'YTick',0:0.5:1)
+set(gca,'YTickLabel',{'U_w','U','U_0'});
+grid on 
+box on
+[~,~] = format_ticks(gca,'',{'U_w','U','U_0'});
+text(-0.1,-0.2,'z/D [.]')
+%xlabel('')
+%ylabel('U [m/s]')
+title('VortexCylinderUUi')
+
+
+
+%% For one r
+U0=10;
+Uw=1/3*U0;
+gamma=U0-Uw;
+R=40;
+D=2*R;
+nD=2.5;
+r=0*R;
+z=linspace(-nD*D,nD*D,20);
+ui=z*0;
+
+
+for i=1:length(z)
+    F = @(z0,psi)R*gamma/(4*pi)*(R-r*cos(psi))./((z(i)-z0).^2 + R^2+r^2-2*r*R*cos(psi)).^(3/2);
+    ui(i) = dblquad(F,0,100*D,0,2*pi);
+end
+U=U0-ui;
+
+
+figure
+hold on
+ylim([0,1])
+plot(z/D,U/U0,'k','LineWidth',2)
+plot([min(z) max(z)]/D,[2/3 2/3] ,'k-.')
+plot([min(z) max(z)]/D,[1/3 1/3] ,'k-.')
+plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
+grid on 
+box on
+xlabel('z/D [.]')
+ylabel('U/U_0 [.]')
+title('VortexCylinderU')
+
+%% For lot's of r 3D
+U0=10;
+Uw=1/3*U0;
+gamma=U0-Uw;
+R=40;
+D=2*R;
+nD=2.5;
+r=0*R;
+z=linspace(-nD*D,nD*D,40);
+r=linspace(0,2*R,30);
+ui=zeros(length(r),length(z));
+
+for k=1:length(r)
+    for i=1:length(z)
+        F = @(z0,psi)R*gamma/(4*pi)*(R-r(k)*cos(psi))./((z(i)-z0).^2 + R^2+r(k)^2-2*r(k)*R*cos(psi)).^(3/2);
+        ui(k,i) = dblquad(F,0,100*D,0,2*pi);
+    end
+end
+U=U0-ui;
+%%
+[X,Y]=meshgrid(z/D,r/R);
+surf(X,Y,U/U0,'FaceColor','none')
+xlabel('z/D [.]')
+ylabel('r/R [.]')
+zlabel('U/U_0 [.]')
+xlim([-2.5 2.5])
+zlim([-0 1.5])
+ylim([0 2])
+title('Vortex Cylinder 3D')
+setFigureTitle(0)
+%% for  3r in  2D
+U0=10;
+Uw=1/3*U0;
+gamma=U0-Uw;
+R=40;
+D=2*R;
+nD=2.5;
+r=0*R;
+z=linspace(-nD*D,nD*D,40);
+r=[0 0.5 0.9]*R;
+ui=zeros(length(r),length(z));
+
+for k=1:length(r)
+    for i=1:length(z)
+        F = @(z0,psi)R*gamma/(4*pi)*(R-r(k)*cos(psi))./((z(i)-z0).^2 + R^2+r(k)^2-2*r(k)*R*cos(psi)).^(3/2);
+        ui(k,i) = dblquad(F,0,100*D,0,2*pi);
+    end
+end
+U=U0-ui;
+
+figure
+hold on
+ylim([0,1])
+plot(z/D,U(1,:)/U0,'k','LineWidth',2)
+plot(z/D,U(2,:)/U0,'k--','LineWidth',2)
+plot(z/D,U(3,:)/U0,'k-.','LineWidth',2)
+plot([min(z) max(z)]/D,[2/3 2/3] ,'k-.')
+plot([min(z) max(z)]/D,[1/3 1/3] ,'k-.')
+plot([0 0],[0 1] ,'-','Color',[0.5,0.5,0.5],'LineWidth',2)
+grid on 
+box on
+legend('r/R=0','r/R=0.5','r/R=0.9')
+xlabel('z/D [.]')
+ylabel('U/U_0 [.]')
+title('VortexCylinderU')
+
+
+%% At the rotor (z=0)
+U0=10;
+Uw=1/3*U0;
+gamma=U0-Uw;
+R=40;
+D=2*R;
+nD=2.5;
+r=linspace(0,0.8*R,20);
+z=0
+ui=r*0;
+
+
+for i=1:length(r)
+    F = @(z0,psi)R*gamma/(4*pi)*(R-r(i)*cos(psi))./((z0).^2 + R^2+r(i)^2-2*r(i)*R*cos(psi)).^(3/2);
+    ui(i) = dblquad(F,0,100*D,0,2*pi);
+end
+U=U0-ui;
+
+
+figure
+hold on
+%ylim([0,1])
+plot(r/R,U/U0,'k','LineWidth',2)
+grid on 
+box on
+xlabel('r/R [.]')
+ylabel('U/U_0 [.]')
 title('VortexCylinderURotor')
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_CodesAndTheory.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_CodesAndTheory.m`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,158 +1,158 @@
-% This script looks only at the wake expansion (it doens' look at tip-losses or BEM etc.)
-% There are some nasty copy paste to look at different CT
-
-%% 
-InitClear;
-PATH.EXPANSION='/work/lib/WTTheory/Expansion/';
-require('THEODORSEN','v01');
-% require('EXPANSION','');
-require('OPTIMCIRC','v00');
-require('WTlib','v03');
-require('VC_LIB_MAT','v04');
-require('BEM','v03');
-require('VL','v03');
-require('VC_LIB_C','v04');
-% require('VC_LIB_C','v01_siemens');
-
-
-% setFigurePath({'./' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
-setFigurePath({'./' , '/work/publications/phdthesis/figsdump/'});
-
-vCT=[0.35 0.65 0.8];
-% vCT=0.85;
-% vCT=0.737;
-for iCT=1:length(vCT)
-    CT=vCT(iCT);
-    vz_bar=linspace(0,30,100); %z/R !!! not z/D
-
-    Algo.nr=100;
-    Algo.ntheta=length(vz_bar); % dangerous
-    Algo.z_inf=max(vz_bar);     % dangerous
-    Algo.bWT=1;
-%     lambda=15
-    lambda=7.06;
-    nB=3;
-    U0=10;
-    R=1;
-
-    [ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_bar);
-    [ exp_rathmann ] = fExpansionRathmann(CT,vz_bar);
-    [ exp_theodorsen ] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT, Algo); % !!!! mean a, that's not really good
-    [ exp_vortexrings ] = fExpansionVortexRings(CT,vz_bar); 
-
-
-    %%
-    figure,hold all,grid on,box on
-    plot(vz_bar/2,exp_franksen,'')
-    plot(vz_bar/2,exp_rathmann,'')
-    plot(vz_bar/2,exp_theodorsen,'k')
-    plot(vz_bar/2,exp_vortexrings,'k--')
-    k=0.05;m=1;
-    plot(vz_bar/2,k*(vz_bar/2).^m+1,'','Color',[0.4 0.4 0.4])
-    xlim([0 6])
-    xlabel('z/D [.]')
-    ylabel('r/R [.]')
-    title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
-    legend('Franksen','Rathman','Theodorsen','Vortex Cylinder','k x^m')
-
-
-    %% BEM run to then use local value for Mac's prescribed wake
-    vx=linspace(0,R,100);
-    [w_bar l_bar CTgold G]=fGoldsteinFarWakeParams(CT,lambda,nB);
-
-    [ WT ]   = fInitWT( 'SB1' ,'xblade',PATH.DATA_WT);
-    WT.Rotor.cone=0; WT.Nacelle.tilt=0;
-    WT.Sources.Rotor.chord=WT.Sources.Rotor.chord/WT.Rotor.R;
-    WT.Sources.Rotor.twist=WT.Sources.Rotor.twist*0+20;
-    WT.Rotor.R=R; WT.Rotor.rhub=0.00; WT.Rotor.BladeLength=R; WT.Rotor.R_coned=R; WT.Rotor.SweptArea=pi*R^2;
-    WT.Sources.Rotor.r=linspace(WT.Rotor.rhub,R,length(WT.Sources.Rotor.r));
-    Scale=60/WT.Rotor.R;
-    [ WT ] = fSetRotorGrid(40,WT);
-    % BEM Algorithm init
-    [ Algo ] = fInitAlgo();
-    Algo.bPrescribedGamma=1;
-    RPM=lambda*U0/WT.Rotor.R*60/2/pi;
-    [ Sim ]  = fInitSim( WT , [U0 RPM -10]);
-    [ Wind ] = fInitWind( Sim );
-    Gamma=G/nB*w_bar*U0*2*pi*R*l_bar;
-    Algo.r_PrescribedGamma=vx;
-    Algo.PrescribedGamma=Gamma;
-    [ BEM ] = fRunBEM(WT,Sim,Wind,Algo);
-    fprintf('CT asked %.2f - CT gold %.2f - CT BEM %.2f (Gold circ)\n',CT,CTgold,BEM.CT);
-
-    %% Mac's prescribed wake
-    Algo.WakeExpansionMethod='Mac';
-    Algo.WakeType='Prescribed';
-    zcoord=linspace(0,max(vz_bar),10000);
-    Algo.Viscous.t=zeros(1,length(zcoord)+1);
-    algo.Viscous.Model=0;
-    rhelix=(WT.Rotor.rfull(1:end-1)+WT.Rotor.rfull(2:end))/2;
-    [ Wake ] = fGeometryPrescribedWake(lambda,nB,U0,R,rhelix, BEM.r, BEM.Gamma, BEM.CTloc , BEM.a, BEM.aprime , zcoord ,[],[],[], [],[],[], Algo );
-
-    %% Free wake with prescribed Gamma
-%     [ Sim ]  = fInitSim( WT , [U0 lambda*U0/R*60/(2*pi) 0] );
-%     [ Wind ] = fInitWind( Sim );
-    % Main Parameters
-    Algo.VL.bCorrector=0; % !!!!
-    Algo.bSteady=0;
-    Algo.bPrescribedGamma=1;
-    Algo.bPlots=0; 
-    Algo.bExport=0; 
-    Algo.bInspectResults=0;
-    % Resolution parameters
-    Algo.n_span=6;    % number of PANELS spanwise
-    Algo.n_chord=1;    % number of PANELS chordwise
-    Algo.nRev=30;
-    Algo.nPhi=15;
-    Algo.Viscous.Model=4;    %!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-    Algo.Viscous.delta=1;
-    Algo.Viscous.t0=0.5;
-    Algo.Viscous.delta_wake=0.0001;
-    Algo.Viscous.delta_bound=0.001;
-    % Running with function
-%     [ VL WTout ] = fRunVL(WT,Sim,Wind,Algo );
-
-
-
-% 
-    %% wake extremities
-    % find wake extremities for mac's prescribed wake
-    MI=getIntervals(Wake.X(:,end)>1);
-    I=[];
-    for i=1:size(MI,1)
-        [~,ii]=max(Wake.X(MI(i,2):MI(i,3),end));
-        I=[I MI(i,2)+ii-1];
-    end
-    %% Free wake - extremities
-%     % find wake extremities for free wake, because of rollup I look at several of them
-%     Ztip={};
-%     Xtip={};
-%     for iend=0:2
-%         MI=getIntervals(VL.Wake.X(:,end-iend)>1);
-%         Ifree=[];
-%         for i=1:size(MI,1)
-%             [~,ii]=max(VL.Wake.X(MI(i,2):MI(i,3),end-iend));
-%             Ifree=[Ifree MI(i,2)+ii-1];
-%         end
-%         Ztip{iend+1}=VL.Wake.Z(Ifree,end-iend);
-%         Xtip{iend+1}=VL.Wake.X(Ifree,end-iend);
-%     end
-% 
-
-    %% plotting
-    figure(12),hold all,grid on,box on
-    plot(vz_bar/2,exp_theodorsen,'-','Color',fColrs(iCT))
-    plot(vz_bar/2,exp_vortexrings,'--','Color',fColrs(iCT))
-    plot(Wake.Z(I,end)/2,Wake.X(I,end),'+','Color',fColrs(iCT));
-%     for iend=1:length(Ztip)
-%         plot(Ztip{iend}/2,Xtip{iend},'o','Color',fColrs(iend))
-%     end
-    xlim([0 4])
-    ylim([1 1.3])
-    xlabel('z/D [.]')
-    legend('Theodorsen','Vortex Cylinder','Prescribed Wake','Location','North')
-    title('WakeExpansionTheodorsenCylinderMac')
-    ylabel('r/R [.]')
-    %%
-end
-%%
+% This script looks only at the wake expansion (it doens' look at tip-losses or BEM etc.)
+% There are some nasty copy paste to look at different CT
+
+%% 
+InitClear;
+PATH.EXPANSION='/work/lib/WTTheory/Expansion/';
+require('THEODORSEN','v01');
+% require('EXPANSION','');
+require('OPTIMCIRC','v00');
+require('WTlib','v03');
+require('VC_LIB_MAT','v04');
+require('BEM','v03');
+require('VL','v03');
+require('VC_LIB_C','v04');
+% require('VC_LIB_C','v01_siemens');
+
+
+% setFigurePath({'./' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
+setFigurePath({'./' , '/work/publications/phdthesis/figsdump/'});
+
+vCT=[0.35 0.65 0.8];
+% vCT=0.85;
+% vCT=0.737;
+for iCT=1:length(vCT)
+    CT=vCT(iCT);
+    vz_bar=linspace(0,30,100); %z/R !!! not z/D
+
+    Algo.nr=100;
+    Algo.ntheta=length(vz_bar); % dangerous
+    Algo.z_inf=max(vz_bar);     % dangerous
+    Algo.bWT=1;
+%     lambda=15
+    lambda=7.06;
+    nB=3;
+    U0=10;
+    R=1;
+
+    [ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_bar);
+    [ exp_rathmann ] = fExpansionRathmann(CT,vz_bar);
+    [ exp_theodorsen ] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT, Algo); % !!!! mean a, that's not really good
+    [ exp_vortexrings ] = fExpansionVortexRings(CT,vz_bar); 
+
+
+    %%
+    figure,hold all,grid on,box on
+    plot(vz_bar/2,exp_franksen,'')
+    plot(vz_bar/2,exp_rathmann,'')
+    plot(vz_bar/2,exp_theodorsen,'k')
+    plot(vz_bar/2,exp_vortexrings,'k--')
+    k=0.05;m=1;
+    plot(vz_bar/2,k*(vz_bar/2).^m+1,'','Color',[0.4 0.4 0.4])
+    xlim([0 6])
+    xlabel('z/D [.]')
+    ylabel('r/R [.]')
+    title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
+    legend('Franksen','Rathman','Theodorsen','Vortex Cylinder','k x^m')
+
+
+    %% BEM run to then use local value for Mac's prescribed wake
+    vx=linspace(0,R,100);
+    [w_bar l_bar CTgold G]=fGoldsteinFarWakeParams(CT,lambda,nB);
+
+    [ WT ]   = fInitWT( 'SB1' ,'xblade',PATH.DATA_WT);
+    WT.Rotor.cone=0; WT.Nacelle.tilt=0;
+    WT.Sources.Rotor.chord=WT.Sources.Rotor.chord/WT.Rotor.R;
+    WT.Sources.Rotor.twist=WT.Sources.Rotor.twist*0+20;
+    WT.Rotor.R=R; WT.Rotor.rhub=0.00; WT.Rotor.BladeLength=R; WT.Rotor.R_coned=R; WT.Rotor.SweptArea=pi*R^2;
+    WT.Sources.Rotor.r=linspace(WT.Rotor.rhub,R,length(WT.Sources.Rotor.r));
+    Scale=60/WT.Rotor.R;
+    [ WT ] = fSetRotorGrid(40,WT);
+    % BEM Algorithm init
+    [ Algo ] = fInitAlgo();
+    Algo.bPrescribedGamma=1;
+    RPM=lambda*U0/WT.Rotor.R*60/2/pi;
+    [ Sim ]  = fInitSim( WT , [U0 RPM -10]);
+    [ Wind ] = fInitWind( Sim );
+    Gamma=G/nB*w_bar*U0*2*pi*R*l_bar;
+    Algo.r_PrescribedGamma=vx;
+    Algo.PrescribedGamma=Gamma;
+    [ BEM ] = fRunBEM(WT,Sim,Wind,Algo);
+    fprintf('CT asked %.2f - CT gold %.2f - CT BEM %.2f (Gold circ)\n',CT,CTgold,BEM.CT);
+
+    %% Mac's prescribed wake
+    Algo.WakeExpansionMethod='Mac';
+    Algo.WakeType='Prescribed';
+    zcoord=linspace(0,max(vz_bar),10000);
+    Algo.Viscous.t=zeros(1,length(zcoord)+1);
+    algo.Viscous.Model=0;
+    rhelix=(WT.Rotor.rfull(1:end-1)+WT.Rotor.rfull(2:end))/2;
+    [ Wake ] = fGeometryPrescribedWake(lambda,nB,U0,R,rhelix, BEM.r, BEM.Gamma, BEM.CTloc , BEM.a, BEM.aprime , zcoord ,[],[],[], [],[],[], Algo );
+
+    %% Free wake with prescribed Gamma
+%     [ Sim ]  = fInitSim( WT , [U0 lambda*U0/R*60/(2*pi) 0] );
+%     [ Wind ] = fInitWind( Sim );
+    % Main Parameters
+    Algo.VL.bCorrector=0; % !!!!
+    Algo.bSteady=0;
+    Algo.bPrescribedGamma=1;
+    Algo.bPlots=0; 
+    Algo.bExport=0; 
+    Algo.bInspectResults=0;
+    % Resolution parameters
+    Algo.n_span=6;    % number of PANELS spanwise
+    Algo.n_chord=1;    % number of PANELS chordwise
+    Algo.nRev=30;
+    Algo.nPhi=15;
+    Algo.Viscous.Model=4;    %!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+    Algo.Viscous.delta=1;
+    Algo.Viscous.t0=0.5;
+    Algo.Viscous.delta_wake=0.0001;
+    Algo.Viscous.delta_bound=0.001;
+    % Running with function
+%     [ VL WTout ] = fRunVL(WT,Sim,Wind,Algo );
+
+
+
+% 
+    %% wake extremities
+    % find wake extremities for mac's prescribed wake
+    MI=getIntervals(Wake.X(:,end)>1);
+    I=[];
+    for i=1:size(MI,1)
+        [~,ii]=max(Wake.X(MI(i,2):MI(i,3),end));
+        I=[I MI(i,2)+ii-1];
+    end
+    %% Free wake - extremities
+%     % find wake extremities for free wake, because of rollup I look at several of them
+%     Ztip={};
+%     Xtip={};
+%     for iend=0:2
+%         MI=getIntervals(VL.Wake.X(:,end-iend)>1);
+%         Ifree=[];
+%         for i=1:size(MI,1)
+%             [~,ii]=max(VL.Wake.X(MI(i,2):MI(i,3),end-iend));
+%             Ifree=[Ifree MI(i,2)+ii-1];
+%         end
+%         Ztip{iend+1}=VL.Wake.Z(Ifree,end-iend);
+%         Xtip{iend+1}=VL.Wake.X(Ifree,end-iend);
+%     end
+% 
+
+    %% plotting
+    figure(12),hold all,grid on,box on
+    plot(vz_bar/2,exp_theodorsen,'-','Color',fColrs(iCT))
+    plot(vz_bar/2,exp_vortexrings,'--','Color',fColrs(iCT))
+    plot(Wake.Z(I,end)/2,Wake.X(I,end),'+','Color',fColrs(iCT));
+%     for iend=1:length(Ztip)
+%         plot(Ztip{iend}/2,Xtip{iend},'o','Color',fColrs(iend))
+%     end
+    xlim([0 4])
+    ylim([1 1.3])
+    xlabel('z/D [.]')
+    legend('Theodorsen','Vortex Cylinder','Prescribed Wake','Location','North')
+    title('WakeExpansionTheodorsenCylinderMac')
+    ylabel('r/R [.]')
+    %%
+end
+%%
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_ForEwan.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_ForEwan.m`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,58 +1,58 @@
-%%  Init
-InitClear;
-PATH.EXPANSION='/work/lib/WTTheory/WakeExpansion/';
-require('EXPANSION','');
-
-require('THEODORSEN','v02');
-require('OPTIMCIRC','v01_nomex');
-
-
-%% Params
-CT=0.737;
-lambda=7.06;
-nB=3;
-
-U0=10;% should not matter
-R=1;  % should not matter
-
-%% Different models
-vz_barb=linspace(0,30,100); %z/R !!! not z/D
-
-[ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_barb);
-[ exp_rathmann ] = fExpansionRathmann(CT,vz_barb);
-[ exp_vortexrings ] = fExpansionVortexRings(CT,vz_barb); 
-
-%% Theodorsen - Not iterative
-[ exp_theodorsen_notiterative vz_bar] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT); % !!!! mean a, that's not really good
-
-%% Theodorsen iterative
-[w_bar l_bar Rw exp_theodorsen_iterative]=fTheodorsenFarWakeParams(CT,lambda,nB);
-
-%% Theodorsen Using Goldstein's(Okulov) far wake param... Needs lower level interface fTheodorsenExpansion
-[w_bar_gold l_bar_gold CTout G ]=fGoldsteinFarWakeParams(CT,lambda,nB);
-Algo.nr=100;
-Algo.ntheta=3000;
-Algo.z_inf=100;
-Algo.bWT=1;
-vx=linspace(0,1,Algo.nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
-[ ~, ExpFactor] = fTheodorsenExpansion(l_bar_gold,vx,G,nB,Algo.z_inf,Algo.ntheta,Algo.bWT );
-exp_theodorsen_goldstein=1+ExpFactor*CT;
-
-
-%% Plot
-k=0.05;m=1;
-figure,hold all,grid on,box on
-plot(vz_barb/2,exp_franksen,'--')
-plot(vz_barb/2,exp_rathmann,'--')
-plot(vz_barb/2,exp_vortexrings,'k--')
-% plot(vz_barb/2,k*(vz_barb/2).^m+1,'','Color',[0.4 0.4 0.4])
-
-plot(vz_bar/2,exp_theodorsen_notiterative,'k')
-plot(vz_bar/2,exp_theodorsen_iterative,'g')
-plot(vz_bar/2,exp_theodorsen_goldstein,'m')
-xlim([0 6])
-xlabel('z/D [.]')
-ylabel('r/R [.]')
-title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
-legend('Franksen','Rathman','Vortex Cylinder','Theodorsen not iterative','Theodorsen iterative','Theodorsen Goldstein','Location','EastOutside')
-
+%%  Init
+InitClear;
+PATH.EXPANSION='/work/lib/WTTheory/WakeExpansion/';
+require('EXPANSION','');
+
+require('THEODORSEN','v02');
+require('OPTIMCIRC','v01_nomex');
+
+
+%% Params
+CT=0.737;
+lambda=7.06;
+nB=3;
+
+U0=10;% should not matter
+R=1;  % should not matter
+
+%% Different models
+vz_barb=linspace(0,30,100); %z/R !!! not z/D
+
+[ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_barb);
+[ exp_rathmann ] = fExpansionRathmann(CT,vz_barb);
+[ exp_vortexrings ] = fExpansionVortexRings(CT,vz_barb); 
+
+%% Theodorsen - Not iterative
+[ exp_theodorsen_notiterative vz_bar] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT); % !!!! mean a, that's not really good
+
+%% Theodorsen iterative
+[w_bar l_bar Rw exp_theodorsen_iterative]=fTheodorsenFarWakeParams(CT,lambda,nB);
+
+%% Theodorsen Using Goldstein's(Okulov) far wake param... Needs lower level interface fTheodorsenExpansion
+[w_bar_gold l_bar_gold CTout G ]=fGoldsteinFarWakeParams(CT,lambda,nB);
+Algo.nr=100;
+Algo.ntheta=3000;
+Algo.z_inf=100;
+Algo.bWT=1;
+vx=linspace(0,1,Algo.nr);  % Note: there is a singularity at x=1, see the denominator of y1 for theta=tau=0. The denaminator cancels out. Normal, vortex singularity 
+[ ~, ExpFactor] = fTheodorsenExpansion(l_bar_gold,vx,G,nB,Algo.z_inf,Algo.ntheta,Algo.bWT );
+exp_theodorsen_goldstein=1+ExpFactor*CT;
+
+
+%% Plot
+k=0.05;m=1;
+figure,hold all,grid on,box on
+plot(vz_barb/2,exp_franksen,'--')
+plot(vz_barb/2,exp_rathmann,'--')
+plot(vz_barb/2,exp_vortexrings,'k--')
+% plot(vz_barb/2,k*(vz_barb/2).^m+1,'','Color',[0.4 0.4 0.4])
+
+plot(vz_bar/2,exp_theodorsen_notiterative,'k')
+plot(vz_bar/2,exp_theodorsen_iterative,'g')
+plot(vz_bar/2,exp_theodorsen_goldstein,'m')
+xlim([0 6])
+xlabel('z/D [.]')
+ylabel('r/R [.]')
+title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
+legend('Franksen','Rathman','Vortex Cylinder','Theodorsen not iterative','Theodorsen iterative','Theodorsen Goldstein','Location','EastOutside')
+
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/MainComparisons_TheoryOnly.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/MainComparisons_TheoryOnly.m`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-% This script looks only at the wake expansion (it doens' look at tip-losses or BEM etc.)
-% There are some nasty copy paste to look at different CT
-
-%% 
-InitClear;
-PATH.EXPANSION='/work/lib/WTTheory/WakeExpansion/';
-require('EXPANSION','');
-
-require('THEODORSEN','v01');
-require('OPTIMCIRC','v01_nomex');
-
-
-setFigurePath({'./' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
-
-vCT=[0.35 0.65 0.8];
-vCT=0.737;
-for CT=vCT
-    vz_bar=linspace(0,30,100); %z/R !!! not z/D
-
-    Algo.nr=100;
-    Algo.ntheta=length(vz_bar); % dangerous
-    Algo.z_inf=max(vz_bar);     % dangerous
-    Algo.bWT=1;
-%     lambda=15;
-    lambda=7.06;
-    nB=3;
-    U0=10;
-    R=1;
-
-    [ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_bar);
-    [ exp_rathmann ] = fExpansionRathmann(CT,vz_bar);
-    [ exp_theodorsen ] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT, Algo); % !!!! mean a, that's not really good
-    [ exp_vortexrings ] = fExpansionVortexRings(CT,vz_bar); 
-
-
-    %%
-    figure,hold all,grid on,box on
-    plot(vz_bar/2,exp_franksen,'')
-    plot(vz_bar/2,exp_rathmann,'')
-    plot(vz_bar/2,exp_theodorsen,'k')
-    plot(vz_bar/2,exp_vortexrings,'k--')
-    k=0.05;m=1;
-    plot(vz_bar/2,k*(vz_bar/2).^m+1,'','Color',[0.4 0.4 0.4])
-    xlim([0 6])
-    xlabel('z/D [.]')
-    ylabel('r/R [.]')
-    title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
-    legend('Franksen','Rathman','Theodorsen','Vortex Cylinder','k x^m')
-
-end
-%%
+% This script looks only at the wake expansion (it doens' look at tip-losses or BEM etc.)
+% There are some nasty copy paste to look at different CT
+
+%% 
+InitClear;
+PATH.EXPANSION='/work/lib/WTTheory/WakeExpansion/';
+require('EXPANSION','');
+
+require('THEODORSEN','v01');
+require('OPTIMCIRC','v01_nomex');
+
+
+setFigurePath({'./' , '/work/publications/articles/2012-tiploss-theoretical/figs/'});
+
+vCT=[0.35 0.65 0.8];
+vCT=0.737;
+for CT=vCT
+    vz_bar=linspace(0,30,100); %z/R !!! not z/D
+
+    Algo.nr=100;
+    Algo.ntheta=length(vz_bar); % dangerous
+    Algo.z_inf=max(vz_bar);     % dangerous
+    Algo.bWT=1;
+%     lambda=15;
+    lambda=7.06;
+    nB=3;
+    U0=10;
+    R=1;
+
+    [ exp_franksen ] = fExpansionFranksen(CT,0.7,2,vz_bar);
+    [ exp_rathmann ] = fExpansionRathmann(CT,vz_bar);
+    [ exp_theodorsen ] = fTheodorsenExpansionWrap(lambda,nB,U0,R,1/2*(1-sqrt(1-CT)),CT, Algo); % !!!! mean a, that's not really good
+    [ exp_vortexrings ] = fExpansionVortexRings(CT,vz_bar); 
+
+
+    %%
+    figure,hold all,grid on,box on
+    plot(vz_bar/2,exp_franksen,'')
+    plot(vz_bar/2,exp_rathmann,'')
+    plot(vz_bar/2,exp_theodorsen,'k')
+    plot(vz_bar/2,exp_vortexrings,'k--')
+    k=0.05;m=1;
+    plot(vz_bar/2,k*(vz_bar/2).^m+1,'','Color',[0.4 0.4 0.4])
+    xlim([0 6])
+    xlabel('z/D [.]')
+    ylabel('r/R [.]')
+    title(sprintf('WakeExpansionDifferentTheoriesCT%2d',CT*100));
+    legend('Franksen','Rathman','Theodorsen','Vortex Cylinder','k x^m')
+
+end
+%%
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionFranksen.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionFranksen.m`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,24 +1,24 @@
-function [Expansion vz_bar]=fExpansionFranksen(CT,alpha,k,varargin)
-% the variable argument provides vz_bar (distance behind the rotor in terms of rotor radius);
-% Remeber dimensionsless with radius not diameters!!!!!!
-
-% default values are alpha =0.7 and k=2
-
-if(nargin==1)
-    vz_bar=linspace(0,20,100);
-else
-    vz_bar=varargin{1};
-end
-if(vz_bar(1)<0)
-    error('that should not be');
-end
-
-a=(1-sqrt(1-CT));  % check with article!!!!!! they use a weird a!!!!
-beta=(1-a/2)/(1-a);
-
-Expansion = (beta.^(k/2)+1/2*alpha*vz_bar).^(1/k);
-
-if vz_bar(1)==0
-    Expansion(1)=1;
-end
-
+function [Expansion vz_bar]=fExpansionFranksen(CT,alpha,k,varargin)
+% the variable argument provides vz_bar (distance behind the rotor in terms of rotor radius);
+% Remeber dimensionsless with radius not diameters!!!!!!
+
+% default values are alpha =0.7 and k=2
+
+if(nargin==1)
+    vz_bar=linspace(0,20,100);
+else
+    vz_bar=varargin{1};
+end
+if(vz_bar(1)<0)
+    error('that should not be');
+end
+
+a=(1-sqrt(1-CT));  % check with article!!!!!! they use a weird a!!!!
+beta=(1-a/2)/(1-a);
+
+Expansion = (beta.^(k/2)+1/2*alpha*vz_bar).^(1/k);
+
+if vz_bar(1)==0
+    Expansion(1)=1;
+end
+
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionRathmann.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionRathmann.m`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-function [Expansion vz_bar]=fExpansionRathmann(CT,varargin)
-% the variable argument provides vz_bar (distance behind the rotor in terms of rotor radius);
-% Remeber dimensionsless with radius not diameters!!!!!!
-
-if(nargin==1)
-    vz_bar=linspace(0,20,100);
-else
-    vz_bar=varargin{1};
-end
-if(vz_bar(1)<0)
-    error('that should not be');
-end
-
-a=(1-sqrt(1-CT));  % check with article!!!!!! they use a weird a!!!!
-beta=(1-a/2)/(1-a);
-alpha=0.7;
-Expansion = max(beta^(1/2),(1/2*alpha*vz_bar).^(1/2));
-
-if vz_bar(1)==0
-    Expansion(1)=1;
-end
-
+function [Expansion vz_bar]=fExpansionRathmann(CT,varargin)
+% the variable argument provides vz_bar (distance behind the rotor in terms of rotor radius);
+% Remeber dimensionsless with radius not diameters!!!!!!
+
+if(nargin==1)
+    vz_bar=linspace(0,20,100);
+else
+    vz_bar=varargin{1};
+end
+if(vz_bar(1)<0)
+    error('that should not be');
+end
+
+a=(1-sqrt(1-CT));  % check with article!!!!!! they use a weird a!!!!
+beta=(1-a/2)/(1-a);
+alpha=0.7;
+Expansion = max(beta^(1/2),(1/2*alpha*vz_bar).^(1/2));
+
+if vz_bar(1)==0
+    Expansion(1)=1;
+end
+
```

### Comparing `welib-0.0.2/welib/wt_theory/WakeExpansion/fExpansionVortexRings.m` & `welib-1.0.0/welib/wt_theory/matlab/WakeExpansion/fExpansionVortexRings.m`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/DEBUG.py` & `welib-1.0.0/welib/yams/DEBUG.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/FNSB_FAST.py` & `welib-1.0.0/welib/yams/TNSB_FAST.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,93 +7,91 @@
 from welib.yams.yams import FASTBeamBody, RigidBody
 from welib.yams.utils import *
 from welib.yams.TNSB import manual_assembly, auto_assembly
 
 import welib.weio as weio
 
 # --------------------------------------------------------------------------------}
-# --- Creating a FNSB model from a FAST model
+# --- Creating a TNSB model from a FAST model
 # --------------------------------------------------------------------------------{
-# TODO TODO TODO
-# TODO TODO TODO HARMONIZE WITH WINDTURBINE.PY AND TNSB..
-# TODO TODO TODO
-def FASTmodel2FNSB(FST_file,shapes_sub=[0,4], nShapes_bld=0,nSpan_sub=101,nSpan_bld=61,bHubMass=1,bNacMass=1,bBldMass=1,DEBUG=False,main_axis ='x',bStiffening=True, assembly='manual', q=None, bTiltBeforeNac=False,
+def FASTmodel2TNSB(ED_or_FST_file,nB=3,nShapes_twr=2, nShapes_bld=0,nSpan_twr=None, nSpan_bld=None, bHubMass=1,bNacMass=1,bBldMass=1,DEBUG=False,main_axis ='x',bStiffening=True, assembly='manual', q=None, bTiltBeforeNac=False,
         spanFrom0=True, # TODO for legacy, we keep this for now..
-        bladeMassExpected=None
-):
+        bladeMassExpected=None,
+        gravity=None,
+        algo='' # TODO replace with OpenFAST
+        ):
     """ 
     Returns the following structure
-      Fnd :  BeamBody
+      Twr :  BeamBody
       Shft:  RigiBody
       Nac :  RigidBody
       Blds:  List of BeamBodies
 
       MM, KK, DD : mass, stiffness and damping matrix of full system
 
-      shapes_sub: 0:ux, 1:uy, 2:uz, 3:vx, 4:vy, 5:vz 
-              E.g. for surge and pitch (ux, vy): [0,4]
-
 
       NOTE/TODO: compare this with "windturbine.py"
     """
     
+    nDOF = 1 + nShapes_twr + nShapes_bld * nB # +1 for Shaft
+    if q is None:
+        q = np.zeros((nDOF,1)) # TODO, full account of q not done
 
-    # --- Read fst file
-    ext=os.path.splitext(FST_file)[1]
-    if ext.lower()!='.fst':
-        raise Exception('FNSB requires a fst file as input')
-
-    FST=weio.read(FST_file)
-    rootdir = os.path.dirname(FST_file)
-    EDfile = os.path.join(rootdir,FST['EDFile'].strip('"')).replace('\\','/')
-    subfile = os.path.join(rootdir,FST['SubFile'].strip('"')).replace('\\','/')
+    # --- Input data from ED file
+    ext=os.path.splitext(ED_or_FST_file)[1]
+    if ext.lower()=='.fst':
+        FST=weio.read(ED_or_FST_file)
+        rootdir = os.path.dirname(ED_or_FST_file)
+        EDfile = os.path.join(rootdir,FST['EDFile'].strip('"')).replace('\\','/')
+        if gravity is None:
+            try:
+                gravity = FST['gravity']
+            except:
+                pass
+    else:
+        EDfile=ED_or_FST_file
 
     # Reading elastodyn file
     ED      = weio.read(EDfile)
     rootdir = os.path.dirname(EDfile)
     bldfile = os.path.join(rootdir,ED['BldFile(1)'].strip('"')).replace('\\','/')
     twrfile = os.path.join(rootdir,ED['TwrFile'].strip('"')).replace('\\','/')
-    #twr     = weio.read(twrfile)
+    twr     = weio.read(twrfile)
     bld     = weio.read(bldfile)
+    if gravity is None:
+        gravity = ED['gravity'] # Old interface, method above should work, so raise Exception here
 
-    # Reading SubDyn file
-    sub     = weio.read(subfile)
-    nShapes_sub = len(shapes_sub)
-    graph = sub.toGraph() # NOTE: this is repeated in bodies.py...
-    graph.divideElements(sub['NDiv'])
-    graph.sortNodesBy('z')
-    df = graph.nodalDataFrame()
-    zBot = np.min(df['z'])
-    zTop = np.max(df['z'])
-    RayleighCoeff=None
-    DampMat=None
-    if sub['GuyanDampMod']==1:
-        # Rayleigh Damping
-        RayleighCoeff=sub['RayleighDamp']
-        #if RayleighCoeff[0]==0:
-        #    damp_zeta=omega*RayleighCoeff[1]/2. 
-    elif sub['GuyanDampMod']==2:
-        # Full matrix
-        DampMat = sub['GuyanDampMatrix']
-        DampMat=DampMat[np.ix_(shapes,shapes)]
-
-
+    # --- Default arguments
+    if nSpan_twr is None:
+        if algo=='OpenFAST':
+            nSpan_twr = ED['TwrNodes']
+            print('[INFO] TNSB_FAST: Using number of tower nodes ({}) from OpenFAST Input file.'.format(nSpan_twr))
+        else:
+            nSpan_twr=101
+            print('[INFO] TNSB_FAST: Using default of tower nodes ({}).'.format(nSpan_twr))
+    else:
+        if algo=='OpenFAST':
+            print('[INFO] TNSB_FAST: Using user-specified number of tower nodes ({}).'.format(nSpan_twr))
+    if nSpan_bld is None:
+        if algo=='OpenFAST':
+            nSpan_bld = ED['BldNodes']
+            print('[INFO] TNSB_FAST: Using number of blade nodes ({}) from OpenFAST Input file.'.format(nSpan_bld))
+        else:
+            nSpan_bld=61
+            print('[INFO] TNSB_FAST: Using default number of blade nodes ({}).'.format(nSpan_bld))
+    else:
+        if algo=='OpenFAST':
+            print('[INFO] TNSB_FAST: Using user-specified number of blade nodes ({}).'.format(nSpan_bld))
 
-    nB = ED['NumBl']
-    nDOF = 1 + nShapes_sub + nShapes_bld * nB # +1 for Shaft
-    if q is None:
-        q = np.zeros((nDOF,1)) # TODO, full account of q not done
 
     ## --- Strucural and geometrical Inputs
     if main_axis=='x':
         theta_tilt_y= ED['ShftTilt']*np.pi/180 # NOTE: tilt has wrong orientation in FAST
         theta_cone_y=-ED['Precone(1)']*np.pi/180
-        r_EF_inE    = np.array([[zBot]                         ,[0],[0]]) 
-        r_ET_inE    = np.array([[ED['TowerBsHt']]              ,[0],[0]]) 
-        r_FT_inF    = np.array([[ED['TowerBsHt']-zBot]         ,[0],[0]]) 
+        r_ET_inE    = np.array([[ED['TowerBsHt']]              ,[0],[0]]) # NOTE: could be used to get hub height
         r_TN_inT    = np.array([[ED['TowerHt']-ED['TowerBsHt']],[0],[0]])
         if bTiltBeforeNac:
             raise NotImplementedError()
             R_NS0 = np.eye(3)
             R_TN0 = R_y(theta_tilt_y)
         else:
             R_NS0 = R_y(theta_tilt_y)
@@ -101,19 +99,16 @@
             r_NGnac_inN = np.array([[ED['NacCMzn']]                ,[0],[ED['NacCMxn']]] )
             r_NS_inN    = np.array([[ED['Twr2Shft']]               ,[0],[0]]) # S on tower axis
         r_SR_inS    = np.array([[0]                            ,[0],[ED['OverHang']]] ) # S and R 
         r_SGhub_inS = np.array([[0]                            ,[0],[ED['OverHang']+ED['HubCM']]]   ) # 
     elif main_axis=='z':
         theta_tilt_y=-ED['ShftTilt']*np.pi/180 # NOTE: tilt has wrong orientation in FAST
         theta_cone_y= ED['Precone(1)']*np.pi/180
-
-        r_EF_inE    = np.array([[0], [0] , [zBot]  ]) 
-        r_ET_inE    = np.array([[0], [0], [ED['TowerBsHt']]        ]) 
-        r_FT_inF    = np.array([[0], [0], [ED['TowerBsHt']-zBot]   ]) 
-        r_TN_inT    = np.array([[0], [0],[ED['TowerHt']-ED['TowerBsHt']] ])
+        r_ET_inE    = np.array([[0]                         ,[0],[ED['TowerBsHt']]               ]) # NOTE: could be used to get hub height
+        r_TN_inT    = np.array([[0]                         ,[0],[ED['TowerHt']-ED['TowerBsHt']] ])
         if bTiltBeforeNac:
             raise NotImplementedError()
             R_NS0 = np.eye(3)
             R_TN0 = R_y(theta_tilt_y)
         else:
             R_NS0 = R_y(theta_tilt_y)
             R_TN0 = np.eye(3)
@@ -123,71 +118,75 @@
         r_SGhub_inS = np.array([[ED['OverHang']+ED['HubCM']],[0],[0]]                             ) # 
 
     r_RGhub_inS = - r_SR_inS + r_SGhub_inS
 
 
     M_hub   = ED['HubMass']*bHubMass
     M_nac   = ED['NacMass'] *bNacMass
+    M_yaw   = ED['YawBrMass']
     IR_hub = np.zeros((3,3))
     I0_nac=np.zeros((3,3)) 
 
+	# TODO, here hub and Gen put together...
     if main_axis=='x':
         IR_hub[2,2] = ED['HubIner'] + ED['GenIner']*ED['GBRatio']**2
         I0_nac[0,0]= ED['NacYIner']
     elif main_axis=='z':
         IR_hub[0,0] = ED['HubIner'] + ED['GenIner']*ED['GBRatio']**2
         I0_nac[2,2] = ED['NacYIner']
     IR_hub = IR_hub * bHubMass
     I0_nac = I0_nac * bNacMass
 
     # Inertias not at COG...
-    IG_hub = translateInertiaMatrix(IR_hub, M_hub, np.array([0,0,0]), r_RGhub_inS)
+    IG_hub = translateInertiaMatrix(I_A=IR_hub, Mass=M_hub, r_BG=np.array([0,0,0]), r_AG=r_RGhub_inS)
     IG_nac = translateInertiaMatrixToCOG(I0_nac, M_nac, r_NGnac_inN)
 
     # --------------------------------------------------------------------------------}
     ## --- Creating bodies
     # --------------------------------------------------------------------------------{
     # Bld
     Blds=[]
-    Blds.append(FASTBeamBody('blade',ED,bld,Mtop=0,nShapes=nShapes_bld, nSpan=nSpan_bld, main_axis=main_axis, spanFrom0=spanFrom0, massExpected=bladeMassExpected)) # NOTE: legacy spanfrom0
+    Blds.append(FASTBeamBody('blade',ED,bld,Mtop=0,nShapes=nShapes_bld, nSpan=nSpan_bld, main_axis=main_axis, spanFrom0=spanFrom0, massExpected=bladeMassExpected, gravity=gravity, algo=algo)) # NOTE: legacy spanfrom0
     Blds[0].MM *=bBldMass
     for iB in range(nB-1):
         Blds.append(copy.deepcopy(Blds[0]))
     # IMPORTANT FOR RNA set R_b2g
     for iB,B in enumerate(Blds):
         B.name='bld'+str(iB+1)
         psi_B= -iB*2*np.pi/len(Blds) 
         if main_axis=='x':
             R_SB = R_z(0*np.pi + psi_B) # TODO psi offset and psi0
         elif main_axis=='z':
             R_SB = R_x(0*np.pi + psi_B) # TODO psi0
         R_SB = np.dot(R_SB, R_y(ED['PreCone({})'.format(iB+1)]*np.pi/180)) # blade2shaft
         B.R_b2g= R_SB
 
-    # ShaftHub Body 
-    Sft=RigidBody('ShaftHub',M_hub,IG_hub,r_SGhub_inS);
+    # ShaftHubGen Body  NOTE: generator!!! This is ugly
+    Sft=RigidBody('ShaftHubGen',M_hub,IG_hub,r_SGhub_inS)
+    
+    # Gen only
+    Gen=RigidBody('Gen', 0, IG_hub, r_SGhub_inS)
+
+    #print('>>> IG_hub',IG_hub, r_SGhub_inS)
     # Nacelle Body
     Nac=RigidBody('Nacelle',M_nac,IG_nac,r_NGnac_inN);
-    M_rot= sum([B.Mass for B in Blds])
-    M_RNA= M_rot + Sft.Mass + Nac.Mass;
-    # Substructure Body
-    Fnd = FASTBeamBody('substructure', ED, sub, Mtop=M_RNA, shapes=shapes_sub, nSpan=nSpan_sub, main_axis=main_axis, bStiffening=bStiffening)
-    #print(Fnd)
-    #print('Fnd MM\n',Fnd.MM[6:,6:])
-    #print('Fnd KK\n',Fnd.KK[6:,6:])
-    # HACK here because doesn't handle this for now
-    if sub['GuyanDampMod']==1:
-        Fnd.DD[6:,6:] = Fnd.MM[6:,6:]*RayleighCoeff[0] + Fnd.KK[6:,6:]*RayleighCoeff[1] 
-
-
+    # Yaw Bearing # TODO TODO TODO
+    Yaw=RigidBody('YawBearing',M_yaw,(0,0,0),(0,0,0));
+    if M_yaw>0:
+        print('[WARN] TODO YAW BEARING MASS NOT FULLY IMPLEMENTED IN TNSB')
+
+    M_rot= sum([B.mass for B in Blds])
+    M_RNA= M_rot + Sft.mass + Nac.mass + Yaw.mass
+    # Tower Body
+    Twr = FASTBeamBody('tower',ED,twr,Mtop=M_RNA,nShapes=nShapes_twr, nSpan=nSpan_twr, main_axis=main_axis,bStiffening=bStiffening, gravity=gravity, algo=algo)
     #print('Stiffnening', bStiffening)
     #print('Ttw.KKg   \n', Twr.KKg[6:,6:])
     if DEBUG:
-        print('HubMass',Sft.Mass)
-        print('NacMass',Nac.Mass)
+        print('HubMass',Sft.mass)
+        print('NacMass',Nac.mass)
         print('RotMass',M_rot)
         print('RNAMass',M_RNA)
         print('IG_hub')
         print(IG_hub)
         print('IG_nac')
         print(IG_nac)
         print('I_gen_LSS', ED['GenIner']*ED['GBRatio']**2)
@@ -195,56 +194,41 @@
         print('I_rot_LSS', nB*Blds[0].MM[5,5])
         print('I_tot_LSS', nB*Blds[0].MM[5,5]+ED['hubIner']+ED['GenIner']*ED['GBRatio']**2) 
         print('r_NGnac_inN',r_NGnac_inN.T)
         print('r_SGhub_inS',r_SGhub_inS.T)
     # --------------------------------------------------------------------------------}
     # --- Assembly 
     # --------------------------------------------------------------------------------{
-    r_ET_inE = r_EF_inE
-    r_TN_inT = r_FT_inF+r_TN_inT # assume that F and T are in system E here
-
     if assembly=='manual':
-        Struct = manual_assembly(Fnd,Nac,Sft,Blds,q,r_ET_inE,r_TN_inT,r_NS_inN,r_SR_inS,main_axis=main_axis,theta_tilt_y=theta_tilt_y,theta_cone_y=theta_cone_y,DEBUG=DEBUG, bTiltBeforeNac=bTiltBeforeNac)
+        Struct = manual_assembly(Twr,Yaw,Nac,Gen,Sft,Blds,q,r_ET_inE,r_TN_inT,r_NS_inN,r_SR_inS,main_axis=main_axis,theta_tilt_y=theta_tilt_y,theta_cone_y=theta_cone_y,DEBUG=DEBUG, bTiltBeforeNac=bTiltBeforeNac)
     else:
-        Struct = auto_assembly(Fnd,Nac,Sft,Blds,q,r_ET_inE,r_TN_inT,r_NS_inN,r_SR_inS,main_axis=main_axis,theta_tilt_y=theta_tilt_y,theta_cone_y=theta_cone_y,DEBUG=DEBUG, bTiltBeforeNac=bTiltBeforeNac)
+        Struct = auto_assembly(Twr,Yaw,Nac,Gen,Sft,Blds,q,r_ET_inE,r_TN_inT,r_NS_inN,r_SR_inS,main_axis=main_axis,theta_tilt_y=theta_tilt_y,theta_cone_y=theta_cone_y,DEBUG=DEBUG, bTiltBeforeNac=bTiltBeforeNac)
 
     # --- Initial conditions
     omega_init = ED['RotSpeed']*2*np.pi/60 # rad/s
     psi_init   = ED['Azimuth']*np.pi/180   # rad
     FA_init    = ED['TTDspFA']
-    Surge_init = ED['PtfmSurge']
-    Sway_init  = ED['PtfmSway']
-    Heave_init = ED['PtfmHeave']
-    Roll_init  = ED['PtfmRoll'] *np.pi/180
-    Pitch_init = ED['PtfmPitch']*np.pi/180
-    Yaw_init   = ED['PtfmYaw']*np.pi/180
-
     iPsi     = Struct.iPsi
     nDOFMech = len(Struct.MM)
     q_init   = np.zeros(2*nDOFMech) # x2, state space
 
-    if nShapes_sub>0:
-        sub_init = np.array([Surge_init, Sway_init, Heave_init, Roll_init, Pitch_init, Yaw_init])
-        for iDOF,iDOFfull in enumerate(shapes_sub):
-            q_init[iDOF] = sub_init[iDOFfull]
+    if nShapes_twr>0:
+        q_init[0] = FA_init
 
     q_init[iPsi]          = psi_init
     q_init[nDOFMech+iPsi] = omega_init
 
     Struct.q_init = q_init
     if DEBUG:
         print('Initial conditions:')
         print(q_init)
 
     # --- Useful data
     Struct.ED=ED
 
-    Struct.DampMat=DampMat
-    Struct.RayleighCoeff=RayleighCoeff
-
 
     return Struct
 
 
 # --------------------------------------------------------------------------------}
 # --- Read Relevant fields from an outb file 
 # --------------------------------------------------------------------------------{
@@ -263,20 +247,20 @@
     q[[0]]= 0          # Twr 1
 #     q[[1]]=0.1        # Twr 2
 #     q[[2]]=0*np.pi/4. # psi
 
     np.set_printoptions(linewidth=500)
     assembly='auto'
     main_axis='z'
-    #StructA= FASTmodel2TNSB('', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
+    #StructA= FASTmodel2TNSB('../data/NREL5MW_ED.dat', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
     StructA= FASTmodel2TNSB('examples/_F0T2RNA/Spar_ED_ForED.dat', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
     assembly='manual'
 #     assembly='auto'
 #     main_axis='x'
-#     #StructM= FASTmodel2TNSB('', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
+#     #StructM= FASTmodel2TNSB('../data/NREL5MW_ED.dat', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
     StructM= FASTmodel2TNSB('examples/_F0T2RNA/Spar_ED_ForED.dat', nShapes_twr=nShapes_twr,nShapes_bld=nShapes_bld, DEBUG=False, assembly=assembly , q=q, main_axis=main_axis, bStiffening=bStiffening)
 #     print('------------------')
     from scipy.linalg import block_diag
 #     print('RR')
     RR = np.eye(3)
 #     RR = np.zeros((3,3))
 #     RR[0,2]=1 # send z to x
```

### Comparing `welib-0.0.2/welib/yams/README.md` & `welib-1.0.0/welib/yams/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/TNSB.py` & `welib-1.0.0/welib/yams/TNSB.py`

 * *Files 3% similar despite different names*

```diff
@@ -155,18 +155,18 @@
         Fisrt linearization: assumes the sum of alpha_y small
         """
         if (s.nShapes_twr!=1):
             raise NotImplementedError('Number of shape function not 1')
         if s.main_axis=='x':
             raise NotImplementedError('Main axis along x')
 
-        rhoN_x = s.r_NGrna_inN[0,0]
-        rhoN_z = s.r_NGrna_inN[2,0]
-        rNR_x  = s.r_NR_inN[0,0]
-        rNR_z  = s.r_NR_inN[2,0]
+        rhoN_x = s.r_NGrna_inN.flatten()[0]
+        rhoN_z = s.r_NGrna_inN.flatten()[2]
+        rNR_x  = s.r_NR_inN.flatten()[0]
+        rNR_z  = s.r_NR_inN.flatten()[2]
         g      = s.gravity
         ux1c   = s.Twr.Bhat_x_bc[1,0]
         vy1c   = s.Twr.Bhat_t_bc[1,0]  # Bhat_t_bc[1,j]= self.PhiV[j][0,iNode]
 
         GF  =   T*cos(s.theta_tilt) 
         if bFull:
             GF += - T* vy1c * sin(s.theta_tilt) * x[0]
@@ -190,18 +190,18 @@
         print('Origin N :',s.Nac.r_O.T)
         print('Origin R :',s.Blds[0].r_O.T)
         print('Origin S :',s.Sft.r_O.T)
 
     def print_RNA(s):
         print('----------------- RNA ---------------------------------------')
         print('M_RNA      ', s.M_RNA)
-        print('r_NGrna_inN',s.r_NGrna_inN.T)
-        print('     r_NGnac_inN ',s.r_NGnac_inN.T , 'M_nac',s.Nac.mass)
-        print('     r_NGhub_inN ',s.r_NGhub_inN.T , 'M_hub',s.Sft.mass)
-        print('     r_NGrot_inN ',s.r_NGrot_inN.T , 'M_rot',s.M_rot)
+        print('r_NGrna_inN', np.asarray(s.r_NGrna_inN).flatten())
+        print('     r_NGnac_inN ',np.asarray(s.r_NGnac_inN).flatten(), 'M_nac',s.Nac.mass)
+        print('     r_NGhub_inN ',np.asarray(s.r_NGhub_inN).flatten(), 'M_hub',s.Sft.mass)
+        print('     r_NGrot_inN ',np.asarray(s.r_NGrot_inN).flatten(), 'M_rot',s.M_rot)
 
     def print_couplings(s):
         print('---------------Couplings ---------------------------------------')
         print('Constant: (Bhat_t)')
         print(s.Twr.Bhat_t_bc) # Constant
         print('Time varying:')
         print(s.Twr.alpha_couplings) # Time varying function of Twr.gzf
```

### Comparing `welib-0.0.2/welib/yams/bodies.py` & `welib-1.0.0/welib/yams/bodies.py`

 * *Files 8% similar despite different names*

```diff
@@ -27,16 +27,18 @@
 # --------------------------------------------------------------------------------{
 class Body(object):
     """
     Base class for rigid bodies and flexible bodies
     """
     def __init__(self, name='', r_O=[0,0,0], R_b2g=np.eye(3)):
         self.name = name
-        self._r_O   = np.asarray(r_O).ravel()
-        self._R_b2g = np.asarray(R_b2g)
+        self._r_O            = np.asarray(r_O).ravel()
+        self.pos_global_init = np.asarray(r_O).ravel()
+        self._R_b2g          = np.asarray(R_b2g)
+        self.R_b2g_init      = np.asarray(R_b2g)
 
         self._mass=None
         self.MM  = None # To be defined by children
 
     def __repr__(self):
         s='<Generic Body object>:\n'
         return s
@@ -151,15 +153,15 @@
 
     @property
     def masscenter_pos_global(self):
         """ return masscenter position from inertial frame """
         try:
             return self._r_O + self.R_b2g.dot(self._s_OG)
         except:
-            import pdb; pdb.set_trace()
+            raise Exception()
 
     @property    
     def inertia(self):
         """ Inertia at body origin in body coordinates"""
         return self.inertia_at([0,0,0])
 
     @property    
@@ -190,19 +192,21 @@
         """ Body mass matrix at a given point"""
         J = self.inertia_at(s_OP)
         s_PG = -np.asarray(s_OP)+ self._s_OG
         return rigidBodyMassMatrix(self.mass, J, s_PG) # TODO change interface
 
     def __repr__(self):
         s='<RigidBody object>:\n'.format(self.name)
+        s+=' - pos_global_init        {} (origin)\n'.format(np.around(self.pos_global_init,6))
         s+=' * pos_global:            {} (origin)\n'.format(np.around(self.pos_global,6))
         s+=' * masscenter:            {} (body frame)\n'.format(np.around(self.masscenter,6))
         s+=' * masscenter_pos_global: {} \n'.format(np.around(self.masscenter_pos_global,6))
         s+=' - mass:         {}\n'.format(self.mass)
         s+=' * R_b2g: \n {}\n'.format(self.R_b2g)
+        s+=' - R_b2g_init: \n {}\n'.format(self.R_b2g_init)
         s+=' * masscenter_inertia: \n{}\n'.format(np.around(self.masscenter_inertia,6))
         s+=' * inertia: (at origin)\n{}\n'.format(np.around(self.inertia,6))
         s+='Useful getters: inertia_at, mass_matrix\n'
         return s
 
     def combine(self, other, name=None, R_b2g=np.eye(3), r_O=None):
         """ Combine two rigid bodies and form a new rigid body
@@ -346,14 +350,26 @@
             #print('>>> WARNING, some stiffness matrix values are nan, replacing with 0')
             B.KK[np.isnan(B.KK)]=0
 
     def computeDampingMatrix(self, damp_zeta=None):
         self.DD = np.zeros((6+self.nf,6+self.nf))
         if damp_zeta is None:
             return
+        if self.int_method=='OpenFAST':
+            pass
+            # TODO TODO TODO
+            # Using KK0 and MM without top mass
+            #omegas = np.sqrt(np.diag(self.MM[6:,6:])/np.diag(self.KK0[6:,6:]))
+            #facts = 2*zeta/(omegas)
+            #print('TODO ')
+            #p['CTFA'][I,L] = ( 0.01*p['TwrFADmp'][L] )*p['KTFA'][I,L]/( np.pi*p['FreqTFA'][L,0] );
+            #p['CTSS'][I,L] = ( 0.01*p['TwrSSDmp'][L] )*p['KTSS'][I,L]/( np.pi*p['FreqTSS'][L,0] );
+            #xi = zeta*2*np.pi
+            #c  = xi * gm * om / np.pi
+            #self.DD[6+j,6+j] = c
         for j,zeta in enumerate(damp_zeta):
             gm = self.MM[6+j,6+j]
             gk = self.KK[6+j,6+j]
             if gk<0:
                 print('[WARN] Bodies: Shape function has negative stiffness (likely due to geometrical stiffening)')
                 om = 0
             else:
@@ -483,26 +499,39 @@
     def mass_matrix_at(self, s_OP):
         """ Body mass matrix at a ginve point"""
         J = self.inertia_at(s_OP)
         s_PG = -np.asarray(s_OP)+ self._s_OG
         return rigidBodyMassMatrix(self.mass, J, s_PG) # TODO change interface
 
 
-    def updateFlexibleKinematics(B, qe, qep):
+    def updateFlexibleKinematics(B, qe, qep, qepp=None):
         """ see yams.py updateKinematics"""
         # Deflections shape
         B.U  = np.zeros((3,B.nSpan));
         B.V  = np.zeros((3,B.nSpan));
         B.K  = np.zeros((3,B.nSpan));
-        B.UP = np.zeros((3,B.nSpan));
+        # Displacement fields
         for j in range(B.nf):
-            B.UP[0:3,:] +=  qep[j] * B.PhiU[j][0:3,:]
             B.U [0:3,:] +=  qe[j]  * B.PhiU[j][0:3,:]
             B.V [0:3,:] +=  qe[j]  * B.PhiV[j][0:3,:]
             B.K [0:3,:] +=  qe[j]  * B.PhiK[j][0:3,:]
+
+        # Velocities
+        B.UP = np.zeros((3,B.nSpan));
+        B.VP = np.zeros((3,B.nSpan));
+        for j in range(B.nf):
+            B.UP[0:3,:] +=  qep[j] * B.PhiU[j][0:3,:]
+            B.VP[0:3,:] +=  qep[j] * B.PhiV[j][0:3,:]
+        # Accelerations
+        if qepp is not None:
+            B.UPP = np.zeros((3,B.nSpan));
+            B.VPP = np.zeros((3,B.nSpan));
+            for j in range(B.nf):
+                B.UPP[0:3,:] +=  qepp[j] * B.PhiU[j][0:3,:]
+                B.VPP[0:3,:] +=  qepp[j] * B.PhiV[j][0:3,:]
         #B.V_tot=B.V+B.V0;
         #B.K_tot=B.K+B.K0;
         # Position of mean line
         #B.s_P=B.s_P0+B.U;
         # Position of COG TODO see yams.py for a better treatment
         B.s_G = B.s_G0 + B.U;
 
@@ -583,19 +612,22 @@
                 Bhat_t_bc[0,j]=-self.PhiV[j][1,iNode]
                 Bhat_t_bc[1,j]= self.PhiV[j][0,iNode]
                 Bhat_t_bc[2,j]= 0                     # torsion
         return Bhat_t_bc
 
     def __repr__(self):
         s='<BeamBody {} object>:\n'.format(self.name)
+        s+=' - pos_global_init        {} (origin)\n'.format(np.around(self.pos_global_init,6))
+        s+=' * pos_global:            {} (origin)\n'.format(np.around(self.pos_global,6))
         s+=' * pos_global:            {} (origin)\n'.format(np.around(self.pos_global,6))
         s+=' * masscenter:            {} (body frame)\n'.format(np.around(self.masscenter,6))
         s+=' * masscenter_pos_global: {} \n'.format(np.around(self.masscenter_pos_global,6))
         s+=' - mass:         {}\n'.format(self.mass)
         s+=' * length:      {}\n'.format(self.length)
+        s+=' - R_b2g_init: \n {}\n'.format(self.R_b2g_init)
         s+=' * R_b2g: \n {}\n'.format(self.R_b2g)
         s+=' * masscenter_inertia: \n{}\n'.format(np.around(self.masscenter_inertia,6))
         s+=' * inertia: (at origin)\n{}\n'.format(np.around(self.inertia,6))
         s+=' - Properties: s_span, m, EI, Mtop, PhiU, PhiV, PhiW\n'
         s+='               MM, KK, KK0, KKg, KKg_Mtop, KKg_self\n'
         s+='Usefull getters: inertia_at, mass_matrix_at, toRigidBody \n'
         return s
@@ -638,15 +670,18 @@
             for iishape, ishape in enumerate(shapes):
                 base=shapeBase[ishape]
                 coeff[0, iishape] = inp[base+'Sh(2)']
                 coeff[1, iishape] = inp[base+'Sh(3)']
                 coeff[2, iishape] = inp[base+'Sh(4)']
                 coeff[3, iishape] = inp[base+'Sh(5)']
                 coeff[4, iishape] = inp[base+'Sh(6)']
-            damp_zeta = np.array([ inp['BldFlDmp(1)'], inp['BldFlDmp(2)'], inp['BldEdDmp(1)']])/100
+            try:
+                damp_zeta = np.array([ inp['BldFlDmp(1)'], inp['BldFlDmp(2)'], inp['BldEdDmp(1)']])/100
+            except:
+                damp_zeta = np.array([ inp['BldFlDmp1'], inp['BldFlDmp2'], inp['BldEdDmp1']])/100
             damp_zeta=damp_zeta[shapes]
             mass_fact = inp['AdjBlMs']   # Factor to adjust blade mass density (-)
             prop      = inp['BldProp']  
             s_bar, m, EIFlp, EIEdg  =prop[:,0], prop[:,3], prop[:,4], prop[:,5]
             """
             BldBodyStartAtRoot    BldBodyAndSpanStartAtR     BldBodyAndSpanStartAtR
                   /                          /                       /
@@ -726,15 +761,15 @@
                     nSpan = ED['TwrNodes']
                     #print('Using nSpan = TwrNodes = ',nSpan)
 
         elif 'SttcSolve' in inp.keys():
             # --- Substructure / fnd
             from welib.fast.subdyn import SubDyn   
             name = 'fnd'
-            sd = SubDyn(sdData = inp)
+            sd = SubDyn(inp)
             p, damp_zeta, RayleighCoeff, DampMat = sd.toYAMSData(shapes)
             r_O   = p['r_O']
             R_b2g = p['R_b2g']
 
         else:
             print(inp.keys())
             raise Exception('Body type not supported, key `BldProp`, `TowProp`, or `SttcSolve` not found in file')
@@ -748,26 +783,25 @@
         if name in ['twr','bld']:
             m *= mass_fact
             p = GeneralizedMCK_PolyBeam(s_span, m, EIFlp, EIEdg, coeff, exp, damp_zeta, jxxG=jxxG, 
                     gravity=gravity, Mtop=Mtop, Omega=Omega, nSpan=nSpan, bAxialCorr=bAxialCorr, bStiffening=bStiffening, main_axis=main_axis, shapes=shapes, algo=algo, s_start=s_start)
 #             from welib.fast.elastodyn import bladeParameters
 #             pGM=p
 #             pED = bladeParameters(ED.filename)
-#             import pdb; pdb.set_trace()
 
 
         elif name in ['fnd']:
             pass
 
         else:
             raise NotImplementedError()
 
         # TODO TODO sort out span for Blades and HubRad 
-
         BeamBody.__init__(self, name, p['s_span'], p['s_P0'], p['m'], p['EI'], p['PhiU'], p['PhiV'], p['PhiK'], jxxG=p['jxxG'], 
                 s_min=p['s_min'], s_max=p['s_max'],
                 r_O = r_O, R_b2g=R_b2g,  # NOTE: this is lost in YAMS
                 damp_zeta=damp_zeta, RayleighCoeff=RayleighCoeff, DampMat=DampMat,
                 bAxialCorr=bAxialCorr, bOrth=name=='bld', gravity=gravity, Mtop=Mtop, Omega=Omega, bStiffening=bStiffening, main_axis=main_axis,
                 massExpected=massExpected,
                 int_method=int_method
                 )
+        self.shapes=shapes
```

### Comparing `welib-0.0.2/welib/yams/examples/Tower_MassMatrix_ShapeFunctions.py` & `welib-1.0.0/welib/yams/examples/Tower_MassMatrix_ShapeFunctions.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_numeric_recursive/Tower_SubBeams.py` & `welib-1.0.0/welib/yams/examples_numeric_recursive/Tower_SubBeams.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/L1_Top.py` & `welib-1.0.0/welib/yams/examples_symbolic_kane/L1_Top.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/L3_BladeModels.py` & `welib-1.0.0/welib/yams/examples_symbolic_kane/L3_BladeModels.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/L3_FXTXRNA_Simulation.py` & `welib-1.0.0/welib/yams/examples_symbolic_kane/L3_FXTXRNA_Simulation.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.py` & `welib-1.0.0/welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/L3_OneRigidBody_SparHydro.py` & `welib-1.0.0/welib/yams/examples_symbolic_kane/L3_OneRigidBody_SparHydro.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_kane/README.md` & `welib-1.0.0/welib/yams/examples_symbolic_kane/README.md`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/examples_symbolic_recursive/T1NRNA_yams_rec.py` & `welib-1.0.0/welib/yams/examples_symbolic_recursive/T1NRNA_yams_rec.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/flexibility.py` & `welib-1.0.0/welib/yams/flexibility.py`

 * *Files 4% similar despite different names*

```diff
@@ -6,16 +6,20 @@
 
 Reference:
      [1]: Flexible multibody dynamics using joint coordinates and the Rayleigh-Ritz approximation: the general framework behind and beyond Flex
      [2]: Standard Input Data of Flexible Members in Multibody Systems. Wallrapp 1993
 '''
 
 def skew(x):
+    """ Returns the skew symmetric matrix M, such that: cross(x,v) = M v 
+    [ 0, -z , y]
+    [ z,  0 ,-x]
+    [-y,  x , 0]
+    """
     x=np.asarray(x).ravel()
-    """ Returns the skew symmetric matrix M, such that: cross(x,v) = M v """
     return np.array([[0, -x[2], x[1]],[x[2],0,-x[0]],[-x[1],x[0],0]])
 
 def fcumtrapzlr(s_span, p):
     r""" Cumulative trapezoidal integration, flipped left-right 
     Useful to return the following:
          P(x) = \int_x^R p(r) dr
     """
@@ -1051,15 +1055,18 @@
 
     return p
 
 
 
 def beamSectionLoads1D(z, p, Ftop=0, Mtop=0, s=1, F_lumped=None, method='plin'):
     r"""
-    Integrate section loads along a beam based on inline and lumped loads and top load.
+    Integrate section loads along a beam based on inline loads, lumped loads and top load.
+    All the loads are assumed to be in the same direction.
+    NOTE: loads in other directions will actually affect the section loads in the current direction.
+          To account for the contributions from other components, see beamSectionLoads
 
     S(z) = int_z^L p(z') dz',   dS/dz = - p(z)
     M(z) =-int_z^L S(z') dz',   dM/dz = - S(z)
 
     Lumped forces can be inserted in the integral p= F_i \delta(x_i) with delta a Dirac
 
     Loads are integrated from "top" (z=L) to "bottom" (z=0)
@@ -1074,15 +1081,15 @@
     n=len(z)
     Fsec=np.zeros(n)
     Msec=np.zeros(n)
     if F_lumped is None:
         F_lumped=np.zeros(n)
 
     if method=='plin':
-        """ 
+        r""" 
         Analytical results assuming linear variation of p:
             p(z) = (p_i-p_{i-1}) \tilde{z} + p_{i-1}
         """
         Fsec[-1]=Ftop 
         Msec[-1]=Mtop 
         for i in np.arange(n-2,-1,-1): # TODO vectorize me
             i1      = i+1
@@ -1113,102 +1120,223 @@
 
     else:
         raise NotImplementedError()
 
     return Fsec, Msec
 
 
-
-def beamSectionLoads(x, xd, xdd, p_ext, F_top, M_top, s_span, PhiU, PhiV, m, 
-        M_lumped=None, m_hydro=None, a_ext=None, F_ext_lumped=None, corrections=1):
+def beamSectionLoads3D(p_ext, F_top, M_top, s_span, m, U=None, V=None, K=None, a_struct=None, 
+        M_lumped=None, m_hydro=None, a_ext=None, F_ext_lumped=None, 
+        corrections=1,
+        bSelfWeight=False,
+        main_axis='z'
+        ):
     """ 
+    p_ext: loads along the beam (without inertia), shape: (3 x n) [N/m]
+    F_top: beam top force , shape:(3) [N]
+    M_top: beam top moment, shape:(3) [N/m]
+    s_span: coordinates along the beam, shape:(n) [m]
+    m     : mass per length of the beam, shape:(n) [kg/m]
+    U     : Displacements along the span, shape:(3,n) [m]
+    V     : Slopes along the span       , shape:(3,n) [m/m]
+    K     : Curvature along the span    , shape:(3,n) [m/m/m]
+
+    M_lumped: lumped masses along the span: shape(n) [kg] (zero where no mass)
+    F_lumped: lumped forces along the span: shape(n) [N]  (zero where no force)
+
+    a_ext : external linear-acceleration vector, (0,0,-g) for gravity
     
     """
     # Main dimensions
-    shapeDisp = PhiU[0].shape
-    nf        = len(PhiU)
-    nSpan     = shapeDisp[1]
+    nSpan     = len(s_span)
 
     # Default values
     if m_hydro is None:
         m_hydro  = np.zeros(nSpan)           # added mass, only on wet surface of structure
     if M_lumped is None:
         M_lumped = np.zeros(nSpan)
     if F_ext_lumped is None:
         F_ext_lumped=np.zeros(nSpan)
 
     # Linear Translation, Velocity, Acceleration
-    U        = np.zeros(shapeDisp)
-    V        = np.zeros(shapeDisp)
-    #v_struct = np.zeros(shapeDisp)
-    a_struct = np.zeros(shapeDisp)
-    for j in np.arange(nf):
-        U         += x  [j] * PhiU[j] # Deflections
-        V         += x  [j] * PhiV[j] # Slopes
-        #v_struct  += xd [j] * PhiU[j]
-        a_struct  += xdd[j] * PhiU[j]
+    if U is None:
+        U = np.zeros((3,nSpan))
+    if V is None:
+        print('[WARN] yams: flexibility: beamSectionLoads3D: computing V as gradient U')
+        V = np.zeros((3,nSpan)) 
+        V[0,:] = np.gradient(U[0,:],  s_span, edge_order=2)
+        V[1,:] = np.gradient(U[1,:],  s_span, edge_order=2)
+        V[2,:] = np.gradient(U[2,:],  s_span, edge_order=2)
+        #from welib.mesh.gradient import gradient_regular
+        #V[0,:] = gradient_regular(U[0,:], dx=s_span[1]-s_span[0], order=4)
+        #V[1,:] = gradient_regular(U[1,:], dx=s_span[1]-s_span[0], order=4)
+        #V[2,:] = gradient_regular(U[2,:], dx=s_span[1]-s_span[0], order=4)
+    if K is None:
+        print('[WARN] yams: flexibility: beamSectionLoads3D: computing K as gradient U')
+        K = np.zeros((3,nSpan)) 
+        K[0,:] = np.gradient(V[0,:],  s_span, edge_order=2)
+        K[1,:] = np.gradient(V[1,:],  s_span, edge_order=2)
+        K[2,:] = np.gradient(V[2,:],  s_span, edge_order=2)
+    if a_struct is None:
+        a_struct = np.zeros((3,nSpan))
     if a_ext is not None:
         # Typically gravity
         # TODO Body root acceleration!
         a_struct[0,:] -= a_ext[0]
         a_struct[1,:] -= a_ext[1]
         a_struct[2,:] -= a_ext[2]
-
-    #print('a2',a_struct[0,:])
     # --- Inertial loads
     try:
         m_struct = m
         m_tot = m_struct + m_hydro
         p_inertia        = m_tot    * a_struct # TODO is it really m_tot
         F_inertia_lumped = M_lumped * a_struct
     except:
-        import pdb; pdb.set_trace()
+        raise Exception()
 
     # --- Total loads from external forces and inertia (inline and lumped)
     p_all        = p_ext        - p_inertia 
     F_lumped_all = F_ext_lumped - F_inertia_lumped
-#     print('p2',p_all[0,:])
+
+    # --- Axial force 
+    p_x = np.zeros(nSpan) 
+    pax = np.zeros(nSpan) 
+    Pax = np.zeros(nSpan)  # Cumulative axial force \int_z^L pax dz
+    if main_axis=='z':
+        if bSelfWeight:
+            pax_SW = - p_inertia[2,:] #   - m * (g + zddot)
+            Pax_SW  = fcumtrapzlr(s_span, pax_SW)
+            pax = pax + pax_SW # TODO lumped forces
+            Pax = Pax + Pax_SW # TODO lumped forces
+            #print(m)
+            #print(np.sum(m))
+            #print(pax)
+            #print(np.sum(pax))
+            #print(Pax)
+            #Pax[:] += F_top[2] # Not so sure here
+            #pax[-1] += F_top[2]
+            p_x +=  K[0,:] * Pax
+            p_x += - V[0,:] * pax
+            p_all[0,:] += p_x
+    # TODO self-weight correction
+#     # FT=fcumtrapzlr(s_span,m);
+#     FT = - sciint.cumtrapz( m[-1::-1], s_span[-1::-1],)[-1::-1] 
+#     FT = np.concatenate((FT,[0]))
+#     if V_tot is None: 
+#         raise Exception('Please provide Vtot for axial correction'); end
+#     if main_axis=='x':
+#         Mxt[0,1]=+trapzs(V_tot[2,:]*FT) # m15
+#         Mxt[0,2]=-trapzs(V_tot[1,:]*FT) # m16
+#     else:
+#         # TODO TODO TODO VERIFY ME
+#         Mxt[2,0]=+trapzs(V_tot[1,:]*FT) # m15
+#         Mxt[2,1]=-trapzs(V_tot[0,:]*FT) # m16
+#     # --- Axial force 
+#     Pacc    = np.zeros(nSpan) 
+#     # TopMass contribution to Pacc
+#     if bMtop:
+#         Pacc_MT = -Mtop * gravity*np.ones(nSpan)
+#         Pacc=Pacc+Pacc_MT
+#     if bSelfWeight:
+#         Pacc_SW  = fcumtrapzlr(s_span, -m * gravity)
+#         Pacc=Pacc+Pacc_SW
+#     if bRot:
+#         Pacc_Rot = fcumtrapzlr(s_span,  m * Omega**2 * s_span)
+#         Pacc=Pacc+Pacc_Rot
+#     # Method 2
+#     KKCorr = np.zeros((nf,nf))
+#     for i in range(0,nf):
+#         for j in range(0,nf):
+#             #xx=trapz(s_span, Pacc .* PhiV{i}(1,:).* o.PhiV{j}(1,:));
+#             if main_axis=='x':
+#                 yy=trapzs(Pacc * dU[i][1,:] * dU[j][1,:])
+#                 zz=trapzs(Pacc * dU[i][2,:] * dU[j][2,:])
+#                 KKCorr[i,j]=yy+zz
+#             elif main_axis=='z':
+#                 xx=trapzs(Pacc * dU[i][0,:] * dU[j][0,:])
+#                 yy=trapzs(Pacc * dU[i][1,:] * dU[j][1,:])
+#                 KKCorr[i,j]=yy+xx
+
+
+
+
 
     # --- Section Loads
     z  = s_span-s_span[0]
     zn = z[-1::-1]  # flip z so it goes from top to bottom for cumtrapz
     F_sec=np.zeros((3,len(z)))
     M_sec=np.zeros((3,len(z)))
     # Bending momemts 
-    #print('p_inertia[0,:]',p_inertia[0,:])
-    #print('p_all[0,:]',p_all[0,:])
     F_sec[0,:], M_sec[1,:] = beamSectionLoads1D(z, p_all[0,:], F_top[0], M_top[1], s=1,  F_lumped = F_lumped_all[0,:])
     F_sec[1,:], M_sec[0,:] = beamSectionLoads1D(z, p_all[1,:], F_top[1], M_top[0], s=-1, F_lumped = F_lumped_all[1,:])
     # Axial force
     F_sec[2,:-1] =- sciint.cumtrapz(p_all[2, -1::-1], zn)[-1::-1] # NOTE: mostly m*acc, can use FXG
     F_sec[2,:] += F_top[2] 
     # Torsion moment
     M_sec[2,:] += M_top[2]  # TODO integrate external torsions - torsional inertias and contributions from sectionn loads due to lever arm of deflection
 
     # Additional forces and moments from top loads due to deflections (ExtraLeverArm)
     if corrections>=1:
-        F_sec[0,:] +=  F_top[2] * V[1,:] # Fx = Fz v_y 
-        F_sec[1,:] +=  F_top[2] * V[0,:] # Fy = Fz v_x  # TODO check sign
+        F_sec[0,:] += -F_top[2] * V[0,:] # Fx = Fz v_y 
+        F_sec[1,:] +=  F_top[2] * V[1,:] # Fy = Fz v_x  # TODO check sign
         dx = U[0,-1] - U[0,:]
         dy = U[1,-1] - U[1,:]
         M_sec[1,:] += -F_top[2] * dx # My =-Fz dx 
         M_sec[0,:] += +F_top[2] * dy # Mx = Fz dy 
         M_sec[2,:] +=  F_top[1]*dx - F_top[0]*dy # Mz = Fy dx - Fx dy 
 
+
     # Torsion correction
     if corrections>=2:
         M_sec[2,1:] +=- V[1,1:]*M_sec[0,1:]-V[0,1:]*M_sec[1,1:] # Mx = - Vy Mx - Vx My # TODO check sign
 
     # KEEP ME: M_y approximation
     #M_sec[1,0] = F_top[1]*z[-1] + M_top[1] # approximation
 
     return F_sec, M_sec
 
 
 
+def beamSectionLoadsFromShapeFunctions(x, xd, xdd, p_ext, F_top, M_top, s_span, PhiU, PhiV, m, 
+        M_lumped=None, m_hydro=None, a_ext=None, F_ext_lumped=None, corrections=1, PhiK=None):
+    """ 
+    Compute section loads along a beam represented by shape functions
+    INPUTS:
+     - x, xd, xdd : elastic motion associated with the shape functions
+                 array-like of shape nf
+     - p_ext: loads along the beam (without inertia), shape: (3 x n) [N/m]
+
+     - PhiU, PhiV, PhiK: Deflections, slopes, curvature of shape functions (nf x 3 x n)  
+    
+    """
+    # Main dimensions
+    shapeDisp = PhiU[0].shape
+    nf        = len(PhiU)
+    # Linear Translation, Velocity, Acceleration
+    U        = np.zeros(shapeDisp)
+    V        = np.zeros(shapeDisp)
+    #v_struct = np.zeros(shapeDisp)
+    a_struct = np.zeros(shapeDisp)
+
+    # Compute elastic deformation, slope curvature:
+    for j in np.arange(nf):
+        U         += x  [j] * PhiU[j] # Deflections
+        V         += x  [j] * PhiV[j] # Slopes
+        #v_struct  += xd [j] * PhiU[j]
+        a_struct  += xdd[j] * PhiU[j] # TODO base motion
+    if PhiK is not None:
+        for j in np.arange(nf):
+            K += x[j] * PhiK[j] # Deflections
+
+    return beamSectionLoads3D(p_ext=p_ext, F_top=F_top, M_top=M_top, s_span=s_span, m=m, U=U, V=V, K=K, a_struct=a_struct, 
+            M_lumped=M_lumped, m_hydro=m_hydro, a_ext=a_ext, F_ext_lumped=F_ext_lumped, corrections=corrections)
+    #return F_sec, M_sec
+
+
+
 
 def GeneralizedMCK_PolyBeam(s_span, m, EIFlp, EIEdg, coeffs, exp, damp_zeta, jxxG=None, gravity=None, Mtop=0, Omega=0, nSpan=None, 
         bAxialCorr=False, bStiffening=True, main_axis='z', shapes=[0,1,2,3], algo='', s_start=0):
     """ 
     Compute generalized mass, stiffness and damping matrix, and shape integrals for a beam defined using polynomial coefficients
     The shape functions of the beam are defined as:
        (U_j = a_ij s^i,  i=1..nExponents),  j=1..nShapes
```

### Comparing `welib-0.0.2/welib/yams/kinetics_sympy.py` & `welib-1.0.0/welib/yams/kinetics_sympy.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/models/FTNSB_sympy.py` & `welib-1.0.0/welib/ws_estimator/tabulated.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,686 +1,733 @@
 import numpy as np
-from sympy import Matrix, symbols, simplify, Function, expand_trig, Symbol, diff
-from sympy import cos, sin, transpose, pi
-from sympy import latex, python
-from sympy.physics.mechanics import dynamicsymbols, ReferenceFrame, Point, inertia
-
-#from welib.yams.sympy_tools import *
-#from welib.yams.yams_sympy import DCMtoOmega
-from welib.yams.yams_sympy       import YAMSRigidBody, YAMSInertialBody, YAMSFlexibleBody
-from welib.yams.yams_sympy_model import YAMSModel
-from welib.yams.models.FTNSB_sympy_symbols import *
-from welib.yams.models.utils import stiffness6DOF
-
-
-_defaultOpts={
-    'floating':True,
-    'yaw'    : 'fixed',  # 'fixed', 'dynamic' or 'zero'
-    'tilt'   : 'fixed',  # 'fixed', 'dynamic' or 'zero'
-    # Blades Options
-    'nB':3                , # Number of blades
-    'azimuth_init': 'fixed',# 'fixed', or 'zero'
-    'pitch'  : 'fixed',# '','fixed', 'dynamic', 'or 'zero'
-    'cone'   : 'fixed',# '','fixed', or 'zero'
-    'coneAtRotorCenter': False,  # Ture in OpenFAST, coning starts at the rotor center, not at the blade root
-    'r_hub': 'fixed',  # 'fixed' or 'zero', hub radius depend on coneAtRotorCenter
-    #
-    'Mform'  : 'TaylorExpanded', # 'symbolic',or 'TaylorExpanded'
-    'mergeFndTwr':True, # Use one body for FND and TWR
-    'tiltShaft':False, # Tilt shaft or nacelle
-    'twrDOFDir':['x','y','x','y'], # Order in which the flexible DOF of the tower are set
-    'collectiveBldDOF':False,      # Use the same degrees of freedom for all blades "collective"
-    'linRot' : False,              #<<< Very important if True will assume that omegas are time derivatives of DOFs
-    'rot_elastic_type':'Body',     #<<< Very important, SmallRot, or Body, will affect the rotation matrix
-    'rot_elastic_subs':True,       #<<< Very important, will substitute alpha_y with nuy q. Recommended True
-    'rot_elastic_smallAngle':False,#<<< Very important, will perform small angle approx: sin(nu q) = nu q and nu^2=0 !!! Will remove all nu^2 and nu^3 terms!! might not be recommended
-    'moor_loads':False, # Add mooring loads on the foundation
-    'hydro_loads':False, # Add hydro on the foundation 
-    'aero_torques':False, # Add aerodynamic torques
-    'aero_forces':True, # Add aerodynamic torques
-    'orderMM':2, #< order of taylor expansion for Mass Matrix
-    'orderH':2,  #< order of taylor expansion for H term
-    'verbose':False, 
-}
-
-
-def get_model(model_name, **opts):
-    """ 
-
-    model: string defining model
-
-    opts: dictionary of options with keys:
-        see _defaultOpts
-    
+import os
+import pandas as pd
+import matplotlib.pyplot as plt
+import scipy.interpolate as si
+from scipy.optimize import minimize_scalar
+
+from welib.weio.fast_input_deck import FASTInputDeck
+from welib.tools.signal_analysis import zero_crossings
+
+# ---
+def interp2d_pairs(*args,**kwargs):
+    """ Same interface as interp2d but the returned interpolant will evaluate its inputs as pairs of values.
+    Inputs can therefore be arrays
+
+    example:
+       f = interp2d_pairs(vx, vy, M, kind='cubic')
+
+    vx: array of length nx
+    vy: array of length ny
+    M : array of shape nx x ny
+    f : interpolant function
+          v = f(x,y) : if x,y are array of length n, v is of length n
+                       with  v_i = f(x_i, y_i)
+    author: E. Branlard
     """
+    # Internal function, that evaluates pairs of values, output has the same shape as input
+    def interpolant(x,y,f):
+        x,y = np.asarray(x), np.asarray(y)
+        return (si.dfitpack.bispeu(f.tck[0], f.tck[1], f.tck[2], f.tck[3], f.tck[4], x.ravel(), y.ravel())[0]).reshape(x.shape)
+    # Wrapping the scipy interp2 function to call out interpolant instead
+    return lambda x,y: interpolant(x,y,si.interp2d(*args,**kwargs))
 
-    for k,v in _defaultOpts.items():
-        if k not in opts.keys():
-            opts[k]=v
-    for k,v in opts.items():
-        if k not in _defaultOpts.keys():
-            raise Exception('Key {} not supported for model options.'.format(k))
-    #print(opts)
-    verbose=opts['verbose']
-
-    # --------------------------------------------------------------------------------}
-    # --- Extract info from model name
-    # --------------------------------------------------------------------------------{
-    # Nicknames
-    bFullRNA   = model_name.find('RNA')==-1
-    bRotorOnly = model_name.find('R')==0
-
-    if bRotorOnly and not bFullRNA:
-        raise Exception('Cannot have "Rotor" and RNA')
-
-    if bRotorOnly:
-        # Rotor only, overriding options
-        bFullRNA=True
-        opts['nB']=int(model_name.split('R')[1][0]) 
-        opts['mergeFndTwr'] = True
-        opts['floating'] = False
-        opts['yaw' ] = 'zero'
-        opts['tilt'] = 'zero'
-
-    # Default values, no DOF
-    bFndDOFs = [False]*6
-    bNac=False   # Is there Nacelle DOFs
-    bSft=False   # Is there Shaft DOFs
-    bBld=False   # Is there blade DOF
-    nDOF_fnd   = 0 # Number of DOFs for foundation
-    nDOF_twr   = 0 # Number of DOFs for tower
-    nDOF_nac   = 0 # Number of DOFs for nacelle 
-    nDOF_sft   = 0 # Number of DOFs for shaft
-    nDOF_bld   = 0 # Total number of DOF per blade = nDOF_bld_e+nDOF_bld_f+nDOF_bld_t
-    nDOF_bld_e = 0 # Number of edge DOF per blade
-    nDOF_bld_f = 0 # Number of flap DOF per blade
-    nDOF_bld_t = 0 # Number of torsion DOF per blade
-
-    if not bRotorOnly:
-        # "Foundation"/substructure
-        sFnd= model_name.split('T')[0][1:] # TODO why not F????
-        if len(sFnd)==1:
-            bFndDOFs   = [False]*6
-            nDOF_fnd = int(sFnd[0])
-            bFndDOFs[0]=nDOF_fnd>=1 # x
-            bFndDOFs[4]=nDOF_fnd>=2 # phiy
-            bFndDOFs[2]=nDOF_fnd==3 or nDOF_fnd==6 # z
-            bFndDOFs[1]=nDOF_fnd>=5 # y
-            bFndDOFs[3]=nDOF_fnd>=5 # phi_x
-            bFndDOFs[5]=nDOF_fnd>=5 # phi_z
-        else:
-            bFndDOFs=[s=='1' for s in sFnd]
 
-    if not bRotorOnly:
-        # Tower
-        nDOF_twr = int(model_name.split('T')[1][0])
-
-    if bFullRNA:
-        # Rotor nacelle assembly is made of several bodies and DOFs
-        bNac = model_name.find('N')>0
-        bSft = model_name.find('S')>0
-        bBld = model_name.find('B')>0
-        if bNac:
-            nDOF_nac = int(model_name.split('N')[1][0])
-        if bSft:
-            nDOF_sft = int(model_name.split('S')[1][0])
-        if bBld:
-            sDOF_bld = model_name.split('B')[1]
-            if len(sDOF_bld)==1:
-                nDOF_bld_f = int(sDOF_bld[0])
-            elif len(sDOF_bld)==3:
-                nDOF_bld_f = int(sDOF_bld[0])
-                nDOF_bld_e = int(sDOF_bld[1])
-                nDOF_bld_t = int(sDOF_bld[2])
-            else:
-                raise NotImplementedError()
+def Paero(WS, Pitch, Omega, R, rho, fCP):
+    """ Taero returns the aerodynamic power
+         - Pitch  [deg]
+         - Omega [rad/s]
+         - R : the blade radius [m]
+         - fCP : an interpolant for CP(Pitch,lambda) as returned by interp2d_paris
+         - rho : the air density [kg/m^3]
+    """
+    Lambda = Omega * R / WS
+    CP     = fCP(Pitch, Lambda)
+    P      = 1/2*rho*np.pi*R**2*WS**3*CP
+    return P
 
-    else:
-        # Rotor nacelle assembly is one rigid body
-        pass
-
-    nDOF_fnd = sum(bFndDOFs)
-    nDOF_bld = nDOF_bld_f+nDOF_bld_e+nDOF_bld_t
-
-    bldDOFDir = []
-    if True:
-        bldDOFDir += ['x']*nDOF_bld_f
-        bldDOFDir += ['y']*nDOF_bld_e
-        bldDOFDir += ['t']*nDOF_bld_t
-    else:
-        pass # TODO distribute DOFs 1st flap, ed tors, 2nd flap, ed tors, ets
-
-
-    if verbose:
-        print('Degrees of freedom:')
-        print('fnd',','.join(['1' if b else '0' for b in bFndDOFs]), 'twr',nDOF_twr, 'nac',nDOF_nac, 'sft',nDOF_sft, 'nB:{}'.format(opts['nB']), 'bld',nDOF_bld, '({},{},{}) {:s}'.format(nDOF_bld_f,nDOF_bld_e,nDOF_bld_t, ''.join(bldDOFDir)) )
-
-    # --------------------------------------------------------------------------------}
-    # --- Isolated bodies 
-    # --------------------------------------------------------------------------------{
-    # --- Reference frame
-    ref = YAMSInertialBody('E') 
-
-    # --- Fnd Floater/Foundation/Substructure
-    fnd = None
-    if not bRotorOnly:
-        # Foundation, floater, always rigid for now
-        if (not opts['floating']) or opts['mergeFndTwr']:
-            fnd = None # the floater is merged with the twr, or we are not floating
-        else:
-            fnd = YAMSRigidBody('F', rho_G = [0,0,z_FG], J_diag=True) 
-    # --- Tower
-    twr = None
-    if not bRotorOnly:
-        if nDOF_twr==0:
-            # Ridid tower
-            twr = YAMSRigidBody('T', rho_G = [0,0,z_TG], J_diag=True) 
-        elif nDOF_twr<=4:
-            # Flexible tower
-            twr = YAMSFlexibleBody('T', nDOF_twr, directions=opts['twrDOFDir'], orderMM=opts['orderMM'], orderH=opts['orderH'], predefined_kind='twr-z')
-
-    # --- Nacelle rotor assembly
-    blds = []
-    rot  = None
-    nac  = None
-    if bFullRNA:
-        if not bRotorOnly:
-            # Nacelle
-            nac = YAMSRigidBody('N', rho_G = [x_NG ,0, z_NG], J_cross=True) 
-
-        # Shaft
-        # TODO shaft mass and inertia...
-
-        # Individual blades or rotor
-        if bBld:
-            # Creating a fake "rotor body" with no inertia for convenience
-            rot = YAMSRigidBody('R', rho_G = [0,0,0], J_G=[0,0,0], mass=0)
-            #rot.inertia = (inertia(rot.frame, Jxx_R, JO_R, JO_R), rot.origin)  # defining inertia at orign
-            if nDOF_bld==0:
-                print('>>> Rigid blades')
-                # NOTE: for now we assume the blades to be identical, hence the use of name_for_var
-                for ib, b in enumerate(np.arange(opts['nB'])):
-                    B = YAMSRigidBody('B{:d}'.format(ib+1), rho_G = [x_BG ,y_BG, z_BG], name_for_var='B')
-                    blds.append(B)
-            else:
-                print('>>> Flexible blades')
-                # NOTE: for now we assume the blades to be identical, hence the use of name_for_var
 
-                if opts['collectiveBldDOF']:
-                    for ib, b in enumerate(np.arange(opts['nB'])):
-                        B = YAMSFlexibleBody('B{:d}'.format(ib+1), rho_G = [x_BG ,y_BG, z_BG], name_for_var='B', name_for_DOF='B') # <<< Collective DOF (same name)
-                        blds.append(B)
+def Qaero(WS, Pitch, Omega, R, rho, fCP):
+    """ Qaero returns the aerodynamic torque
+         - Pitch [deg]
+         - Omega [rad/s]
+         - R : the blade radius
+         - fCP : an interpolant for CP(Pitch,lambda)
+         - rho : the air density
+    """
+    Pitch = np.asarray(Pitch)
+    WS    = np.asarray(WS)
+    Omega = np.asarray(Omega)
+    Lambda = Omega * R / WS
+    CP = fCP(Pitch, Lambda)
+    Q = 1/2*rho*np.pi*R**2*WS**3/Omega*CP
+    return Q
+
+def Taero(WS, Pitch, Omega, R, rho, fCT):
+    """ Taero returns the aerodynamic thrust of a given turbine
+         - Pitch [deg]
+         - Omega [rad/s]
+         - R : the blade radius
+         - fCP : an interpolant for CP(Pitch,lambda)
+         - rho : the air density
+    """
+    Lambda = Omega * R / WS
+    CT = fCT(Pitch,Lambda)
+    T = 1/2*rho*np.pi*R**2*WS**2*CT
+    return T
+
+
+class TabulatedWSEstimatorBase():
+
+
+    def __init__(self, R=None, rho=1.225, fstFile=None):
+        """ 
+        INPUTS:
+          either:
+          - fstFile: FAST Input file, used to obtain rotor radius and airdensity
+          or
+          - rho : air density [kg/m^3]
+          - R       : rotor radius [m]
+        """
+        # --- Data
+        self.WSmax = 35
+        self.CP    = None
+        self.CT    = None
+        self.OP    = None
+
+        # ---
+        if fstFile:
+            fst = FASTInputDeck(fstFile)
+            R       = fst.ED['TipRad']
+            if fst.AD is None:
+                raise Exception('AeroDyn file not read but needed for wind speed estimator, while reading {}'.format(fstFile))
+            rho_AD = fst.AD['AirDens']
+            try:
+                rho_main = fst.fst['AirDens']
+            except:
+                rho_main = rho_AD
+            if isinstance(rho_AD, str):
+                rho_AD = rho_main
+
+        self.fstFile  = fstFile
+        self.R       = R
+        self.rho = rho
+
+    def _sanitizeOP(self, OP, expectedCols=None, onlyExpected=True):
+        if expectedCols is None:
+            expectedCols = ['WS_[m/s]', 'Pitch_[deg]', 'RotSpeed_[rpm]']
+
+        # --- Trying to be nice about column names
+        OP.columns = [c.lower().replace(' ','_').replace('(','[').replace(')',']') for c in OP.columns]
+
+        d =dict([(k, 'WS_[m/s]') for k in ['ws_[m/s]', 'ws']])
+        OP.rename(columns = d, inplace=True)
+
+        d =dict([(k, 'Pitch_[deg]') for k in ['bldpitch1_[deg]', 'bldpitch_[deg]','pitch_[deg]', 'pitch']])
+        OP.rename(columns = d, inplace=True)
+
+        d =dict([(k, 'RotSpeed_[rpm]') for k in ['rotspeed_[rpm]', 'rpm', 'rpm_[rpm]', 'omega_[rpm]']])
+        OP.rename(columns = d, inplace=True)
+
+        if 'rtaeromxh_[kn-m]' in OP.keys(): # TODO standardize Units WE
+            OP['rtaeromxh_[n-m]'] =  OP['rtaeromxh_[kn-m]'].values*1000
+        d =dict([(k, 'Qaero_[Nm]') for k in ['rtaeromxh_[n-m]']])
+        OP.rename(columns = d, inplace=True)
+
+        d =dict([(k, 'PhiY_[deg]') for k in ['phiy_[deg]']])
+        OP.rename(columns = d, inplace=True)
+
+        for c in expectedCols:
+            if c not in OP:
+                print('>>> Columns', OP.keys())
+                raise Exception('OP is missing: {}'.format(c))
+
+        if onlyExpected:
+            OP = OP[expectedCols]
+
+        return OP
+
+
+class TabulatedWSEstimator(TabulatedWSEstimatorBase):
+
+    def __init__(self, R=None, rho=1.225, fstFile=None, basename=None, operFile=None, aeroMapFile=None, OmegaLow=0, OmegaRated=10):
+        """ 
+        INPUTS:
+          either:
+          - fstFile: FAST Input file, used to obtain rotor radius and airdensity
+          or
+          - rho : air density [kg/m^3]
+          - R       : rotor radius [m]
+        """
+        # Initialize parent class
+        TabulatedWSEstimatorBase.__init__(self, R, rho, fstFile)
+
+        if basename is not None:
+            aeroMapFile = basename+'_CPCTCQ.txt'
+            operFile    = basename+'_Oper.csv'
+
+        # --- DATA
+        self.Pitch    = None
+        self.Lambda   = None
+        # Operating condition
+        self.OmegaLow   = OmegaLow
+        self.OmegaRated = OmegaRated
+        self.OP     = None
+        # Files
+        self.operFile = operFile
+        self.aeroMapFile = aeroMapFile
+
+        if operFile is not None:
+            self.loadOper(operFile)
+
+        if aeroMapFile is not None:
+            self.loadAeroMap(aeroMapFile)
+
+
+    def loadOper(self, operFile):
+        if not os.path.exists(operFile):
+            print('[WARN] Operating point file not found: ',operFile)
+        else:
+            #print('>>> Loading oper file: ',operFile)
+            import welib.weio as weio
+            OP = weio.read(operFile).toDataFrame()
+
+            OP = self._sanitizeOP(OP, ['WS_[m/s]', 'Pitch_[deg]', 'RotSpeed_[rpm]', 'Qaero_[Nm]'], onlyExpected=False)
+
+            self.WS   =OP['WS_[m/s]'].values
+            self.Omega=OP['RotSpeed_[rpm]'].values*2*np.pi/60
+            self.OmegaRated=np.max(self.Omega)
+            self.OmegaLow  =0.4*self.OmegaRated
+            self.WSRated=np.interp(self.OmegaRated*0.98,self.Omega,self.WS)
+            self.WSCutOff=28
+            self.OP=OP
+            self.operFile = operFile
+
+    def loadAeroMap(self, aeroMapFile):
+        """ Load file containing aeromap: CP(Lambda, Pitch) """
+        #print('>>>> Loading aeroMapFile', aeroMapFile)
+        # TODO more file formats
+        from welib.weio.rosco_performance_file import ROSCOPerformanceFile
+        rs = ROSCOPerformanceFile(aeroMapFile)
+        self.Pitch  = rs['pitch']
+        self.Lambda = rs['TSR']
+        self.CP     = rs['CP']
+        self.CT     = rs['CT']
+        # Trigger
+        self.aeroMapFile = aeroMapFile
+        self.computeWeights()
+
+    def loadFromBasename(self, basename=None, suffix=''):
+        """  """
+        aeroMapFile = basename+'_CPCTCQ'+suffix+'.txt'
+        operFile      = basename+'_Oper'+suffix+'.csv'
+
+        if os.path.exists(aeroMapFile):
+            self.loadAeroMap(aeroMapFile)
+        else:
+            # Old format
+            LambdaFile  = basename + '_Lambda'+suffix+'.csv'
+            PitchFile   = basename + '_Pitch'+suffix+'.csv'
+            CPFile      = basename + '_CP'+suffix+'.csv'
+            CTFile      = basename + '_CT'+suffix+'.csv'
+            self.Pitch  = pd.read_csv(PitchFile ,header = None).values.ravel()
+            self.Lambda = pd.read_csv(LambdaFile,header = None).values.ravel()
+            self.CP     = pd.read_csv(CPFile,header     = None).values
+            self.CP[self.CP<=0]=0
+            self.CT     = pd.read_csv(CTFile,header     = None).values
+            self.CT[self.CT<=0]=0
+            # Trigger
+            self.computeWeights()
+
+        if os.path.exists(operFile):
+            self.loadOper(operFile)
+
+    def computeWeights(self):
+        # Compute interpolants
+        self.CP[self.CP<=0]=0
+        self.fCP = interp2d_pairs(self.Pitch,self.Lambda,self.CP,kind='cubic')
+        if self.CT is not None:
+            self.CT[self.CT<=0]=0
+            self.fCT = interp2d_pairs(self.Pitch,self.Lambda,self.CT,kind='cubic')
+        else:
+            self.fCT = None
+
+        # --- Lambda at higher res
+        LambdaMid = self.Lambda[:-1] + np.diff(self.Lambda)/2
+        Lambda = np.sort(np.concatenate((self.Lambda, LambdaMid)))
+        self.LambdaHR = Lambda
+
+    def Power(self,WS,Pitch,Omega):
+        return Paero(WS, Pitch, Omega, self.R, self.rho, self.fCP)
+
+    def Thrust(self,WS,Pitch,Omega):
+        return Taero(WS, Pitch, Omega, self.R, self.rho, self.fCT)
+
+    def Torque(self,WS,Pitch,Omega):
+        return Qaero(WS, Pitch, Omega, self.R, self.rho, self.fCP)
+
+    def TorqueAt(self, Pitch, Omega):
+        """ 
+        Return Torque(WS) curve for a given pitch and rotational speed
+        Pitch,Omega: scalar
+        """
+        WS     = Omega * self.R / self.LambdaHR[-1::-1] # NOTE using LambdaHR to benefit from cubic interpolation
+        WS = WS[WS<self.WSmax]
+        vPitch = np.array([Pitch]*len(WS))
+        vOmega = np.array([Omega]*len(WS))
+        return WS, self.Torque(WS, vPitch, vOmega)
+
+    def estimate(self, Qa, pitch, omega, WS0, relaxation=0, WSavg=None, debug=False, method='min', deltaWSMax=1): 
+        """
+        INPUTS:
+         - Qa: aerodynamic torque [Nm]
+         - omega: rotational speed [rad/s]
+         - pitch: pitch angle [deg]
+         - WS0:  wind speed guess/previous estimate [m/s]
+         - method: method
+         # TODO compute rolling average on the fly
+
+        NOTE: 
+          - 'min'/ fCP : uses cubic interpolation
+          - 'crossing': uses linear interpolation (but at higher res thanks)
+        """
+        info=None
+        if debug:
+            # Store state
+            info={}
+            info['Qa']=Qa; info['pitch']=pitch; info['omega']=omega; info['WS0']=WS0
+            info['relaxation']=relaxation; info['method']=method; info['deltaWSMax']=deltaWSMax;
+
+
+        def estim(WS0, delta, maxiter=50, tol=0.0001):
+            vWS, vQ = self.TorqueAt(Pitch=pitch, Omega=omega)
+            try:
+                fQ = si.interp1d(vWS, vQ, kind='cubic')
+            except:
+                raise Exception()
+
+            #fun = lambda WS : abs(Qa - fQ(WS))
+            def fun(WS):
+                res = abs(Qa - fQ(WS))
+                #print('WS:{:.3f} res:{:15.5f} Qa:{:10.1f} {:10.1f}'.format(*(WS, res, Qa, fQ(WS))))
+                return res
+            WSmin = max(max(0, WS0-delta), vWS[0])
+            WSmax = min(min(WS0+delta, self.WSmax), vWS[-1])
+            #print('Bounds:', WSmin, WSmax, 'Mid:', (WSmax+WSmin)/2, vWS[0], vWS[-1])
+            #fun = lambda WS : abs(Qa - Qaero(WS, pitch, omega, self.R, self.rho, self.fCP)) # OLD
+            res = minimize_scalar(fun, bounds=[WSmin, WSmax], method='bounded', options={'xatol': tol, 'maxiter': maxiter})
+            residual = Qa - Qaero(res.x, pitch, omega, self.R, self.rho, self.fCP)
+            return res.x, residual
+
+#         if WSavg is not None:
+#             WS0=(WS0+WSavg)/2
+        WS_est = WS0
+        if method.find('min')>=0:
+            if omega<=0.1:
+                WS_est = WS0
+            elif omega<self.OmegaLow:
+                if self.OP is not None:
+                    ws_guess=np.interp(omega, self.Omega, self.WS)
                 else:
-                    for ib, b in enumerate(np.arange(opts['nB'])):
-                        B = YAMSFlexibleBody('B{:d}'.format(ib+1), nDOF_bld, directions=bldDOFDir, orderMM=opts['orderMM'], orderH=opts['orderH'], predefined_kind='bld-z',
-                                name_for_var='B')
-                        blds.append(B)
-        else:
-            # Rotor
-            rot = YAMSRigidBody('R', rho_G = [0,0,0], J_diag=True)
-            rot.inertia = (inertia(rot.frame, Jxx_R, JO_R, JO_R), rot.origin)  # defining inertia at orign
-    else:
-        # Nacelle
-        #nac = YAMSRigidBody('RNA', rho_G = [x_RNAG ,0, z_RNAG], J_diag=True) 
-        nac = YAMSRigidBody('RNA', rho_G = [x_RNAG ,0, z_RNAG], J_cross=True) 
-        rot = None
-
-    # --------------------------------------------------------------------------------}
-    # --- Body DOFs
-    # --------------------------------------------------------------------------------{
-    # --- Fnd
-    if (not opts['floating']):
-        fndDOFs   = []
-        fndSpeeds = []
-    else:
-        fndDOFsAll    = [x, y, z, phi_x,     phi_y,       phi_z]
-        fndSpeedsAll  = [xd,yd,zd,omega_x_T,omega_y_T,omega_z_T]
-        fndDOFs    = [dof for active,dof in zip(bFndDOFs,fndDOFsAll)   if active]
-        fndSpeeds  = [dof for active,dof in zip(bFndDOFs,fndSpeedsAll) if active]
-    # --- Twr
-    twrDOFs   = []
-    twrSpeeds = []
-    if nDOF_twr>0: # flexible tower
-        twrDOFs   = twr.q
-        twrSpeeds = twr.qd
-
-    # --- Nac
-    if nDOF_nac==2:
-        opts['yaw']='dynamic'
-        opts['tilt']='dynamic'
-    if opts['tiltShaft'] and opts['tilt']=='dynamic':
-        raise Exception('Cannot do tiltshaft with tilt dynamic')
-
-    yawDOF  = {'zero':0, 'fixed':theta_yaw,  'dynamic':q_yaw }[opts['yaw']]
-    tiltDOF = {'zero':0, 'fixed':theta_tilt, 'dynamic':q_tilt}[opts['tilt']]
-    nacDOFs     = []
-    nacSpeeds   = []
-    nacKDEqSubs = []
-    if opts['yaw']=='dynamic':
-        nacDOFs     += [q_yaw]
-        nacSpeeds   += [qd_yaw]
-        nacKDEqSubs += [(qd_yaw, diff(q_yaw, time))]
-    if opts['tilt']=='dynamic':
-        nacDOFs     += [q_tilt]
-        nacSpeeds   += [qd_tilt]
-        nacKDEqSubs += [(qd_tilt, diff(q_tilt, time))]
-
-    nacDOFsAct=(opts['yaw']=='dynamic',opts['tilt']=='dynamic')
-    if nDOF_nac==0:
-        if not (nacDOFsAct==(False,False)):
-            raise Exception('If nDOF_nac is 0, yaw and tilt needs to be "fixed" or "zero"')
-    elif nDOF_nac==1:
-        if not (nacDOFsAct==(True,False) or nacDOFsAct==(False,True) ):
-            raise Exception('If nDOF_nac is 1, yaw or tilt needs to be "dynamic"')
-    else:
-        if not (nacDOFsAct==(True,True)):
-            raise Exception('If nDOF_nac is 2, yaw and tilt needs to be "dynamic"')
-
-    # --- Shaft
-    sftDOFs  =[]
-    sftSpeeds=[]
-    if bFullRNA:
-        if nDOF_sft==1:
-            sftDOFs   = [q_psi]
-            sftSpeeds = [omega_x_R]
-        elif nDOF_sft==0:
-            pass
-        else:
-            raise Exception('nDOF shaft should be 0 or 1')
-
-    # --- Blade/Rotor
-    bldDOFs=[] 
-    bldSpeeds=[] 
-    if bFullRNA:
-        bldDOFs   = []
-        bldSpeeds = []
-        if nDOF_bld>0: # flexible tower
-            for ib, bld in enumerate(blds): 
-                bldDOFs   += bld.q
-                bldSpeeds += bld.qd
-
-
-    pitchDOF  = {'zero':0, 'fixed':theta_pitch,  'dynamic':q_pitch }[opts['pitch']]
-    coneDOF   = {'zero':0, 'fixed':theta_cone}[opts['cone']]
-    psi0      = {'zero':0, 'fixed':psi_0}[opts['azimuth_init']]
-    rh        = {'zero':0, 'fixed':r_hub}[opts['r_hub']]
-
-    coordinates = fndDOFs   + twrDOFs   + nacDOFs   + sftDOFs   + bldDOFs 
-    speeds      = fndSpeeds + twrSpeeds + nacSpeeds + sftSpeeds + bldSpeeds  # Order determine eq order
-
-    if verbose:
-        print('>>> Coordinates:',coordinates)
-        print('    speeds     :',speeds)
-
-
-
-    # --------------------------------------------------------------------------------}
-    # --- Connections between bodies
-    # --------------------------------------------------------------------------------{
-    z_OT = Symbol('z_OT')
-    if opts['floating']:
-        rel_pos=[0,0,0]
-        rel_pos[0] = x      if bFndDOFs[0] else 0
-        rel_pos[1] = y      if bFndDOFs[1] else 0
-        rel_pos[2] = z+z_OT if bFndDOFs[2] else z_OT
-        rots =[0,0,0]
-        rots[0] = phi_x if bFndDOFs[3] else 0
-        rots[1] = phi_y if bFndDOFs[4] else 0
-        rots[2] = phi_z if bFndDOFs[5] else 0
-        if nDOF_fnd==0:
-            #print('Rigid connection ref twr', rel_pos)
-            ref.connectTo(twr, type='Rigid' , rel_pos=rel_pos)
-        elif nDOF_fnd==1: 
-            #print('Constraint connection ref twr')
-            #ref.connectTo(twr, type='Free' , rel_pos=(x,0,z_OT), rot_amounts=(0    , x * symbols('nu'), 0   ), rot_order='XYZ')
-            print('>>>> TODO TODO TODO FTNSB_sympy, commented hacked case for nDOF_fnd==1')
-            ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=rots, rot_order='XYZ')  #NOTE: rot order is not "optimal".. phi_x should be last
-        else:
-            #print('Free connection ref twr', rel_pos, rots)
-            ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=rots, rot_order='XYZ')  #NOTE: rot order is not "optimal".. phi_x should be last
-            #ref.connectTo(twr, type='Free' , rel_pos=rel_pos, rot_amounts=(rots[2],rots[1],rots[0]), rot_order='ZYX')  #NOTE: rot order is not "optimal".. phi_x should be last
-    else:
-        if not bRotorOnly:
-            #print('Rigid connection ref twr')
-            ref.connectTo(twr, type='Rigid' , rel_pos=(0,0,0))
-
-    if not bRotorOnly:
-        # Rigid connection between twr and fnd if fnd exists
-        if fnd is not None:
-            #print('Rigid connection twr fnd')
-            if nDOF_twr==0:
-                twr.connectTo(fnd, type='Rigid', rel_pos=(0,0,0)) # -L_F
-            else:
-                twr.connectTo(fnd, type='Rigid', rel_pos=(0,0,0)) # -L_F
-
-        if nDOF_twr==0:
-            # Tower rigid -> Rigid connection to nacelle
-            # TODO TODO L_T or twr.L
-            #if nDOF_nac==0:
-            #print('Rigid connection twr nac')
-            #else:
-            #print('Dynamic connection twr nac')
-
-            if opts['tiltShaft']:
-                # Shaft will be tilted, not nacelle
-                twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(yawDOF,0,0), rot_order='ZYX')
+                    ws_guess=WS0 # TODO
+                WS1,residual = estim(WS0, delta=2)
+                WS_est=(4*WS1+ws_guess)/5
             else:
-                # Nacelle is tilted
-                twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(yawDOF,tiltDOF,0), rot_order='ZYX')
+                WS_est, residual = estim(WS0, delta=deltaWSMax)
+                #print('residual',residual)
 
-        else:
-            # Flexible tower -> Flexible connection to nacelle
-            #print('Flexible connection twr nac')
-            if opts['tiltShaft']:
-                twr.connectToTip(nac, type='Joint', rel_pos=(0,0,twr.L)  , rot_amounts=(yawDOF, 0      , 0), rot_order='ZYX', rot_type_elastic=opts['rot_elastic_type'], doSubs=opts['rot_elastic_subs'])
-            else:
-                twr.connectToTip(nac, type='Joint', rel_pos=(0,0,twr.L)  , rot_amounts=(yawDOF, tiltDOF, 0), rot_order='ZYX', rot_type_elastic=opts['rot_elastic_type'], doSubs=opts['rot_elastic_subs'])
-
-    # --- Ref to blades
-    if opts['coneAtRotorCenter']:
-        # Like in OpenFAST we cone at the rotor center
-        x_RB = rh * sin(coneDOF) # NOTE: cone <0 for wind turbines, so x_RB<0 (downstream)
-        z_RB = rh * cos(coneDOF)
-    else:
-        x_RB = 0
-        z_RB = rh
-
-    nB = opts['nB']
-    psi_b = [psi0+ib*2 * pi/nB for ib,_ in enumerate(blds)] # blade default azimuthal position
-    if not bRotorOnly:
-        # --- Nacelle to rotor/blades
-        if bFullRNA:
-            if opts['tiltShaft']:
-                if nDOF_sft==0:
-                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,tiltDOF,0), rot_order='ZYX')
-                else:
-                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,tiltDOF,q_psi), rot_order='ZYX')
-            else:
-                if nDOF_sft==0:
-                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,0      ,0), rot_order='ZYX')
+        WSoper = None
+        # --- Use operating conditions
+        if method.find('oper')>=0:
+            if self.OP is None:
+                raise Exception('Cannot use method `oper`, operFile was not provided')
+            WSOP    = self.OP['WS_[m/s]'].values   #[m/s]
+            QaeroOP = self.OP['Qaero_[Nm]'].values #[Nm]
+            PitchOP = self.OP['Pitch_[deg]'].values #[deg]
+            # np.interp(Qa, self.OP['RtAeroMxh_[N-m]'], self.OP['WS_[m/s]'])
+            WScrossOP, _, _ = zero_crossings(QaeroOP-Qa, x=WSOP)
+            if len(WScrossOP)==0:
+                # Can happen if torque below minimum or above maximum torque
+                #print('>>> No crossing OP', pitch, omega, Qa)
+                #import matplotlib.pyplot as plt
+                #fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+                #fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+                #ax.plot(WSOP, QaeroOP, label='Omega = {:3.1f}'.format(omega))
+                #ax.plot(WSOP, Qa+WSOP*0)
+                #ax.set_xlabel('WS [m/s]')
+                #ax.set_ylabel('Q [N]')
+                #ax.set_xlim([0,30])
+                #ax.set_ylim([0,2e7])
+                #ax.legend()
+                #plt.show()
+                WSoper = WS0
+            elif len(WScrossOP)==1:
+                WSoper = WScrossOP[0]
+            elif len(WScrossOP)>=1:
+                #print('{} OPcross p={:8.3f} om={:8.3} Qa={:10.2f} WS0={:7.3f}'.format(len(WScrossOP), pitch, omega, Qa, WS0), WScrossOP)
+                WSoper=WScrossOP[0]
+                #import matplotlib.pyplot as plt
+                #fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+                #fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+                #ax.plot(WSOP, QaeroOP, label='Omega = {:3.1f}'.format(omega))
+                #ax.plot(WSOP, Qa+WSOP*0)
+                #ax.set_xlabel('WS [m/s]')
+                #ax.set_ylabel('Q [N]')
+                #ax.set_xlim([0,30])
+                #ax.set_ylim([0,2e7])
+                #ax.legend()
+                #plt.show()
+                #raise Exception('TODO')
+            WSest = WSoper
+            if debug:
+                info['WS_oper'] = WSoper
+                info['WS_crossOP'] = WScrossOP
+
+        # --- Find torque for given pitch and omega
+        if method.find('crossing')>=0:
+            if omega>0:
+                iNear = None
+                vWS, vQ = self.TorqueAt(Pitch=pitch, Omega=omega)
+                WScross, iBef, sign = zero_crossings(vQ-Qa, x=vWS)
+                if len(WScross)==0:
+                    #print('{} cross p={:8.3f} om={:8.3} Qa={:10.2f} WS0={:7.3f}'.format(len(WScross), pitch, omega, Qa, WS0), WScross)
+                    #import matplotlib.pyplot as plt
+                    #fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+                    #fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+                    #ax.plot(vWS, vQ, label='Omega = {:3.1f}'.format(omega))
+                    #ax.plot(vWS, Qa+vWS*0)
+                    #ax.set_xlabel('WS [m/s]')
+                    #ax.set_ylabel('Q [N]')
+                    #ax.set_xlim([0,30])
+                    #ax.set_ylim([0,2e7])
+                    #ax.legend()
+                    #plt.show()
+                    WS_est = WS_est # WS0
+                elif len(WScross)==1:
+                    #print('{} cross p={:8.3f} om={:8.3} Qa={:10.2f} WS0={:7.3f}'.format(len(WScross), pitch, omega, Qa, WS0), WScross)
+                    WS_est = WScross[0]
+                elif len(WScross)==2:
+                    #print('{} cross p={:8.3f} om={:8.3} Qa={:10.2f} WS0={:7.3f}'.format(len(WScross), pitch, omega, Qa, WS0), WScross)
+                    if WSoper is not None:
+                        iNear = np.argmin(abs(WScross-WSoper))
+                    else:
+                        iNear = np.argmin(abs(WScross-WS0))
+                    WS_est = WScross[iNear] # TODO
                 else:
-                    nac.connectTo(rot, type='Joint', rel_pos=(x_NR,0,z_NR), rot_amounts=(0,0      ,q_psi), rot_order='ZYX')
-            if bBld:
-                print('>>> Rigid connection from rotating shaft to each blades')
-                for ib,bld in enumerate(blds): 
-                    rot.connectTo(bld, type='Rigid', rel_pos=(x_RB,-z_RB*sin(psi_b[ib]), z_RB*cos(psi_b[ib])), rot_amounts=(psi_b[ib], coneDOF, pitchDOF), rot_order='XYZ')
-    else:
-
-        # --- Rotor Only
-        if nDOF_sft==0:
-            ref.connectTo(rot, type='Rigid', rel_pos=(0,0,0), rot_amounts=(0,0,0), rot_order='ZYX')
-        else:
-            ref.connectTo(rot, type='Rigid', rel_pos=(0,0,0), rot_amounts=(0,0,q_psi), rot_order='ZYX')
-
-        print('>>> TODO TODO hub radius, and precone')
-        for ib,bld in enumerate(blds): 
-            print('x_RB', x_RB, 'z_RB',z_RB, psi_b[ib])
-            rot.connectTo(bld, type='Rigid', rel_pos=(x_RB, -z_RB*sin(psi_b[ib]), z_RB*cos(psi_b[ib])), rot_amounts=(psi_b[ib], coneDOF, pitchDOF), rot_order='XYZ')
-
-    # --------------------------------------------------------------------------------}
-    # --- bodies
-    # --------------------------------------------------------------------------------{
-    bodies           = []
-    if fnd is not None:
-        bodies+= [fnd]
-    if twr is not None:
-        bodies      += [twr]
-    if nac is not None:
-        bodies      += [nac]
-    if rot is not None:
-        bodies      += [rot]
-    for ib,bld in enumerate(blds):
-        bodies      += [bld]
-    if verbose:
-        print('>>> Bodies:')
-        for b in bodies:
-            print('name',b.name)
-
-    # --------------------------------------------------------------------------------}
-    # --- Kinetics
-    # --------------------------------------------------------------------------------{
-    body_loads       = []
-    g_vect           = -gravity * ref.frame.z
-    # --- Foundation/floater loads
-    if fnd is not None:
-        grav_F = (fnd.masscenter, -fnd.mass * gravity * ref.frame.z)
-        # Point of application for Buoyancy and mooring
-
-        P_O = twr.origin                                       # Body origin
-        #P_M = twr.origin.locatenew('P_M', z_TM * fnd.frame.z) # Mooring      <<<< Measured from T
-        P_M = twr.origin                                       # Mooring (transfered to tower origin)
-        #P_M = twr.origin.locatenew('P_M', z_TM * fnd.frame.z) # <<<< Measured from T
-        #P_0 = twr.origin.locatenew('P_0', (-z_OT) * twr.frame.z) # 0- sea level <<<< Measured from T
-        P_0 = twr.origin.locatenew('P_0', (-z_OT) * fnd.frame.z) # 0- sea level <<<< Measured from T
-        P_M.v2pt_theory(twr.origin, ref.frame, twr.frame); # PM & T are fixed in e_T
-        P_0.v2pt_theory(twr.origin, ref.frame, twr.frame); # P0 & T are fixed in e_T
-
-        if opts['moor_loads']:
-            #K_Mx, K_My, K_Mz          = symbols('K_x_M, K_y_M, K_z_M') # Mooring restoring
-            #K_Mphix, K_Mphiy, K_Mphiz = symbols('K_phi_x_M, K_phi_y_M, K_phi_z_M') # Mooring restoring
-            ### Restoring mooring and torques
-            #fr=0
-            #fr += -K_Mx * x *ref.frame.x if bFndDOFs[0] else 0
-            #fr += -K_My * y *ref.frame.y if bFndDOFs[1] else 0
-            #fr += -K_Mz * z *ref.frame.z if bFndDOFs[2] else 0
-            #Mr += -K_MPhix * phi_x *ref.frame.x if bFndDOFs[3] else 0
-            #Mr += -K_MPhiy * phi_y *ref.frame.y if bFndDOFs[4] else 0
-            #Mr += -K_MPhiz * phi_z *ref.frame.z if bFndDOFs[5] else 0
-            KMoorKeep=[(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(0,4),(1,5)]
-            DOFs=[x, y, z, phi_x, phi_y, phi_z]
-            fr, Mr, KM = stiffness6DOF(DOFs, ref.frame, label='KM', bDOFs=bFndDOFs, IKeep=KMoorKeep)
-            body_loads  += [(fnd, (P_M,  fr))]
-            body_loads  += [(fnd, (fnd.frame, Mr))]
-            print('>>> Adding mooring loads')
-
-        if opts['hydro_loads']:
-            # Hydro force
-            #F_B = dynamicsymbols('F_B') # Buoyancy force
-            F_hx, F_hy, F_hz = dynamicsymbols('F_hx, F_hy, F_hz') # Hydrodynamic force, function to time 
-            M_hx, M_hy, M_hz = dynamicsymbols('M_hx, M_hy, M_hz') # Hydrodynamic moment, function to time 
-            fh = F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z
-            Mh = M_hx * ref.frame.x + M_hy * ref.frame.y + M_hz * ref.frame.z
-            if model_name.find('hydroO')>1:
-                body_loads  += [(fnd, (P_O,  fh))] # NOTE: using P_O
-                print('>>> Adding hydro loads at Tower Origin')
-            else:
-                body_loads  += [(fnd, (P_0,  fh))] # NOTE: using P_0
-                print('>>> Adding hydro loads at Hydro 0-Point')
-            body_loads  += [(fnd, (fnd.frame, Mh))] 
-
-            ##P_0 = body.origin.locatenew('P_0', z_B0 * ref.frame.z) # 0- sea level <<<< Measured from T Does not work
-            ##P_0 = body.origin.locatenew('P_0', z_B0*cos(phi_y) * body.frame.z - z_B0*sin(phi_y) * body.frame.x) # 0- sea level <<<< Measured from T Does not Work
-            ## Hydro force
-            #if modelName.find('hydro0')>1:
-            #    model.addForce(body,  P_0,        F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z)
-            #elif modelName.find('hydroO')>1:
-            #    model.addForce(body,  P_O,        F_hx * ref.frame.x + F_hy * ref.frame.y + F_hz * ref.frame.z)
-            #else:
-            #    raise NotImplementedError()
-            #model.addMoment(body, body.frame, M_hx * ref.frame.x + M_hy * ref.frame.y + M_hz * ref.frame.z)
-
-
-        # Gravity
-        body_loads  += [(fnd,grav_F)]
-
-    # --- Tower loads
-    if twr is not None:
-        grav_T       = (twr.masscenter, -twr.mass * gravity * ref.frame.z)
-        body_loads  += [(twr,grav_T)]  
-
-    # --- Nacelle loads
-    if nac is not None:
-        grav_N = (nac.masscenter, -nac.mass * gravity * ref.frame.z)
-        body_loads  += [(nac,grav_N)]  
-
-
-    # --- Aero loads
-    T_a              = dynamicsymbols('T_a') # NOTE NOTE
-    #T_a              = Function('T_a')(dynamicsymbols._t, *coordinates, *speeds) # NOTE: to introduce it in the linearization, add coordinates
-    M_ax, M_ay, M_az = dynamicsymbols('M_x_a, M_y_a, M_z_a') # Aero torques
-    if bFullRNA:
-        if bBld:
-            # Gravity on blades
-            for ib,bld in enumerate(blds):
-                grav_B       = (bld.masscenter, -bld.mass * gravity * ref.frame.z)
-                body_loads  += [(bld,grav_B)]  
-
-            print('>>>> TODO aero/misc loads on blades')
-        else:
-            # Rotor loads
-            grav_R = (rot.masscenter, -M_R * gravity * ref.frame.z)
-            body_loads  += [(rot,grav_R)]  
-
-            # NOTE: loads on rot, but expressed in N frame
-            # TODO more than just thrust
-            if opts['tiltShaft']:
-                # TODO actually tilt shaft, introduce non rotating shaft body
-                #thrustR = (rot.origin, T_a *cos(tiltDOF) * nac.frame.x -T_a *sin(tiltDOF) * nac.frame.z)
-                fa_R = (rot.origin, T_a * rot.frame.x)
-                Ma_R = (rot.frame, M_ax*rot.frame.x )# TODO TODO
-            else:
-                fa_R = (rot.origin, T_a * nac.frame.x )
-                #thrustR = (rot.origin, T_a * rot.frame.x )
-                #M_a_R = (nac.frame, M_ax*nac.frame.x +  M_ay*nac.frame.y  + M_az*nac.frame.z) 
-                Ma_R = (rot.frame, M_ax*rot.frame.x +  M_ay*rot.frame.y  + M_az*rot.frame.z)  # TODO TODO TODO introduce a non rotating shaft
-            if opts['aero_forces']:
-                body_loads  += [(rot,fa_R)]
-            if opts['aero_torques']:
-                print('>>> Adding aero torques ')
-                body_loads+=[(nac, Ma_R)]
-
-    else:
-        # RNA loads, point load at R
-        R=Point('R')
-        R.set_pos(nac.origin, x_NR * nac.frame.x + z_NR* nac.frame.z)
-        R.set_vel(nac.frame, 0 * nac.frame.x)
-        R.v2pt_theory(nac.origin, ref.frame, nac.frame)
-        #thrustN = (nac.masscenter, T * nac.frame.x)
-        if opts['tiltShaft']:
-            thrustN = (R, T_a *cos(tiltDOF) * nac.frame.x -T_a *sin(tiltDOF) * nac.frame.z)
-        else:
-            thrustN = (R, T_a * nac.frame.x )
-        if opts['aero_forces']:
-            body_loads  += [(nac,thrustN)]
-
-        if opts['aero_torques']:
-            print('>>> Adding aero torques 3')
-            if opts['tiltShaft']:
-                # NOTE: for a rigid RNA we keep only M_y and M_z, no shaft torque
-                x_tilted = cos(tiltDOF) * nac.frame.x - sin(tiltDOF) * nac.frame.z
-                z_tilted = cos(tiltDOF) * nac.frame.y + sin(tiltDOF) * nac.frame.x
-                M_a_N = (nac.frame,                  M_ay*nac.frame.y + M_az*z_tilted) 
-            else:
-                M_a_N = (nac.frame, M_ax*nac.frame.x +  M_ay*nac.frame.y  + M_az*nac.frame.z)
-            body_loads  += [(nac, M_a_N)]  
-    if verbose:
-        print('>>> Loads:')
-        for (b,l) in body_loads:
-            print(b.name, l)
-
-    # --------------------------------------------------------------------------------}
-    # --- Kinematic equations 
-    # --------------------------------------------------------------------------------{
-    # --- Defining Body rotational velocities
-    if not bRotorOnly:
-        omega_TE = twr.ang_vel_in(ref)        # Angular velocity of nacelle in inertial frame
-        omega_NT = nac.ang_vel_in(twr.frame)  # Angular velocity of nacelle in inertial frame
-        if rot is not None:
-            omega_RN = rot.ang_vel_in(nac.frame)  # Angular velocity of rotor wrt Nacelle (omega_R-omega_N)
-    else:
-        # Rotor only
-        omega_RN = diff(q_psi, time) * ref.frame.x  # Angular velocity of rotor wrt Nacelle (omega_R-omega_N)
-
-
-    kdeqsSubs =[]
-    # --- Fnd
-    if not opts['floating']:
-        # fixed bottom
-        pass
-    else:
-        # Kdeqs for fnd: 
-        #  : (xd, diff(x,time)) and  (omega_y_T, diff(phi_y,time))
-        fndVelAll = [diff(x,time), diff(y,time),  diff(z,time)]
-        if opts['linRot']:
-            fndVelAll += [diff(phi_x,time), diff(phi_y,time),  diff(phi_z,time)]  
-        else:
-            #print('>>>>>>>> TODO sort out which frame')
-            #fndVelAll +=[ omega_TE.dot(ref.frame.x).simplify(), omega_TE.dot(ref.frame.y).simplify(), omega_TE.dot(ref.frame.z).simplify()]  
-            fndVelAll +=[ omega_TE.dot(twr.frame.x).simplify(), omega_TE.dot(twr.frame.y).simplify(), omega_TE.dot(twr.frame.z).simplify()]  
-        kdeqsSubs+=[ (fndSpeedsAll[i], fndVelAll[i]) for i,dof in enumerate(bFndDOFs) if dof] 
-
-    # --- Twr
-    if nDOF_twr>0:
-        kdeqsSubs +=[ (twr.qd[i], twr.qdot[i]) for i,_ in enumerate(twr.q)]; 
-
-    # --- Nac
-    kdeqsSubs+=nacKDEqSubs
-
-    # --- Shaft
-    if bFullRNA:
-        if bBld:
-            if nDOF_sft==1:
-                #print('>>>>>>>> TODO sort out which frame')
-                # I believe we should use omega_RE
-                if rot is None:
-                    kdeqsSubs+=[ (omega_x_R,  omega_RN.dot(ref.frame.x).simplify()) ]  
+                    #print('{} cross p={:8.3f} om={:8.3} Qa={:10.2f} WS0={:7.3f}'.format(len(WScross), pitch, omega, Qa, WS0), WScross)
+                    # Find WS based on OP
+                    if WSoper is not None:
+                        iNear = np.argmin(abs(WScross-WSoper))
+                    else:
+                        iNear = np.argmin(abs(WScross-WS0))
+                    WS_est = WScross[iNear] # TODO
+        #             import matplotlib.pyplot as plt
+        #             fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+        #             fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+        #             ax.plot(vWS, vQ, label='Omega = {:3.1f}'.format(omega))
+        #             ax.plot(vWS, Qa+vWS*0)
+        #             ax.set_xlabel('WS [m/s]')
+        #             ax.set_ylabel('Q [N]')
+        #             ax.set_xlim([0,30])
+        #             ax.set_ylim([0,2e7])
+        #             ax.legend()
+        #             plt.show()
+
+                # --- Use closest point
+                if WSoper is not None:
+                    WS_guess = (WSoper+WS0)/2
                 else:
-                    kdeqsSubs+=[ (omega_x_R,  omega_RN.dot(rot.frame.x).simplify()) ]  
-            if nDOF_bld>0:
-                for bld in blds:
-                    kdeqsSubs +=[ (bld.qd[i], bld.qdot[i]) for i,_ in enumerate(bld.q)]; 
-        else:
-            if nDOF_sft==1:
-                #print('>>>>>>>> TODO sort out which frame')
-                # I believe we should use omega_RE
-                kdeqsSubs+=[ (omega_x_R, omega_RN.dot(rot.frame.x).simplify()) ]  
-
-    if verbose:
-        print('>>> kdeqsSubs:', kdeqsSubs)
+                    WS_guess = WS0
+                if abs(WS_est - WS_guess) > deltaWSMax:
+                    #print('>>>', WS_est)
+                    dist = np.sqrt( ((vWS-WS_guess)/WS_guess)**2 + ((vQ-Qa)/Qa)**2 )
+                    i = np.argmin(dist)
+                    WS_est = vWS[i]
+
+                if debug:
+                    info['WS_cross'] = WScross
+                    info['iNear'] = iNear
+                    #info['cross_vQ'] = vQ
+                    #info['cross_vWS'] = vWS
+
+            
+
+
+
+#         if omega<self.OmegaRated*0.95:
+#             #  Below rated, we have the quasi steady ws as functin of omega as a best guess
+#             ws_qs=np.interp(omega,self.Omega,self.WS)
+#             if omega<self.OmegaLow:
+#                 WS1,residual = estim(WS0,3)
+#                 WS=(4*WS1+ws_qs)/5
+#             else:
+#                 WS,residual = estim(WS0,3)
+# 
+#             if np.abs(WS-ws_qs)>4:
+#                 WS,residual = estim(ws_qs,3, maxiter=1000)
+# 
+#             if np.abs(residual)/Qa>0.1:
+#                 WS,residual = estim(ws_qs, 17, maxiter=1000)
+# 
+#             if np.abs(residual)/Qa>0.1:
+#                 WS,residual = estim(ws_qs+10, 10, maxiter=1000)
+# 
+#             if np.abs(residual)/Qa>0.1:
+#                 if WSavg is not None:
+#                     print('NOT GOOD 1 - WS={:.1f} WSqs={:.1f} WSavg={:.1f} - om={:.2f} pitch={:.2f}'.format(WS,ws_qs,WSavg,omega,pitch))
+#                 else:
+#                     print('NOT GOOD 1 - WS={:.1f} WSqs={:.1f} - om={:.2f} pitch={:.2f}'.format(WS,ws_qs,omega,pitch))
+#         else:
+#             # above omega rated, we are between WSrated-3 and WSCutoff
+#             WS,residual = estim(WS0,3)
+#             if WS<self.WSRated:
+#                 WSmid=(self.WSCutOff+self.WSRated)/2
+#                 WS,residual = estim(WSmid, 16, maxiter=1000)
+# 
+# #                 if WSavg is not None:
+# #                     if np.abs(WS-WSavg)>4:
+# #                         WS,residual = estim(WSavg, 6, maxiter=1000)
+# 
+#             if np.abs(residual)/Qa>0.1:
+#                 print('NOT GOOD 2 - WS={:.1f} WS0={:.1f} - om={:.2f} pitch={:.2f}'.format(WS,WS0,omega,pitch))
+
+        WS = WS0*relaxation + (1-relaxation)*WS_est
+
+        if debug:
+            info['WS_est1'] = WS_est
+            info['WS_est2'] = WS
+            self._debug_info=info
+
+        return WS, info
+
+
+    def estimateTimeSeries(self, Qaero, Pitch, Omega, WS_prev=None, WS_ref=None, debug=False, **kwargs):
+        """ 
+        Perform wind speed estimation given a time series of aerodynamic torque, pitch and rotational speed
+        """
+        print('Estimating WS on time series...')
+        WS_est = np.zeros(Omega.shape)
+        if WS_prev is None:
+            WS_prev = 1
+        ts_info = None
+        if debug:
+            # Storage for debug
+            pass
+        for i,(Qa, pitch, omega) in enumerate(zip(Qaero, Pitch, Omega)):
+            ws_hat, info    = self.estimate(Qa, pitch, omega, WS_prev, debug=debug, **kwargs)
+            WS_est[i] = ws_hat
+            WS_prev   = ws_hat
+            if debug:
+                if WS_ref is not None:
+                    if abs(WS_est[i] - WS_ref[i])>6:
+                        print('[FAIL] Error too big:\n')
+                        info['WS_ref'] = WS_ref[i]
+                        self.debugPlot(info=info, HR=False)
+
+                        return WS_est, ts_info
+        return WS_est, ts_info
+
+    def estimateTimeSeriesFromOF(self, outFilename, tRange=None, **kwargs):
+        """" 
+         - tRange: tuple (tmin, tmax) to limit the time used
+        """
+        import welib.weio as weio
+        df = weio.read(outFilename).toDataFrame()
+        if tRange is not None:
+            df = df[np.logical_and(df['Time_[s]']>=tRange[0],df['Time_[s]']<=tRange[1])]
+        time       = df['Time_[s]'].values
+        WS_ref     = df['RtVAvgxh_[m/s]'].values # Rotor avg
+        Pitch      = df['BldPitch1_[deg]'].values
+        Qaero_ref  = df['RtFldMxh_[N-m]'].values
+        Omega      = df['RotSpeed_[rpm]'].values*2*np.pi/60 # rad/s
+        lambda_ref = Omega*self.R/WS_ref
+        # Estimating wind speed on time series
+        WS_est, ts_info = self.estimateTimeSeries(Qaero_ref, Pitch, Omega, WS_prev=WS_ref[0]*0.9, WS_ref=WS_ref, **kwargs)
+        # Evaluating torque
+        Qaero_eval = self.Torque(WS_ref, Pitch, Omega)
+        Qaero_est  = self.Torque(WS_est, Pitch, Omega)
+        # Storing data into a dataframe
+        M    = np.column_stack((time, WS_ref, WS_est, Qaero_ref, Qaero_eval, Qaero_est, Omega, Pitch))
+        cols = ['Time_[s]','WS_ref_[m/s]','WS_est_[m/s]','Qaero_ref_[N]','Qaero_eval_[N]','Qaero_est_[N]','Omega_[rad/s]','Pitch_[deg]']
+        dfOut = pd.DataFrame(data=M, columns=cols)
+        return dfOut
+
+    def debugPlot(self, info=None, HR=False):
+        from welib.tools.colors import python_colors
+
+
+        if info is None:
+            info = self._debug_info
+        for k,v in info.items():
+            print('{:15s}={}'.format(k,v))
+
+
+        pitch = info['pitch']
+        omega = info['omega']
+        Qa    = info['Qa']
+        WS_guess= info['WS0']
+        try:
+            WS_est= info['WS_est1']
+            Qeval1 = self.Torque(info['WS_est1'], pitch, omega)
+        except:
+            WS_est = None
+            Qeval1 = None
+        try:
+            WS_ref= info['WS_ref']
+        except:
+            WS_ref = None
+
+        WS0, Q0 = self.TorqueAt(Pitch=pitch, Omega=omega)
+        WS1, Q1 = self.TorqueAt(Pitch=pitch, Omega=omega*0.95)
+        WS2, Q2 = self.TorqueAt(Pitch=pitch, Omega=omega*1.05)
+
+
+        fig,ax = plt.subplots(1, 1, sharey=False, figsize=(6.4,4.8)) # (6.4,4.8)
+        fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
+        ax.plot(WS0   , Q0      , '-+', c=python_colors(0),       label='Interpolated data (at LambdaHR)')
+        ax.plot(WS1   , Q1      , '--', c=python_colors(0), alpha=0.5)
+        ax.plot(WS2   , Q2      , '--', c=python_colors(0), alpha=0.5)
+        if WS_ref is not None:
+            ax.plot(WS_ref, Qa      , 'ko',       label='Ref')
+        if WS_est is not None:
+            ax.plot(WS_est, Qeval1  , 'd', c=python_colors(1) , ms=5, label='Est.')
+        ax.plot(WS0   , WS0*0+Qa, 'k--',      label='Qa')
+        ax.plot([WS_guess, WS_guess], [np.min(Q0), np.max(Q0)], 'k:', label='WS guess/prev')
+
+        if 'WS_cross' in info.keys():
+            for iWS,WS in enumerate(info['WS_cross']):
+                ax.plot(WS, Qa  , '*' , c=python_colors(3), ms=4, label='Cross (n={})'.format(len(info['WS_cross'])) if iWS==0 else None)
+
+        if 'WS_crossOP' in info.keys():
+            for iWS,WS in enumerate(info['WS_crossOP']):
+                ax.plot(WS, Qa  , '^' , c=python_colors(4), ms=7, label='CrossOP (n={})'.format(len(info['WS_crossOP'])) if iWS==0 else None)
+            ax.plot(info['WS_oper'], Qa, 'o',  label='Oper', ms=4)
+
+            WSOP    = self.OP['WS_[m/s]'].values   #[m/s]
+            QaeroOP = self.OP['Qaero_[Nm]'].values #[Nm]
+            ax.plot(WSOP, QaeroOP, 'k--', label='OP')
+
+
+        if HR:
+            nHR=1000
+            WS_HR = np.linspace(WS0[0],WS0[-1],nHR)
+            Qeval_HR = self.Torque(WS_HR, [pitch]*nHR, [omega]*nHR)
+            ax.plot(WS_HR, Qeval_HR, 'k-', lw=0.5, label='High Res eval')
+        ax.set_xlabel('Wind Speed [m/s]')
+        ax.set_ylabel('Torque [N]')
+        ax.legend()
+
+    def __repr__(self):
+        s=''
+        s+='<ws_estimator.TabulatedWSEstimator object> \n'
+        s+=' - Lambda : [min={:8.3f}, max={:8.3f}, delta={:8.4f}, n={}]  \n'.format(np.min(self.Lambda),np.max(self.Lambda),self.Lambda[1]-self.Lambda[0], len(self.Lambda))
+        s+=' - Pitch  : [min={:8.3f}, max={:8.3f}, delta={:8.4f}, n={}]  \n'.format(np.min(self.Pitch) ,np.max(self.Pitch) ,self.Pitch[1]-self.Pitch[0]  , len(self.Pitch))
+        s+=' - CP     : [min={:8.3f}, max={:8.3f}, n={}x{}]  \n'.format(np.min(self.CP),np.max(self.CP),self.CP.shape[0],self.CP.shape[1])
+        if self.CT is not None:
+            s+=' - CT     : [min={:8.3f}, max={:8.3f}, n={}x{}]  \n'.format(np.min(self.CT),np.max(self.CT),self.CT.shape[0],self.CT.shape[1])
+        s+=' - R      : {}  \n'.format(self.R)
+        s+=' - rho    : {}  \n'.format(self.rho)
+        s+=' - OmegaLow:{}  \n'.format(self.OmegaLow)
+        # files
+        s+=' - fstFile:     {}  \n'.format(self.fstFile)
+        s+=' - aeroMapFile: {}  \n'.format(self.aeroMapFile)
+        s+=' - operFile:    {}  \n'.format(self.operFile)
+        return s
+
+
+if __name__=='__main__':
+    import pandas as pd
+    import matplotlib.pyplot as plt
+    from spectral import fft_wrap
+    import welib.weio as weio
+    # --- Parameters
+    # InputFile = 'GeneratorDynamics.outb'
+    InputFile = 'DLC120_ws13_ye000_s1_r1.outb'
+
+    # --- Turbine data
+    turbine = dict()
+    turbine['R']         = 63
+    turbine['rho']   = 1.225
+    g=9.81
+
+    # --- Reading aerodynamic data for the turbine
+    Pitch  = pd.read_csv('Pitch_data.csv',header  = -1).values
+    Lambda = pd.read_csv('Lambda_data.csv',header = -1).values
+    CP     = pd.read_csv('CP_data.csv',header     = -1).values
+    CT     = pd.read_csv('CT_data.csv',header     = -1).values
+    # Create the interpolant for CP and CT, CP(pitch,lambda) (same interface interp2d) 
+    turbine['fCP'] = interp2d_pairs(Pitch,Lambda,CP,kind='cubic')
+    turbine['fCT'] = interp2d_pairs(Pitch,Lambda,CT,kind='cubic')
+
+
+
+    # --- Reading in some "measuremensts" or "simulation"
+    # --- Removing units from columns
+    df=weio.read(InputFile).toDataFrame()
+    df.columns = [  v.split('_[')[0] for v in df.columns.values] 
+    time      = df['Time'].values
+    genspeed  = df['GenSpeed'].values * 2*np.pi/60 # converted to rad/s
+    rotspeed  = df['RotSpeed'].values * 2*np.pi/60 # converted to rad/s
+    thrust    = df['RotThrust']*1000
+    gentq     = df['GenTq']*1000*97                # Convert to rot torque
+    azimuth   = df['Azimuth']                      # deg
+    windspeed = df['Wind1VelX']
+    pitch     = df['BldPitch3']
+    rottorq   = df['RotTorq']*1000
+    rottorq2  = df['RtFldMxh']
+    thrust2   = df['RtFldFxh']
 
 
 
-    # --------------------------------------------------------------------------------}
-    # --- Create a YAMS wrapper model
-    # --------------------------------------------------------------------------------{
-    model = YAMSModel(name=model_name)
-    model.opts        = opts
-    model.ref         = ref
-    model.bodies      = bodies
-    model.body_loads  = body_loads
-    model.coordinates = coordinates
-    model.speeds      = speeds
-    model.kdeqsSubs   = kdeqsSubs
-    #print(model)
-
-    model.fnd=fnd
-    model.twr=twr
-    model.nac=nac
-    model.rot=rot
-    #model.sft=sft
-    model.blds=blds
-    model.g_vect=g_vect
-
-    # Small angles
-    model.smallAnglesFnd    = [phi_x,phi_y,phi_z]
-    if nDOF_twr>0:
-        if opts['rot_elastic_smallAngle']:
-            model.smallAnglesTwr    = twr.vcList
-        else:
-            model.smallAnglesTwr    = []
-    else:
-        model.smallAnglesTwr    = []
-
-    model.smallAnglesNac = []
-    if opts['yaw']=='dynamic':
-        model.smallAnglesNac += [q_yaw]
-    if opts['tilt']=='dynamic':
-        model.smallAnglesNac += [q_tilt]
-    model.smallAngles=model.smallAnglesFnd + model.smallAnglesTwr + model.smallAnglesNac
-
-    # Shape normalization
-    if nDOF_twr>0:
-        model.shapeNormSubs= [(v,1) for v in twr.ucList]
-    else:
-        model.shapeNormSubs= []
 
-    return model
+    # --- Evaluate the interpolant on each pairs of x and y values
+    F = Taero(windspeed, pitch, rotspeed, turbine['R'], turbine['rho'], turbine['fCT'])
+    
+    Q = Qaero(windspeed, pitch, rotspeed, turbine['R'], turbine['rho'], turbine['fCP'])
+    
+    # --- normalize F, Q, rottorq2 and thrust2 to imrpove spectra analysis
+    Fnorm = F - np.average(F)
+    Qnorm = Q - np.average(Q)
+    thrust2norm = thrust2 - np.average(thrust2)
+    rottorq2norm = rottorq2 - np.average(rottorq2)
+    # --- Import functio for calculating spectra from Q and F data
+#    f1, S1, Info  = fft_wrap(time,Fnorm,output_type='amplitude',averaging='Welch')
+#    f2, S2, Info  = fft_wrap(time,rottorq2norm,output_type='amplitude',averaging='Welch')
+    f1, S1, Info  = fft_wrap(time,Fnorm,output_type='PSD',averaging='Welch')
+    f2, S2, Info  = fft_wrap(time,thrust2norm,output_type='PSD',averaging='Welch')
+    
+    
+    
+    # --- Figures
+    
+    # -- Figure 1: Qaero
+    plt.figure(num=1, figsize=(11, 6), dpi=80, facecolor='w', edgecolor='k')
+    plt.plot(time,Q/1000,'r--',label='Qaero calc')
+    plt.plot(time,rottorq2/1000,'k',label = 'Qaero fast')
+    plt.gca().legend()
+    plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
+    plt.xlabel('time (s)')
+    plt.ylabel('Qaeo (kN.m)')
+    
+    # --- Figure 2: Faero
+    plt.figure(num=2, figsize=(11, 6), dpi=80, facecolor='w', edgecolor='k')
+    plt.plot(time,F      ,'c--',label='Faero calc')
+    plt.plot(time,thrust2,'m'  ,label='Faero (FAST)')
+    plt.plot(time,thrust ,'b:' ,label='Faero (FAST Fstruct - Fweight)')
+    plt.gca().legend()
+    plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
+    plt.xlabel('time (s)')
+    plt.ylabel('Faero (kN)')
+
+    # --- Figure 3: Spectra between Faero calc and Faero FAST
+    plt.figure(num=3, figsize=(11, 6), dpi=80, facecolor='w', edgecolor='k')
+    plt.plot(f1,S1,'r:',label='Faero calc')
+    plt.plot(f2,S2,'k--',label='Faero (FAST)')
+    plt.gca().legend()
+    plt.axvline(x=.201)
+    plt.axvline(x=3*.201)
+    plt.axvline(x=9*.201)
+    
+    plt.xlim([-.0001, 5])
+    plt.xlabel('Frequency (Hz)')
+    plt.ylabel('Power Spectral Density (Welch Avg.)') 
+    plt.yscale('log')
```

### Comparing `welib-0.0.2/welib/yams/models/FTNSB_sympy_symbols.py` & `welib-1.0.0/welib/yams/models/FTNSB_sympy_symbols.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/models/OneRigidBody_sympy.py` & `welib-1.0.0/welib/yams/models/OneRigidBody_sympy.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,28 +13,29 @@
     'Mform'  : 'TaylorExpanded', # 'symbolic',or 'TaylorExpanded'
     'linRot' : False,              #<<< Very important if True will assume that omegas are time derivatives of DOFs
     'loads':False, # Add loads on the foundation (restoring and buoyancy)
     'orderMM':2, #< order of taylor expansion for Mass Matrix
     'orderH':2,  #< order of taylor expansion for H term
     'rotOrder':'XYZ',  #< 
     'CG_on_z':False,  #< 
-    'J_cross':True,  #< 
+    'J_form':'cross',  #< 
     'J_at_Origin':False,  #< 
     'NoDOFImpliesNoSpeed':False,  #< if the DOF is not active, then its derivative and accelerations (arising from rotation of COG) are zeroed
+    'extraRot':(0,0,0)
 }
 
 
 time = symbols('t')
 phi_x, phi_y, phi_z       = dynamicsymbols('phi_x, phi_y, phi_z')
 x, y, z                   = dynamicsymbols('x, y, z')
 xd, yd, zd                = dynamicsymbols('xd, yd, zd')                # dynamicsymbols('x, y, z',1)
 omega_x, omega_y, omega_z = dynamicsymbols('omega_x, omega_y, omega_z')
-M_B                       = symbols('M_B')                              # Masses: Foundation/Tower/Nacelle/Rotor
-Jxx_B, Jyy_B, Jzz_B       = symbols('Jxx_B, Jyy_B, Jzz_B')              # NOTE: JO                                                = Jyy = Jzz for a three bladed rotor!
-x_BG, y_BG, z_BG          = symbols('x_BG, y_BG, z_BG')                # Position of Foundation COG in F, measured from point T
+# M_B                       = symbols('M_B')                              # Masses: Foundation/Tower/Nacelle/Rotor
+# Jxx_B, Jyy_B, Jzz_B       = symbols('Jxx_B, Jyy_B, Jzz_B')              # NOTE: JO                                                = Jyy = Jzz for a three bladed rotor!
+# x_BG, y_BG, z_BG          = symbols('x_BG, y_BG, z_BG')                # Position of Foundation COG in F, measured from point T
 
 J_O, J_zz        = symbols('J_O, J_zz')    # NOTE: JO                                                = Jyy = Jzz for a three bladed rotor!
 
 def get_model_one_body(model_name, **opts):
     """ 
 
     model: string defining model
@@ -45,19 +46,20 @@
     """
 
     for k,v in _defaultOpts.items():
         if k not in opts.keys():
             opts[k]=v
     for k,v in opts.items():
         if k not in _defaultOpts.keys():
-            print('Key {} not supported for model options.'.format(k))
+            raise Exception('Key {} not supported for model options.'.format(k))
     #print(opts)
 
     # Extract info from model name
-    s= model_name[1:]
+    sB = model_name[0].upper()
+    s  = model_name[1:]
     if len(s)==1:
         nDOF_body   = int(s[0])
         bDOFs   = [False]*6
         bDOFs[0]=nDOF_body>=1 # x
         bDOFs[4]=nDOF_body>=2 # phiy
         bDOFs[2]=nDOF_body==3 or nDOF_body==6 # z
         bDOFs[1]=nDOF_body>=5 # y
@@ -65,20 +67,22 @@
         bDOFs[5]=nDOF_body>=5 # phi_z
     else:
         bDOFs=[s=='1' for s in s[:6]]
         nDOF_body  = sum(bDOFs)
 
     print('body',','.join(['1' if b else '0' for b in bDOFs]))
 
+    x_BG, y_BG, z_BG  = symbols('x_{}G, y_{}G, z_{}G'.format(sB,sB,sB))                # Position of Foundation COG in F, measured from point T
+
     # --- Isolated bodies 
     ref = YAMSInertialBody('E') 
     if opts['CG_on_z']:
-        body = YAMSRigidBody('B', rho_G = [0,0,z_BG], J_diag=True, J_cross=opts['J_cross'], J_at_Origin=opts['J_at_Origin']) 
+        body = YAMSRigidBody(sB, rho_G = [0,0,z_BG], J_form=opts['J_form'], J_at_Origin=opts['J_at_Origin']) 
     else:
-        body = YAMSRigidBody('B', rho_G = [x_BG,y_BG,z_BG], J_diag=True, J_cross=opts['J_cross'], J_at_Origin=opts['J_at_Origin'])
+        body = YAMSRigidBody(sB, rho_G = [x_BG,y_BG,z_BG], J_form=opts['J_form'], J_at_Origin=opts['J_at_Origin'])
     #print(body)
 
     # --- Body DOFs
     bodyDOFsAll    = [x, y, z, phi_x,     phi_y,       phi_z]
     bodySpeedsAll  = [xd,yd,zd,omega_x,omega_y,omega_z]
     bodyDOFs    = [dof for active,dof in zip(bDOFs,bodyDOFsAll)   if active]
     bodySpeeds  = [dof for active,dof in zip(bDOFs,bodySpeedsAll) if active]
@@ -86,17 +90,17 @@
     coordinates = bodyDOFs   
 
     # --- Connections between bodies
     rel_pos=[0,0,0]
     rel_pos[0] = x      if bDOFs[0] else 0
     rel_pos[1] = y      if bDOFs[1] else 0
     rel_pos[2] = z      if bDOFs[2] else 0
-    rPhix= phi_x if bDOFs[3] else 0
-    rPhiy= phi_y if bDOFs[4] else 0
-    rPhiz= phi_z if bDOFs[5] else 0
+    rPhix= phi_x + opts['extraRot'][0] if bDOFs[3] else 0
+    rPhiy= phi_y + opts['extraRot'][1] if bDOFs[4] else 0
+    rPhiz= phi_z + opts['extraRot'][2] if bDOFs[5] else 0
     print('Free connection ref', rel_pos, (rPhix,rPhiy,rPhiz))
     print('>>>>>>>>>>>> ORDER IMPORTANT')
     #ref.connectTo(body, type='Free' , rel_pos=rel_pos, rot_amounts=(rPhiy,rPhix,rPhiz), rot_order='YXZ')  
     #ref.connectTo(body, type='Free' , rel_pos=rel_pos, rot_amounts=(rPhiz,rPhiy,rPhix), rot_order='ZYX')  
     if opts['rotOrder']=='XYZ': # Bryant
         ref.connectTo(body, type='Free' , rel_pos=rel_pos, rot_amounts=(rPhix,rPhiy,rPhiz), rot_order='XYZ')  
     else:
```

### Comparing `welib-0.0.2/welib/yams/models/generator.py` & `welib-1.0.0/welib/yams/models/generator.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/models/generator_oneRigidBody.py` & `welib-1.0.0/welib/yams/models/generator_oneRigidBody.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 import os
 import numpy as np
 # Local
 from welib.yams.models.utils import stiffness6DOF
 from welib.yams.models.OneRigidBody_sympy import *  # get_model_one_body, x, phi_x, xd, omega_x, x_BG, Jxx_B, M_B, etc
 
 def generateOneRigidBodyModel(modelName, packageDir='py', texDir='tex', fullPage=True,
-        CG_on_z=False, # <<<, 
+        CG_on_z=False, J_form='diag',# <<<, 
         KMoorKeep=[(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(0,4),(1,5)], 
         silentTimer=True,
         IMU=True
         ):
     """
     Generate python package for typical models
     """
@@ -65,21 +65,21 @@
         #opts['tiltShaft']    = True    # OpenFAST tilts shaft not nacelle
         ##opts['linRot']       = False    # Linearize rotations matrices from the beginning
         #opts['linRot']       = True    # Linearize rotations matrices from the beginning
         #opts['Mform']        = 'symbolic'  # or 'TaylorExpanded'
         #opts['twrDOFDir']    = ['x','y','x','y']  # Order in which the flexible DOF of the tower are set
 
         model = get_model_one_body(modelName, linRot=False, orderMM=1, orderH=1, 
-                                   J_cross=False, CG_on_z=CG_on_z, J_at_Origin=True)
+                                   J_form=J_form, CG_on_z=CG_on_z, J_at_Origin=True)
 
     elif 'moor' in modelName or 'hydro' in modelName:
 #     if modelName in  H0Models+HOModels:
         # --- Hydro/Mooring Dynamic Load
         model = get_model_one_body(modelName, linRot=False, orderMM=1, orderH=1, 
-                                   J_cross=False, CG_on_z=CG_on_z, J_at_Origin=True)
+                                   J_form=J_form, CG_on_z=CG_on_z, J_at_Origin=True)
         body = model.body
         ref  = model.ref
         # Points
         z_B0= symbols('z_B0')
         z_BM= symbols('z_BM')
         z_B0= symbols('z_B0')
         P_0 = body.origin.locatenew('P_0', z_B0 * body.frame.z) # 0- sea level <<<< Measured from T
```

### Comparing `welib-0.0.2/welib/yams/models/packman.py` & `welib-1.0.0/welib/yams/models/packman.py`

 * *Files 2% similar despite different names*

```diff
@@ -64,17 +64,22 @@
     # Storing
     sysNL._M0       = MM0
     sysNL._forcing0 = forcing0.ravel()
 
     # Create a Mechanical System
     sysNL = MechSystem(fM, F=fF, x0=q0, xdot0=qd0 )
     # Integrate in time
-    resNL = sysNL.integrate(time, method='RK45')
+    resNL, _ = sysNL.integrate(time, method='RK45')
     # Store in a nice dataframe, potentially with acceleration and forcing
-    dfNL = sysNL.toDataFrame(acc=acc, forcing=forcing, **kwargs)
+    calc=''
+    if acc:
+        calc+='xdd,'
+    if forcing:
+        calc+='f,'
+    dfNL = sysNL.res2DataFrame(resNL, calc=calc, **kwargs)
 
     # TODO point accelerations, additional outputs etc.
 
     return resNL, sysNL, dfNL
 
 
 # --------------------------------------------------------------------------------}
@@ -102,15 +107,15 @@
         print('[WARN] py_lin: Setting all input operating points to 0')
         uop=dict() # Inputs at operating points
         for key in info['su']:
             uop[key]= 0 
 
     # --- Initial conditions (with op)
     q0  = dq0 + qop
-    qd0 = dq0 + qdop
+    qd0 = dqd0 + qdop
 #     dq0  = self.q0  - qop
 #     dqd0 = self.qd0 - qdop
     print('q0  :',q0)
     print('qd0 :',qd0)
     print('qop :',qop)
     print('qdop:',qdop)
     print('uop: ',uop)
@@ -127,16 +132,16 @@
     if MCKextra is not None:
         Me, Ce, Ke = MCKextra
         M_lin += Me
         C_lin += Ce
         K_lin += Ke
     print('B_lin\n',B_lin)
     if noBlin:
-        n=B_lin.shape[1]
-        B_lin[:n,:n] = np.eye(n)
+        n,m=B_lin.shape
+        B_lin = np.eye(max(n,m))[:n,:m]
         print('B_lin\n',B_lin)
 
     if MCKu is not None:
         Mu, Cu, Ku = MCKu
         M_lin += B_lin.dot(Mu)
         C_lin += B_lin.dot(Cu)
         K_lin += B_lin.dot(Ku)
@@ -207,24 +212,24 @@
     Example of calculation for dq and dqd
              dq  = ((np.max(dfFS[sq]) -np.min(dfFS[sq]))/100).values
              dqd = ((np.max(dfFS[sqd])-np.min(dfFS[sqd]))/100).values
     """
     if qd0 is None:
         qd0=np.asarray(q0)*0
 
-    fh = AccelerationP_IMU
-    f0 = fh(q0, qd0, p, u, pkg)
+    fh = lambda q,qd : AccelerationP_IMU(q,qd,p,u,pkg)
+    f0 = fh(q0, qd0) #, p, u, pkg)
     if method=='finiteDifferences':
         # --- Method 1 Finite differences
         from welib.system.linearization import numerical_jacobian
         qdd0 = q0*0
         if dq is None or dqd is None:
             raise Exception('dq and dqd need to be provided when using finite differences')
-        Kacc = numerical_jacobian(fh, (q0,qd0), 0, dq  , p, pkg)
-        Cacc = numerical_jacobian(fh, (q0,qd0), 1, dqd , p, pkg)
+        Kacc = numerical_jacobian(fh, (q0,qd0), 0, dq )
+        Cacc = numerical_jacobian(fh, (q0,qd0), 1, dqd)
     elif method=='packageJacobians':
         # --- Method 2 pkg
         Ma,Ca,Ka = pkg.AccLinP_IMU(q=q0, qd=qd0, p=p)
         M    = pkg.M_lin(q0,p)
         Minv = np.linalg.inv(M)
         K    = pkg.K_lin(q0,qd0,p,uop)
         C    = pkg.C_lin(q0,qd0,p,uop)
```

### Comparing `welib-0.0.2/welib/yams/models/simulator.py` & `welib-1.0.0/welib/yams/models/simulator.py`

 * *Files 13% similar despite different names*

```diff
@@ -13,28 +13,35 @@
 
 
 # --------------------------------------------------------------------------------}
 # --- Helper functions 
 # --------------------------------------------------------------------------------{
 
 
-def _loadOFOut(filename, tMax=None):
+def _loadOFOut(filename, tMax=None, tRange=None):
+    """ see also welib.fast.linmodel """
     ext = os.path.splitext(filename)[1].lower()
     if ext=='.fst':
         if os.path.exists(filename.replace('.fst','.outb')): 
             dfFS = weio.read(filename.replace('.fst','.outb')).toDataFrame()
         elif os.path.exists(filename.replace('.fst','.out')): 
             dfFS = weio.read(filename.replace('.fst','.out')).toDataFrame()
         else:
             raise Exception('Cannot find an OpenFAST output file near: {}'.format(filename))
     else:
         dfFS = weio.read(filename).toDataFrame()
     if tMax is not None:
         dfFS=dfFS[dfFS['Time_[s]']<tMax]
+    if tRange is not None:
+        dfFS = dfFS[np.logical_and(dfFS['Time_[s]']>=tRange[0],dfFS['Time_[s]']<=tRange[1])]
     time =dfFS['Time_[s]'].values
+    dfFS.reset_index(inplace=True)
+
+    # Remove duplicate
+    dfFS = dfFS.loc[:,~dfFS.columns.duplicated()].copy()
     return dfFS, time
 
 
 def hydroMatToSysMat(M, su, sq=None):
     """ 
     Returns a dataframe with row "su" and columns "sq", filling in the 6x6 hydro matrix where necessary
     """
@@ -89,30 +96,73 @@
 
 # --------------------------------------------------------------------------------}
 # --- SimulatorFromOF 
 # --------------------------------------------------------------------------------{
 class SimulatorFromOF():
     def __init__(self, WT=None, fstFilename=None, modelName=None, packageDir=''):
 
+        # --- Main Data
+        self.u           = None
+        self.du          = None
+        self.uop         = None
+        self.qop         = None
+        self.qdop        = None
+        self.WT          = None
+        self.fstFilename = None
+        self.modeName    = None
+        self.packageDir  = None
+        self.sysLI       = None
+        self.sysNL       = None
+        self.dfNL = None
+        self.dfLI = None
+        self.dfFS = None
+        self.time = None
+
+
         # --- Load the wind turbine model, NOTE relevant parameters "p" are in WT.yams_parameters()
         if WT is not None:
             self.WT = WT
             self.fstFilename = WT.FST.filename
         else:
             self.WT = FASTWindTurbine(fstFilename, twrShapes=[0,2], nSpanTwr=50)  # TODO
             self.fstFilename = fstFilename
 
-        self.dfNL = None
-        self.dfLI = None
         # --- Import the python module that was generated
         self.modelName=modelName
         if modelName is not None:
             self.loadPackage(modelName, packageDir)
             self.WT.checkPackage(self.pkg)
 
+
+    def __repr__(self):
+        s='<YAMS {} object>:\n'.format(type(self).__name__)
+        s+=' - fstFilename: {} \n'.format(self.fstFilename)
+        s+=' - modelName: {} \n'.format(self.modelName)
+        s+=' - packageDir: {} \n'.format(self.packageDir)
+        s+=' - u:    {} \n'.format(self.u) # TODO
+        s+=' - du:   {} \n'.format(self.du) # TODO
+        s+=' - uop:  {} \n'.format(self.uop)
+        s+=' - qop:  {} \n'.format(self.qop)
+        s+=' - qdop: {} \n'.format(self.qdop)
+        s+=' object attributes: \n'
+        s+=' - WT, sysLI, sysNL, qdop \n'
+        if self.sysLI is not None:
+            s+=' * M_lin, K_lin, C_lin, B_lin, forcing0_lin\n'
+            s+=' * q0_lin:   {} \n'.format(self.q0_lin)
+        if self.sysNL is not None:
+            s+=' * M0, forcing0 \n'
+            s+=' * q0    :   {} \n'.format(self.q0)
+        s+=' useful functions:  \n'
+        s+='  - setupSim: setup a simulation based on a fst/out file\n'
+        s+='  - loadPackage: load a YAMS package\n'
+        s+='  - unloadPackage: unload a YAMS package\n'
+        return s
+
+
+
     def loadPackage(self, modelName=None, packageDir='', packagePath=None):
         pkg, packagePath=loadPackage(modelName=modelName, packageDir=packageDir, packagePath=packagePath)
         self.pkg          = pkg
         self._packagePath = packagePath
         self.info         = self.pkg.info()
 
     def unloadPackage(self):
@@ -120,14 +170,15 @@
         self.info=None
 
     def reloadPackage(self):
         self.unloadPackage()
         self.loadPackage(packagePath=self._packagePath)
 
     def setupSim(self, outFile=None, tMax=None, **kwargs):
+        # TODO: Harmonize with fast.linmodel
         # --- Load Reference simulation
         if outFile is None:
             self.dfFS, self.time = _loadOFOut(self.fstFilename, tMax)
         else:
             self.dfFS, self.time = _loadOFOut(outFile, tMax)
 
         # --- Initial inputs to zero
@@ -138,14 +189,20 @@
         if self.modelName[0]=='B':
             self.p = self.WT.yams_parameters(flavor='onebody',**kwargs)
         else:
             self.p = self.WT.yams_parameters(**kwargs)
 
         return self.time, self.dfFS, self.p
 
+    # --------------------------------------------------------------------------------}
+    # --- INPUTS
+    # --------------------------------------------------------------------------------{
+    # From welib.system.statespace.py
+    #def setInputTimeSeries(self, vTime, vU):
+    #def setInputFunction(self, fn, signature_u=None):
 
     def _zeroInputs(self):
         """ 
         u:   dictionary of functions of time
         uop: dictionary
         du : nu x nt array, time series of time
         """
@@ -265,15 +322,15 @@
     def M0(self): return self.sysNL._M0
     @property
     def forcing0(self): return self.sysNL._forcing0
     @property
     def q0(self): return self.sysNL.q0
 
 
-    def plot(self, export=False, nPlotCols=2, prefix='', fig=None, figSize=(12,10), title=''):
+    def plot(self, export=False, nPlotCols=2, prefix='', fig=None, figSize=(12,10), title='', dfFSlin=None):
         from welib.tools.colors import python_colors
         # --- Simple Plot
         dfNL = self.dfNL
         dfLI = self.dfLI
         dfFS = self.dfFS
         if dfLI is None and dfNL is None:
             df = dfFS
@@ -293,27 +350,32 @@
             fig.subplots_adjust(left=0.07, right=0.98, top=0.955, bottom=0.05, hspace=0.20, wspace=0.33)
         for i,ax in enumerate((np.asarray(axes).T).ravel()):
             if i+1>=len(df.columns):
                 continue
             chan=df.columns[i+1]
             if dfNL is not None:
                 if chan in dfNL.columns:
-                    ax.plot(dfNL['Time_[s]'], dfNL[chan], '-'  , label='non-linear', c=python_colors(0))
+                    ax.plot(dfNL['Time_[s]'], dfNL[chan], '-'  , label='WELIB non-linear', c=python_colors(0))
                 else:
-                    print('Missing column in NL: ',chan)
+                    print('simulator: plot: Missing column in NL          : ',chan)
             if dfLI is not None:
                 if chan in dfLI.columns:
-                    ax.plot(dfLI['Time_[s]'], dfLI[chan], '--' , label='linear', c=python_colors(1))
+                    ax.plot(dfLI['Time_[s]'], dfLI[chan], '--' , label='WELIB linear', c=python_colors(1))
                 else:
-                    print('Missing column in Lin: ',chan)
+                    print('simulator: plot: Missing column in Lin         : ',chan)
+            if dfFSlin is not None:
+                if chan in dfFSlin.columns:
+                    ax.plot(dfFSlin['Time_[s]'], dfFSlin[chan], '-.' , label='OpenFAST lin', c=python_colors(2))
+                else:
+                    print('simulator: plot: Missing column in Lin OpenFAST: ',chan)
             if dfFS is not None:
                 if chan in dfFS.columns:
-                    ax.plot(dfFS['Time_[s]'], dfFS[chan], 'k:' , label='OpenFAST')
+                    ax.plot(dfFS['Time_[s]'], dfFS[chan], 'k:' , label='OpenFAST non-linear')
                 else:
-                    print('Missing column in OpenFAST: ',chan)
+                    print('simulator: plot: Missing column in OpenFAST    : ',chan)
             ax.set_xlabel('Time [s]')
             ax.set_ylabel(chan)
             ax.tick_params(direction='in')
             if i==0:
                 ax.legend()
 
         # Scale axes if tiny range
@@ -325,61 +387,80 @@
         fig.suptitle(title)
 
         if export:
             fig.savefig(self.fstFilename.replace('.fst','{}_yamsSim.png'.format(prefix)))
 
         return fig
 
-    def save(self, filename=None, prefix=''):
+    def save(self, filename=None, prefix='', suffix='', **kwargs):
         if filename is None:
-            filename = self.fstFilename.replace('.fst','{}_yamsSim.pkl'.format(prefix))
+            parentDir= os.path.dirname(self.fstFilename)
+            base     = os.path.splitext(os.path.basename(self.fstFilename))[0]
+            filename = os.path.join(parentDir, prefix+base+suffix+'_yamsSim.pkl')
+
+        if self.sysNL is not None:
+            self.sysNL.picklable()
+        if self.sysLI is not None:
+            self.sysLI.picklable()
 
-        import pickle
         D={'dfNL':self.dfNL, 'dfLI':self.dfLI, 'dfFS':self.dfFS, 'p':self.p}
+        D['sysLI']=self.sysLI
+        D['sysNL']=self.sysNL
+        D.update(kwargs)
+        print(D.keys())
         print('>>> Export to:',filename)
+        import pickle
         pickle.dump(D,  open(filename,'wb'))
 
     # --------------------------------------------------------------------------------}
     # --- Model specific
     # --------------------------------------------------------------------------------{
-    def setPrescribedHydroInputs(self, zRef=None, meanMhy=False):
-        """ Set inputs based on OpenFAST"""
+    def setPrescribedHydroInputs(self, zRef=None, meanMhy=False, forceTransfer=False):
+        """ 
+        Set inputs "u" based on OpenFAST HydroFxi etc time series
+        """
         dfFS    = self.dfFS
         p       = self.p
         time    = self.time
         u       = self.u
         uop     = self.uop
         du      = self.du
         if zRef is None:
             if self.modelName[0]=='B':
                 zRef =  self.p['z_B0']
             else:
                 zRef =  -self.p['z_OT'] 
         P_HDRef = np.array((0,0,0))
         P_EDRef = np.array((0,0,zRef))
 
-        if 'hydro0' in self.modelName:
-            print('>>> Precribed Hydro Loads at ',(0,0,0))
-        elif 'hydroO' in self.modelName:
-            print('>>> Precribed Hydro Loads at ',(0,0,zRef), 'NOTE: WEIRD SIGN<<<<<< TODO TODO TODO TODO')
+        if 'hydro0' in self.modelName and (not forceTransfer):
+            print('setInputs: >>> Precribed Hydro Loads at ',(0,0,0), '(Using HydroFxi etc directly)')
+        elif 'hydroO' in self.modelName or (forceTransfer):
+            print('setInputs: >>> Precribed Hydro Loads at ',(0,0,zRef), '(Transfering HydroFxi Loads to ref point) NOTE: WEIRD SIGN<<<<<< TODO TODO TODO TODO')
             from welib.FEM.utils import transferRigidLoads
             from welib.yams.utils import transferLoadsZPoint
             # Input loads are at the body origin (ED ref point)
             cols = ['HydroFxi_[N]', 'HydroFyi_[N]', 'HydroFzi_[N]', 'HydroMxi_[N-m]', 'HydroMyi_[N-m]', 'HydroMzi_[N-m]']
             if 'Q_R_[rad]' in dfFS.columns:
                 vphi_x = dfFS['Q_R_[rad]']
             else:
                 vphi_x = dfFS['PtfmRoll_[deg]'].values*np.pi/180
             if 'Q_P_[rad]' in dfFS.columns:
                 vphi_y = dfFS['Q_P_[rad]']
             else:
                 vphi_y = dfFS['PtfmPitch_[deg]'].values*np.pi/180
+            if 'Q_Y_[rad]' in dfFS.columns:
+                vphi_z = dfFS['Q_Y_[rad]']
+            else:
+                vphi_z = dfFS['PtfmYaw_[deg]'].values*np.pi/180
             M = dfFS[cols].values
             #MT = transferRigidLoads(M.T, P_HDRef, P_EDRef).T
-            MT = transferLoadsZPoint(M.T, zRef, vphi_x, vphi_y).T
+            #MT = transferLoadsZPoint(M.T, zRef, vphi_x, vphi_y, vphi_z, rot_type='smallRot_OF').T
+            #MT = transferLoadsZPoint(M.T, zRef, vphi_x, vphi_y, vphi_z, rot_type='smallRot').T
+            MT = transferLoadsZPoint(M.T, zRef, vphi_x, vphi_y, vphi_z, rot_type='default').T
             dfFS = pd.DataFrame(data=MT, columns=cols)
         else:
             raise NotImplementedError()
 
         # Input loads are at the "0" hydro point
         u['F_hx'] = lambda t,q=None,qd=None: np.interp(t, time, dfFS['HydroFxi_[N]'])
         u['F_hy'] = lambda t,q=None,qd=None: np.interp(t, time, dfFS['HydroFyi_[N]'])
```

### Comparing `welib-0.0.2/welib/yams/models/utils.py` & `welib-1.0.0/welib/yams/models/utils.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.fst` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.outb` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.outb`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Spar_ED_ForED.dat` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Spar_ED_ForED.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F0T2N0S1_yams_model.py` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F0T2N0S1_yams_model.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.fst` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.fst`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.outb` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.outb`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Spar_ED_ForED.dat` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Spar_ED_ForED.dat`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/papers/2022-symbolic-framework/F2T1RNA_yams_model.py` & `welib-1.0.0/welib/yams/papers/2022-symbolic-framework/F2T1RNA_yams_model.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/rotations.py` & `welib-1.0.0/welib/yams/rotations.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,15 +4,52 @@
  - BodyZXZ : Euler 
  - BodyXYZ : Bryant 
  - BodyZYX :  
 """
 import numpy as np
 from numpy import cos, sin, tan, arccos, trace
 
+# --- Definitions to ease comparison with sympy versions
+def Matrix(m):
+    return np.asarray(m)
 
+# --------------------------------------------------------------------------------}
+# --- Wrapper Function 
+# --------------------------------------------------------------------------------{
+def rotMat(p, rot="smallRot_OF"):
+    """ NOTE: this is a body to parent, not DCM """
+    if  rot == 'smallRot_OF':
+        R_b2p = smallRot_OF(p[0], p[1], p[2]).T 
+
+    elif rot =='bodyXYZ':
+        R_b2p = BodyXYZ_A(p[0], p[1], p[2])
+
+    elif rot =='bodyZXZ':
+        R_b2p = BodyZXZ_A(p[0], p[1], p[2]) #def BodyZXZ_A(phi, theta, psi):
+
+    elif rot =='bodyZYX':
+        R_b2p = BodyZYX_A(p[0], p[1], p[2]) #def BodyZYX_A(phi_x, phi_y, phi_z)
+
+    elif rot =='EulerP':
+        R_b2p = EulerP_A(p[0], p[1], p[2], p[3])
+    else:
+        raise NotImplementedError('Rotation type {}'.format(rot))
+    return R_b2p
+
+# --------------------------------------------------------------------------------}
+# --- Rotation matrices
+# --------------------------------------------------------------------------------{
+def R_x(t):
+    return Matrix( [[1,0,0], [0,cos(t),-sin(t)], [0,sin(t),cos(t)]])
+
+def R_y(t):
+    return Matrix( [[cos(t),0,sin(t)], [0,1,0], [-sin(t),0,cos(t)] ])
+
+def R_z(t): 
+    return Matrix( [[cos(t),-sin(t),0], [sin(t),cos(t),0], [0,0,1]])
 
 # --------------------------------------------------------------------------------}
 # --- Euler parameters 
 # --------------------------------------------------------------------------------{
 def EulerP_A(e0,e1,e2,e3):
     """ Transformation matrix body to global for Euler parameters
     Shabana (2.33), Nikravesh (6.19)
```

### Comparing `welib-0.0.2/welib/yams/sid.py` & `welib-1.0.0/welib/yams/sid.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_bodies.py` & `welib-1.0.0/welib/yams/tests/test_bodies.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_flexibility.py` & `welib-1.0.0/welib/yams/tests/test_flexibility.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_rotations.py` & `welib-1.0.0/welib/yams/tests/test_rotations.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_sectionloads.py` & `welib-1.0.0/welib/yams/tests/test_sectionloads.py`

 * *Files 5% similar despite different names*

```diff
@@ -21,21 +21,18 @@
         M_top=1000
         F_top=400
 
         F_lumped =np.zeros(p.shape)
         #F_lumped[int(n/2)]=1000
         #F_lumped[int(3*n/4)]=1000
 
-
-        method='plin'
-
         F_tot = np.trapz(p,z) + F_top + np.sum(F_lumped)
         M_tot = np.trapz(p*z ,z) + F_top*z[-1]
 
-        Fs, Ms   = beamSectionLoads1D(z, p, F_top, M_top, s=1, F_lumped=F_lumped, method=method)
+        Fs, Ms   = beamSectionLoads1D(z, p, F_top, M_top, s=1, F_lumped=F_lumped, method='plin')
         Fs2, Ms2 = beamSectionLoads1D(z, p, F_top, M_top, s=1, F_lumped=F_lumped, method='manual')
         Fs3, Ms3 = beamSectionLoads1D(z, p, F_top, M_top, s=1, F_lumped=F_lumped, method='cumtrapz')
 
         #import matplotlib.pyplot as plt
         #fig,axes = plt.subplots(1, 2, sharey=True, figsize=(6.4,4.8)) # (6.4,4.8)
         #fig.subplots_adjust(left=0.12, right=0.95, top=0.95, bottom=0.11, hspace=0.20, wspace=0.20)
 
@@ -52,14 +49,15 @@
         #axes[1].plot([M_tot,M_tot], [z[0],z[-1]], 'k--')
         #
         #axes[0].set_ylabel('z [m]')
         #axes[0].set_xlabel('F [N]')
         #axes[1].set_xlabel('M [Nm]')
         #axes[0].legend()
         #axes[1].legend()
+        #plt.show()
 
         
         dz=np.diff(z)[0]
         dMsdz = np.diff(Ms)/dz
         dFsdz = np.diff(Fs)/dz
         z2=z[0:-1]+np.diff(z)/2
         p2   = np.interp(z2, z,p)
```

### Comparing `welib-0.0.2/welib/yams/tests/test_sid.py` & `welib-1.0.0/welib/yams/tests/test_sid.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_utils.py` & `welib-1.0.0/welib/yams/tests/test_utils.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests/test_windturbine.py` & `welib-1.0.0/welib/yams/tests/test_windturbine.py`

 * *Files 22% similar despite different names*

```diff
@@ -12,17 +12,19 @@
 # --- TESTS Wind Turbine, With OpenFAST Algo. Should give perfect match, but some TODOs
 # --------------------------------------------------------------------------------{
 class TestWindTurbSparOpenFAST(unittest.TestCase):
 
     @classmethod
     def setUpClass(cls):
         # Read FAST structural model
-        cls.WT = FASTWindTurbine(os.path.join(MyDir,'./../../../data/Spar/Main_Spar_ED.fst'), algo='OpenFAST') #, bldStartAtRotorCenter=False )
+        fstSim = os.path.join(MyDir,'./../../../data/Spar/Main_Spar_ED.fst')
+        cls.WT = FASTWindTurbine(fstSim, algo='OpenFAST') #, bldStartAtRotorCenter=False )
+        cls.fstSim = fstSim
 
-    def test_bld(self):
+    def test_WT_00_bld(self):
         # --- Blade
         # NOTE: bldes have "R" as origin
         bld0=self.WT.bld[0]
         #print(bld0)
         #print('start_pos',bld0.start_pos)
         #print('s_span',bld0.s_span)
         #print('MM\n',bld0.MM[:6,:6])
@@ -105,42 +107,76 @@
         #from welib.fast.elastodyn import bladeParameters
         #pED = bladeParameters(self.WT.ED.filename)
         #print('BldMass   {:15.3f}{:15.3f}'.format(pED['BldMass']  ,    17600.781))
         #print('SecondMom {:15.3f}{:15.3f}'.format(pED['SecondMom'], 11688798.933))
         #print('FirstMom  {:15.3f}{:15.3f}'.format(pED['FirstMom'] ,   361234.779))
         #print('CG        {:15.3f}{:15.3f}'.format(pED['BldCG']    ,       20.524))
 
-    def test_twr(self):
+    def test_WT_00_twr(self):
         # --- Tower
         twr=self.WT.twr
         #print(twr)
 	# Comparison with ElastoDyn summary file
         # Tower Mass            (kg)       217511.246
         np.testing.assert_almost_equal(twr.mass,        217511.246, 3)
         np.testing.assert_almost_equal(twr.length,      67.6)
         # np.testing.assert_allclose(np.diag(twr.inertia), [2.6183e8,2.6183e8, 0.0], 1e-3)
 
-    def test_rotor(self):
+    def test_WT_00_rotor(self):
         # NOTE: rotor is hub + rigid blades, with "R" as origin, but define with "N" as global
         rot = self.WT.rot
         # Rotor Mass            (kg)       109582.342
         # Rotor Inertia         (kg-m^2) 38479110.193
         np.testing.assert_almost_equal(rot.mass,           109582.342, 3)
         np.testing.assert_almost_equal(rot.inertia[0,0], 38479110.193, 3) # TODO TODO TODO WRONG BECAUSE OF BLADE DEFINITION
 
 
+    def test_WT_50_Kinematics(self):
+        qDict   = {'Sg': 10.0, 'Sw':20.0, 'Hv': 5.0, 'R':0.0, 'P':0.3, 'Y':0, 'TFA1':1.0, 'TSS1':10.0,'TFA2':0, 'TSS2':0, 'Yaw':np.pi/8}
+        qdDict  = {'Sg':  1.0, 'Sw': 2.0, 'Hv': 3.0, 'R':0.1, 'P':0.3, 'Y':0, 'TFA1':0.1, 'TSS1':0.2, 'TFA2':0, 'TSS2':0, 'Yaw':0.0}
+        qddDict = {'Sg':  0.1, 'Sw': 0.0, 'Hv': 0.2, 'R':0.01,'P':0.1, 'Y':0, 'TFA1':0.1, 'TSS1':0.0, 'TFA2':0, 'TSS2':0, 'Yaw':0.0}
+#         qDict   = {'Sg':  0.0, 'Sw': 0.0, 'Hv': 0.0, 'R':0.0, 'P':0.0, 'Y':0, 'TFA1':0.0, 'TSS1':0.0, 'TFA2':0, 'TSS2':0, 'Yaw':0.0}
+#         qdDict  = {'Sg':  0.0, 'Sw': 0.0, 'Hv': 0.0, 'R':0.0, 'P':0.0, 'Y':0, 'TFA1':0.0, 'TSS1':0.0, 'TFA2':0, 'TSS2':0, 'Yaw':100.0}
+#         qddDict = {'Sg':  0.0, 'Sw': 0.0, 'Hv': 0.0, 'R':0.0, 'P':0.0, 'Y':0, 'TFA1':0.0, 'TSS1':0.0, 'TFA2':0, 'TSS2':0, 'Yaw':0.0}
+
+        kin = self.WT.kinematics(qDict, qdDict, qddDict)
+
+        if True:
+            from welib.fast.elastodyn import ED_Parameters, ED_CalcOutputs
+            p = ED_Parameters(self.fstSim)
+            #print(p.keys())
+            # NOTE: noAxRed for now
+            CS, dat, IEC =  ED_CalcOutputs(x={'qDict':qDict, 'qdDict':qdDict}, p=p, noAxRed=True)
+
+            #print('------------------------')
+            #for k,v in kin.items():
+            #    if len(v.shape)==1:
+            #        if k in IEC.keys():
+            #            print('{:15s} :{} {}'.format(k,v, IEC[k]))
+            #        else:
+            #            print('{:15s} :{}'.format(k,v))
+            np.testing.assert_almost_equal(kin['r_F']  , IEC['r_F'] , 4)
+            np.testing.assert_almost_equal(kin['R_g2f'], CS['R_g2f'] , 5)
+            np.testing.assert_almost_equal(kin['r_T']  , IEC['r_T'] , 4)
+            np.testing.assert_almost_equal(kin['r_N']  , IEC['r_N'] , 4)
+            np.testing.assert_almost_equal(kin['R_g2n'], CS['R_g2n'] , 4)
+            np.testing.assert_almost_equal(kin['r_Gn'] , IEC['r_Gn'], 4)
+            np.testing.assert_almost_equal(kin['omega_n'] , IEC['omega_n'] , 4)
+
+
+
 # --------------------------------------------------------------------------------}
 # --- TESTS Wind Turbine, Without OpenFAST Algo
 # --------------------------------------------------------------------------------{
 class TestWindTurbSpar(unittest.TestCase):
 
     @classmethod
     def setUpClass(cls):
         # Read FAST structural model
-        cls.WT = FASTWindTurbine(os.path.join(MyDir,'./../../../data/Spar/Main_Spar_ED.fst'), algo='')
+        cls.WT = FASTWindTurbine(os.path.join(MyDir,'./../../../data/Spar/Main_Spar_ED.fst'), algo='', twrShapes=[0,1,2,3])
 
     def test_fnd_ED(self):
         # --- Floater
         fnd=self.WT.fnd
         # Values from SubDyn summary file
         Mfnd_ref =  np.array([[   7.500000E+06,   0.000000E+00,   0.000000E+00,   0.000000E+00,  -6.749999E+08,  0.000000E+00],
                               [   0.000000E+00,   7.500000E+06,   0.000000E+00,   6.749999E+08,   0.000000E+00,   0.000000E+00],
```

### Comparing `welib-0.0.2/welib/yams/tests_numeric_recursive/test_TNSB_FAST.py` & `welib-1.0.0/welib/yams/tests_numeric_recursive/test_TNSB_FAST.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_numeric_recursive/test_TNSB_article.py` & `welib-1.0.0/welib/yams/tests_numeric_recursive/test_TNSB_article.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_numeric_recursive/test_yams.py` & `welib-1.0.0/welib/yams/tests_numeric_recursive/test_yams.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/_F2T1RNA.py` & `welib-1.0.0/welib/yams/tests_symbolic_kane/_F2T1RNA.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T0N2S1.py` & `welib-1.0.0/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T0N2S1.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T1RNA.py` & `welib-1.0.0/welib/yams/tests_symbolic_kane/test_FTNSB_sympy_F0T1RNA.py`

 * *Files identical despite different names*

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/test_run_Examples.py` & `welib-1.0.0/welib/fast/tests/test_run_Examples.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,20 +14,23 @@
         exec(compile(file.read(), filepath, 'exec'), globals, locals)
 
 class TestExamples(unittest.TestCase):
     def test_run_examples(self):
         exclude_list=[]
         # Add tests to class
         MyDir=os.path.dirname(__file__)
-        files = glob.glob(os.path.join(MyDir,'../papers/2022-symbolic-framework/[a-zA-Z]*.py'))
-        import matplotlib.pyplot as plt
+        files = glob.glob(os.path.join(MyDir,'../examples/[a-zA-Z-_]*.py'))
         print('\n--------------------------------------------------------------')
+        import matplotlib.pyplot as plt
         for f in files:
             print('Running example script: {}'.format(f))
             if hasattr(self,'subTest'):
                 with self.subTest(filename=os.path.basename(f)):
                     execfile(f, {'__name__': '__test__', 'print': lambda *_:None})
-                    plt.close('all')
+            try:
+                plt.close('all')
+            except:
+                pass
 
 
 if __name__ == '__main__':
     unittest.main()
```

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/test_yams_sympy_rigid.py` & `welib-1.0.0/welib/yams/tests_symbolic_kane/test_yams_sympy_rigid.py`

 * *Files 2% similar despite different names*

```diff
@@ -40,18 +40,18 @@
         B       = symbols('B')
         K_x     = symbols('K_x')
         K_phi_y = symbols('K_phi_y')
         theta_yaw, theta_tilt = symbols('theta_yaw, theta_tilt') # Position of mooring line attachment point and Buoyancy center in F, measured from point T (negative)
 
         # --- Bodies
         ref = YAMSInertialBody('E') 
-        twr = YAMSRigidBody('T', rho_G = [0,0,z_G_T]      , J_diag=True) 
-        fnd = YAMSRigidBody('F', rho_G = [0,0,z_G_F]      , J_diag=True) 
-        nac = YAMSRigidBody('N', rho_G = [x_G_N ,0, z_G_N], J_diag=True) 
-        rot = YAMSRigidBody('R', rho_G = [0,0,0]          , J_diag=True)
+        twr = YAMSRigidBody('T', rho_G = [0,0,z_G_T]      , J_form='diag') 
+        fnd = YAMSRigidBody('F', rho_G = [0,0,z_G_F]      , J_form='diag') 
+        nac = YAMSRigidBody('N', rho_G = [x_G_N ,0, z_G_N], J_form='diag') 
+        rot = YAMSRigidBody('R', rho_G = [0,0,0]          , J_form='diag')
         rot.inertia = (inertia(rot.frame, Jxx_R, JO_R, JO_R), rot.origin)  # defining inertia at orign
 
         # --- Bodies connections
         ref.connectTo(twr, type='Free' , rel_pos=(x,0,0)   , rot_amounts=(0,phi_y,0), rot_order='XYZ')
         twr.connectTo(fnd, type='Rigid', rel_pos=(0,0,-L_F))
         twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(theta_yaw,theta_tilt,0),rot_order='ZYX')
         #twr.connectTo(nac, type='Rigid', rel_pos=(0,0,L_T)  , rot_amounts=(0,0,0),rot_order='ZYX')
```

### Comparing `welib-0.0.2/welib/yams/tests_symbolic_kane/test_yams_sympy_tools.py` & `welib-1.0.0/welib/yams/tests_symbolic_kane/test_yams_sympy_tools.py`

 * *Files 11% similar despite different names*

```diff
@@ -36,15 +36,14 @@
         self.assertEqual(expr0, expr0_ref)
 
     def test_linearization(self):
         # --- Test linearization without replacing time derivatives
         x,y = dynamicsymbols('x, y')
         z   = symbols('z')
         a,b,c,d = symbols('a,b,c,d')
-        time = dynamicsymbols._t
 
         # Linearization 0th order of sin
         expr      = a*sin(b*x)
         expr0_ref =    0
         expr0     = linearize(expr, [(x,0)], order=0)
         self.assertEqual(expr0, expr0_ref)
 
@@ -81,36 +80,66 @@
 
         # Linearization 1st order, mix of sin and cos
         expr      = a*cos(x) + b*sin(x) + c*sin(x)**2 + d*cos(y)*sin(y)
         expr0_ref =    a     + b*x                    + d*y
         expr0     = linearize(expr, [(x,0),(y,0)] )
         self.assertEqual(expr0, expr0_ref)
 
+        # Linearization polynomial vars is polynomial
+        expr      = a * (x +y)**2
+        expr0_ref = a * x**2 + 2* a*x*y + a* y**2
+        expr0     = linearize(expr, [(x,0),(y,0)], order=3 )
+        self.assertEqual(expr0, expr0_ref)
+
+        # Linearization polynomial vars is polynomial
+        expr      = a * exp(x +y)
+        expr0_ref = a*x + a*y + a
+        expr0     = linearize(expr, [(x,0),(y,0)], order=1 )
+        self.assertEqual(expr0, expr0_ref)
+
+    def test_linearization_with_diff(self):
+
+        x,y      = dynamicsymbols('x, y')
+        a,b,c,d  = symbols('a,b,c,d')
+        theta    = dynamicsymbols('theta')
+        T0  = symbols('T0')
+        TD0  = symbols('TD0')
+        time = dynamicsymbols._t
+        xdot = diff(x,time)
+        thetadot = diff(theta,time)
+
         # Linearization 1st order with time derivatives
         expr      = a*cos(x) + b*cos(x)*diff(x,time)+ cos(x)**2 * diff(diff(x,time),time)**2
         expr0_ref =    a +     b*       diff(x,time)+      1    * diff(diff(x,time),time)**2
         expr0     = linearize(expr, [(x,0)] )
         self.assertEqual(expr0, expr0_ref)
 
         expr      = a*sin(y) + b*sin(x)*diff(x,time)+ sin(x)**2 * diff(diff(y,time),time)**2
         expr0_ref = a* y     + b*x     *diff(x,time)+   0
         expr0     = linearize(expr, [(x,0),(y,0)], order=1 )
         self.assertEqual(expr0, expr0_ref)
 
         # Linearization polynomial vars is polynomial
-        expr      = a * (x +y)**2
-        expr0_ref = a * x**2 + 2* a*x*y + a* y**2
-        expr0     = linearize(expr, [(x,0),(y,0)], order=3 )
+        expr      = 3*thetadot*theta
+        expr0_ref = 3
+        expr0_ref = 3*T0*TD0 + 3*T0*( thetadot-TD0) + 3*TD0*(theta-T0)
+        expr0     = linearize(expr, [(theta, T0), (thetadot, TD0)], order=1 )
         self.assertEqual(expr0, expr0_ref)
 
-        # Linearization polynomial vars is polynomial
-        expr      = a * exp(x +y)
-        expr0_ref = a*x + a*y + a
-        expr0     = linearize(expr, [(x,0),(y,0)], order=1 )
+        # ISSUE when you do a substitution within a derivative, the substitution of derivative does not work
+        expr      = thetadot**3
+        expr0_ref = TD0**3 + 3*TD0**2* (thetadot-TD0)
+        expr02_ref =-TD0**3 - 3*TD0**2* (thetadot-TD0)
+        expr2     = (thetadot**3).subs([(theta, -theta)])
+        expr0  =  linearize(expr  ,  [(thetadot,TD0)], order=1 )
+        expr02 =  linearize(expr2 ,  [(thetadot,TD0)], order=1 )
         self.assertEqual(expr0, expr0_ref)
+        self.assertEqual(expr02, expr02_ref)
+
+
 
     def test_jacobian(self):
 
         from welib.yams.yams_sympy_tools import myjacobian
         from sympy import Symbol, Matrix
         x,y   = symbols('x, y')
         x0,y0 = symbols('x0, y0')
@@ -124,9 +153,10 @@
         self.assertEqual(J[1,0], a+2*b*x0)
 
         J = myjacobian(f1, [x,y], [x0,y0])
         self.assertEqual(J[0,0], a)
 
 
 if __name__=='__main__':
-    TestYAMSSPTools().test_jacobian()
-#     unittest.main()
+    #TestYAMSSPTools().test_jacobian()
+    #TestYAMSSPTools().test_linearization_with_diff()
+    unittest.main()
```

### Comparing `welib-0.0.2/welib/yams/yams.py` & `welib-1.0.0/welib/yams/yams.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,11 +1,13 @@
 """
 
 Yams numerical and recursive formulation.
 
+NOTE: this file is intended to be comparable with yams_sympy.py
+
 Reference:
      [1]: Branlard, Flexible multibody dynamics using joint coordinates and the Rayleigh-Ritz approximation: the general framework behind and beyond Flex, Wind Energy, 2019
 """
 
 import numpy as np
 from .utils import *
 from .bodies import Body         as GenericBody
@@ -103,15 +105,15 @@
         s+='|Usefull getters: None \n'
         return s
 
 
 # --------------------------------------------------------------------------------}
 # --- Bodies 
 # --------------------------------------------------------------------------------{
-class Body(GenericBody):
+class Body(GenericBody): # TODO rename YAMSRecBody
     def __init__(B,name=''):
         GenericBody.__init__(B, name=name)
         B.Children    = []
         B.Connections = []
         B.MM     = None
         B.B           = [] # Velocity transformation matrix
         B.updatePosOrientation(colvec([0,0,0]), eye(3))
@@ -314,26 +316,33 @@
 # %             nf_N=0;
 # %             BB_N_inN =[B_N_inN zeros(6,nf_N) ; zeros(nf_N, size(B_N_inN,2)) eye(nf_N)];
 # %             % Update of mass matrix
 # %             MM_N= BB_N_inN'*Nac.MM*BB_N_inN;
 # %             KK_N= BB_N_inN'*Nac.KK*BB_N_inN;
 
 
-    def updateKinematics(o,x_0,R_0b,gz,v_0,a_v_0):
+    def updateKinematics(o, x_0=None, R_0b=None, gz=None, v_0=None, a_v_0=None):
         # NOTE: this is overriden by BeamBody
         # Updating position of body origin in global coordinates
-        o.r_O = x_0[0:3]
-        o.gzf = gz
+        if x_0 is not None:
+            o.r_O = x_0[0:3]
+        if gz is not None:
+            o.gzf = gz
         # Updating Transformation matrix
-        o.R_0b=R_0b
+        if R_0b is not None:
+            o.R_0b=R_0b
+        else:
+            R_0b = o.R_0b
         # Updating rigid body velocity and acceleration
-        o.v_O_inB     = np.dot(R_0b, v_0[0:3])
-        o.om_O_inB    = np.dot(R_0b, v_0[3:6])
-        o.a_O_v_inB   = np.dot(R_0b, a_v_0[0:3])
-        o.omp_O_v_inB = np.dot(R_0b, a_v_0[3:6])
+        if v_0 is not None:
+            o.v_O_inB     = np.dot(R_0b, v_0[0:3])
+            o.om_O_inB    = np.dot(R_0b, v_0[3:6])
+        if a_v_0 is not None:
+            o.a_O_v_inB   = np.dot(R_0b, a_v_0[0:3])
+            o.omp_O_v_inB = np.dot(R_0b, a_v_0[3:6])
 
     @property
     def _positions_global(B): # todo rename
         # NOTE: this is overriden by BeamBody
         return B.r_O # for rigid bodies
 
 
@@ -526,15 +535,15 @@
             D=c._getFullD(D)
         return D
 
 
 # --------------------------------------------------------------------------------}
 # --- Rigid Body 
 # --------------------------------------------------------------------------------{
-class RigidBody(Body,GenericRigidBody):
+class RigidBody(Body,GenericRigidBody): # TODO rename YAMSRecRigidBody
     def __init__(B, name, mass, J_G, rho_G):
         """
         Creates a rigid body 
         """
         Body.__init__(B,name)
         GenericRigidBody.__init__(B, name, mass, J_G, rho_G)
         B.s_G_inB = B.masscenter
@@ -545,29 +554,34 @@
         B.KK = np.zeros((6,6))
 
 
 
 # --------------------------------------------------------------------------------}
 # --- Beam Body 
 # --------------------------------------------------------------------------------{
-class BeamBody(GenericBeamBody, Body):
+class BeamBody(GenericBeamBody, Body): # TODO rename to YAMSRecBeamBody
     def __init__(B, s_span, s_P0, m, PhiU, PhiV, PhiK, EI, jxxG=None, s_G0=None, 
             s_min=None, s_max=None,
             bAxialCorr=False, bOrth=False, Mtop=0, bStiffening=True, gravity=None,main_axis='z',
             massExpected=None,
-            name='dummy'
+            name='dummy',
+            algo=''
             ):
         """ 
           Points P0 - Undeformed mean line of the body
         """
-        # --- nherit from BeamBody and Body 
+        int_method    = 'Flex'
+        if algo=='OpenFAST': 
+            int_method='OpenFAST'
+        # --- Inherit from BeamBody and Body 
         Body.__init__(B)
         GenericBeamBody.__init__(B,name, s_span, s_P0, m, EI, PhiU, PhiV, PhiK, jxxG=jxxG, s_G0=s_G0, s_min=s_min, s_max=s_max,
                  bAxialCorr=bAxialCorr, bOrth=bOrth, Mtop=Mtop, bStiffening=bStiffening, gravity=gravity, main_axis=main_axis,
-                 massExpected=massExpected
+                 massExpected=massExpected,
+                 int_method=int_method
                 )
 
         B.gzf   = np.zeros((B.nf,1))
         B.gzpf  = np.zeros((B.nf,1))
         B.gzppf = np.zeros((B.nf,1))
 
         # TODO
@@ -665,28 +679,68 @@
         return s
 
 
 # --------------------------------------------------------------------------------}
 # --- Uniform Beam Body 
 # --------------------------------------------------------------------------------{
 class UniformBeamBody(BeamBody):
-    def __init__(B, name, nShapes, nSpan, L, EI0, m, Mtop=0, jxxG=None, GKt=None, bAxialCorr=True, bCompatibility=False, bStiffnessFromGM=False, bStiffening=True, gravity=None, main_axis='x'):
+    def __init__(B, name, nShapes, nSpan, L, EI0, m, Mtop=0, jxxG=None, GKt=None, 
+            bAxialCorr=True, bCompatibility=False, bStiffnessFromGM=False, bStiffening=True, 
+            gravity=None, main_axis='x',
+            shapeFunctions='masslessbeam',
+            bottomBC='clamped',
+            topBC='free',
+            ):
 
         import welib.beams.theory as bt
         if jxxG is None:
             jxxG=0
         if GKt is None:
             GKt=0
         if gravity is None and (bStiffening or Mtop>0):
             raise Exception('`gravity` is None, but `bStiffening` is true or `Mtop`>0. Please provide `gravity`.')
 
         A=1; rho=A*m;
         x=np.linspace(0,L,nSpan);
+        BC = '{}-{}'.format(bottomBC, topBC)
         # Mode shapes
-        freq,s_span,U,V,K = bt.UniformBeamBendingModes('unloaded-topmass-clamped-free',EI0,rho,A,L,x=x,Mtop=Mtop, nModes=nShapes)
+        if shapeFunctions=='masslessbeam':
+            freq,s_span,U,V,K = bt.UniformBeamBendingModes('unloaded-topmass-{}'.format(BC),EI0,rho,A,L,x=x,Mtop=Mtop, nModes=nShapes)
+        elif shapeFunctions=='Guyan':
+            if BC=='clamped-free':
+                freq,s_span,U,V,K  = bt.UniformBeamGuyanModes(EI0, rho, A, L, x= x, nModes = nShapes)
+            else:
+                raise NotImplementedError('{} {}'.format(shapeFunctions, BC))
+
+        elif shapeFunctions=='FEM':
+            #from welib.FEM.fem_beam import *
+            raise NotImplementedError('{} {}'.format(shapeFunctions, BC))
+            #nel      = 10             # Number of elements along the beam
+            #element  = 'frame3d'      # Type of element used in FEM
+            #if TopMass:
+            #    Mtop = 50000  # Top mass [kg]
+            #    M_tip= rigidBodyMassMatrixAtP(m=Mtop, J_G=None, Ref2COG=None)
+            #else:
+            #    M_tip=None
+            ## --- Structural data for uniform beam
+            #E   = 210e9     # Young modulus [Pa] [N/m^2]
+            #G   = 79.3e9    # Shear modulus. Steel: 79.3  [Pa] [N/m^2]
+            #L   = 100       # Beam Length [m]
+            #EIy0= 1.654e+12 # Planar second moment of area [m^4]
+            #m0  = 1.026e+04 # Mass per length [kg/m]
+            #EIx0= EIy0*2    # Polar second moment of area [m^4]
+            #A   = 1.00      # Area [m^2] 
+            #Kt  = EIy0/E*10 # Torsion constant [m^4]
+            ## --- Compute FEM model and mode shapes
+            #FEM=cbeam(L,m=m0,EIx=EIx0,EIy=EIy0,EIz=EIy0,EA=E*A,A=A,E=E,G=G,Kt=Kt,
+            #        element=element, nel=nel, BC=BC, M_tip=M_tip)
+            #x =FEM['xNodes'][0,:]
+            #Q =FEM ['Q']
+            #QY1 = [Q [1::6, iMode] for iMode in range(10) if FEM ['modeNames'][iMode].startswith('uy')]
+
         PhiU = np.zeros((nShapes,3,nSpan)) # Shape
         PhiV = np.zeros((nShapes,3,nSpan)) # Slope
         PhiK = np.zeros((nShapes,3,nSpan)) # Curvature
         if main_axis=='x':
             iModeAxis=2      # Setting modes along z
         elif main_axis=='z':
             iModeAxis=0      # Setting modes along x
@@ -726,15 +780,16 @@
 
 
 # --------------------------------------------------------------------------------}
 # --- FAST Beam body 
 # --------------------------------------------------------------------------------{
 class FASTBeamBody(BeamBody, GenericFASTBeamBody):
     def __init__(B, body_type, ED, inp, Mtop=0, shapes=None, nShapes=None, main_axis='x',nSpan=None,bAxialCorr=False,bStiffening=True, 
-            spanFrom0=False, massExpected=None, gravity=None
+            spanFrom0=False, massExpected=None, gravity=None,
+            algo='' # TODO OpenFAST
             ):
         """ 
         """
         if shapes is None:
             if nShapes==2:
                 shapes=[0,1]
             elif nShapes==0:
@@ -742,22 +797,25 @@
             elif nShapes==1:
                 shapes=[0]
             else:
                 raise NotImplementedError('>> TODO')
         GenericFASTBeamBody.__init__(B, ED, inp, Mtop=Mtop, shapes=shapes, main_axis=main_axis, nSpan=nSpan, bAxialCorr=bAxialCorr, bStiffening=bStiffening, 
                 spanFrom0=spanFrom0,
                 massExpected=massExpected,
-                gravity=gravity
+                gravity=gravity,
+                algo=algo
                 )
         # We need to inherit from "YAMS" Beam not just generic Beam
+        # NOTE: TODO TODO TODO: This will result in "YAMSBeamBody to be called twice...)
         BeamBody.__init__(B, B.s_span, B.s_P0, B.m, B.PhiU, B.PhiV, B.PhiK, B.EI, jxxG=B.jxxG, s_G0=B.s_G0, 
                 # NOTE: r_O, r_b2g is lost here
                 s_min=B.s_min, s_max=B.s_max,
                 bAxialCorr=bAxialCorr, bOrth=B.bOrth, Mtop=Mtop, bStiffening=bStiffening, gravity=B.gravity,main_axis=main_axis,
-                massExpected=massExpected
+                massExpected=massExpected,
+                algo=algo
                 )
 
 # --------------------------------------------------------------------------------}
 # --- B Matrices 
 # --------------------------------------------------------------------------------{
 def fB_inB(R_EI, B_I):
     """ Transfer a global B_I matrix (body I at point I) into a matrix in it's own coordinate.
@@ -810,15 +868,15 @@
     if len(Bhat_x)==0:
         ni = 0
     elif len(Bhat_x.shape)==2:
         ni = Bhat_x.shape[1]
     else:
         raise Exception('Bi needs to be empty or a 2d array')
 
-    r_pi=r_pi.reshape(3,1)
+    r_pi=colvec(r_pi)
 
     # TODO use Translate here
     Bi = Matrix(np.zeros((6,ni+n_p)))
     for j in range(n_p):
         Bi[:3,j] = Bp[:3,j]+cross(Bp[3:,j],r_pi.ravel()) # Recursive formula for Bt mentioned after Eq.(15)
         Bi[3:,j] = Bp[3:,j] # Recursive formula for Bx mentioned after Eq.(12)
     if ni>0:
```

### Comparing `welib-0.0.2/welib/yams/yams_kane.py` & `welib-1.0.0/welib/yams/yams_kane.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-from __future__ import print_function, division
-
 from sympy.core.backend import zeros, Matrix, diff, eye
 from sympy import solve_linear_system_LU
 # try:
 #     from sympy.core.compatibility import range
 # except:
 #     pass
 try:
```

### Comparing `welib-0.0.2/welib/yams/yams_sympy.py` & `welib-1.0.0/welib/yams/yams_sympy.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,8 +1,14 @@
 """
+
+Yams recursive formulation with sympy.
+For Kane's formalism (similar), see yams_kane.py
+
+NOTE: this file is intended to be comparable with yams.py
+
 Reference:
      [1]: Branlard, Flexible multibody dynamics using joint coordinates and the Rayleigh-Ritz approximation: the general framework behind and beyond Flex, Wind Energy, 2019
 """
 import numpy as np
 import sympy
 from sympy import Symbol, symbols
 from sympy import Matrix, Function, diff
@@ -18,36 +24,29 @@
 from sympy.physics.mechanics import RigidBody as SympyRigidBody
 from sympy.physics.mechanics import Point, ReferenceFrame, inertia, dynamicsymbols
 from sympy.physics.mechanics.functions import msubs
 
 from sympy.physics.vector import init_vprinting, vlatex
 
 # Local
-from welib.yams.yams_sympy_tools import exprHasFunction
+from welib.yams.yams_sympy_tools import exprHasFunction, skew, colvec, cross #,ete
 from collections import OrderedDict 
 
 #init_vprinting(use_latex='mathjax', pretty_print=False)
 #
 #display=lambda x: sympy.pprint(x, use_unicode=False,wrap_line=False)
 
 
 __all__ = ['YAMSBody','YAMSInertialBody','YAMSRigidBody','YAMSFlexibleBody'] # New general implementation
 __all__+= ['Body','RigidBody','GroundBody'] # Old "recursive" implementation. TODO merge the two
 __all__+= ['skew', 'rotToDCM', 'DCMtoOmega']
 
 # --------------------------------------------------------------------------------}
 # --- Helper functions 
 # --------------------------------------------------------------------------------{
-def colvec(v): 
-    return Matrix([[v[0]],[v[1]],[v[2]]])
-def cross(V1,V2):
-    return [V1[1]*V2[2]-V1[2]*V2[1], V1[2]*V2[0]-V1[0]*V2[2], (V1[0]*V2[1]-V1[1]*V2[0]) ]
-def eye(n): 
-    return Matrix( np.eye(n).astype(int) )
-
 def ensureMat(x, nr, nc):
     """ Ensures that the input is a matrix of shape nr, nc"""
     if not isinstance(x,Matrix):
         x=Matrix(x)
     return x.reshape(nr, nc)
 
 def ensureList(x, nr):
@@ -58,37 +57,46 @@
     return x
             
 def coord2vec(M31, e):
     """ Ugly conversion from a matrix or vector coordinates (implicit frame) to a vector (in a given frame) """
     M31 = ensureList(M31, 3)
     return M31[0] * e.x + M31[1] * e.y + M31[2] * e.z
 
-            
-def skew(x):
-    """ Returns the skew symmetric matrix M, such that: cross(x,v) = M v """
-    #S = Matrix(np.zeros((3,3)).astype(int))
-    if hasattr(x,'shape') and len(x.shape)==2:
-        if x.shape[0]==3:
-            return Matrix(np.array([[0, -x[2,0], x[1,0]],[x[2,0],0,-x[0,0]],[-x[1,0],x[0,0],0]]))
-        else:
-            raise Exception('fSkew expect a vector of size 3 or matrix of size 3x1, got {}'.format(x.shape))
-    else:
-        return Matrix(np.array([[0, -x[2], x[1]],[x[2],0,-x[0]],[-x[1],x[0],0]]))
 
 def rotToDCM(rot_type, rot_amounts, rot_order=None):
     """
     return matrix from a ref_frame to another frame rotated by specified amounts
+
+    INPUTS (see sympy.physics.vector.ReferenceFrame.orient):
+     - rot_type    : The method used to generate the direction cosine matrix. Supported methods are
+              'SmallRot': small angle rotations (ADDED in YAMS)
+              'Axis': simple rotations about a single common axis
+              'DCM': for setting the direction cosine matrix directly
+              'Body': three successive rotations about new intermediate axes, also called Euler and Tait-Bryan angles
+              'Space': three successive rotations about the parent frames unit vectors
+              'Quaternion': rotations defined by four parameters which result in a singularity free direction cosine matrix
+     - rot_amounts : expressions defining the rotation angles or direction cosine matrix. These must match the rot_type. 
+                The input types are:
+                'Axis': 2-tuple (expr/sym/func, Vector)
+                'DCM': Matrix, shape(3,3)
+                'Body': 3-tuple of expressions, symbols, or functions
+                'Space': 3-tuple of expressions, symbols, or functions
+                'Quaternion': 4-tuple of expressions, symbols, or functions
+
+     - rot_order: string or int. If applicable, the order of the successive of rotations. 
+                  The string '123', 'XYZ' and integer 123 are equivalent.
+                  Required for 'Body' and 'Space'.
     
     New type added: SmallRot
     
     see sympy.orientnew
-        rotToDCM(frame, 'Axis', (3, N.x)       )
-        rotToDCM(frame, 'Body', (x,y,z), 'XYZ' )
-        rotToDCM(frame, 'DCM' , M )
-        rotToDCM(frame, 'SmallRot' , (x,y,z) )
+        rotToDCM('Axis', (3, N.x)       )
+        rotToDCM('Body', (x,y,z), 'XYZ' )
+        rotToDCM('DCM' , M )
+        rotToDCM('SmallRot' , (x,y,z) )
     """
     ref_frame = ReferenceFrame('dummyref')
     if rot_type =='SmallRot':
             M=-skew(rot_amounts)
             M[0,0]=1
             M[1,1]=1
             M[2,2]=1
@@ -190,15 +198,15 @@
 #Me.eval([x,y])
 #Md = Taylor('T','M_d', 3, 1, nq=2, rname='xyz', cname=[''])
 #skew(Md.M0)
 # --------------------------------------------------------------------------------}
 # --- Connections 
 # --------------------------------------------------------------------------------{
 class Connection():
-    def __init__(self,Type,RelPoint=None,RelOrientation=None,JointRotations=None):
+    def __init__(self, Type, RelPoint=None, RelOrientation=None, JointRotations=None):
         if RelOrientation is None:
             RelOrientation=eye(3)
         if RelPoint is None:
             RelPoint=colvec([0,0,0])
 
         self.Type=Type
         
@@ -259,14 +267,16 @@
         self.origin.set_vel(self.frame,0*self.frame.x)
         
         self.parent = None # Parent body, assuming a tree structure
         self.children = [] # children bodies
         self.inertial_frame = None # storing the typical inertial frame use for computation
         self.inertial_origin = None # storing the typical inertial frame use for computation
 
+        self.viz_opts={}
+
     def __repr__(self):
         s='<{} object "{}" with attributes:>\n'.format(type(self).__name__,self.name)
         s+=' - origin:       {}\n'.format(self.origin)
         s+=' - frame:        {}\n'.format(self.frame)
         s+=' - inertial_frame: {} \n'.format(self.inertial_frame)
         try:
             posI=self.pos_global
@@ -415,88 +425,154 @@
                 return self.frame.ang_acc_in(frame_or_body.frame)
             else:
                 raise Exception('Unknown class type, use ReferenceFrame of YAMSBody as argument')
                 
     # --------------------------------------------------------------------------------}
     # --- Connection between bodies
     # --------------------------------------------------------------------------------{
-    def connectTo(parent, child, type='Rigid', rel_pos=None, rot_type='Body', rot_amounts=None, rot_order=None, dynamicAllowed=False):
-        # register parent/child relationship
+    def connectTo(parent, child, type='Rigid', rel_pos=None, rel_pos_b=None, rot_type='Body', rot_amounts=None, rot_order=None, dynamicAllowed=False, ref_frame=None):
+        """ 
+        Define a connection between parent and child bodies
+
+        INPUTS:
+         - type: 
+             'Rigid': the two bodies are rigidly connected
+             'Free' : the two bodies have free motions (e.g. a floating platform, or two bodies with spring)
+             'Joint': the two bodies have a rotational joint between them, rot_amounts needs to be provided
+
+         - rel_pos: array like of shape 1, 2 or 3, for x, y, z component of relative position between 
+                    parent and child expressed in the PARENT COORDINATE SYSTEM. Examples:
+                        rel_pos = (x_PC(t), y_PC, 0)   where x_PC is a dynamic symbol
+
+         - rel_pos_b: array like of shape 1, 2 or 3, for x, y, z component of relative position between 
+                    parent and child expressed in the CHILD COORDINATE  SYSTEM. Examples:
+                        rel_pos = (x_PC(t), y_PC, 0)   where x_PC is a dynamic symbol
+
+
+        ROTATION/ORIENTATION INPUTS: (see sympy.physics.vector.ReferenceFrame.orient):
+         - rot_type    : The method used to generate the direction cosine matrix. Supported methods are
+                  'SmallRot': small angle rotations (ADDED in YAMS)
+                  'Axis': simple rotations about a single common axis
+                  'DCM': for setting the direction cosine matrix directly
+                  'Body': three successive rotations about new intermediate axes, also called Euler and Tait-Bryan angles
+                  'Space': three successive rotations about the parent frames unit vectors
+                  'Quaternion': rotations defined by four parameters which result in a singularity free direction cosine matrix
+         - rot_amounts : expressions defining the rotation angles or direction cosine matrix. These must match the rot_type. 
+                    The input types are:
+                    'Axis': 2-tuple (expr/sym/func, Vector)
+                    'DCM': Matrix, shape(3,3)
+                    'Body': 3-tuple of expressions, symbols, or functions
+                    'Space': 3-tuple of expressions, symbols, or functions
+                    'Quaternion': 4-tuple of expressions, symbols, or functions
+    
+         - rot_order: string or int. If applicable, the order of the successive of rotations. 
+                      The string '123', 'XYZ' and integer 123 are equivalent.
+                      Required for 'Body' and 'Space'.
+
+         - frame_ref: when provided, the rotations are actually about the ref_frame
+                      otherwise, rotations are about the parent frame
+
+        """
+        # --- Safety checks
+        if rel_pos is None and rel_pos_b is None:
+            raise Exception('Provide either rel_pos or rel_pos_b')
+        if rel_pos is not None and rel_pos_b is not None:
+            raise Exception('Provide either rel_pos or rel_pos_b')
+
+        # --- register parent/child relationship
         child.parent = parent
         parent.children.append(child)
         if isinstance(parent, YAMSInertialBody):
             parent.inertial_frame  = parent.frame
             child.inertial_frame   = parent.frame
             parent.inertial_origin = parent.origin
             child.inertial_origin  = parent.origin
         else:
             if parent.inertial_frame is None:
                 raise Exception('Parent body was not connected to an inertial frame. Bodies needs to be connected in order, starting from inertial frame.')
             else:
                 child.inertial_frame  = parent.inertial_frame # the same frame is used for all connected bodies
                 child.inertial_origin = parent.inertial_origin
 
-        if rel_pos is None or len(rel_pos)!=3:
-            raise Exception('rel_pos needs to be an array of size 3')
 
-        pos = 0 * parent.frame.x
-        vel = 0 * parent.frame.x
+        # --- Deal with orientation first (creating a path connecting frames together)
+        if ref_frame is None:
+            ref_frame = parent.frame
+        if rot_amounts is None:
+            child.frame.orient(ref_frame, 'Axis', (0, ref_frame.x) ) 
+        else:
+            if rot_type in ['Body','Space']:
+                child.frame.orient(ref_frame, rot_type, rot_amounts, rot_order) # <<< 
+            else: 
+                # rot_type is DCM
+                child.frame.orient(ref_frame, rot_type, rot_amounts) # <<< 
+
 
+        # --- Then deal with position and velocity
         t = dynamicsymbols._t
+        if rel_pos is not None:
+            pos_frame = parent.frame
+            rel_pos_in_child_frame = False
+        else:
+            rel_pos = rel_pos_b
+            pos_frame = child.frame
+            rel_pos_in_child_frame = True
+        if len(rel_pos)!=3:
+            raise Exception('rel_pos needs to be an array of size 3')
+
+        pos = 0 * pos_frame.x
+        vel = 0 * pos_frame.x
 
         if type=='Free':
             # --- "Free", "floating" connection
             if not isinstance(parent, YAMSInertialBody):
                 raise Exception('Parent needs to be inertial body for a free connection')
             # Defining relative position and velocity of child wrt parent
-            for d,e in zip(rel_pos[0:3], (parent.frame.x, parent.frame.y, parent.frame.z)):
+            for d,e in zip(rel_pos[0:3], (pos_frame.x, pos_frame.y, pos_frame.z)):
                 if d is not None:
                     pos += d * e
                     vel += diff(d,t) * e
 
         elif type=='Rigid':
             # Defining relative position and velocity of child wrt parent
-            for d,e in zip(rel_pos[0:3], (parent.frame.x, parent.frame.y, parent.frame.z)):
+            for d,e in zip(rel_pos[0:3], (pos_frame.x, pos_frame.y, pos_frame.z)):
                 if d is not None:
                     pos += d * e
                     d_ = diff(d,t)
                     #if exprHasFunction(d) and not dynamicAllowed:
                     if d_!=0 and not dynamicAllowed:
                         raise Exception('Position variable cannot be a dynamic variable for a rigid connection: variable {}'.format(d))
                     if dynamicAllowed:
                         vel += d_ * e
         elif type=='Joint':
             # Defining relative position and velocity of child wrt parent
-            for d,e in zip(rel_pos[0:3], (parent.frame.x, parent.frame.y, parent.frame.z)):
+            for d,e in zip(rel_pos[0:3], (pos_frame.x, pos_frame.y, pos_frame.z)):
                 if d is not None:
                     pos += d * e
                     if exprHasFunction(d) and not dynamicAllowed:
                         raise Exception('Position variable cannot be a dynamic variable for a joint connection, variable: {}'.format(d))
                     if dynamicAllowed:
                         vel += diff(d,t) * e
             #  Orientation
             if rot_amounts is None:
                 raise Exception('rot_amounts needs to be provided with Joint connection')
-            for d in rot_amounts:
+            if rot_type.lower()=='axis':
+                rot_vars = [rot_amounts[0]]
+            else:
+                rot_vars = rot_amounts
+            for d in rot_vars:
                 if d!=0 and d!=1 and not exprHasFunction(d):
                     print('>>> WARNING: Rotation amount variable is not a dynamic variable for joint connection, variable: {}'.format(d))
                     #raise Exception('Rotation amount variable should be a dynamic variable for a joint connection, variable: {}'.format(d))
         else:
             raise Exception('Unsupported joint type: {}'.format(type))
 
-        # Orientation (creating a path connecting frames together)
-        if rot_amounts is None:
-            child.frame.orient(parent.frame, 'Axis', (0, parent.frame.x) ) 
-        else:
-            if rot_type in ['Body','Space']:
-                child.frame.orient(parent.frame, rot_type, rot_amounts, rot_order) # <<< 
-            else: 
-                # rot_type is DCM
-                child.frame.orient(parent.frame, rot_type, rot_amounts) # <<< 
-
+        if rel_pos_in_child_frame:
+            # NOTE: because the position is expressed wrt child frame, diff above does not work
+            vel =  diff(pos, t, parent.frame)
         # Position of child origin wrt parent origin
         child.origin.set_pos(parent.origin, pos)
         # Velocity of child origin frame wrt parent frame (0 for rigid or joint)
         child.origin.set_vel(parent.frame, vel);
 
         parent.update_kinematics_trigger()
 
@@ -509,14 +585,112 @@
             child.origin.v1pt_theory(parent.origin, child.inertial_frame, parent.frame)
             # Velocity of child masscenter wrt inertial frame, using parent origin/frame as intermediate
             child.masscenter.v1pt_theory(parent.origin, child.inertial_frame, parent.frame)
 
         #r_OB = child.origin.pos_from(child.inertial_origin)
         #vel_OB = r_OB.diff(t, child.inertial_frame)
 
+    def update_origin_pos(body, PointRef, pos):
+        """ 
+        Set position of origin and perform necessary triggers
+        TODO
+        """
+        pass
+        #body.origin.set_pos(PointRef, pos)
+        #body.origin.v2pt_theory(ref.origin, ref.frame, body.frame)
+
+    def update_ang_vel(body, omega_symbs, ref_frame=None, out_frame=None):
+        # Default values
+        if ref_frame is None:
+            ref_frame = body.inertial_frame
+            #ref_frame = body.parent.frame # <<<
+        if out_frame is None:
+            out_frame = body.frame
+
+        omega = omega_symbs[0]*out_frame.x + omega_symbs[1]*out_frame.y + omega_symbs[2]*out_frame.z
+
+        body.frame.set_ang_vel(ref_frame, omega)
+        # Update origin velocity (origin may move compared to parent origin, so use v1pt)
+        body.origin.v1pt_theory    (body.parent.origin, ref_frame, body.frame)   # TODO
+        body.origin.v1pt_theory    (body.inertial_origin, ref_frame, body.frame) # TODO
+        # Update masscenter velocity (COG and origin fixed in bod frame, so use v2pt)
+        body.masscenter.v2pt_theory(body.origin, ref_frame,  body.frame)
+
+    def kdeqsSubsOmega(body, omega_symbs, ref_frame=None, out_frame=None, simplify=True):
+        """
+        return kinematic differential substitutions for "omega"
+
+        omega is the rotational velocity from the ref_frame to the body frame
+
+        The three symbols omega_symbs are expected to be the components of omega
+        in the out_frame
+
+        """
+        # Default values
+        if ref_frame is None:
+            ref_frame = body.inertial_frame
+        if out_frame is None:
+            out_frame = body.frame
+        omega = body.frame.ang_vel_in(ref_frame) 
+        kdeqsSubs = []
+        if simplify:
+            kdeqsSubs += [(omega_symbs[0], omega.dot(out_frame.x).simplify())]
+            kdeqsSubs += [(omega_symbs[1], omega.dot(out_frame.y).simplify())] 
+            kdeqsSubs += [(omega_symbs[2], omega.dot(out_frame.z).simplify())]
+        else:
+            kdeqsSubs += [(omega_symbs[0], omega.dot(out_frame.x))]
+            kdeqsSubs += [(omega_symbs[1], omega.dot(out_frame.y))] 
+            kdeqsSubs += [(omega_symbs[2], omega.dot(out_frame.z))]
+        return kdeqsSubs
+
+
+    def printPosVel(body, origin=True, masscenter=True, inertial=True, kdeqsSubs=None,):
+        """ print position and velocity """
+        from IPython.display import display
+        # Origin position and velocity
+        if origin:
+            print('Position of body origin from parent origin')
+            display(body.origin.pos_from(body.parent.origin))
+            if inertial:
+                print('Position of body origin from inertial origin')
+                display(body.origin.pos_from(body.inertial_origin))
+            print('Velocity of body origin from parent frame')
+            display(body.origin.vel(body.parent.frame))
+            if inertial:
+                print('Velocity of body origin from inertial frame')
+                display(body.origin.vel(body.inertial_frame))
+                if kdeqsSubs:
+                    display(body.origin.vel(body.inertial_frame).express(body.inertial_frame).subs(kdeqsSubs).simplify())
+
+        # Mass center position and velocity
+        if masscenter:
+            print('Position of body masscenter from parent origin')
+            display(body.masscenter.pos_from(body.parent.origin))
+            if inertial:
+                print('Position of body masscenter from inertial origin')
+                display(body.masscenter.pos_from(body.inertial_origin))
+            print('Velocity of body masscenter from parent frame')
+            display(body.masscenter.vel(body.parent.frame))
+            if inertial:
+                print('Velocity of body masscenter from inertial frame')
+                display(body.masscenter.vel(body.inertial_frame))
+        # Angular velocity
+        print('Angular velocity of body frame wrt parent frame')
+        display(body.frame.ang_vel_in(body.parent.frame))
+        if kdeqsSubs is not None:
+            print('Angular velocity of body frame wrt parent frame (with kdeqs substitutions)')
+            display(body.frame.ang_vel_in(body.parent.frame).subs(kdeqsSubs))
+        if inertial:
+            print('Angular velocity of body frame wrt inertial frame')
+            display(body.frame.ang_vel_in(body.inertial_frame))
+            if kdeqsSubs is not None:
+                print('Angular velocity of body frame wrt inertial frame (with kdeqs substitutions)')
+                display(body.frame.ang_vel_in(body.inertial_frame).subs(kdeqsSubs))
+
+
     # --------------------------------------------------------------------------------}
     # --- Visualization 
     # --------------------------------------------------------------------------------{
     
     def vizOrigin(self, radius=1.0, color='black', format='pydy'):
         if format=='pydy':
             from pydy.viz.shapes import Sphere
@@ -730,31 +904,33 @@
         super(GroundBody,B).__init__('Grd')
         B.nf   = 0
 
 # --------------------------------------------------------------------------------}
 # --- Rigid Body 
 # --------------------------------------------------------------------------------{
 class YAMSRigidBody(YAMSBody,SympyRigidBody):
-    def __init__(self, name, mass=None, J_G=None, rho_G=None, J_diag=False, J_cross=False, J_at_Origin=False,
+    def __init__(self, name, mass=None, J_G=None, rho_G=None, J_form='full', J_at_Origin=False,
              name_for_var = None):
         """
         Define a rigid body and introduce symbols for convenience.
         
            Origin point have no velocities in the body frame! 
             
         
         INPUTS:
             name: string (can be one character), make sure this string is unique between all bodies
         
         OPTIONAL INPUTS:
             mass : scalar, body mass
             J_G  : 3x3 array or 3-array defining the coordinates of the inertia tensor in the body frame at the COG
             rho_G: array-like of length 3 defining the coordinates of the COG in the body frame
-            J_diag: if true, the inertial tensor J_G is initialized as diagonal
-            J_cross: if true, the inertial tensor J_G is initialized as a "cross"
+            J_form:  form of the inertial tensor
+                   'full': all components are included 
+                   'diag': only diagonal component  
+                   'cross': diagonal and anti-diagonal components
             name_for_var: name to use for variables names. If None, name is used.
         
         
         """
         # YAMS Body creates a default "origin", "masscenter", and "frame"
         YAMSBody.__init__(self, name)
         
@@ -783,18 +959,22 @@
         else:
             ixx = Symbol('J_xx_'+name_for_var)
             iyy = Symbol('J_yy_'+name_for_var)
             izz = Symbol('J_zz_'+name_for_var)
             izx = Symbol('J_zx_'+name_for_var)
             ixy = Symbol('J_xy_'+name_for_var)
             iyz = Symbol('J_yz_'+name_for_var)
-        if J_diag:
+        if J_form=='full':
+            pass
+        elif J_form=='diag':
             ixy, iyz, izx =0,0,0
-        if J_cross:
+        elif J_form=='cross':
             ixy, iyz =0,0
+        else:
+            raise NotImplementedError('J_form ',J_form)
             
         #inertia: dyadic : (inertia(frame, *list), point)
         if J_at_Origin:
             _inertia = (inertia(self.frame, ixx, iyy, izz, ixy, iyz, izx), self.origin)
             print('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> NOTE: inertia at origin')
         else:
             _inertia = (inertia(self.frame, ixx, iyy, izz, ixy, iyz, izx), self.masscenter)
@@ -1412,15 +1592,17 @@
             for j in np.arange(self.De.M0.shape[1]):
                 s=repr(self.De.M0[i,j])
                 if len(s)>1:
                     rd[s] = ('DD_{}'.format(self.name_for_var), [i+6,j+6])
         return rd
     
 
-
+# --------------------------------------------------------------------------------}
+# --- Beam Body 
+# --------------------------------------------------------------------------------{
 class BeamBody(Body):
     def __init__(B,Name,nf,main_axis='z',nD=2):
         super(BeamBody,B).__init__(Name)
         B.nf  = nf
         B.nD  = nD
         B.main_axis = main_axis
     @property
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `welib-0.0.2/welib/yams/yams_sympy_model.py` & `welib-1.0.0/welib/yams/yams_sympy_model.py`

 * *Files 9% similar despite different names*

```diff
@@ -1,10 +1,11 @@
 import os
 import numpy as np
-
+import pandas as pd
+import sympy as sp
 from sympy.physics.mechanics import dynamicsymbols
 from sympy.physics.mechanics.functions import find_dynamicsymbols
 from sympy import diff, Matrix, trigsimp
 from sympy import python
 
 from .yams_sympy_tools import smallAngleApprox, cleantex, subs_no_diff , cleanPy, myjacobian
 from .yams_kane import YAMSKanesMethod
@@ -124,15 +125,18 @@
         self.Points.append(P)
         self.PointsFrames.append(frame)
 
 
     def kaneEquations(self, Mform='symbolic', addGravity=True):
         """ 
         Compute equation of motions using Kane's method
-        Mform: form to use for mass matrix
+        Mform: form to use for mass matrix, either: 
+              - 'symbolic' : for most application, the mass matrix of flexible bodies is such that each element is a symbol
+              - 'TaylorExpanded': for flexible bodies, using Wallrapp's Taylor Expansion 
+
         addGravity: include gravity for elastic bodies
         """
         for sa in ['ref', 'coordinates', 'speeds','kdeqs','bodies','loads']:
             if getattr(self,sa) is None:
                 raise Exception('Attribute {} needs to be set before calling `kane` method'.format(sa))
 
         with Timer('Kane step1',True,silent=True):
@@ -141,14 +145,129 @@
         # --- Expensive kane step
         with Timer('Kane step 2',True,silent=True):
             #(use  Mform ='symbolic' or 'TaylorExpanded'), Mform='symbolic'
             self.fr, self.frstar  = self.kane.kanes_equations(self.bodies, self.loads, Mform=Mform, addGravity=addGravity, g_vect=self.g_vect)
         self.kane.fr     = self.fr
         self.kane.frstar = self.frstar
 
+    @property
+    def q_full(self):
+        return self.coordinates+self.speeds
+
+    def integrate(self, time, x0=None, p=None, u=None, M=None, F=None):
+        """ 
+        Perform time integration for a set of numerical values
+        Using Kane's equations of motions
+
+        x0: dictionary of initial states, keys are sympy variable, values are numerical
+        p: dictionary of parameters, keys are sympy variable, values are numerical
+        u: dictionary of inputs, keys are sympy variable, values are numerical
+        M: Optional mass matrix
+        D: Optional forcing vector
+        """
+        # --- Simulation
+        from scipy.integrate import odeint
+        from pydy.codegen.ode_function_generators import generate_ode_function
+        from collections import OrderedDict
+
+        # Get important matrices
+        if M is None:
+            M = self.kane.mass_matrix_full
+            #mass_matrix.simplify() #<<< Might change solution
+        if F is None:
+            F = self.kane.forcing_full
+            #forcing_vector.simplify()
+
+        # From dictionaries to list
+        if p is not None:
+            p_var = [k for k,v in p.items()]
+            p_num = np.array([v for k,v in p.items()])
+        else:
+            p_var = []
+            p_num = []
+        if u is not None:
+            u_var = [k for k,v in u.items()]
+            u_num = np.array([v for k,v in u.items()])
+        else:
+            u_var = []
+            u_num = []
+        x0DictFull = OrderedDict({k: 0.0 for k in self.q_full})
+        x0DictFull.update(x0)
+        x0 = np.array([v for k,v in x0DictFull.items()])
+
+        print('p_var',p_var)
+        print('p_num',p_num)
+        print('u_var',u_var)
+        print('u_num',u_num)
+        print('x0',x0)
+
+        # --- Generate code
+        RHS = generate_ode_function(F, self.coordinates, self.speeds, p_var, mass_matrix=M, specifieds=u_var)
+        self._RHS = RHS
+
+        if len(x0)!=len(self.q_full):
+            raise Exception('x0 should be twice the length of numerical coordinates')
+
+        # --- Simulate
+        y = odeint(RHS, x0, time, args=(u_num, p_num))
+
+        # TODO create dataframe
+        cols=['Time_[s]']+['{}'.format(sp.latex(c)) for c in self.q_full]
+        dat = np.column_stack((time, y))
+        df = pd.DataFrame(data=dat, columns=cols)
+        self.df = df
+
+
+        # --- Store for vizualisation
+        self._u = u
+        self._p = p
+        self._y=y
+        self._t=time
+        return y
+
+
+    def getScene(self, y=None, rp=0.1, al=1, axes=True, origins=True):
+        from pydy.viz.shapes import Cylinder, Sphere
+        from pydy.viz.visualization_frame import VisualizationFrame
+        from welib.yams.yams_sympy_tools import body_viz, frame_viz, MyScene
+        # --- Axes for each body
+        axes_viz=[]
+        if axes:
+            xax,yax,zax = frame_viz(self.ref.origin, self.ref.frame, l=al, r=0.05*al, name='inertial')
+            axes_viz += [xax,yax,zax]
+            for b in self.bodies:
+                 xax,yax,zax = frame_viz(b.origin, b.frame, l=al, r=0.05*al, name=b.name)
+                 axes_viz += [xax,yax,zax]
+        # --- Origins for each body
+        orgs_viz = []
+        if origins:
+            PointSphere = Sphere(color='black', radius=rp) 
+            for b in self.bodies:
+                 O_viz = VisualizationFrame(b.name+'_origin',b.frame, b.origin, PointSphere)
+                 orgs_viz+= [O_viz]
+
+        # --- Bodies representation
+        bods_viz=[]
+        for b in self.bodies:
+            # TODO function
+            bods_viz+=body_viz(b, b.viz_opts)
+
+        scene = MyScene(self.ref.frame, self.ref.origin,
+            *orgs_viz,
+            *axes_viz,
+            *bods_viz,
+             )
+        scene.constants = self._p
+        scene.states_symbols = self.coordinates + self.speeds
+        scene.states_trajectories = self._y
+        scene.times = self._t
+        return scene
+
+
+
     def smallAngleApprox(self, angle_list, extraSubs=None, order=1):
         """ 
         Apply small angle approximation to forcing and mass matrix
         NOTE: can be called multiple times with different angle list (cumulative effect)
         """
         extraSubs = [] if extraSubs is None else extraSubs
         # Forcing
@@ -245,19 +364,21 @@
                 B = EOM.jacobian(self.var              ).subs(extraSubs).subs(op_point)
             else:
                 B=Matrix([])
 
 
         return M,C,K,B
 
-    def to_EOM(self, extraSubs=None):
+    def to_EOM(self, extraSubs=None, simplify=False):
         """ return a class to easily manipulate the equations of motion in place"""
         EOM = self.EOM().subs(self.kdeqsSubs).doit()
         if extraSubs is not None:
             EOM = EOM.subs(extraSubs)
+        if simplify:
+            EOM.simplify()
 
         bodyReplaceDict=OrderedDict()
         for b in self.bodies:
             if isinstance(b, YAMSFlexibleBody):
                 b.replaceDict(bodyReplaceDict)
 
         return EquationsOfMotionQ(EOM, self.coordinates, self.name, bodyReplaceDict)
@@ -318,15 +439,15 @@
 
         #  --- Small angle approximations
         if smallAngles is not None:
             with Timer('Small angle approx', silent=silentTimer):
                 for sa_list_order in smallAngles:
                     sa_list = sa_list_order[0]
                     order   = sa_list_order[1]
-                    EOM.smallAngleApprox(sa_list, order=order)
+                    EOM.smallAngleApprox(sa_list, order=order, inPlace=True) # NOTE <<< EOM is now changed!
             with Timer('Simplify', silent=silentTimer):
                 EOM.simplify()
 
         # --- Separate EOM into mass matrix and forcing
         with Timer('Mass forcing term', silent=silentTimer):
             EOM.mass_forcing_form() # EOM.M and EOM.F
 
@@ -583,14 +704,23 @@
 
         self.name=name
         self.bodyReplaceDict=bodyReplaceDict
 
         self.input_vars=findInputs(EOM, q)     
         #self.mass_forcing_form(self, extraSubs=None) # M and F
         #self.linearize(self, op_point, noAcc, noVel=False, extraSubs=None): # M0,K0,B0
+
+
+    @property
+    def qdot(self):
+        return [diff(c,dynamicsymbols._t) for c in self.q]
+
+    @property
+    def qddot(self):
+        return [diff(diff(c,dynamicsymbols._t),dynamicsymbols._t) for c in self.q]
  
 
     def __repr__(self):
         s='<{} object "{}" with attributes:>\n'.format(type(self).__name__,self.name)
         s+=' - name:    {}\n'.format(self.name)
         s+=' - q:       {}\n'.format(self.q)
         s+=' - input_vars: {}\n'.format(self.input_vars)
@@ -599,14 +729,20 @@
         s+='attributes: EOM\n'.format(self.smallAnglesUsed)
         s+='attributes: M,F          (call mass_forcing_form) \n'.format(self.smallAnglesUsed)
         s+='attributes: M0,K0,C0,B0  (call linearize) \n'.format(self.smallAnglesUsed)
         s+='methods that act on EOM in place (not M/F,M0): subs, simplify, trigsimp, expand\n'
         return s
 
 
+    def changeVar(self, newq, subs):
+        EOM_ = self.EOM.subs(subs)
+        EOM_.simplify()
+        return EquationsOfMotionQ(EOM_, newq, self.name, bodyReplaceDict=self.bodyReplaceDict)
+
+
     def subs(self, subs_list, inPlace=True):
         """ Apply substitutions to equations of motion """
         if inPlace:
             self.EOM = self.EOM.subs(subs_list)
         else:
             return self.EOM.subs(subs_list)
 
@@ -619,44 +755,63 @@
         """ Trigonometric simplifications of  equations of motion """
         self.EOM = trigsimp(self.EOM)
 
     def expand(self):
         """ Trigonometric simplifications of  equations of motion """
         self.EOM = self.EOM.expand()
 
-    def smallAngleApprox(self, angle_list, order=1, inPlace=True):
+    def smallAngleApprox(self, angle_list, order=1, inPlace=False, newInstance=True):
         """ 
         Apply small angle approximation to EOM 
 
-        NOTE: inPlace!
+        NOTE: inPlace! <<<< TODO return another instance of EOM instead!
         """
         with Timer('Small angle approx',True,silent=True):
+            EOM_sa = smallAngleApprox(self.EOM, angle_list, order=order)
             if inPlace:
-                self.EOM = smallAngleApprox(self.EOM, angle_list, order=order)
+                # Change current object
+                self.EOM = EOM_sa
                 self.smallAnglesUsed+=angle_list
+            elif newInstance:
+                # Return a new instance of EOM
+                EOM = EquationsOfMotionQ(EOM_sa, self.q, self.name+'_sa', bodyReplaceDict=self.bodyReplaceDict)
+                EOM.input_vars = self.input_vars # ensure we have the same inputs..
+                EOM.smallAnglesUsed=self.smallAnglesUsed+angle_list
+                # NOTE: remember to call mass_forcing_form...
+                return EOM
             else:
-                return smallAngleApprox(self.EOM, angle_list, order=order)
+                # Return EOM directly
+                return EOM_sa
 
-    def mass_forcing_form(self, extraSubs=None):
+
+    def mass_forcing_form(self, extraSubs=None, simplify=False):
         """ Extract Mass Matrix and RHS from EOM """
         extraSubs = [] if extraSubs is None else extraSubs
         qd  = [diff(c,dynamicsymbols._t) for c in self.q]
         qdd = [diff(diff(c,dynamicsymbols._t),dynamicsymbols._t) for c in self.q]
         self.M = - myjacobian(self.EOM, qdd)  # mass matrix is jacobian wrt qdd
         self.F = (self.M * Matrix(qdd) + self.EOM).expand() # remainder
         self.F = self.F.subs([(qddi,0) for qddi in qdd  ]) # safety
         self.F = self.F.expand()
+        if simplify:
+            self.F.simplify()
+            self.M.simplify()
 
-    def linearize(self, op_point=None, noAcc=True, noVel=False, extraSubs=None):
+    def linearize(self, op_point=None, noAcc=True, noVel=False, extraSubs=None, simplify=False):
         """
         Linearize EOM
         """
         op_point  = [] if op_point is None else op_point
         extraSubs = [] if extraSubs is None else extraSubs
         self.M0,self.C0,self.K0,self.B0, self.input_vars = linearizeQ(self.EOM, self.q, op_point=op_point, noAcc=noAcc, noVel=noVel, extraSubs=extraSubs)
+        if simplify:
+            self.M0.simplify()
+            self.K0.simplify()
+            self.C0.simplify()
+            self.B0.simplify()
         return self.M0, self.C0, self.K0, self.B0
 
     def saveTex(self, name='', prefix='', suffix='', folder='./', extraSubs=None, header=True, extraHeader=None, variables=['M','F','M0','C0','K0','B0'], doSimplify=False, velSubs=[(0,0)], fullPage=True):
         """ 
         Save EOM to a latex file
         """
         extraSubs = [] if extraSubs is None else extraSubs
@@ -763,15 +918,15 @@
     # NOTE: order important
     op_point0=[]
     if noAcc: 
         op_point0=[(qddi,0) for qddi in qdd]
     if noVel: 
         op_point0=[(qdi,0) for qdi in qd]
     op_point= op_point0+op_point # order might matter
-    print('>>> TODO sort op point so that diff wrt time are first, or do the trick with symbols')
+    print('>>> TODO linearize does not protect derivatives in substituion!')
     # use if isinstance sympy.core.function.Derivative
 
     # --- Inputs are dynamic symbols that are not coordinates
     if u is None:
         u = findInputs(EOM, q)
     # KEEP ME Alternative
     #M, A, B = linearizer.linearize(op_point=op_point ) #o
```

### Comparing `welib-0.0.2/welib.egg-info/PKG-INFO` & `welib-1.0.0/welib.egg-info/PKG-INFO`

 * *Files 7% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: welib
-Version: 0.0.2
+Version: 1.0.0
 Summary: Wind Energy Library
 Home-page: http://github.com/ebranlard/welib/
 Author: Emmanuel Branlard
 Author-email: lastname@gmail.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Development Status :: 5 - Production/Stable
```

### Comparing `welib-0.0.2/welib.egg-info/SOURCES.txt` & `welib-1.0.0/welib.egg-info/SOURCES.txt`

 * *Files 6% similar despite different names*

```diff
@@ -1,12 +1,15 @@
+.gitattributes
+.gitconfig
 .gitignore
 .travis.yml
 LICENSE.TXT
 Makefile
 README.md
+developper_notes.md
 requirements.txt
 setup.py
 .github/workflows/tests.yml
 data/Hawc2/BD.dat
 data/Hawc2/Blade_Planform_Hawc2.csv
 data/Hawc2/Blade_Structural_Hawc2.csv
 data/Monopile/.gitignore
@@ -15,17 +18,19 @@
 data/Monopile/MT100_ED.dat
 data/Monopile/MT100_HD_RegularWave.dat
 data/Monopile/MT100_HD_Still.dat
 data/Monopile/MT100_LoadsMotions.csv
 data/Monopile/MT100_SD.dat
 data/Monopile/Main_MT100_RegularWave.fst
 data/Monopile/README.py
+data/NREL5MW/.gitignore
 data/NREL5MW/Main_Onshore.fst
 data/NREL5MW/Main_Onshore_DriveTrainTorsion.fst
 data/NREL5MW/NREL5MW_Blade_FEM_Modes.csv
+data/NREL5MW/NREL5MW_CPCTCQ.txt
 data/NREL5MW/NREL5MW_Oper.csv
 data/NREL5MW/NREL5MW_Tower_Onshore_FEM_Modes.csv
 data/NREL5MW/5MW_Baseline/NREL5MW_IW.dat
 data/NREL5MW/5MW_Baseline/NREL5MW_IW_Step.dat
 data/NREL5MW/5MW_Baseline/NREL5MW_SvD.dat
 data/NREL5MW/5MW_Baseline/NREL5MW_SvD_Simple.dat
 data/NREL5MW/5MW_Baseline/NRELOffshrBsline5MW_AeroDyn_blade.dat
@@ -57,21 +62,24 @@
 data/NREL5MW/hawc2/Blade_Structural_Hawc2.csv
 data/NREL5MW/hawc2/README.md
 data/NREL5MW/offshore/NREL5MW_ED_Offshore.dat
 data/NREL5MW/offshore/NREL5MW_ED_Offshore_Legacy.dat
 data/NREL5MW/offshore/NREL5MW_HD.dat
 data/NREL5MW/onshore/NREL5MW_AD.dat
 data/NREL5MW/onshore/NREL5MW_ED_Onshore.dat
+data/Spar/MAP.dat
 data/Spar/Main_Spar_ED.fst
 data/Spar/Main_Spar_ED_HydroExample.fst
 data/Spar/Main_Spar_ED_HydroExample.outb
+data/Spar/Main_Spar_ED_MAP.fst
 data/Spar/Main_Spar_SD.fst
 data/Spar/Spar_ED_ForED.dat
 data/Spar/Spar_ED_ForSD.dat
 data/Spar/Spar_HD.dat
+data/Spar/Spar_HD_Dummy.dat
 data/Spar/Spar_SD.dat
 data/SubDyn/.gitignore
 data/SubDyn/Jacket.dat
 data/SubDyn/Jacket.dvr
 data/SubDyn/JacketTwr.dat
 data/SubDyn/JacketTwr.dvr
 data/SubDyn/SD_Cable_5Joints.dat
@@ -82,14 +90,15 @@
 data/SubDyn/TwrSmall.dvr
 data/Waves/RegularWave.Elev
 data/example_files/FASTSum_Pendulum.SD.sum.yaml
 data/example_files/FASTSum_PendulumNoCB.SD.sum.yaml
 data/example_files/fastout_allnodes.outb
 welib/Makefile
 welib/__init__.py
+welib/essentials.py
 welib.egg-info/PKG-INFO
 welib.egg-info/SOURCES.txt
 welib.egg-info/dependency_links.txt
 welib.egg-info/not-zip-safe
 welib.egg-info/requires.txt
 welib.egg-info/top_level.txt
 welib/BEM/_OTHER.py
@@ -258,17 +267,18 @@
 welib/FEM/frame3d.py
 welib/FEM/frame3dlin.py
 welib/FEM/graph.py
 welib/FEM/reduction.py
 welib/FEM/timoshenko.py
 welib/FEM/utils.py
 welib/FEM/derivations/GuyanReduction.py
-welib/FEM/examples/Beam_CraigBamptonReduction_Monopile.py
+welib/FEM/derivations/frame2D_sympy.ipynb
+welib/FEM/derivations/frame3D_sympy.ipynb
+welib/FEM/examples/Beam_CraigBampton_Monopile.py
 welib/FEM/examples/Beam_FlexibleProperties_Tower.py
-welib/FEM/examples/Beam_ModeShapes_Monopile.py
 welib/FEM/examples/Beam_ModeShapes_Tower.py
 welib/FEM/examples/Beam_ModeShapes_UniformBeamFrame3d.py
 welib/FEM/examples/Graph_CreateSimpleGraph.py
 welib/FEM/examples/README.md
 welib/FEM/examples/frame2d_element.py
 welib/FEM/matlab/fBeamMatrices2D_2DOF.m
 welib/FEM/matlab/fBeamMatrices3D_Frame6DOF.m
@@ -291,30 +301,41 @@
 welib/FEM/matlab/examples/Main_TowerTopExcitation.m
 welib/FEM/matlab/examples/RefDisp.csv
 welib/FEM/matlab/examples/ThinBeam3D.m
 welib/FEM/matlab/examples/ThinRotatingBeam_FEM.m
 welib/FEM/matlab/examples/fTowerTopExcitation.m
 welib/FEM/matlab/examples/fTowerTopMDKR.m
 welib/FEM/matlab/examples/fTowerTopYDot.m
+welib/FEM/models/__init__.py
+welib/FEM/models/uniform_beam.py
 welib/FEM/tests/_FEMBeam2SID.py
 welib/FEM/tests/__init__.py
 welib/FEM/tests/test_beam_linear_element.py
+welib/FEM/tests/test_fem_elements.py
 welib/FEM/tests/test_frame3d.py
 welib/FEM/tests/test_reduction.py
 welib/FEM/tests/test_run_Examples.py
+welib/FEM/tests/test_timoshenko.py
 welib/FEM/tests/test_utils.py
 welib/airfoils/DynamicStall.py
 welib/airfoils/Makefile
 welib/airfoils/Polar.py
+welib/airfoils/_Polar_Wisdem.py
 welib/airfoils/__init__.py
+welib/airfoils/naca.py
+welib/airfoils/polar_file.py
+welib/airfoils/section.py
+welib/airfoils/shapes.py
+welib/airfoils/wings.py
 welib/airfoils/data/63-235.csv
 welib/airfoils/data/Cylinder.csv
 welib/airfoils/data/Cylinder.dat
 welib/airfoils/data/DU21_A17.csv
 welib/airfoils/data/FFA-W3-241-Re12M.dat
+welib/airfoils/data/tjaere11_ds.csv
 welib/airfoils/examples/README.md
 welib/airfoils/examples/correction3D.py
 welib/airfoils/examples/createADPolarFile.py
 welib/airfoils/examples/dynamic_stall_mhh.py
 welib/airfoils/examples/dynamic_stall_mhh_riso_1792.py
 welib/airfoils/examples/dynamic_stall_mhh_step_change.py
 welib/airfoils/examples/dynamic_stall_oye.py
@@ -367,15 +388,17 @@
 welib/airfoils/matlab/data/geom-ffaw3241.dat
 welib/airfoils/matlab/data/geom-karman-trefftz_-0.1_0.0_5.dat
 welib/airfoils/tests/__init__.py
 welib/airfoils/tests/test_dynamic_stall.py
 welib/airfoils/tests/test_polar_interp.py
 welib/airfoils/tests/test_polar_manip.py
 welib/airfoils/tests/test_polar_params.py
+welib/airfoils/tests/test_polar_subfunctions.py
 welib/airfoils/tests/test_run_Examples.py
+welib/airfoils/tests/test_section.py
 welib/beams/__init__.py
 welib/beams/theory.py
 welib/beams/examples/Ex1_BeamModes.py
 welib/beams/examples/Ex2_BeamModesAllBC.py
 welib/beams/examples/___TestBeamDynUniform.py
 welib/beams/examples/__init__.py
 welib/beams/matlab/fInputParser.m
@@ -393,14 +416,15 @@
 welib/dyninflow/DynamicInflow.py
 welib/dyninflow/__init__.py
 welib/dyninflow/examples/Ex1_StepUp.py
 welib/dyninflow/examples/__init__.py
 welib/fast/FASTLin.py
 welib/fast/README.md
 welib/fast/__init__.py
+welib/fast/aerodyn.py
 welib/fast/beamdyn.py
 welib/fast/campbell.py
 welib/fast/case_gen.py
 welib/fast/elastodyn.py
 welib/fast/extract.py
 welib/fast/fast_mesh - Copy.py
 welib/fast/fast_mesh.py
@@ -414,36 +438,45 @@
 welib/fast/linearization.py
 welib/fast/linmodel.py
 welib/fast/olaf.py
 welib/fast/postpro.py
 welib/fast/runner.py
 welib/fast/subdyn.py
 welib/fast/subdyn_sum.py
+welib/fast/tuning.py
 welib/fast/examples/.gitignore
 welib/fast/examples/Example_CPLambdaPitch.py
+welib/fast/examples/Example_ElastoDynShapeFunctionFitting.py
 welib/fast/examples/Example_ExcelFile.py
 welib/fast/examples/Example_ExtractInertia.py
 welib/fast/examples/Example_Hawc2ToBeamDyn.py
 welib/fast/examples/Example_HydroDyn_PrescribedMotion.py
 welib/fast/examples/Example_Parametric.py
 welib/fast/examples/Example_PointMesh.py
 welib/fast/examples/Example_PowerCurve_Parametric.py
 welib/fast/examples/Example_RadialInterp.py
 welib/fast/examples/Example_RadialPostPro.py
 welib/fast/examples/Example_Remap.py
 welib/fast/examples/Example_SubDyn_Modes.py
+welib/fast/examples/Example_TuneTowerDamping.py
 welib/fast/examples/ParametricExcel.xlsx
 welib/fast/examples/README.md
+welib/fast/modules/__init__.py
+welib/fast/modules/map/__init__.py
+welib/fast/modules/map/examples/MAPStiffnessMatrix.py
 welib/fast/tests/__init__.py
 welib/fast/tests/test_elastodyn.py
 welib/fast/tests/test_hydrodyn.py
 welib/fast/tests/test_mesh.py
 welib/fast/tests/test_run_Examples.py
+welib/fast/tools/__init__.py
+welib/fast/tools/lin.py
 welib/hydro/__init__.py
 welib/hydro/_spectral.py
+welib/hydro/addedmass.py
 welib/hydro/hydrostat.py
 welib/hydro/morison.py
 welib/hydro/spectra.py
 welib/hydro/tools.py
 welib/hydro/wavekin.py
 welib/hydro/examples/Ex1_WaveKinematics.py
 welib/hydro/examples/Ex2_Jonswap_spectrum.py
@@ -453,15 +486,14 @@
 welib/hydro/examples/__init__.py
 welib/hydro/tests/__init__.py
 welib/hydro/tests/test_morison.py
 welib/hydro/tests/test_run_Examples.py
 welib/hydro/tests/test_spectra.py
 welib/hydro/tests/test_wavekin.py
 welib/kalman/TN.py
-welib/kalman/TNLin - Copy.py
 welib/kalman/TNLin.py
 welib/kalman/__init__.py
 welib/kalman/filters.py
 welib/kalman/kalman.py
 welib/kalman/kalmanfilter.py
 welib/kalman/examples/Mech_1DOF.py
 welib/kalman/examples/onshore_OFLin/001_Linearization_GenerateCase.py
@@ -483,19 +515,24 @@
 welib/mesh/gradient.py
 welib/mesh/mesh.py
 welib/mesh/vectoranalysis.py
 welib/mesh/tests/__init__.py
 welib/mesh/tests/test_vectoranalysis.py
 welib/moor/__init__.py
 welib/moor/mappp.py
+welib/ode/__init__.py
+welib/ode/generalizedalpha.py
+welib/ode/rk_dormand_prince.py
+welib/ode/rk_nystrom.py
 welib/ode/matlab/fodeKrenk.m
 welib/ode/matlab/fodeNewmark.m
 welib/ode/matlab/fodeNewmarkNonLinear.m
 welib/ode/matlab/fodeProgressBar.m
 welib/ode/matlab/fodeRK4.m
+welib/ode/tests/__init__.py
 welib/plot/_PlotTorus.py
 welib/plot/__init__.py
 welib/plot/json3d.py
 welib/plot/surface3d.py
 welib/plot/examples/JSON3D_01_CreateSimpleFile.py
 welib/plot/examples/Plot_3D_blades.py
 welib/plot/examples/Plot_3D_surfaces.py
@@ -504,14 +541,15 @@
 welib/standards/IEC.py
 welib/standards/__init__.py
 welib/standards/examples/Ex1_TurbulenceClasses.py
 welib/standards/examples/Ex2_EOG.py
 welib/standards/examples/__init__.py
 welib/system/Makefile
 welib/system/__init__.py
+welib/system/chaos.py
 welib/system/eva.py
 welib/system/firstorder.py
 welib/system/linearization.py
 welib/system/lti.py
 welib/system/mbc.py
 welib/system/mech_system.py
 welib/system/secondorder.py
@@ -520,81 +558,90 @@
 welib/system/statespacelinear.py
 welib/system/system.py
 welib/system/tools.py
 welib/system/transferfunction.py
 welib/system/examples/Example_DriveTrainTorsion.py
 welib/system/examples/Example_DriveTrainTorsion_Wrap.py
 welib/system/examples/FirstOrderSystem_Scalar.py
+welib/system/examples/Lorenz.py
 welib/system/examples/MassSpringDamper_Duhamel.py
 welib/system/examples/MassSpringDamper_ForcedVibrations.py
 welib/system/examples/MassSpringDamper_StateSpace_FreqDomain.py
 welib/system/examples/SecondOrderSystem_Scalar.py
 welib/system/examples/StepResponse.py
 welib/system/examples/pendulum.py
 welib/system/examples/pendulum_3d.py
 welib/system/examples/pendulum_on_prescribed_cart.py
-welib/system/examples_stab/__init__.py
-welib/system/examples_stab/exA1.py
-welib/system/examples_stab/exA2.py
-welib/system/examples_stab/exB1.py
-welib/system/examples_stab/model15DOFs.py
-welib/system/examples_stab/model5DOFs.py
-welib/system/examples_stab/test_model.py
 welib/system/tests/__init__.py
 welib/system/tests/test_eva.py
 welib/system/tests/test_linearization.py
 welib/system/tests/test_mbc.py
 welib/system/tests/test_run_Examples.py
 welib/system/tests/test_singledof.py
 welib/system/tests/test_system.py
+welib/system/wtmodels/__init__.py
+welib/system/wtmodels/model15M.py
+welib/system/wtmodels/model5CS.py
+welib/system/wtmodels/examples/model15M_exA1.py
+welib/system/wtmodels/examples/model15M_exA2.py
+welib/system/wtmodels/examples/model15M_exB1.py
+welib/system/wtmodels/examples/model5CS_ronnie.py
+welib/system/wtmodels/tests/__init__.py
+welib/system/wtmodels/tests/test_model15M.py
+welib/system/wtmodels/tests/test_run_Examples.py
 welib/time/TimeManager.m
 welib/time/fInitTime.m
 welib/tools/README.md
 welib/tools/__init__.py
 welib/tools/bithashlib.py
 welib/tools/clean_exceptions.py
 welib/tools/colors.py
 welib/tools/compare.py
 welib/tools/curve_fitting.py
 welib/tools/curves.py
 welib/tools/damping.py
+welib/tools/dictlib.py
 welib/tools/eva.py
 welib/tools/fatigue.py
 welib/tools/fields.py
 welib/tools/figure.py
 welib/tools/functions.py
 welib/tools/galib.py
 welib/tools/latex.py
 welib/tools/lic.py
 welib/tools/pandalib.py
 welib/tools/pycmd.py
+welib/tools/regression.py
 welib/tools/repo.py
 welib/tools/requirements.txt
 welib/tools/signal_analysis.py
 welib/tools/spectral.py
 welib/tools/stats.py
 welib/tools/strings.py
+welib/tools/svd.py
 welib/tools/tictoc.py
 welib/tools/SpectralAnalysis/fLogSmooth.m
 welib/tools/SpectralAnalysis/fSpectrum.m
 welib/tools/SpectralAnalysis/fSpectrumAngular.m
 welib/tools/examples/ExampleCoherence.py
 welib/tools/examples/ExampleCorrelation.py
 welib/tools/examples/Example_FFT.py
+welib/tools/examples/Example_SVD.py
 welib/tools/examples/VortexCylinderPressure.py
 welib/tools/external/Makefile
 welib/tools/external/__init__.py
 welib/tools/external/_lic_demo.py
 welib/tools/external/lic_internal.c
 welib/tools/external/lic_internal.pyx
 welib/tools/external/setup.py
 welib/tools/tests/__init__.py
 welib/tools/tests/test_colors.py
 welib/tools/tests/test_curve_fitting.py
 welib/tools/tests/test_curves.py
+welib/tools/tests/test_dictlib.py
 welib/tools/tests/test_fatigue.py
 welib/tools/tests/test_functions.py
 welib/tools/tests/test_signal.py
 welib/tools/tests/test_spectral.py
 welib/tools/tests/test_vectoranalyses.py
 welib/vortilib/.gitignore
 welib/vortilib/__init__.py
@@ -615,15 +662,14 @@
 welib/vortilib/elements/VortexSurfaceFlowField.py
 welib/vortilib/elements/__init__.py
 welib/vortilib/elements/elliptic.py
 welib/vortilib/elements/fOmega_VortexBrick2D.py
 welib/vortilib/elements/fOmega_VortexBrick3D.py
 welib/vortilib/elements/fUi_VortexSegment11_smooth.py
 welib/vortilib/elements/examples/EllipticalCoordinates.py
-welib/vortilib/elements/examples/InducedVelocities.py
 welib/vortilib/elements/examples/InviscidVortexPatch.py
 welib/vortilib/elements/examples/LambOseenFenics.py
 welib/vortilib/elements/examples/SourceEllipsoid_Deriv.py
 welib/vortilib/elements/examples/SourceEllipsoid_Plots.py
 welib/vortilib/elements/examples/VortexHelix.py
 welib/vortilib/elements/examples/VortexParticle_Regularization.py
 welib/vortilib/elements/examples/VortexPoint2DDistribution.py
@@ -643,14 +689,15 @@
 welib/vortilib/elements/fortran/UISegments.f90
 welib/vortilib/elements/fortran/UIVortexCylinders.f90
 welib/vortilib/elements/fortran/UIVortexPoint2D.f90
 welib/vortilib/elements/fortran/UIVortexPoint2DPerdiodic.f90
 welib/vortilib/elements/fortran/UIVortexRings.f90
 welib/vortilib/elements/tests/__init__.py
 welib/vortilib/elements/tests/test_elements.py
+welib/vortilib/elements/tests/test_run_Examples.py
 welib/vortilib/particles/__init__.py
 welib/vortilib/particles/initialization.py
 welib/vortilib/particles/particles.py
 welib/vortilib/particles/projection.py
 welib/vortilib/particles/examples/MainVC2D_TestProj.py
 welib/vortilib/particles/tests/__init__.py
 welib/vortilib/particles/tests/test_particles.py
@@ -682,18 +729,22 @@
 welib/weio/hawc2_htc_file.py
 welib/weio/hawc2_pc_file.py
 welib/weio/hawc2_st_file.py
 welib/weio/hawcstab2_cmb_file.py
 welib/weio/hawcstab2_ind_file.py
 welib/weio/hawcstab2_pwr_file.py
 welib/weio/mannbox_file.py
+welib/weio/mannbox_input_file.py
+welib/weio/matlabmat_file.py
 welib/weio/mini_yaml.py
 welib/weio/netcdf_file.py
 welib/weio/parquet_file.py
+welib/weio/pickle_file.py
 welib/weio/raawmat_file.py
+welib/weio/rosco_discon_file.py
 welib/weio/rosco_performance_file.py
 welib/weio/tdms_file.py
 welib/weio/tecplot_file.py
 welib/weio/turbsim_file.py
 welib/weio/turbsim_ts_file.py
 welib/weio/user.py
 welib/weio/vtk_file.py
@@ -740,96 +791,109 @@
 welib/windwave/fWaveKin.m
 welib/windwave/fWindCalc.m
 welib/windwave/fgetDispersion.m
 welib/windwave/fqPrime.m
 welib/windwave/include_globals.m
 welib/ws_estimator/__init__.py
 welib/ws_estimator/tabulated.py
+welib/ws_estimator/tabulated_floating.py
+welib/ws_estimator/examples/Floating.py
+welib/ws_estimator/tests/__init__.py
+welib/ws_estimator/tests/test_tabulated.py
 welib/wt_theory/AxialInduction-CT.m
-welib/wt_theory/AxialInduction.py
 welib/wt_theory/AxialInductionCT.m
-welib/wt_theory/OptimalCirculation/.gitignore
-welib/wt_theory/OptimalCirculation/VERSIONS
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Dates.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Lists.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Maths.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Plots.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SQL.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m
-welib/wt_theory/OptimalCirculation/Mathematica/lib/Functions_Stats.m
-welib/wt_theory/OptimalCirculation/__main__/MainGoldsteinPlots.m
-welib/wt_theory/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m
-welib/wt_theory/OptimalCirculation/__main__/PrandtlTheory.m
-welib/wt_theory/OptimalCirculation/__tests__/testCompareGoldstein.m
-welib/wt_theory/OptimalCirculation/__tests__/testGoldstein.m
-welib/wt_theory/OptimalCirculation/v-1/fBetzCirculation.m
-welib/wt_theory/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m
-welib/wt_theory/OptimalCirculation/v01/fCirculationBetz.m
-welib/wt_theory/OptimalCirculation/v01/fCirculationGoldstein.m
-welib/wt_theory/OptimalCirculation/v01/fCirculationPrandtl.m
-welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor.mexa64
-welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m
-welib/wt_theory/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m
-welib/wt_theory/OptimalCirculation/v01/fGoldsteinFarWakeParams.m
-welib/wt_theory/OptimalCirculation/v01/fGoldsteinOkulovF.m
-welib/wt_theory/OptimalCirculation/v01/fTiberyWrench.m
-welib/wt_theory/OptimalCirculation/v01/fTipLossGoldsteinOkulov.m
-welib/wt_theory/OptimalCirculation/v01/fTipLossPrandtl.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationBetz.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationGoldstein.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fCirculationPrandtl.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fTiberyWrench.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fTipLossGoldsteinOkulov.m
-welib/wt_theory/OptimalCirculation/v01_nomex/fTipLossPrandtl.m
-welib/wt_theory/OptimalTurbine/.gitignore
-welib/wt_theory/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m
-welib/wt_theory/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m
-welib/wt_theory/OptimalTurbine/OptiminumParam.m
-welib/wt_theory/OptimalTurbine/old/Exercise4bnew.m
-welib/wt_theory/OptimalTurbine/old/Test1OptiminumParam.m
-welib/wt_theory/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m
-welib/wt_theory/OptimalTurbine/old/Test3OptimumLambda.m
-welib/wt_theory/OptimalTurbine/old/Test3OptimumLambdaClCd.m
-welib/wt_theory/OptimalTurbine/old/Test5PowerCurve.m
-welib/wt_theory/OptimalTurbine/old/fBEM_backup.m
-welib/wt_theory/OptimalTurbine/wtta1/BEMfunction.m
-welib/wt_theory/OptimalTurbine/wtta1/Exercise1.m
-welib/wt_theory/OptimalTurbine/wtta1/Exercise2new.m
-welib/wt_theory/OptimalTurbine/wtta1/Exercise3new.m
-welib/wt_theory/OptimalTurbine/wtta1/GlauertSolutions.m
-welib/wt_theory/OptimalTurbine/wtta1/fakeBEM.m
-welib/wt_theory/OptimalTurbine/wtta1/getOptimizedParameters.m
-welib/wt_theory/OptimalTurbine/wtta1/getRelationAX.m
-welib/wt_theory/OptimalTurbine/wtta1/getThrustFromBlade.m
-welib/wt_theory/OptimalTurbine/wtta1/getTorqueFromBlade.m
-welib/wt_theory/OptimalTurbine/wtta1/loading.m
-welib/wt_theory/Theodorsen/.gitignore
-welib/wt_theory/Theodorsen/TheodorsenTheory.m
-welib/wt_theory/Theodorsen/TheodorsenTheory_Expansion_DevPhase0.m
-welib/wt_theory/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m
-welib/wt_theory/Theodorsen/VERSIONS
-welib/wt_theory/Theodorsen/WaldWakeRotorMapping.m
-welib/wt_theory/Theodorsen/fTheodorsenAtOperatingPoint.m
-welib/wt_theory/Theodorsen/fTheodorsenExpansion.m
-welib/wt_theory/Theodorsen/fTheodorsenExpansionWrap.m
-welib/wt_theory/Theodorsen/fTheodorsenFarWakeParams.m
-welib/wt_theory/VortexCylinder/.gitignore
-welib/wt_theory/VortexCylinder/VortexCylinder.m
-welib/wt_theory/WakeExpansion/.gitignore
-welib/wt_theory/WakeExpansion/MainComparisons_CodesAndTheory.m
-welib/wt_theory/WakeExpansion/MainComparisons_ForEwan.m
-welib/wt_theory/WakeExpansion/MainComparisons_TheoryOnly.m
-welib/wt_theory/WakeExpansion/fExpansionFranksen.m
-welib/wt_theory/WakeExpansion/fExpansionRathmann.m
-welib/wt_theory/WakeExpansion/fExpansionVortexRings.m
+welib/wt_theory/highthrust.py
+welib/wt_theory/idealrotors.py
+welib/wt_theory/wakeexpansion.py
+welib/wt_theory/examples/WakeExpansion.py
+welib/wt_theory/examples/WakeLengthInducedVelocity.py
+welib/wt_theory/matlab/OptimalCirculation/.gitignore
+welib/wt_theory/matlab/OptimalCirculation/VERSIONS
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Dates.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_LidarSpectra.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Lists.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Maths.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Plots.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SQL.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_SpectralAnalysis.m
+welib/wt_theory/matlab/OptimalCirculation/Mathematica/lib/Functions_Stats.m
+welib/wt_theory/matlab/OptimalCirculation/__main__/MainGoldsteinPlots.m
+welib/wt_theory/matlab/OptimalCirculation/__main__/OptimalPowerCoeffOkulov.m
+welib/wt_theory/matlab/OptimalCirculation/__main__/PrandtlTheory.m
+welib/wt_theory/matlab/OptimalCirculation/__main__/matfig/ComparisonBetzPrandtlGoldstein.fig
+welib/wt_theory/matlab/OptimalCirculation/__main__/matfig/ComparisonBetzPrandtlGoldsteinF.fig
+welib/wt_theory/matlab/OptimalCirculation/__tests__/testCompareGoldstein.m
+welib/wt_theory/matlab/OptimalCirculation/__tests__/testGoldstein.m
+welib/wt_theory/matlab/OptimalCirculation/v-1/fBetzCirculation.m
+welib/wt_theory/matlab/OptimalCirculation/v-1/fTipLossGoldsteinOkulov.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationBetz.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationGoldstein.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fCirculationPrandtl.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor.mexa64
+welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_Matlab.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFactor_MatlabOld.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinFarWakeParams.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fGoldsteinOkulovF.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fTiberyWrench.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fTipLossGoldsteinOkulov.m
+welib/wt_theory/matlab/OptimalCirculation/v01/fTipLossPrandtl.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationBetz.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationGoldstein.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fCirculationPrandtl.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFactor_MatlabOld.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinFarWakeParams.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fGoldsteinOkulovF.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTiberyWrench.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTipLossGoldsteinOkulov.m
+welib/wt_theory/matlab/OptimalCirculation/v01_nomex/fTipLossPrandtl.m
+welib/wt_theory/matlab/OptimalTurbine/.gitignore
+welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cp_CT_Lambda.m
+welib/wt_theory/matlab/OptimalTurbine/MomentumTheory_Cylinder_Cp_CT_Lambda.m
+welib/wt_theory/matlab/OptimalTurbine/OptiminumParam.m
+welib/wt_theory/matlab/OptimalTurbine/old/Exercise4bnew.m
+welib/wt_theory/matlab/OptimalTurbine/old/Test1OptiminumParam.m
+welib/wt_theory/matlab/OptimalTurbine/old/Test2BEMCodeForoneLambda_mostrecent.m
+welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambda.m
+welib/wt_theory/matlab/OptimalTurbine/old/Test3OptimumLambdaClCd.m
+welib/wt_theory/matlab/OptimalTurbine/old/Test5PowerCurve.m
+welib/wt_theory/matlab/OptimalTurbine/old/fBEM_backup.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/BEMfunction.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise1.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise2new.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/Exercise3new.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/GlauertSolutions.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/fakeBEM.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/getOptimizedParameters.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/getRelationAX.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/getThrustFromBlade.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/getTorqueFromBlade.m
+welib/wt_theory/matlab/OptimalTurbine/wtta1/loading.m
+welib/wt_theory/matlab/Theodorsen/.gitignore
+welib/wt_theory/matlab/Theodorsen/TheodorsenTheory.m
+welib/wt_theory/matlab/Theodorsen/TheodorsenTheory_Expansion_DevPhase0.m
+welib/wt_theory/matlab/Theodorsen/TheodorsenTheory_Expansion_DevPhase2.m
+welib/wt_theory/matlab/Theodorsen/VERSIONS
+welib/wt_theory/matlab/Theodorsen/WaldWakeRotorMapping.m
+welib/wt_theory/matlab/Theodorsen/fTheodorsenAtOperatingPoint.m
+welib/wt_theory/matlab/Theodorsen/fTheodorsenExpansion.m
+welib/wt_theory/matlab/Theodorsen/fTheodorsenExpansionWrap.m
+welib/wt_theory/matlab/Theodorsen/fTheodorsenFarWakeParams.m
+welib/wt_theory/matlab/VortexCylinder/.gitignore
+welib/wt_theory/matlab/VortexCylinder/VortexCylinder.m
+welib/wt_theory/matlab/WakeExpansion/.gitignore
+welib/wt_theory/matlab/WakeExpansion/MainComparisons_CodesAndTheory.m
+welib/wt_theory/matlab/WakeExpansion/MainComparisons_ForEwan.m
+welib/wt_theory/matlab/WakeExpansion/MainComparisons_TheoryOnly.m
+welib/wt_theory/matlab/WakeExpansion/fExpansionFranksen.m
+welib/wt_theory/matlab/WakeExpansion/fExpansionRathmann.m
+welib/wt_theory/matlab/WakeExpansion/fExpansionVortexRings.m
+welib/wt_theory/tests/__init__.py
+welib/wt_theory/tests/test_run_Examples.py
+welib/wt_theory/tests/test_wakeexpansion.py
 welib/yams/.gitignore
 welib/yams/DEBUG.py
 welib/yams/FNSB_FAST.py
 welib/yams/README.md
 welib/yams/TNSB.py
 welib/yams/TNSB_FAST.py
 welib/yams/__init__.py
@@ -843,22 +907,35 @@
 welib/yams/utils.py
 welib/yams/windturbine.py
 welib/yams/yams.py
 welib/yams/yams_kane.py
 welib/yams/yams_sympy.py
 welib/yams/yams_sympy_model.py
 welib/yams/yams_sympy_tools.py
+welib/yams/derivations/Inertia_Rotor.ipynb
+welib/yams/derivations/README.md
+welib/yams/derivations/RigidBodyDyn_SkewMatrix.ipynb
+welib/yams/derivations/RotationMatricesAndCoordinates.ipynb
 welib/yams/examples/Tower_MassMatrix_ShapeFunctions.py
 welib/yams/examples_numeric_recursive/Tower_SubBeams.py
 welib/yams/examples_symbolic_kane/.gitignore
 welib/yams/examples_symbolic_kane/L1_Top.py
+welib/yams/examples_symbolic_kane/L2_1DOF_MassSpringDamper.ipynb
+welib/yams/examples_symbolic_kane/L2_1DOF_Pendulum.ipynb
+welib/yams/examples_symbolic_kane/L2_2DOF_DoublePendulum.ipynb
+welib/yams/examples_symbolic_kane/L2_2DOF_MassSpringDamper.ipynb
+welib/yams/examples_symbolic_kane/L2_2DOF_PendulumOnACart.ipynb
+welib/yams/examples_symbolic_kane/L2_3DOF_Top.ipynb
+welib/yams/examples_symbolic_kane/L2_5DOF_SimplifiedCampbell.ipynb
 welib/yams/examples_symbolic_kane/L3_BladeModels.py
 welib/yams/examples_symbolic_kane/L3_FXTXRNA_Simulation.py
+welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.ipynb
 welib/yams/examples_symbolic_kane/L3_FXTXRNA_YAMSW.py
 welib/yams/examples_symbolic_kane/L3_OneRigidBody_SparHydro.py
+welib/yams/examples_symbolic_kane/L3_OneRigidBody_YAMSW.ipynb
 welib/yams/examples_symbolic_kane/README.md
 welib/yams/examples_symbolic_recursive/T1NRNA_yams_rec.py
 welib/yams/models/FTNSB_sympy.py
 welib/yams/models/FTNSB_sympy_symbols.py
 welib/yams/models/OneRigidBody_sympy.py
 welib/yams/models/__init__.py
 welib/yams/models/generator.py
@@ -871,14 +948,23 @@
 welib/yams/papers/2022-symbolic-framework/F2T1RNA_yams_model.py
 welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.fst
 welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Main_Spar_ED.outb
 welib/yams/papers/2022-symbolic-framework/F0T2N0S1/Spar_ED_ForED.dat
 welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.fst
 welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Main_Spar_ED.outb
 welib/yams/papers/2022-symbolic-framework/F2T1RNA_SmallAngle/Spar_ED_ForED.dat
+welib/yams/partdyn/__init__.py
+welib/yams/partdyn/part.py
+welib/yams/partdyn/examples/OnePart_FreeFall.py
+welib/yams/partdyn/examples/ThreePart_Gravitation.py
+welib/yams/partdyn/examples/ThreeSprings.py
+welib/yams/partdyn/examples/TwoPart_Orbits.py
+welib/yams/partdyn/examples/TwoPart_Springs.py
+welib/yams/partdyn/tests/__init__.py
+welib/yams/partdyn/tests/test_run_Examples.py
 welib/yams/tests/__init__.py
 welib/yams/tests/test_bodies.py
 welib/yams/tests/test_flexibility.py
 welib/yams/tests/test_rotations.py
 welib/yams/tests/test_sectionloads.py
 welib/yams/tests/test_sid.py
 welib/yams/tests/test_utils.py
```

