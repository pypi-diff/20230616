# Comparing `tmp/SupermarQ-0.3.30-py3-none-any.whl.zip` & `tmp/SupermarQ-0.3.31-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,36 +1,36 @@
-Zip file size: 35508 bytes, number of entries: 34
--rw-r--r--  2.0 unx      605 b- defN 23-Jun-07 22:25 supermarq/__init__.py
--rw-r--r--  2.0 unx       23 b- defN 23-Jun-07 22:25 supermarq/_version.py
--rw-r--r--  2.0 unx      283 b- defN 23-Jun-07 22:25 supermarq/_version_test.py
--rw-r--r--  2.0 unx      853 b- defN 23-Jun-07 22:25 supermarq/benchmark.py
--rw-r--r--  2.0 unx     1041 b- defN 23-Jun-07 22:25 supermarq/benchmark_test.py
--rw-r--r--  2.0 unx     4704 b- defN 23-Jun-07 22:25 supermarq/converters.py
--rw-r--r--  2.0 unx      423 b- defN 23-Jun-07 22:25 supermarq/converters_test.py
--rw-r--r--  2.0 unx     3194 b- defN 23-Jun-07 22:25 supermarq/features.py
--rw-r--r--  2.0 unx     1435 b- defN 23-Jun-07 22:25 supermarq/features_test.py
--rw-r--r--  2.0 unx    12392 b- defN 23-Jun-07 22:25 supermarq/plotting.py
--rw-r--r--  2.0 unx     1029 b- defN 23-Jun-07 22:25 supermarq/plotting_test.py
--rw-r--r--  2.0 unx      847 b- defN 23-Jun-07 22:25 supermarq/simulation.py
--rw-r--r--  2.0 unx    12415 b- defN 23-Jun-07 22:25 supermarq/stabilizers.py
--rw-r--r--  2.0 unx        0 b- defN 23-Jun-07 22:25 supermarq/benchmarks/__init__.py
--rw-r--r--  2.0 unx     3384 b- defN 23-Jun-07 22:25 supermarq/benchmarks/bit_code.py
--rw-r--r--  2.0 unx      537 b- defN 23-Jun-07 22:25 supermarq/benchmarks/bit_code_test.py
--rw-r--r--  2.0 unx     1609 b- defN 23-Jun-07 22:25 supermarq/benchmarks/ghz.py
--rw-r--r--  2.0 unx      286 b- defN 23-Jun-07 22:25 supermarq/benchmarks/ghz_test.py
--rw-r--r--  2.0 unx     4175 b- defN 23-Jun-07 22:25 supermarq/benchmarks/hamiltonian_simulation.py
--rw-r--r--  2.0 unx      572 b- defN 23-Jun-07 22:25 supermarq/benchmarks/hamiltonian_simulation_test.py
--rw-r--r--  2.0 unx     8677 b- defN 23-Jun-07 22:25 supermarq/benchmarks/mermin_bell.py
--rw-r--r--  2.0 unx      717 b- defN 23-Jun-07 22:25 supermarq/benchmarks/mermin_bell_test.py
--rw-r--r--  2.0 unx     3848 b- defN 23-Jun-07 22:25 supermarq/benchmarks/phase_code.py
--rw-r--r--  2.0 unx      553 b- defN 23-Jun-07 22:25 supermarq/benchmarks/phase_code_test.py
--rw-r--r--  2.0 unx     7420 b- defN 23-Jun-07 22:25 supermarq/benchmarks/qaoa_fermionic_swap_proxy.py
--rw-r--r--  2.0 unx      853 b- defN 23-Jun-07 22:25 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py
--rw-r--r--  2.0 unx     5799 b- defN 23-Jun-07 22:25 supermarq/benchmarks/qaoa_vanilla_proxy.py
--rw-r--r--  2.0 unx      564 b- defN 23-Jun-07 22:25 supermarq/benchmarks/qaoa_vanilla_proxy_test.py
--rw-r--r--  2.0 unx     7077 b- defN 23-Jun-07 22:25 supermarq/benchmarks/vqe_proxy.py
--rw-r--r--  2.0 unx      459 b- defN 23-Jun-07 22:25 supermarq/benchmarks/vqe_proxy_test.py
--rw-r--r--  2.0 unx     2196 b- defN 23-Jun-07 22:25 SupermarQ-0.3.30.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jun-07 22:25 SupermarQ-0.3.30.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Jun-07 22:25 SupermarQ-0.3.30.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     2981 b- defN 23-Jun-07 22:25 SupermarQ-0.3.30.dist-info/RECORD
-34 files, 91053 bytes uncompressed, 30668 bytes compressed:  66.3%
+Zip file size: 35808 bytes, number of entries: 34
+-rw-r--r--  2.0 unx      605 b- defN 23-Jun-15 22:28 supermarq/__init__.py
+-rw-r--r--  2.0 unx       23 b- defN 23-Jun-15 22:28 supermarq/_version.py
+-rw-r--r--  2.0 unx      283 b- defN 23-Jun-15 22:28 supermarq/_version_test.py
+-rw-r--r--  2.0 unx      853 b- defN 23-Jun-15 22:28 supermarq/benchmark.py
+-rw-r--r--  2.0 unx     1041 b- defN 23-Jun-15 22:28 supermarq/benchmark_test.py
+-rw-r--r--  2.0 unx     4704 b- defN 23-Jun-15 22:28 supermarq/converters.py
+-rw-r--r--  2.0 unx      423 b- defN 23-Jun-15 22:28 supermarq/converters_test.py
+-rw-r--r--  2.0 unx     3194 b- defN 23-Jun-15 22:28 supermarq/features.py
+-rw-r--r--  2.0 unx     1435 b- defN 23-Jun-15 22:28 supermarq/features_test.py
+-rw-r--r--  2.0 unx    12392 b- defN 23-Jun-15 22:28 supermarq/plotting.py
+-rw-r--r--  2.0 unx     1029 b- defN 23-Jun-15 22:28 supermarq/plotting_test.py
+-rw-r--r--  2.0 unx      847 b- defN 23-Jun-15 22:28 supermarq/simulation.py
+-rw-r--r--  2.0 unx    12415 b- defN 23-Jun-15 22:28 supermarq/stabilizers.py
+-rw-r--r--  2.0 unx        0 b- defN 23-Jun-15 22:28 supermarq/benchmarks/__init__.py
+-rw-r--r--  2.0 unx     3917 b- defN 23-Jun-15 22:28 supermarq/benchmarks/bit_code.py
+-rw-r--r--  2.0 unx      537 b- defN 23-Jun-15 22:28 supermarq/benchmarks/bit_code_test.py
+-rw-r--r--  2.0 unx     1863 b- defN 23-Jun-15 22:28 supermarq/benchmarks/ghz.py
+-rw-r--r--  2.0 unx      286 b- defN 23-Jun-15 22:28 supermarq/benchmarks/ghz_test.py
+-rw-r--r--  2.0 unx     4175 b- defN 23-Jun-15 22:28 supermarq/benchmarks/hamiltonian_simulation.py
+-rw-r--r--  2.0 unx      572 b- defN 23-Jun-15 22:28 supermarq/benchmarks/hamiltonian_simulation_test.py
+-rw-r--r--  2.0 unx     8677 b- defN 23-Jun-15 22:28 supermarq/benchmarks/mermin_bell.py
+-rw-r--r--  2.0 unx      717 b- defN 23-Jun-15 22:28 supermarq/benchmarks/mermin_bell_test.py
+-rw-r--r--  2.0 unx     4354 b- defN 23-Jun-15 22:28 supermarq/benchmarks/phase_code.py
+-rw-r--r--  2.0 unx      553 b- defN 23-Jun-15 22:28 supermarq/benchmarks/phase_code_test.py
+-rw-r--r--  2.0 unx     7420 b- defN 23-Jun-15 22:28 supermarq/benchmarks/qaoa_fermionic_swap_proxy.py
+-rw-r--r--  2.0 unx      853 b- defN 23-Jun-15 22:28 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py
+-rw-r--r--  2.0 unx     5799 b- defN 23-Jun-15 22:28 supermarq/benchmarks/qaoa_vanilla_proxy.py
+-rw-r--r--  2.0 unx      564 b- defN 23-Jun-15 22:28 supermarq/benchmarks/qaoa_vanilla_proxy_test.py
+-rw-r--r--  2.0 unx     7077 b- defN 23-Jun-15 22:28 supermarq/benchmarks/vqe_proxy.py
+-rw-r--r--  2.0 unx      459 b- defN 23-Jun-15 22:28 supermarq/benchmarks/vqe_proxy_test.py
+-rw-r--r--  2.0 unx     2196 b- defN 23-Jun-15 22:28 SupermarQ-0.3.31.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-15 22:28 SupermarQ-0.3.31.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Jun-15 22:28 SupermarQ-0.3.31.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2981 b- defN 23-Jun-15 22:28 SupermarQ-0.3.31.dist-info/RECORD
+34 files, 92346 bytes uncompressed, 30968 bytes compressed:  66.5%
```

## zipnote {}

```diff
@@ -84,20 +84,20 @@
 
 Filename: supermarq/benchmarks/vqe_proxy.py
 Comment: 
 
 Filename: supermarq/benchmarks/vqe_proxy_test.py
 Comment: 
 
-Filename: SupermarQ-0.3.30.dist-info/METADATA
+Filename: SupermarQ-0.3.31.dist-info/METADATA
 Comment: 
 
-Filename: SupermarQ-0.3.30.dist-info/WHEEL
+Filename: SupermarQ-0.3.31.dist-info/WHEEL
 Comment: 
 
-Filename: SupermarQ-0.3.30.dist-info/top_level.txt
+Filename: SupermarQ-0.3.31.dist-info/top_level.txt
 Comment: 
 
-Filename: SupermarQ-0.3.30.dist-info/RECORD
+Filename: SupermarQ-0.3.31.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## supermarq/_version.py

```diff
@@ -1 +1 @@
-__version__ = "0.3.30"
+__version__ = "0.3.31"
```

## supermarq/benchmarks/bit_code.py

```diff
@@ -6,45 +6,54 @@
 from supermarq.benchmark import Benchmark
 
 
 class BitCode(Benchmark):
     """Creates a circuit for syndrome measurement in a bit-flip error correcting code.
 
     Args:
-    - num_data: The number of data qubits
-    - num_rounds: The number of measurement rounds
-    - bit_state: A list denoting the state to initialize each data qubit to.
+        num_data: The number of data qubits.
+        num_rounds: The number of measurement rounds.
+        bit_state: A list denoting the state to initialize each data qubit to.
 
-    returns a cirq circuit for the bit-flip error correcting code
+    Returns:
+        A `cirq.Circuit` for the bit-flip error correcting code.
     """
 
     def __init__(self, num_data_qubits: int, num_rounds: int, bit_state: List[int]) -> None:
         if len(bit_state) != num_data_qubits:
             raise ValueError("The length of `bit_state` must match the number of data qubits")
         self.num_data_qubits = num_data_qubits
         self.num_rounds = num_rounds
         self.bit_state = bit_state
 
     def _measurement_round_cirq(
         self, qubits: List[cirq.LineQubit], round_idx: int
     ) -> Iterator[cirq.Operation]:
-        """Generates cirq ops for a single measurement round
+        """Generates `cirq.Operation`s for a single measurement round.
 
         Args:
-        - qubits: Circuit qubits - assumed data on even indices and measurement on odd indices
+            qubits: Circuit qubits, assuming data on even indices and measurement on odd indices.
+
+        Returns:
+            A `cirq.Operation` iterator with the operations for a measurement round.
         """
         ancilla_qubits = qubits[1::2]
         for qq in range(1, len(qubits), 2):
             yield cirq.CX(qubits[qq - 1], qubits[qq])
         for qq in range(1, len(qubits), 2):
             yield cirq.CX(qubits[qq + 1], qubits[qq])
         yield cirq.measure(*ancilla_qubits, key=f"mcm{round_idx}")
         yield from cirq.reset_each(*ancilla_qubits)
 
     def circuit(self) -> cirq.Circuit:
+        """Generates bit code circuit.
+
+        Returns:
+            A `cirq.Circuit`.
+        """
         num_qubits = 2 * self.num_data_qubits - 1
         qubits = cirq.LineQubit.range(num_qubits)
         circuit = cirq.Circuit()
 
         # Initialize the data qubits
         for i in range(self.num_data_qubits):
             if self.bit_state[i] == 1:
@@ -54,33 +63,42 @@
         circuit.append(self._measurement_round_cirq(qubits, i) for i in range(self.num_rounds))
 
         circuit.append(cirq.measure(*qubits, key="meas_all"))
 
         return circuit
 
     def _get_ideal_dist(self) -> Dict[str, float]:
-        """Return the ideal probability distribution of self.circuit().
+        """Return the ideal probability distribution of `self.circuit()`.
+
+        Since the only allowed initial states for this benchmark are single product states, there
+        is a single bitstring that should be measured in the noiseless case.
 
-        Since the only allowed initial states for this benchmark are
-        single product states, there is a single bitstring that should be
-        measured in the noiseless case.
+        Returns:
+            Dictionary with measurement results as keys and probabilites as values.
         """
         ancilla_state, final_state = "", ""
         for i in range(self.num_data_qubits - 1):
             # parity checks
             ancilla_state += str((self.bit_state[i] + self.bit_state[i + 1]) % 2)
             final_state += str(self.bit_state[i]) + "0"
         else:
             final_state += str(self.bit_state[-1])
 
         ideal_bitstring = [ancilla_state] * self.num_rounds + [final_state]
         return {"".join(ideal_bitstring): 1.0}
 
     def score(self, counts: Dict[str, float]) -> float:
-        """Device performance is given by the Hellinger fidelity between
-        the experimental results and the ideal distribution. The ideal
-        is known based on the bit_state parameter.
+        """Compute benchmark score.
+
+        Device performance is given by the Hellinger fidelity between the experimental results and
+        the ideal distribution. The ideal is known based on the `bit_state` parameter.
+
+        Args:
+            counts: Dictionary containing the measurement counts from running `self.circuit()`.
+
+        Returns:
+            A float with the computed score.
         """
         ideal_dist = self._get_ideal_dist()
         total_shots = sum(counts.values())
         experimental_dist = {bitstr: shots / total_shots for bitstr, shots in counts.items()}
         return hellinger_fidelity(ideal_dist, experimental_dist)
```

## supermarq/benchmarks/ghz.py

```diff
@@ -3,40 +3,52 @@
 import cirq
 from qiskit.quantum_info import hellinger_fidelity
 
 from supermarq.benchmark import Benchmark
 
 
 class GHZ(Benchmark):
-    """Represents the GHZ state preparation benchmark parameterized
-    by the number of qubits n.
+    """Represents the GHZ state preparation benchmark parameterized by the number of qubits n.
 
-    Device performance is based on the Hellinger fidelity between
-    the experimental and ideal probability distributions.
+    Device performance is based on the Hellinger fidelity between the experimental and ideal
+    probability distributions.
     """
 
     def __init__(self, num_qubits: int) -> None:
+        """Initialize a `GHZ` object.
+
+        Args:
+            num_qubits: Number of qubits in GHZ circuit.
+        """
         self.num_qubits = num_qubits
 
     def circuit(self) -> cirq.Circuit:
-        """Generate an n-qubit GHZ circuit"""
+        """Generate an n-qubit GHZ circuit.
+
+        Returns:
+            A `cirq.Circuit`.
+        """
         qubits = cirq.LineQubit.range(self.num_qubits)
         circuit = cirq.Circuit()
         circuit.append(cirq.H(qubits[0]))
         for i in range(self.num_qubits - 1):
             circuit.append(cirq.CNOT(qubits[i], qubits[i + 1]))
         circuit.append(cirq.measure(*qubits))
         return circuit
 
     def score(self, counts: Dict[str, int]) -> float:
-        r"""Compute the Hellinger fidelity between the experimental and ideal
-        results, i.e., 50% probabilty of measuring the all-zero state and 50%
-        probability of measuring the all-one state.
+        r"""Compute the Hellinger fidelity between the experimental and ideal results.
+
+        The ideal results are 50% probabilty of measuring the all-zero state and 50% probability
+        of measuring the all-one state.
+
+        The formula for the Hellinger fidelity between two distributions p and q is given by
+        $(\sum_i{p_i q_i})^2$.
 
-        The formula for the Hellinger fidelity between two distributions p and q
-        is given by $(\sum_i{p_i q_i})^2$.
+        Returns:
+            Hellinger fidelity as a float.
         """
         # Create an equal weighted distribution between the all-0 and all-1 states
         ideal_dist = {b * self.num_qubits: 0.5 for b in ["0", "1"]}
         total_shots = sum(counts.values())
         device_dist = {bitstr: count / total_shots for bitstr, count in counts.items()}
         return hellinger_fidelity(ideal_dist, device_dist)
```

## supermarq/benchmarks/phase_code.py

```diff
@@ -3,54 +3,60 @@
 import cirq
 from qiskit.quantum_info import hellinger_fidelity
 
 from supermarq.benchmark import Benchmark
 
 
 class PhaseCode(Benchmark):
-    """Creates a circuit for syndrome measurement in a phase-flip error
-    correcting code.
+    """Creates a circuit for syndrome measurement in a phase-flip error correcting code.
 
     Args:
-    - num_data: The number of data qubits
-    - num_rounds: The number of measurement rounds
-    - phase_state: A list of zeros and ones denoting the state to initialize each data
-                   qubit to. Currently just + or - states. 0 -> +, 1 -> -
-
-    returns a cirq circuit for the phase-flip error correcting code
+        num_data: The number of data qubits.
+        num_rounds: The number of measurement rounds.
+        phase_state: A list of zeros and ones denoting the state to initialize each data
+            qubit to. Currently just + or - states. 0 -> +, 1 -> -.
 
+    Returns:
+        A `cirq.Circuit` for the phase-flip error correcting code.
     """
 
     def __init__(self, num_data_qubits: int, num_rounds: int, phase_state: List[int]) -> None:
         if len(phase_state) != num_data_qubits:
             raise ValueError("The length of `phase_state` must match the number of data qubits")
         self.num_data_qubits = num_data_qubits
         self.num_rounds = num_rounds
         self.phase_state = phase_state
 
     def _measurement_round_cirq(
         self, qubits: List[cirq.LineQubit], round_idx: int
     ) -> Iterator[cirq.Operation]:
-        """Generates cirq ops for a single measurement round
+        """Generates `cirq.Operation`s for a single measurement round.
 
         Args:
-        - qubits: Circuit qubits - assumed data on even indices and
-                  measurement on odd indices
+            qubits: Circuit qubits, assuming data on even indices and measurement on odd indices.
+
+        Returns:
+            A `cirq.Operation` iterator with the operations for a measurement round.
         """
         ancilla_qubits = qubits[1::2]
         yield from cirq.H.on_each(*qubits)
         for qq in range(1, len(qubits), 2):
             yield cirq.CZ(qubits[qq - 1], qubits[qq])
         for qq in range(1, len(qubits), 2):
             yield cirq.CZ(qubits[qq + 1], qubits[qq])
         yield from cirq.H.on_each(*qubits)
         yield cirq.measure(*ancilla_qubits, key=f"mcm{round_idx}")
         yield from cirq.reset_each(*ancilla_qubits)
 
     def circuit(self) -> cirq.Circuit:
+        """Generates phase code circuit.
+
+        Returns:
+            A `cirq.Circuit`.
+        """
         num_qubits = 2 * self.num_data_qubits - 1
         qubits = cirq.LineQubit.range(num_qubits)
         circuit = cirq.Circuit()
 
         # Initialize the data qubits
         for i in range(self.num_data_qubits):
             if self.phase_state[i] == 1:
@@ -65,33 +71,42 @@
             circuit.append(cirq.H(qubits[2 * i]))
 
         circuit.append(cirq.measure(*qubits, key="meas_all"))
 
         return circuit
 
     def _get_ideal_dist(self) -> Dict[str, float]:
-        """Return the ideal probability distribution of self.circuit().
+        """Return the ideal probability distribution of `self.circuit()`.
+
+        Since the initial states of the data qubits are either |+> or |->, and we measure the final
+        state in the X-basis, the final state is a single product state in the noiseless case.
 
-        Since the initial states of the data qubits are either |+> or |->,
-        and we measure the final state in the X-basis, the final state is a
-        single product state in the noiseless case.
+        Returns:
+            Dictionary with measurement results as keys and probabilites as values.
         """
         ancilla_state, final_state = "", ""
         for i in range(self.num_data_qubits - 1):
             # parity checks
             ancilla_state += str((self.phase_state[i] + self.phase_state[i + 1]) % 2)
             final_state += str(self.phase_state[i]) + "0"
         else:
             final_state += str(self.phase_state[-1])
 
         ideal_bitstring = [ancilla_state] * self.num_rounds + [final_state]
         return {"".join(ideal_bitstring): 1.0}
 
     def score(self, counts: Dict[str, float]) -> float:
-        """Device performance is given by the Hellinger fidelity between
-        the experimental results and the ideal distribution. The ideal
-        is known based on the phase_state parameter.
+        """Compute benchmark score.
+
+        Device performance is given by the Hellinger fidelity between the experimental results and
+        the ideal distribution. The ideal is known based on the `phase_state` parameter.
+
+        Args:
+            counts: Dictionary containing the measurement counts from running `self.circuit()`.
+
+        Returns:
+            A float with the computed score.
         """
         ideal_dist = self._get_ideal_dist()
         total_shots = sum(counts.values())
         experimental_dist = {bitstr: shots / total_shots for bitstr, shots in counts.items()}
         return hellinger_fidelity(ideal_dist, experimental_dist)
```

## Comparing `SupermarQ-0.3.30.dist-info/METADATA` & `SupermarQ-0.3.31.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,24 +1,24 @@
 Metadata-Version: 2.1
 Name: SupermarQ
-Version: 0.3.30
+Version: 0.3.31
 Summary: SupermarQ is a scalable, application-centric quantum benchmarking suite.
 Home-page: https://github.com/SupertechLabs/SupermarQ
 Author: Super.tech
 Author-email: pranav@super.tech
 License: Apache 2
 Platform: UNKNOWN
 Requires-Python: >=3.7.0
 Description-Content-Type: text/markdown
-Requires-Dist: cirq-superstaq (~=0.3.30)
+Requires-Dist: cirq-superstaq (~=0.3.31)
 Requires-Dist: matplotlib (<=3.5.2)
-Requires-Dist: qiskit-superstaq (~=0.3.30)
+Requires-Dist: qiskit-superstaq (~=0.3.31)
 Requires-Dist: scikit-learn (~=1.0)
 Provides-Extra: dev
-Requires-Dist: general-superstaq[dev] (~=0.3.30) ; extra == 'dev'
+Requires-Dist: general-superstaq[dev] (~=0.3.31) ; extra == 'dev'
 
 <p align="center">
   <img width="300" src="../docs/source/_static/logos/supermarq-logo.webp">
 </p>
 
 ---
 ![Continuous Integration](https://github.com/SupertechLabs/SupermarQ/actions/workflows/ci.yml/badge.svg)
```

## Comparing `SupermarQ-0.3.30.dist-info/RECORD` & `SupermarQ-0.3.31.dist-info/RECORD`

 * *Files 5% similar despite different names*

```diff
@@ -1,34 +1,34 @@
 supermarq/__init__.py,sha256=8Ag_aSTxuwp0Hnx0aJMR97BP7a5ryVmqI-XvnH1nViU,605
-supermarq/_version.py,sha256=KlWlSRXnBh8mmx-ClsWCnopdCDGMM_hXkq4d_r6GB8U,23
+supermarq/_version.py,sha256=Mt09g_tnGN2lq27DwrYVDFgwxtgBKeD_zamqXUJiOm0,23
 supermarq/_version_test.py,sha256=aZap6BcSgWjdtYFWYZyJ-sWWvEWXDg2Ca9YELh6Fqn0,283
 supermarq/benchmark.py,sha256=z9EXKNeN0-sCNOYwd4_Npv9y_ZmEhKJKb28BdHcMipA,853
 supermarq/benchmark_test.py,sha256=Wet3F5UmPLoPmhhhhC3Tadkt8TQ4vamN5a79u8DrJJ8,1041
 supermarq/converters.py,sha256=-PI62lTOWqVhs3CUyevqpiGzpuve218qzc_H1R5_psc,4704
 supermarq/converters_test.py,sha256=GYvUhSuEs0ResqjDJs09P3MQfa4j19bkkzmB2TvIdhI,423
 supermarq/features.py,sha256=dl5_t40EjHwhCGwbZsEyuLbKqtr8HKLbK6JgXAXaXQU,3194
 supermarq/features_test.py,sha256=HBFdS2wJ20X7IlKG-BAfuxHZRyX7nZFFIPgdrxnCNLQ,1435
 supermarq/plotting.py,sha256=7B48tRPi-JH0DAz-VkpELV144lPZK7VnSzbdgH7DMr4,12392
 supermarq/plotting_test.py,sha256=M8a1ac_HL1xpU9vLSJBD8XX1wdbrc7qPRFMxLJZoLvM,1029
 supermarq/simulation.py,sha256=MBKFbUQfHajYARI3-1syH83cbwTGpxi1ZyIZ-Y2bh1A,847
 supermarq/stabilizers.py,sha256=QnO5-9cRipj8vVAzHyw_9jTbfD7bVJhVEQlRCgBWPgg,12415
 supermarq/benchmarks/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-supermarq/benchmarks/bit_code.py,sha256=rYvHrUixDRLxHRcCxyzY4wkfCFy_5JcQanqxRBLAua8,3384
+supermarq/benchmarks/bit_code.py,sha256=BheUnM1Zc8SJFmRcm2QhQ8XNOw9lW4Yfg0muw2UO_zg,3917
 supermarq/benchmarks/bit_code_test.py,sha256=kAGtmoHkf0MbN34HBYJ_THA5Z883t6YY4K1WPQHCHkI,537
-supermarq/benchmarks/ghz.py,sha256=druH_GLH246HIjGml-XA4dxTb-t-_6gqL5jS80auRs0,1609
+supermarq/benchmarks/ghz.py,sha256=zQMcMRGrRVDc3Vpo5d8jejfZ0OATvxDc1V03bJ1Cbwo,1863
 supermarq/benchmarks/ghz_test.py,sha256=aXNzpzhBOTvGU_A6p9qBrVRFY9viowud0pwHaLEMlwk,286
 supermarq/benchmarks/hamiltonian_simulation.py,sha256=G27vCa3fWM9sp0XJRrGivWmrZrYYClVAEcyzqILr2PM,4175
 supermarq/benchmarks/hamiltonian_simulation_test.py,sha256=MGr-QB-Ss01xgFeHXy5DjVbgSwjV3A5mX8zFggd9MKs,572
 supermarq/benchmarks/mermin_bell.py,sha256=qlXrwepITCYxDEyGulBqMdRqQGRYGF90dHr0aqmtDoo,8677
 supermarq/benchmarks/mermin_bell_test.py,sha256=zEynNbYg91g9zn-zYtC3oLPw10lD6VZRRTaPh24bSJM,717
-supermarq/benchmarks/phase_code.py,sha256=xUhZnW1p0TeGRlbuhOAK00bXC0meG5Wc13xJ1fyOEx8,3848
+supermarq/benchmarks/phase_code.py,sha256=UzdzoYzYcqeVUZ1TGVxvDzNZHSbmOMGlNhyorAnEwtg,4354
 supermarq/benchmarks/phase_code_test.py,sha256=9jrXu_13QP__9eo9cBPhPtY1PQwZcrCdO4G1X4qZg48,553
 supermarq/benchmarks/qaoa_fermionic_swap_proxy.py,sha256=_mpMO-PWrZRzhRvljHmGIAi2SShb-LxWhL6opA10dQc,7420
 supermarq/benchmarks/qaoa_fermionic_swap_proxy_test.py,sha256=kh4ePTFSMlyqG5kwv50s-1SJ9yFxnG2jTlPN3krJhKM,853
 supermarq/benchmarks/qaoa_vanilla_proxy.py,sha256=_DzncYEVfTc1QzmKeN7pCUUDsMx9WjoBYJQBW60wUTI,5799
 supermarq/benchmarks/qaoa_vanilla_proxy_test.py,sha256=jd1UKNPiV7wUWzqwIUfTyi1Sw1ElbMJ0x4kjhYFf_po,564
 supermarq/benchmarks/vqe_proxy.py,sha256=U1r-Fq17Jrt8VnxjAlVdwhD8QAZN93v5VBhW24od1n0,7077
 supermarq/benchmarks/vqe_proxy_test.py,sha256=Tpe9cnoqY4b5N5iTrMawrOAHzFJuyfNscRWUkc-9atg,459
-SupermarQ-0.3.30.dist-info/METADATA,sha256=-5y8qH5nD_H5Y5_38R-Aed4GqAKG9KK89uW03kjN1e0,2196
-SupermarQ-0.3.30.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-SupermarQ-0.3.30.dist-info/top_level.txt,sha256=V8aTWpwY33e-w7kLvEOVE_4GqyxxOXu5XMWDjoauq54,10
-SupermarQ-0.3.30.dist-info/RECORD,,
+SupermarQ-0.3.31.dist-info/METADATA,sha256=Sl5xJ9SVMQWY4SnFBLUArnG2Y5p6O7Gav4ctNmDklk0,2196
+SupermarQ-0.3.31.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+SupermarQ-0.3.31.dist-info/top_level.txt,sha256=V8aTWpwY33e-w7kLvEOVE_4GqyxxOXu5XMWDjoauq54,10
+SupermarQ-0.3.31.dist-info/RECORD,,
```

