# Comparing `tmp/pyved-engine-23.5a1.tar.gz` & `tmp/pyved-engine-23.6a1.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyved-engine-23.5a1.tar", last modified: Fri Jun 16 07:37:13 2023, max compression
+gzip compressed data, was "pyved-engine-23.6a1.tar", last modified: Fri Jun 16 12:06:45 2023, max compression
```

## Comparing `pyved-engine-23.5a1.tar` & `pyved-engine-23.6a1.tar`

### file list

```diff
@@ -1,130 +1,131 @@
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.709495 pyved-engine-23.5a1/
--rw-rw-rw-   0        0        0     7817 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/LICENSE
--rw-rw-rw-   0        0        0       45 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/MANIFEST.in
--rw-rw-rw-   0        0        0      300 2023-06-16 07:37:13.708433 pyved-engine-23.5a1/PKG-INFO
--rw-rw-rw-   0        0        0     7411 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/README.md
--rw-rw-rw-   0        0        0       42 2023-06-16 07:37:13.710496 pyved-engine-23.5a1/setup.cfg
--rw-rw-rw-   0        0        0     1642 2023-06-16 07:35:25.000000 pyved-engine-23.5a1/setup.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.772329 pyved-engine-23.5a1/src/
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.887525 pyved-engine-23.5a1/src/pyved_engine/
--rw-rw-rw-   0        0        0     1321 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/Singleton.py
--rw-rw-rw-   0        0        0      704 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/_BaseGameState.py
--rw-rw-rw-   0        0        0    12164 2023-06-13 14:20:23.000000 pyved-engine-23.5a1/src/pyved_engine/__init__.py
--rw-rw-rw-   0        0        0      541 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/__version__.py
--rw-rw-rw-   0        0        0     6068 2023-06-13 14:07:12.000000 pyved-engine-23.5a1/src/pyved_engine/_ecs_pattern.py
--rw-rw-rw-   0        0        0      977 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/_hub.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.940846 pyved-engine-23.5a1/src/pyved_engine/compo/
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/compo/__init__.py
--rw-rw-rw-   0        0        0    11697 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/compo/gfx.py
--rw-rw-rw-   0        0        0     1171 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/compo/modes.py
--rw-rw-rw-   0        0        0    40144 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/compo/packed_capello_ft.py
--rw-rw-rw-   0        0        0     2357 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/compo/vscreen.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.960373 pyved-engine-23.5a1/src/pyved_engine/core/
--rw-rw-rw-   0        0        0     2504 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/core/Injector.py
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/core/__init__.py
--rw-rw-rw-   0        0        0     9884 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/core/events.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.988339 pyved-engine-23.5a1/src/pyved_engine/foundation/
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/foundation/__init__.py
--rw-rw-rw-   0        0        0     6938 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/foundation/defs.py
--rw-rw-rw-   0        0        0     1847 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/foundation/interfaces.py
--rw-rw-rw-   0        0        0     7408 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/foundation/pbackends.py
--rw-rw-rw-   0        0        0    17663 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/legacyevent.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.113520 pyved-engine-23.5a1/src/pyved_engine/looparts/
--rw-rw-rw-   0        0        0      347 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.149782 pyved-engine-23.5a1/src/pyved_engine/looparts/ai/
--rw-rw-rw-   0        0        0     4080 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/ai/FSA_classes_base.py
--rw-rw-rw-   0        0        0     4425 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/ai/NorrecBrain.py
--rw-rw-rw-   0        0        0       80 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/ai/__init__.py
--rw-rw-rw-   0        0        0      700 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/ai/tests.py
--rw-rw-rw-   0        0        0     5168 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/anim.py
--rw-rw-rw-   0        0        0    35710 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/ascii.py
--rw-rw-rw-   0        0        0    18413 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/console.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.196761 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/
--rw-rw-rw-   0        0        0       97 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/__init__.py
--rw-rw-rw-   0        0        0     4326 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/animobs.py
--rw-rw-rw-   0        0        0     8417 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/dialogue.py
--rw-rw-rw-   0        0        0     3606 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/pathfinding.py
--rw-rw-rw-   0        0        0    16211 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/rpgmenu.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.309781 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/
--rw-rw-rw-   0        0        0     6600 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/BaseGuiElement.py
--rw-rw-rw-   0        0        0     1976 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Button.py
--rw-rw-rw-   0        0        0     6595 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Button2.py
--rw-rw-rw-   0        0        0     4628 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/DispCenteredPopup.py
--rw-rw-rw-   0        0        0    10632 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/DispPopup.py
--rw-rw-rw-   0        0        0     3906 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Label.py
--rw-rw-rw-   0        0        0     3598 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/TextBlock.py
--rw-rw-rw-   0        0        0     3553 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Trigger.py
--rw-rw-rw-   0        0        0     4013 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/WidgetBo.py
--rw-rw-rw-   0        0        0     4440 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/WidgetContainer.py
--rw-rw-rw-   0        0        0     7032 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/__init__.py
--rw-rw-rw-   0        0        0     7921 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/base.py
--rw-rw-rw-   0        0        0     7222 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/gui/text.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.373998 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/
--rw-rw-rw-   0        0        0    25486 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/IsometricMapViewer.py
--rw-rw-rw-   0        0        0    17069 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/IsometricMapViewer0.py
--rw-rw-rw-   0        0        0      527 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/__init__.py
--rw-rw-rw-   0        0        0     4805 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/extras.py
--rw-rw-rw-   0        0        0      242 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/flags.py
--rw-rw-rw-   0        0        0      207 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/isosm_config.py
--rw-rw-rw-   0        0        0    26319 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/model.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.424339 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/
--rw-rw-rw-   0        0        0      832 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/__init__.py
--rw-rw-rw-   0        0        0     1062 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/frects.py
--rw-rw-rw-   0        0        0    16054 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/general.py
--rw-rw-rw-   0        0        0     8743 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/image.py
--rw-rw-rw-   0        0        0    29128 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/widgets.py
--rw-rw-rw-   0        0        0    21777 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/rogue.py
--rw-rw-rw-   0        0        0    12262 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/rpg.py
--rw-rw-rw-   0        0        0     2227 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/sysconsole.py
--rw-rw-rw-   0        0        0    16403 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tabletop.py
--rw-rw-rw-   0        0        0     3148 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/terrain.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.462633 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/
--rw-rw-rw-   0        0        0      440 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/__init__.py
--rw-rw-rw-   0        0        0    25731 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/data.py
--rw-rw-rw-   0        0        0     6734 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/misc.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.576349 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/
--rw-rw-rw-   0        0        0      858 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/__init__.py
--rw-rw-rw-   0        0        0     1145 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/common_types.py
--rw-rw-rw-   0        0        0       43 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/exception.py
--rw-rw-rw-   0        0        0     7369 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/layer.py
--rw-rw-rw-   0        0        0     1322 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parser.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.578473 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/__init__.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.638804 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/__init__.py
--rw-rw-rw-   0        0        0    12582 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/layer.py
--rw-rw-rw-   0        0        0     1309 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/properties.py
--rw-rw-rw-   0        0        0     9019 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_map.py
--rw-rw-rw-   0        0        0    10434 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_object.py
--rw-rw-rw-   0        0        0    11079 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tileset.py
--rw-rw-rw-   0        0        0     3266 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/wang_set.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.699658 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/
--rw-rw-rw-   0        0        0        0 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/__init__.py
--rw-rw-rw-   0        0        0    12150 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/layer.py
--rw-rw-rw-   0        0        0      976 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/properties.py
--rw-rw-rw-   0        0        0     6777 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_map.py
--rw-rw-rw-   0        0        0     9657 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_object.py
--rw-rw-rw-   0        0        0     7614 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tileset.py
--rw-rw-rw-   0        0        0     2464 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/wang_set.py
--rw-rw-rw-   0        0        0      483 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/properties.py
--rw-rw-rw-   0        0        0     3393 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_map.py
--rw-rw-rw-   0        0        0     5241 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_object.py
--rw-rw-rw-   0        0        0    10886 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tileset.py
--rw-rw-rw-   0        0        0     2733 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/util.py
--rw-rw-rw-   0        0        0       55 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/version.py
--rw-rw-rw-   0        0        0     3171 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/wang_set.py
--rw-rw-rw-   0        0        0     5104 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/world.py
--rw-rw-rw-   0        0        0     5511 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/ztilemap.py
--rw-rw-rw-   0        0        0     4017 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/pal.py
--rw-rw-rw-   0        0        0     2928 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/state_management.py
--rw-rw-rw-   0        0        0    12155 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/struct.py
--rw-rw-rw-   0        0        0     4896 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/tankui.py
--rw-rw-rw-   0        0        0      566 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/src/pyved_engine/util.py
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:12.904837 pyved-engine-23.5a1/src/pyved_engine.egg-info/
--rw-rw-rw-   0        0        0      300 2023-06-16 07:37:12.000000 pyved-engine-23.5a1/src/pyved_engine.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0     4862 2023-06-16 07:37:12.000000 pyved-engine-23.5a1/src/pyved_engine.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-06-16 07:37:12.000000 pyved-engine-23.5a1/src/pyved_engine.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       17 2023-06-16 07:37:12.000000 pyved-engine-23.5a1/src/pyved_engine.egg-info/requires.txt
--rw-rw-rw-   0        0        0       13 2023-06-16 07:37:12.000000 pyved-engine-23.5a1/src/pyved_engine.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2023-06-16 07:37:13.707430 pyved-engine-23.5a1/tests/
--rw-rw-rw-   0        0        0      751 2023-06-01 14:34:29.000000 pyved-engine-23.5a1/tests/test_engine.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/
+-rw-r--r--   0 runner    (1001) docker     (123)     7652 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/LICENSE
+-rw-r--r--   0 runner    (1001) docker     (123)       44 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/MANIFEST.in
+-rw-r--r--   0 runner    (1001) docker     (123)     7565 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     7227 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/README.md
+-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/setup.cfg
+-rw-r--r--   0 runner    (1001) docker     (123)     1888 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/setup.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.278943 pyved-engine-23.6a1/src/
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.282943 pyved-engine-23.6a1/src/pyved_engine/
+-rw-r--r--   0 runner    (1001) docker     (123)     1282 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/Singleton.py
+-rw-r--r--   0 runner    (1001) docker     (123)      674 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/_BaseGameState.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11796 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      524 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/__version__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5907 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/_ecs_pattern.py
+-rw-r--r--   0 runner    (1001) docker     (123)      944 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/_hub.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.282943 pyved-engine-23.6a1/src/pyved_engine/compo/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/compo/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11367 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/compo/gfx.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1122 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/compo/modes.py
+-rw-r--r--   0 runner    (1001) docker     (123)    40142 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/compo/packed_capello_ft.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2269 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/compo/vscreen.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.282943 pyved-engine-23.6a1/src/pyved_engine/core/
+-rw-r--r--   0 runner    (1001) docker     (123)     2423 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/core/Injector.py
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/core/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9615 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/core/events.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.286943 pyved-engine-23.6a1/src/pyved_engine/foundation/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/foundation/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6708 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/foundation/defs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1777 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/foundation/interfaces.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7231 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/foundation/pbackends.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17075 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/legacyevent.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.286943 pyved-engine-23.6a1/src/pyved_engine/looparts/
+-rw-r--r--   0 runner    (1001) docker     (123)      328 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.286943 pyved-engine-23.6a1/src/pyved_engine/looparts/ai/
+-rw-r--r--   0 runner    (1001) docker     (123)     3934 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/ai/FSA_classes_base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4312 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/ai/NorrecBrain.py
+-rw-r--r--   0 runner    (1001) docker     (123)       77 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/ai/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)      675 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/ai/tests.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5018 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/anim.py
+-rw-r--r--   0 runner    (1001) docker     (123)    35467 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/ascii.py
+-rw-r--r--   0 runner    (1001) docker     (123)    17900 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/console.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.286943 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/
+-rw-r--r--   0 runner    (1001) docker     (123)       93 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4192 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/animobs.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8178 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/dialogue.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3497 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/pathfinding.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15785 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/rpgmenu.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.290943 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/
+-rw-r--r--   0 runner    (1001) docker     (123)     6385 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/BaseGuiElement.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1911 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Button.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6388 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Button2.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4495 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/DispCenteredPopup.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10310 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/DispPopup.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3768 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Label.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3476 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/TextBlock.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3427 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Trigger.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3872 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/WidgetBo.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4293 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/WidgetContainer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6813 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7654 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/base.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7034 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/gui/text.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.290943 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/
+-rw-r--r--   0 runner    (1001) docker     (123)    24924 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/IsometricMapViewer.py
+-rw-r--r--   0 runner    (1001) docker     (123)    16686 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/IsometricMapViewer0.py
+-rw-r--r--   0 runner    (1001) docker     (123)      511 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4678 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/extras.py
+-rw-r--r--   0 runner    (1001) docker     (123)      233 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/flags.py
+-rw-r--r--   0 runner    (1001) docker     (123)      200 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/isosm_config.py
+-rw-r--r--   0 runner    (1001) docker     (123)    25660 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/model.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.290943 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/
+-rw-r--r--   0 runner    (1001) docker     (123)      809 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1025 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/frects.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15619 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/general.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8493 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/image.py
+-rw-r--r--   0 runner    (1001) docker     (123)    28422 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/widgets.py
+-rw-r--r--   0 runner    (1001) docker     (123)    21229 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/rogue.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11888 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/rpg.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2162 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/sysconsole.py
+-rw-r--r--   0 runner    (1001) docker     (123)    15881 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tabletop.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3058 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/terrain.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.294944 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/
+-rw-r--r--   0 runner    (1001) docker     (123)      418 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    24970 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/data.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6546 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/misc.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.294944 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/
+-rw-r--r--   0 runner    (1001) docker     (123)      836 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1100 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/common_types.py
+-rw-r--r--   0 runner    (1001) docker     (123)       41 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/exception.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7189 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/layer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1277 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parser.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.294944 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/__init__.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    12154 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/layer.py
+-rw-r--r--   0 runner    (1001) docker     (123)     1262 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     8784 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10066 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_object.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10750 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tileset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3146 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/wang_set.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/
+-rw-r--r--   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11770 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/layer.py
+-rw-r--r--   0 runner    (1001) docker     (123)      940 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     6619 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)     9363 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_object.py
+-rw-r--r--   0 runner    (1001) docker     (123)     7392 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tileset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2385 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/wang_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)      465 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/properties.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3316 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_map.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5087 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_object.py
+-rw-r--r--   0 runner    (1001) docker     (123)    10641 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tileset.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2649 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/util.py
+-rw-r--r--   0 runner    (1001) docker     (123)       52 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/version.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3085 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/wang_set.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4941 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/world.py
+-rw-r--r--   0 runner    (1001) docker     (123)     5354 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/ztilemap.py
+-rw-r--r--   0 runner    (1001) docker     (123)     3862 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/pal.py
+-rw-r--r--   0 runner    (1001) docker     (123)     2840 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/state_management.py
+-rw-r--r--   0 runner    (1001) docker     (123)    11780 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/struct.py
+-rw-r--r--   0 runner    (1001) docker     (123)     4766 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/tankui.py
+-rw-r--r--   0 runner    (1001) docker     (123)      543 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/src/pyved_engine/util.py
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.282943 pyved-engine-23.6a1/src/pyved_engine.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (123)     7565 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (123)     4905 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       54 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/entry_points.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       17 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (123)       13 2023-06-16 12:06:45.000000 pyved-engine-23.6a1/src/pyved_engine.egg-info/top_level.txt
+drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-06-16 12:06:45.298944 pyved-engine-23.6a1/tests/
+-rw-r--r--   0 runner    (1001) docker     (123)      723 2023-06-16 12:06:35.000000 pyved-engine-23.6a1/tests/test_engine.py
```

### Comparing `pyved-engine-23.5a1/LICENSE` & `pyved-engine-23.6a1/LICENSE`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,165 +1,165 @@
-                   GNU LESSER GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-
-  This version of the GNU Lesser General Public License incorporates
-the terms and conditions of version 3 of the GNU General Public
-License, supplemented by the additional permissions listed below.
-
-  0. Additional Definitions.
-
-  As used herein, "this License" refers to version 3 of the GNU Lesser
-General Public License, and the "GNU GPL" refers to version 3 of the GNU
-General Public License.
-
-  "The Library" refers to a covered work governed by this License,
-other than an Application or a Combined Work as defined below.
-
-  An "Application" is any work that makes use of an interface provided
-by the Library, but which is not otherwise based on the Library.
-Defining a subclass of a class defined by the Library is deemed a mode
-of using an interface provided by the Library.
-
-  A "Combined Work" is a work produced by combining or linking an
-Application with the Library.  The particular version of the Library
-with which the Combined Work was made is also called the "Linked
-Version".
-
-  The "Minimal Corresponding Source" for a Combined Work means the
-Corresponding Source for the Combined Work, excluding any source code
-for portions of the Combined Work that, considered in isolation, are
-based on the Application, and not on the Linked Version.
-
-  The "Corresponding Application Code" for a Combined Work means the
-object code and/or source code for the Application, including any data
-and utility programs needed for reproducing the Combined Work from the
-Application, but excluding the System Libraries of the Combined Work.
-
-  1. Exception to Section 3 of the GNU GPL.
-
-  You may convey a covered work under sections 3 and 4 of this License
-without being bound by section 3 of the GNU GPL.
-
-  2. Conveying Modified Versions.
-
-  If you modify a copy of the Library, and, in your modifications, a
-facility refers to a function or data to be supplied by an Application
-that uses the facility (other than as an argument passed when the
-facility is invoked), then you may convey a copy of the modified
-version:
-
-   a) under this License, provided that you make a good faith effort to
-   ensure that, in the event an Application does not supply the
-   function or data, the facility still operates, and performs
-   whatever part of its purpose remains meaningful, or
-
-   b) under the GNU GPL, with none of the additional permissions of
-   this License applicable to that copy.
-
-  3. Object Code Incorporating Material from Library Header Files.
-
-  The object code form of an Application may incorporate material from
-a header file that is part of the Library.  You may convey such object
-code under terms of your choice, provided that, if the incorporated
-material is not limited to numerical parameters, data structure
-layouts and accessors, or small macros, inline functions and templates
-(ten or fewer lines in length), you do both of the following:
-
-   a) Give prominent notice with each copy of the object code that the
-   Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the object code with a copy of the GNU GPL and this license
-   document.
-
-  4. Combined Works.
-
-  You may convey a Combined Work under terms of your choice that,
-taken together, effectively do not restrict modification of the
-portions of the Library contained in the Combined Work and reverse
-engineering for debugging such modifications, if you also do each of
-the following:
-
-   a) Give prominent notice with each copy of the Combined Work that
-   the Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the Combined Work with a copy of the GNU GPL and this license
-   document.
-
-   c) For a Combined Work that displays copyright notices during
-   execution, include the copyright notice for the Library among
-   these notices, as well as a reference directing the user to the
-   copies of the GNU GPL and this license document.
-
-   d) Do one of the following:
-
-       0) Convey the Minimal Corresponding Source under the terms of this
-       License, and the Corresponding Application Code in a form
-       suitable for, and under terms that permit, the user to
-       recombine or relink the Application with a modified version of
-       the Linked Version to produce a modified Combined Work, in the
-       manner specified by section 6 of the GNU GPL for conveying
-       Corresponding Source.
-
-       1) Use a suitable shared library mechanism for linking with the
-       Library.  A suitable mechanism is one that (a) uses at run time
-       a copy of the Library already present on the user's computer
-       system, and (b) will operate properly with a modified version
-       of the Library that is interface-compatible with the Linked
-       Version.
-
-   e) Provide Installation Information, but only if you would otherwise
-   be required to provide such information under section 6 of the
-   GNU GPL, and only to the extent that such information is
-   necessary to install and execute a modified version of the
-   Combined Work produced by recombining or relinking the
-   Application with a modified version of the Linked Version. (If
-   you use option 4d0, the Installation Information must accompany
-   the Minimal Corresponding Source and Corresponding Application
-   Code. If you use option 4d1, you must provide the Installation
-   Information in the manner specified by section 6 of the GNU GPL
-   for conveying Corresponding Source.)
-
-  5. Combined Libraries.
-
-  You may place library facilities that are a work based on the
-Library side by side in a single library together with other library
-facilities that are not Applications and are not covered by this
-License, and convey such a combined library under terms of your
-choice, if you do both of the following:
-
-   a) Accompany the combined library with a copy of the same work based
-   on the Library, uncombined with any other library facilities,
-   conveyed under the terms of this License.
-
-   b) Give prominent notice with the combined library that part of it
-   is a work based on the Library, and explaining where to find the
-   accompanying uncombined form of the same work.
-
-  6. Revised Versions of the GNU Lesser General Public License.
-
-  The Free Software Foundation may publish revised and/or new versions
-of the GNU Lesser General Public License from time to time. Such new
-versions will be similar in spirit to the present version, but may
-differ in detail to address new problems or concerns.
-
-  Each version is given a distinguishing version number. If the
-Library as you received it specifies that a certain numbered version
-of the GNU Lesser General Public License "or any later version"
-applies to it, you have the option of following the terms and
-conditions either of that published version or of any later version
-published by the Free Software Foundation. If the Library as you
-received it does not specify a version number of the GNU Lesser
-General Public License, you may choose any version of the GNU Lesser
-General Public License ever published by the Free Software Foundation.
-
-  If the Library as you received it specifies that a proxy can decide
-whether future versions of the GNU Lesser General Public License shall
-apply, that proxy's public statement of acceptance of any version is
-permanent authorization for you to choose that version for the
-Library.
+                   GNU LESSER GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+
+  This version of the GNU Lesser General Public License incorporates
+the terms and conditions of version 3 of the GNU General Public
+License, supplemented by the additional permissions listed below.
+
+  0. Additional Definitions.
+
+  As used herein, "this License" refers to version 3 of the GNU Lesser
+General Public License, and the "GNU GPL" refers to version 3 of the GNU
+General Public License.
+
+  "The Library" refers to a covered work governed by this License,
+other than an Application or a Combined Work as defined below.
+
+  An "Application" is any work that makes use of an interface provided
+by the Library, but which is not otherwise based on the Library.
+Defining a subclass of a class defined by the Library is deemed a mode
+of using an interface provided by the Library.
+
+  A "Combined Work" is a work produced by combining or linking an
+Application with the Library.  The particular version of the Library
+with which the Combined Work was made is also called the "Linked
+Version".
+
+  The "Minimal Corresponding Source" for a Combined Work means the
+Corresponding Source for the Combined Work, excluding any source code
+for portions of the Combined Work that, considered in isolation, are
+based on the Application, and not on the Linked Version.
+
+  The "Corresponding Application Code" for a Combined Work means the
+object code and/or source code for the Application, including any data
+and utility programs needed for reproducing the Combined Work from the
+Application, but excluding the System Libraries of the Combined Work.
+
+  1. Exception to Section 3 of the GNU GPL.
+
+  You may convey a covered work under sections 3 and 4 of this License
+without being bound by section 3 of the GNU GPL.
+
+  2. Conveying Modified Versions.
+
+  If you modify a copy of the Library, and, in your modifications, a
+facility refers to a function or data to be supplied by an Application
+that uses the facility (other than as an argument passed when the
+facility is invoked), then you may convey a copy of the modified
+version:
+
+   a) under this License, provided that you make a good faith effort to
+   ensure that, in the event an Application does not supply the
+   function or data, the facility still operates, and performs
+   whatever part of its purpose remains meaningful, or
+
+   b) under the GNU GPL, with none of the additional permissions of
+   this License applicable to that copy.
+
+  3. Object Code Incorporating Material from Library Header Files.
+
+  The object code form of an Application may incorporate material from
+a header file that is part of the Library.  You may convey such object
+code under terms of your choice, provided that, if the incorporated
+material is not limited to numerical parameters, data structure
+layouts and accessors, or small macros, inline functions and templates
+(ten or fewer lines in length), you do both of the following:
+
+   a) Give prominent notice with each copy of the object code that the
+   Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the object code with a copy of the GNU GPL and this license
+   document.
+
+  4. Combined Works.
+
+  You may convey a Combined Work under terms of your choice that,
+taken together, effectively do not restrict modification of the
+portions of the Library contained in the Combined Work and reverse
+engineering for debugging such modifications, if you also do each of
+the following:
+
+   a) Give prominent notice with each copy of the Combined Work that
+   the Library is used in it and that the Library and its use are
+   covered by this License.
+
+   b) Accompany the Combined Work with a copy of the GNU GPL and this license
+   document.
+
+   c) For a Combined Work that displays copyright notices during
+   execution, include the copyright notice for the Library among
+   these notices, as well as a reference directing the user to the
+   copies of the GNU GPL and this license document.
+
+   d) Do one of the following:
+
+       0) Convey the Minimal Corresponding Source under the terms of this
+       License, and the Corresponding Application Code in a form
+       suitable for, and under terms that permit, the user to
+       recombine or relink the Application with a modified version of
+       the Linked Version to produce a modified Combined Work, in the
+       manner specified by section 6 of the GNU GPL for conveying
+       Corresponding Source.
+
+       1) Use a suitable shared library mechanism for linking with the
+       Library.  A suitable mechanism is one that (a) uses at run time
+       a copy of the Library already present on the user's computer
+       system, and (b) will operate properly with a modified version
+       of the Library that is interface-compatible with the Linked
+       Version.
+
+   e) Provide Installation Information, but only if you would otherwise
+   be required to provide such information under section 6 of the
+   GNU GPL, and only to the extent that such information is
+   necessary to install and execute a modified version of the
+   Combined Work produced by recombining or relinking the
+   Application with a modified version of the Linked Version. (If
+   you use option 4d0, the Installation Information must accompany
+   the Minimal Corresponding Source and Corresponding Application
+   Code. If you use option 4d1, you must provide the Installation
+   Information in the manner specified by section 6 of the GNU GPL
+   for conveying Corresponding Source.)
+
+  5. Combined Libraries.
+
+  You may place library facilities that are a work based on the
+Library side by side in a single library together with other library
+facilities that are not Applications and are not covered by this
+License, and convey such a combined library under terms of your
+choice, if you do both of the following:
+
+   a) Accompany the combined library with a copy of the same work based
+   on the Library, uncombined with any other library facilities,
+   conveyed under the terms of this License.
+
+   b) Give prominent notice with the combined library that part of it
+   is a work based on the Library, and explaining where to find the
+   accompanying uncombined form of the same work.
+
+  6. Revised Versions of the GNU Lesser General Public License.
+
+  The Free Software Foundation may publish revised and/or new versions
+of the GNU Lesser General Public License from time to time. Such new
+versions will be similar in spirit to the present version, but may
+differ in detail to address new problems or concerns.
+
+  Each version is given a distinguishing version number. If the
+Library as you received it specifies that a certain numbered version
+of the GNU Lesser General Public License "or any later version"
+applies to it, you have the option of following the terms and
+conditions either of that published version or of any later version
+published by the Free Software Foundation. If the Library as you
+received it does not specify a version number of the GNU Lesser
+General Public License, you may choose any version of the GNU Lesser
+General Public License ever published by the Free Software Foundation.
+
+  If the Library as you received it specifies that a proxy can decide
+whether future versions of the GNU Lesser General Public License shall
+apply, that proxy's public statement of acceptance of any version is
+permanent authorization for you to choose that version for the
+Library.
```

### Comparing `pyved-engine-23.5a1/README.md` & `pyved-engine-23.6a1/README.md`

 * *Ordering differences only*

 * *Files 6% similar despite different names*

```diff
@@ -1,184 +1,184 @@
-<img src="https://gaudia-tech.com/shared/pyved-engine-logo.png"/>
-<p align="center">
-  <a href="https://discord.gg/SHdJhcWvQD">join us on Discord<br>
-    <img alt="join us on Discord" src="https://img.shields.io/discord/876813074894561300.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2">
-  </a>
-</p>
-
-
-What is `pyved-engine`?
-
-* a game engine (=a set of tools whose purpose is the rapid prototyping of video games)
-* a wrapper around the popular [pygame lib](https://github.com/pygame/pygame)
-* the abbreviation for [__k__]ata [__engi__]ne
-
-Why "kata"?
-[Kata.Games](https://kata.games) denotes a new gaming platform that helps indie game developers to create and share
-digital experiences easily, all around the globe!
-Via this innovative platform, we're proud to publish all kinds of games powered by `pyved-engine`.
-
-
-## Design principles
-
-1. Code readability matters. Clean, expressive code is not a luxury!
-
-2. `pyved-engine` encourages the use of patterns such as the Mediator or MVC,
-but people should remain free to use their favorite coding style.
-
-3. `pyved-engine` will be embedded in a versatile toolbox simply named `pyved`
-
-## Feature Overview
-The game engine comes packed with useful features:
-1. global event queue (simplifies the use of both the Mediator and the MVC design patterns)
-2. gamestate stack, state management via events 
-3. simple GUI creation: buttons, checkboxes, *etc.* 
-4. tileset loading, sprite animation
-5. tilemap parser (based on `.tmx` or `.tsj` file formats)
-6. mathematical tools: matrices ; vectors ; gradient noise functions (->procedural generation)
-7. helper classes for coding roguelike or RPG games
-8. helper classes for coding card games (Poker, Blackjack, *etc.*)
-9. helper classes for adding artificial opponents/intelligent entities (NPCs) to your game
-10. ...
-
-
-## Installation
-To get started, first, copy the source-code (as a .zip file) from Github. It is recommended to download the last tagged version,
-(not the most recent commit) because most recent dev versions might be unstable.
-
-Once you have the files on your computer, use the command line to navigate to the root folder of the project (one level below `src\`).
-
-Because `pyved-engine` is still in an *alpha* phase,
-it is recommended to clone the repository by yourself and
-then use the command line to install `pyved-engine` in an editable
-mode.
-```shell
-> git clone https://github.com/gaudiatech/pyved-engine.git .
-> cd pyved-engine
-> pip install -e .
-```
-These 3 lines install `pyved-engine` on your system, but also
-allow you to modify the source-code of the engine.
-
-## Getting started
-
-To test `pyved-engine` right away, you could
-create an empty file named `test_engine.py`.
-Then copy-paste the basic code snippet below, it shows you how
-a game can be built.
-```python
-import pyved_engine as pve
-
-HELP_MSG = 'press ESC to exit, any key to change bg_color...'
-CAPTION = 'my first video game, hi mom!'
-
-pve.init(1, caption=CAPTION)
-pygame = pve.pygame
-screen = pve.get_surface()
-color_idx = 0
-allcolors = ('pink', 'yellow', 'purple')
-bg_color = allcolors[0]
-print(HELP_MSG)
-gameover = False
-
-while not gameover:  # game loop
-    for ev in pygame.event.get():
-        if ev.type == pygame.KEYDOWN:
-            if ev.key == pygame.K_ESCAPE:
-                gameover = True
-            else:
-                color_idx = (color_idx + 1) % len(allcolors)
-    # update "game logic"
-    bg_color = allcolors[color_idx]
-    # update the display
-    screen.fill(bg_color)
-    pve.flip()
-
-print('done!')
-```
-This is only one possibilty, very similar to how you 
-define games using `pygame-ce`. In *the docs* you will see better,
-more efficient ways to define your games.
-
-## Documentation
-
-Its still very rough, some help is needed to improve that part!
-All files to build the documentation can be found within the `docs\` folder.
-
-To read/preview the current version of docs:
-```shell
-pip install -r requirements.txt
-mkdocs build
-mkdocs serve
-```
-
-## Mini tutorial
-If you're familiar with `pygame`, getting used to `pyved-engine` is really easy.
-Navigate to the `src/` folder. There, you see a very basic example that uses only pygame:
-* [demo-a-pygame.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-pygame.py)
-
-Now try to notice what is different when one uses `pyved-engine` (only minor details change):
-* [demo-a-kengi-straightf.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-kengi-straightf.py)
-
-This is only one way to use `pyved-engine` but it's most likely that you will start with this one,
-if you already have some background in creating games using `pygame`.
-Actually, one can see `pyved-engine` as a mere wrapper around pygame. Everything that you can do
-with `pygame` can be done the same way when using `pyved-engine`, but `pyved-engine` also unlocks
-many new features that are very worthy of interest!
-
-To explore more possibilities you can take a glimpse of the next demo
-that implements the same thing but using the M-V-C pattern:
-* [demo-a-kengi-mvc.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-kengi-mvc.py)
-
-Note that this program starts with the declaration
-of a list of user-defined events. User-defined events can have attributes.
-These events, just like regular pygame events, are processed via a standard method
-`proc_event` that you need to re-define when you sub-class
-`pyved-engine.event.EventReceiver`...
-
-## General goal
-As a wise man (Joel Spolsky) once said:
-> "It’s Harder to Read Code than to Write it"
-
-Our general goal is to empower you to:
-
-1. **write standardized therefore very easy-to-read code**
-
-Readability is not to overlook! If you take care of your code readability you'll encounter
-30% fewer bugs, you will fix any bug faster, etc. It works like magic!
-
-2. **write a type of code that can evolve easily**
-
-By using our *built-in event system* along with the *M-V-C pattern*, you can reach
-an amazing level of code flexibility.
-
-3. **be more productive**
-
-And, interestingly enough:
-
-5. **distribute your newly created games via our awesome
-[Kata.Games](https://kata.games) platform!**
-
-In this way, your whole game and the python source-code that it's made of, can be
-played directly by modern browser (Chrome, Brave, etc.). *A world premiere!*
-
-
-## License
-Currently, materials in this repo are all licensed under the LGPL3 license.
-See the `LICENSE` file for more info.
-
-
-## Contribute
-Feel free to join the developer team. It's a super easy two-step process:
-(a) start by forking `pyved-engine`,
- (b) join our Discord to discuss, or create a Pull Request directly!
-
-If you spot a bug, create an issue and tell us how to reproduce the bug.
-The documentation is built via the `mkdocs` tool. Feel free to make it more user-friendly! It's as simple as modifying a few text files in the `docs/` folder.
-Pull Requests are much appreciated!
-
-Newcomers are always welcome,
-below are listed the 10 first contributors –our Hall of fame– ;-)
-* [wkta-tom](https://github.com/wkta) architecture, event system, design patterns
-* [tank-king](https://github.com/tank-king) fancy game templates (flappy bird, match3)
-* [jwvhewitt](https://github.com/jwvhewitt) isometric engine
-* ...
+<img src="https://gaudia-tech.com/shared/pyved-engine-logo.png"/>
+<p align="center">
+  <a href="https://discord.gg/SHdJhcWvQD">join us on Discord<br>
+    <img alt="join us on Discord" src="https://img.shields.io/discord/876813074894561300.svg?label=&logo=discord&logoColor=ffffff&color=7389D8&labelColor=6A7EC2">
+  </a>
+</p>
+
+
+What is `pyved-engine`?
+
+* a game engine (=a set of tools whose purpose is the rapid prototyping of video games)
+* a wrapper around the popular [pygame lib](https://github.com/pygame/pygame)
+* the abbreviation for [__k__]ata [__engi__]ne
+
+Why "kata"?
+[Kata.Games](https://kata.games) denotes a new gaming platform that helps indie game developers to create and share
+digital experiences easily, all around the globe!
+Via this innovative platform, we're proud to publish all kinds of games powered by `pyved-engine`.
+
+
+## Design principles
+
+1. Code readability matters. Clean, expressive code is not a luxury!
+
+2. `pyved-engine` encourages the use of patterns such as the Mediator or MVC,
+but people should remain free to use their favorite coding style.
+
+3. `pyved-engine` will be embedded in a versatile toolbox simply named `pyved`
+
+## Feature Overview
+The game engine comes packed with useful features:
+1. global event queue (simplifies the use of both the Mediator and the MVC design patterns)
+2. gamestate stack, state management via events 
+3. simple GUI creation: buttons, checkboxes, *etc.* 
+4. tileset loading, sprite animation
+5. tilemap parser (based on `.tmx` or `.tsj` file formats)
+6. mathematical tools: matrices ; vectors ; gradient noise functions (->procedural generation)
+7. helper classes for coding roguelike or RPG games
+8. helper classes for coding card games (Poker, Blackjack, *etc.*)
+9. helper classes for adding artificial opponents/intelligent entities (NPCs) to your game
+10. ...
+
+
+## Installation
+To get started, first, copy the source-code (as a .zip file) from Github. It is recommended to download the last tagged version,
+(not the most recent commit) because most recent dev versions might be unstable.
+
+Once you have the files on your computer, use the command line to navigate to the root folder of the project (one level below `src\`).
+
+Because `pyved-engine` is still in an *alpha* phase,
+it is recommended to clone the repository by yourself and
+then use the command line to install `pyved-engine` in an editable
+mode.
+```shell
+> git clone https://github.com/gaudiatech/pyved-engine.git .
+> cd pyved-engine
+> pip install -e .
+```
+These 3 lines install `pyved-engine` on your system, but also
+allow you to modify the source-code of the engine.
+
+## Getting started
+
+To test `pyved-engine` right away, you could
+create an empty file named `test_engine.py`.
+Then copy-paste the basic code snippet below, it shows you how
+a game can be built.
+```python
+import pyved_engine as pve
+
+HELP_MSG = 'press ESC to exit, any key to change bg_color...'
+CAPTION = 'my first video game, hi mom!'
+
+pve.init(1, caption=CAPTION)
+pygame = pve.pygame
+screen = pve.get_surface()
+color_idx = 0
+allcolors = ('pink', 'yellow', 'purple')
+bg_color = allcolors[0]
+print(HELP_MSG)
+gameover = False
+
+while not gameover:  # game loop
+    for ev in pygame.event.get():
+        if ev.type == pygame.KEYDOWN:
+            if ev.key == pygame.K_ESCAPE:
+                gameover = True
+            else:
+                color_idx = (color_idx + 1) % len(allcolors)
+    # update "game logic"
+    bg_color = allcolors[color_idx]
+    # update the display
+    screen.fill(bg_color)
+    pve.flip()
+
+print('done!')
+```
+This is only one possibilty, very similar to how you 
+define games using `pygame-ce`. In *the docs* you will see better,
+more efficient ways to define your games.
+
+## Documentation
+
+Its still very rough, some help is needed to improve that part!
+All files to build the documentation can be found within the `docs\` folder.
+
+To read/preview the current version of docs:
+```shell
+pip install -r requirements.txt
+mkdocs build
+mkdocs serve
+```
+
+## Mini tutorial
+If you're familiar with `pygame`, getting used to `pyved-engine` is really easy.
+Navigate to the `src/` folder. There, you see a very basic example that uses only pygame:
+* [demo-a-pygame.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-pygame.py)
+
+Now try to notice what is different when one uses `pyved-engine` (only minor details change):
+* [demo-a-kengi-straightf.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-kengi-straightf.py)
+
+This is only one way to use `pyved-engine` but it's most likely that you will start with this one,
+if you already have some background in creating games using `pygame`.
+Actually, one can see `pyved-engine` as a mere wrapper around pygame. Everything that you can do
+with `pygame` can be done the same way when using `pyved-engine`, but `pyved-engine` also unlocks
+many new features that are very worthy of interest!
+
+To explore more possibilities you can take a glimpse of the next demo
+that implements the same thing but using the M-V-C pattern:
+* [demo-a-kengi-mvc.py](https://github.com/gaudiatech/pyved-engine/blob/master/src/demo-a-kengi-mvc.py)
+
+Note that this program starts with the declaration
+of a list of user-defined events. User-defined events can have attributes.
+These events, just like regular pygame events, are processed via a standard method
+`proc_event` that you need to re-define when you sub-class
+`pyved-engine.event.EventReceiver`...
+
+## General goal
+As a wise man (Joel Spolsky) once said:
+> "It’s Harder to Read Code than to Write it"
+
+Our general goal is to empower you to:
+
+1. **write standardized therefore very easy-to-read code**
+
+Readability is not to overlook! If you take care of your code readability you'll encounter
+30% fewer bugs, you will fix any bug faster, etc. It works like magic!
+
+2. **write a type of code that can evolve easily**
+
+By using our *built-in event system* along with the *M-V-C pattern*, you can reach
+an amazing level of code flexibility.
+
+3. **be more productive**
+
+And, interestingly enough:
+
+5. **distribute your newly created games via our awesome
+[Kata.Games](https://kata.games) platform!**
+
+In this way, your whole game and the python source-code that it's made of, can be
+played directly by modern browser (Chrome, Brave, etc.). *A world premiere!*
+
+
+## License
+Currently, materials in this repo are all licensed under the LGPL3 license.
+See the `LICENSE` file for more info.
+
+
+## Contribute
+Feel free to join the developer team. It's a super easy two-step process:
+(a) start by forking `pyved-engine`,
+ (b) join our Discord to discuss, or create a Pull Request directly!
+
+If you spot a bug, create an issue and tell us how to reproduce the bug.
+The documentation is built via the `mkdocs` tool. Feel free to make it more user-friendly! It's as simple as modifying a few text files in the `docs/` folder.
+Pull Requests are much appreciated!
+
+Newcomers are always welcome,
+below are listed the 10 first contributors –our Hall of fame– ;-)
+* [wkta-tom](https://github.com/wkta) architecture, event system, design patterns
+* [tank-king](https://github.com/tank-king) fancy game templates (flappy bird, match3)
+* [jwvhewitt](https://github.com/jwvhewitt) isometric engine
+* ...
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/Singleton.py` & `pyved-engine-23.6a1/src/pyved_engine/Singleton.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,39 +1,39 @@
-
-
-class Singleton:
-    """
-    A non-thread-safe helper class to ease implementing singletons.
-    This should be used as a decorator -- not a metaclass -- to the
-    class that should be a singleton.
-
-    The decorated class can define one `__init__` function that
-    takes only the `self` argument. Also, the decorated class cannot be
-    inherited from. Other than that, there are no restrictions that apply
-    to the decorated class.
-
-    To get the singleton instance, use the `instance` method. Trying
-    to use `__call__` will result in a `TypeError` being raised.
-
-    """
-
-    def __init__(self, decorated):
-        self._decorated = decorated
-
-    def instance(self):
-        """
-        Returns the singleton instance. Upon its first call, it creates a
-        new instance of the decorated class and calls its `__init__` method.
-        On all subsequent calls, the already created instance is returned.
-
-        """
-        try:
-            return self._instance
-        except AttributeError:
-            self._instance = self._decorated()
-            return self._instance
-
-    def __call__(self):
-        raise TypeError('Singletons must be accessed through `instance()`.')
-
-    def __instancecheck__(self, inst):
-        return isinstance(inst, self._decorated)
+
+
+class Singleton:
+    """
+    A non-thread-safe helper class to ease implementing singletons.
+    This should be used as a decorator -- not a metaclass -- to the
+    class that should be a singleton.
+
+    The decorated class can define one `__init__` function that
+    takes only the `self` argument. Also, the decorated class cannot be
+    inherited from. Other than that, there are no restrictions that apply
+    to the decorated class.
+
+    To get the singleton instance, use the `instance` method. Trying
+    to use `__call__` will result in a `TypeError` being raised.
+
+    """
+
+    def __init__(self, decorated):
+        self._decorated = decorated
+
+    def instance(self):
+        """
+        Returns the singleton instance. Upon its first call, it creates a
+        new instance of the decorated class and calls its `__init__` method.
+        On all subsequent calls, the already created instance is returned.
+
+        """
+        try:
+            return self._instance
+        except AttributeError:
+            self._instance = self._decorated()
+            return self._instance
+
+    def __call__(self):
+        raise TypeError('Singletons must be accessed through `instance()`.')
+
+    def __instancecheck__(self, inst):
+        return isinstance(inst, self._decorated)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/_BaseGameState.py` & `pyved-engine-23.6a1/src/pyved_engine/_BaseGameState.py`

 * *Ordering differences only*

 * *Files 27% similar despite different names*

```diff
@@ -1,30 +1,30 @@
-from abc import ABCMeta, abstractmethod
-
-
-class BaseGameState(metaclass=ABCMeta):
-
-    def __init__(self, state_ident):
-        self.__state_ident = state_ident
-        self.__state_name = self.__class__.__name__
-
-    @abstractmethod
-    def enter(self):
-        pass
-
-    def get_id(self):
-        return self.__state_ident
-
-    def get_name(self):
-        return self.__state_name
-
-    def pause(self):
-        print(self.__class__.__name__)
-        raise AssertionError('not meant to be paused')
-
-    @abstractmethod
-    def release(self):
-        pass
-
-    def resume(self):
-        print(self.__class__.__name__)
-        raise AssertionError('not meant to be resumed')
+from abc import ABCMeta, abstractmethod
+
+
+class BaseGameState(metaclass=ABCMeta):
+
+    def __init__(self, state_ident):
+        self.__state_ident = state_ident
+        self.__state_name = self.__class__.__name__
+
+    @abstractmethod
+    def enter(self):
+        pass
+
+    def get_id(self):
+        return self.__state_ident
+
+    def get_name(self):
+        return self.__state_name
+
+    def pause(self):
+        print(self.__class__.__name__)
+        raise AssertionError('not meant to be paused')
+
+    @abstractmethod
+    def release(self):
+        pass
+
+    def resume(self):
+        print(self.__class__.__name__)
+        raise AssertionError('not meant to be resumed')
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/__init__.py` & `pyved-engine-23.6a1/src/pyved_engine/__init__.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,368 +1,368 @@
-"""
-+-----------------------------------------------------+
-| KENGI [K]atagames [ENGI]ne                          |
-| Motto ~ Never slow down the innovation              |
-|                                                     |
-| Main author: wkta-tom (github.com/wkta)             |
-|                                                     |
-| an open-source project funded by GAUDIA TECH INC.   |
-| https://github.com/gaudiatech/kengi                 |
-+-----------------------------------------------------+
-
- * defines a subset of the pygame library (chosen functions & objects)
-  and creates a wrapper around it
-
- * allows for a swift implementation of two essential design patterns:
-   Mediator and Model-View-Contoller
-
- * provides easy access to data structures useful in game development:
-   stacks, matrices, trees, graphs, finite state machines, cellular automata
-
- * provides algorithms that may be tricky to code but are super-useful:
-   A-star, Minimax, a FOV algorithm for a 2D grid based world,
-
- * is extensible: kengi is capable of receiving custom events and custom
-  extensions, for example a custom GUI manager, an isometric engine, or
-  antything similar, without requiring any architectural change
-
- * can run along with the KataSDK but can also be detached, to run independently
-
- * does not know ANYTHING about whether your code runs in a web browser or not,
-  although the engine can be hacked to allow such a possibility
-
- * incentivizes you, the creator, to write clean readable easy-to-refactor &
-  easy-to-reuse code!
-"""
-import time
-from abc import ABCMeta, abstractmethod
-
-from ._ecs_pattern import entity, component, EntityManager, System, SystemManager
-
-from . import _hub as hub
-from . import pal
-from . import state_management as _state_sm
-from . import struct
-from . import tankui
-from ._BaseGameState import BaseGameState
-from .__version__ import ENGI_VERSION as _VER_CST
-from ._hub import Injector
-from .compo import gfx
-from .compo import vscreen
-from .compo.modes import GameModeMger, BaseGameMode
-from .compo.vscreen import flip, proj_to_vscreen
-from .core import events
-from .core.events import Emitter, EvListener, EngineEvTypes, game_events_enum
-from .foundation import defs
-from .foundation.defs import STD_SCR_SIZE, KengiEv, Singleton
-from .foundation.interfaces import PygameIface
-from .state_management import declare_game_states
-from .util import underscore_format, camel_case_format
-
-
-_active_state = False
-_gameticker = None
-one_plus_init = False
-_stored_kbackend = None
-pbackend_name = ''  # can be modified from elsewhere
-
-
-class Objectifier:
-    def __init__(self, **entries):
-        self.__dict__.update(entries)
-
-
-def _show_ver_infos():
-    print(f'KENGI - ver {_VER_CST}, built on top of ')
-
-
-def is_ready():
-    global one_plus_init
-    return one_plus_init
-
-
-def bootstrap_e(print_ver_info=True):
-    """
-    ensure the engine is ready to be used
-    :param print_ver_info: bool
-    :return:
-    """
-    global one_plus_init, _gameticker, _stored_kbackend, pbackend_name, pygame
-    if one_plus_init:
-        return
-    del pygame
-    one_plus_init = True
-    if print_ver_info:
-        # skip the msg, (if running KENGI along with katasdk, the sdk has already printed out ver. infos)
-        _show_ver_infos()
-
-    # --> init newest event system! in nov22
-    # from here and later,
-    # we know that kengi_inj has been updated, so we can build a primal backend
-    from .foundation.pbackends import build_primalbackend
-    _stored_kbackend = build_primalbackend(pbackend_name)  # by default: local ctx
-    events.EvManager.instance().a_event_source = _stored_kbackend
-
-    # TODO quick fix this part!
-    # event.create_manager()
-    # _gameticker = event.GameTicker()
-
-    # dry import
-    vscreen.cached_pygame_mod = hub.pygame
-
-
-def screen_param(gfx_mode_code, paintev=None, screen_dim=None):
-    global _active_state, config
-
-    if not isinstance(gfx_mode_code, int) and (1 <= gfx_mode_code <= 3):
-        e_msg = f'graphic mode requested({gfx_mode_code}: {type(gfx_mode_code)}) isnt a valid one! Expected type: int'
-        raise ValueError(e_msg)
-
-    # from here, we know that the gfx_mode_code is 100% valid
-    conventionw, conventionh = STD_SCR_SIZE
-    if gfx_mode_code != 0:
-        adhoc_upscaling = gfx_mode_code
-        taille_surf_dessin = int(conventionw / gfx_mode_code), int(conventionh / gfx_mode_code)
-    else:
-        if screen_dim is None:
-            raise ValueError(f'graphic mode 0 required a valid screen_dim arg (provided by user: {screen_dim})')
-        adhoc_upscaling = 1
-        taille_surf_dessin = screen_dim
-
-    config.SCR_SIZE = taille_surf_dessin
-    config.UPSCALING = adhoc_upscaling
-
-    # ---------------------------------
-    #  legacy code, not modified in july22. It's complex but
-    # it works so dont modify unless you really know what you're doing ;)
-    # ---------------------------------
-    if vscreen.stored_upscaling is None:  # stored_upscaling isnt relevant <= webctx
-        _active_state = True
-        pygame_surf_dessin = hub.pygame.display.set_mode(taille_surf_dessin)
-        vscreen.set_virtual_screen(pygame_surf_dessin)
-    else:
-
-        pygame_surf_dessin = hub.pygame.surface.Surface(taille_surf_dessin)
-        vscreen.set_virtual_screen(pygame_surf_dessin)
-        vscreen.set_upscaling(adhoc_upscaling)
-        if paintev:
-            paintev.screen = pygame_surf_dessin
-        if _active_state:
-            return
-        _active_state = True
-
-        if gfx_mode_code:
-            pgscreen = hub.pygame.display.set_mode(STD_SCR_SIZE)
-        else:
-            pgscreen = hub.pygame.display.set_mode(taille_surf_dessin)
-        vscreen.set_realpygame_screen(pgscreen)
-
-
-
-_joy = None
-
-
-def get_surface():
-    global _active_state
-    if not is_ready():
-        raise Exception('calling kengi.get_surface() while the engine isnt ready! (no previous bootstrap op.)')
-    if not _active_state:
-        raise Exception('kengi.init has not been called yet')
-    return vscreen.screen
-
-
-# TODO repair this part, so it fits kengi v22.11.3+
-
-# def declare_states(gsdefinition, assoc_gscode_cls, mod_glvars=None):
-#     global _multistate_flag, state_stack, _stack_based_ctrl
-#     _multistate_flag = True
-#     state_stack = struct.Stack()
-#     _stack_based_ctrl = event.StackBasedGameCtrl(
-#         _gameticker, gsdefinition, mod_glvars, assoc_gscode_cls
-#     )
-
-
-class _MyGameCtrl(events.EvListener):
-    MAXFPS = 75
-
-    def __init__(self):
-        super().__init__()
-        self._clock = hub.kengi_inj['pygame'].time.Clock()
-        self.gameover = False
-
-    def on_gameover(self, ev):
-        self.gameover = True
-
-    def loop(self):
-        if state_management.multistate_flag:  # force this, otherwise the 1st state enter method isnt called
-            self.pev(events.EngineEvTypes.Gamestart)
-
-        while not self.gameover:
-            self.pev(events.EngineEvTypes.Update)
-            self.pev(events.EngineEvTypes.Paint, screen=vscreen.screen)
-            self._manager.update()
-            flip()
-            self._clock.tick(self.MAXFPS)
-
-
-def get_game_ctrl():
-    return _MyGameCtrl()
-
-
-def get_ev_manager():  # saves some time
-    return events.EvManager.instance()
-
-
-class GameTpl(metaclass=ABCMeta):
-    """
-    the "no name" game template class. It allows to define your game in a quick way,
-    by redefining one or several methods: enter, update, exit
-    """
-    INFO_STOP_MSG = 'kengi.GameTpl->the loop() call has ended.'
-    ERR_LOCK_MSG = 'kengi.GameTpl.loop called while SAFETY_LOCK is on!'
-    SAFETY_LOCK = False  # can be set to True from outside, if you don't want a game to call .loop()
-    MAXFPS = 75
-
-    def __init__(self):
-        self._manager = None
-        self.gameover = False
-        self.clock = hub.kengi_inj['pygame'].time.Clock()
-        self.nxt_game = 'niobepolis'
-
-    @abstractmethod
-    def init_video(self):
-        raise NotImplementedError
-
-    def setup_ev_manager(self):
-        self._manager.setup()
-
-    def enter(self, vms=None):
-        """
-        Careful if you redefine this:
-        one *HAS TO* bind the ev manager to self._manager and call .setup, somehow
-        """
-        self._manager = events.EvManager.instance()
-        self.init_video()
-        self.setup_ev_manager()
-
-        # gamestart event HAS TO be pushed so the game rly starts...
-        self._manager.post(EngineEvTypes.Gamestart)
-
-    def update(self, infot):
-        self._manager.post(EngineEvTypes.Update, curr_t=infot)
-        self._manager.post(EngineEvTypes.Paint, screen=vscreen.screen)
-        self._manager.update()
-        pyg = hub.kengi_inj['pygame']
-        pk = pyg.key.get_pressed()
-        if pk[pyg.K_ESCAPE] or self.gameover:
-            return 2, self.nxt_game
-        flip()
-        self.clock.tick(self.MAXFPS)
-
-    def exit(self, vms=None):
-        quit()
-
-    def loop(self):
-        """
-        its forbidden to call .loop() in the web ctx, but its convenient in the local ctx
-        if one wants to test a program without using the Kata VM
-        :return:
-        """
-        # lock mechanism, for extra safety so we never call .loop() in the web ctx
-        if self.SAFETY_LOCK:
-            raise ValueError(self.ERR_LOCK_MSG)
-
-        # use enter, update, exit to handle the global "run game logic"
-        self.enter()
-
-        while not self.gameover:
-            infot = time.time()
-            self.update(infot)
-        self.exit()
-        print(self.INFO_STOP_MSG)
-
-
-# ----------------------------
-#  init & quit
-# ----------------------------
-class _Config:
-    MAXFPS = 45
-    SCR_SIZE = (None, None)
-    UPSCALING = None  # not defined, yet
-
-
-config = _Config
-
-
-def init(gfc_mode=1, caption=None, maxfps=60, screen_dim=None):
-    global _gameticker, _joy, config
-    bootstrap_e()
-    config.MAXFPS = int(maxfps)
-    pygm = hub.pygame
-    pygm.init()
-    pygm.mixer.init()
-
-    jc = _stored_kbackend.joystick_count()
-    if jc > 0:
-        # ------ init the joystick ------
-        _joy = _stored_kbackend.joystick_init(0)
-        name = _stored_kbackend.joystick_info(0)
-        print(name + ' detected')
-        # numaxes = _joy.get_numaxes()
-        # numballs = _joy.get_numballs()
-        # numbuttons = _joy.get_numbuttons()
-        # numhats = _joy.get_numhats()
-        # print(numaxes, numballs, numbuttons, numhats)
-
-    screen_param(gfc_mode, screen_dim=screen_dim)
-    if caption is None:
-        caption = f'untitled demo, uses KENGI ver {_VER_CST}'
-    pygm.display.set_caption(caption)
-
-
-def quit():  # we keep the "quit" name bc of pygame
-    global _active_state
-    if _active_state:
-        if _state_sm.multistate_flag:
-            _state_sm.multistate_flag = False
-            _state_sm.stack_based_ctrl.turn_off()
-            _state_sm.stack_based_ctrl = None
-        if hub.kengi_inj.is_loaded('ascii') and hub.ascii.is_ready():
-            hub.ascii.reset()
-
-        events.EvManager.instance().hard_reset()
-        vscreen.init2_done = False
-        pyg = get_injector()['pygame']
-        pyg.mixer.quit()
-        pyg.quit()
-        _active_state = False
-
-
-# ----------------------------
-#  Related to lazy import
-# ----------------------------
-pygame = PygameIface()
-
-
-def get_injector():
-    return hub.kengi_inj
-
-
-def plugin_bind(plugin_name, pypath):
-    hub.kengi_inj.register(plugin_name, pypath)
-
-
-def bulk_plugin_bind(darg: dict):
-    """
-    :param darg: association extension(plug-in) name to a pypath
-    :return:
-    """
-    for pname, ppath in darg.items():
-        plugin_bind(ppath, ppath)
-
-
-def __getattr__(attr_name):
-    if attr_name in ('ver', 'vernum'):
-        return _VER_CST
-    if is_ready():
-        return getattr(hub, attr_name)
-    raise AttributeError(f"kengi cannot lazy load, it hasnt bootstrap yet! (user request: {attr_name})")
+"""
++-----------------------------------------------------+
+| KENGI [K]atagames [ENGI]ne                          |
+| Motto ~ Never slow down the innovation              |
+|                                                     |
+| Main author: wkta-tom (github.com/wkta)             |
+|                                                     |
+| an open-source project funded by GAUDIA TECH INC.   |
+| https://github.com/gaudiatech/kengi                 |
++-----------------------------------------------------+
+
+ * defines a subset of the pygame library (chosen functions & objects)
+  and creates a wrapper around it
+
+ * allows for a swift implementation of two essential design patterns:
+   Mediator and Model-View-Contoller
+
+ * provides easy access to data structures useful in game development:
+   stacks, matrices, trees, graphs, finite state machines, cellular automata
+
+ * provides algorithms that may be tricky to code but are super-useful:
+   A-star, Minimax, a FOV algorithm for a 2D grid based world,
+
+ * is extensible: kengi is capable of receiving custom events and custom
+  extensions, for example a custom GUI manager, an isometric engine, or
+  antything similar, without requiring any architectural change
+
+ * can run along with the KataSDK but can also be detached, to run independently
+
+ * does not know ANYTHING about whether your code runs in a web browser or not,
+  although the engine can be hacked to allow such a possibility
+
+ * incentivizes you, the creator, to write clean readable easy-to-refactor &
+  easy-to-reuse code!
+"""
+import time
+from abc import ABCMeta, abstractmethod
+
+from ._ecs_pattern import entity, component, EntityManager, System, SystemManager
+
+from . import _hub as hub
+from . import pal
+from . import state_management as _state_sm
+from . import struct
+from . import tankui
+from ._BaseGameState import BaseGameState
+from .__version__ import ENGI_VERSION as _VER_CST
+from ._hub import Injector
+from .compo import gfx
+from .compo import vscreen
+from .compo.modes import GameModeMger, BaseGameMode
+from .compo.vscreen import flip, proj_to_vscreen
+from .core import events
+from .core.events import Emitter, EvListener, EngineEvTypes, game_events_enum
+from .foundation import defs
+from .foundation.defs import STD_SCR_SIZE, KengiEv, Singleton
+from .foundation.interfaces import PygameIface
+from .state_management import declare_game_states
+from .util import underscore_format, camel_case_format
+
+
+_active_state = False
+_gameticker = None
+one_plus_init = False
+_stored_kbackend = None
+pbackend_name = ''  # can be modified from elsewhere
+
+
+class Objectifier:
+    def __init__(self, **entries):
+        self.__dict__.update(entries)
+
+
+def _show_ver_infos():
+    print(f'KENGI - ver {_VER_CST}, built on top of ')
+
+
+def is_ready():
+    global one_plus_init
+    return one_plus_init
+
+
+def bootstrap_e(print_ver_info=True):
+    """
+    ensure the engine is ready to be used
+    :param print_ver_info: bool
+    :return:
+    """
+    global one_plus_init, _gameticker, _stored_kbackend, pbackend_name, pygame
+    if one_plus_init:
+        return
+    del pygame
+    one_plus_init = True
+    if print_ver_info:
+        # skip the msg, (if running KENGI along with katasdk, the sdk has already printed out ver. infos)
+        _show_ver_infos()
+
+    # --> init newest event system! in nov22
+    # from here and later,
+    # we know that kengi_inj has been updated, so we can build a primal backend
+    from .foundation.pbackends import build_primalbackend
+    _stored_kbackend = build_primalbackend(pbackend_name)  # by default: local ctx
+    events.EvManager.instance().a_event_source = _stored_kbackend
+
+    # TODO quick fix this part!
+    # event.create_manager()
+    # _gameticker = event.GameTicker()
+
+    # dry import
+    vscreen.cached_pygame_mod = hub.pygame
+
+
+def screen_param(gfx_mode_code, paintev=None, screen_dim=None):
+    global _active_state, config
+
+    if not isinstance(gfx_mode_code, int) and (1 <= gfx_mode_code <= 3):
+        e_msg = f'graphic mode requested({gfx_mode_code}: {type(gfx_mode_code)}) isnt a valid one! Expected type: int'
+        raise ValueError(e_msg)
+
+    # from here, we know that the gfx_mode_code is 100% valid
+    conventionw, conventionh = STD_SCR_SIZE
+    if gfx_mode_code != 0:
+        adhoc_upscaling = gfx_mode_code
+        taille_surf_dessin = int(conventionw / gfx_mode_code), int(conventionh / gfx_mode_code)
+    else:
+        if screen_dim is None:
+            raise ValueError(f'graphic mode 0 required a valid screen_dim arg (provided by user: {screen_dim})')
+        adhoc_upscaling = 1
+        taille_surf_dessin = screen_dim
+
+    config.SCR_SIZE = taille_surf_dessin
+    config.UPSCALING = adhoc_upscaling
+
+    # ---------------------------------
+    #  legacy code, not modified in july22. It's complex but
+    # it works so dont modify unless you really know what you're doing ;)
+    # ---------------------------------
+    if vscreen.stored_upscaling is None:  # stored_upscaling isnt relevant <= webctx
+        _active_state = True
+        pygame_surf_dessin = hub.pygame.display.set_mode(taille_surf_dessin)
+        vscreen.set_virtual_screen(pygame_surf_dessin)
+    else:
+
+        pygame_surf_dessin = hub.pygame.surface.Surface(taille_surf_dessin)
+        vscreen.set_virtual_screen(pygame_surf_dessin)
+        vscreen.set_upscaling(adhoc_upscaling)
+        if paintev:
+            paintev.screen = pygame_surf_dessin
+        if _active_state:
+            return
+        _active_state = True
+
+        if gfx_mode_code:
+            pgscreen = hub.pygame.display.set_mode(STD_SCR_SIZE)
+        else:
+            pgscreen = hub.pygame.display.set_mode(taille_surf_dessin)
+        vscreen.set_realpygame_screen(pgscreen)
+
+
+
+_joy = None
+
+
+def get_surface():
+    global _active_state
+    if not is_ready():
+        raise Exception('calling kengi.get_surface() while the engine isnt ready! (no previous bootstrap op.)')
+    if not _active_state:
+        raise Exception('kengi.init has not been called yet')
+    return vscreen.screen
+
+
+# TODO repair this part, so it fits kengi v22.11.3+
+
+# def declare_states(gsdefinition, assoc_gscode_cls, mod_glvars=None):
+#     global _multistate_flag, state_stack, _stack_based_ctrl
+#     _multistate_flag = True
+#     state_stack = struct.Stack()
+#     _stack_based_ctrl = event.StackBasedGameCtrl(
+#         _gameticker, gsdefinition, mod_glvars, assoc_gscode_cls
+#     )
+
+
+class _MyGameCtrl(events.EvListener):
+    MAXFPS = 75
+
+    def __init__(self):
+        super().__init__()
+        self._clock = hub.kengi_inj['pygame'].time.Clock()
+        self.gameover = False
+
+    def on_gameover(self, ev):
+        self.gameover = True
+
+    def loop(self):
+        if state_management.multistate_flag:  # force this, otherwise the 1st state enter method isnt called
+            self.pev(events.EngineEvTypes.Gamestart)
+
+        while not self.gameover:
+            self.pev(events.EngineEvTypes.Update)
+            self.pev(events.EngineEvTypes.Paint, screen=vscreen.screen)
+            self._manager.update()
+            flip()
+            self._clock.tick(self.MAXFPS)
+
+
+def get_game_ctrl():
+    return _MyGameCtrl()
+
+
+def get_ev_manager():  # saves some time
+    return events.EvManager.instance()
+
+
+class GameTpl(metaclass=ABCMeta):
+    """
+    the "no name" game template class. It allows to define your game in a quick way,
+    by redefining one or several methods: enter, update, exit
+    """
+    INFO_STOP_MSG = 'kengi.GameTpl->the loop() call has ended.'
+    ERR_LOCK_MSG = 'kengi.GameTpl.loop called while SAFETY_LOCK is on!'
+    SAFETY_LOCK = False  # can be set to True from outside, if you don't want a game to call .loop()
+    MAXFPS = 75
+
+    def __init__(self):
+        self._manager = None
+        self.gameover = False
+        self.clock = hub.kengi_inj['pygame'].time.Clock()
+        self.nxt_game = 'niobepolis'
+
+    @abstractmethod
+    def init_video(self):
+        raise NotImplementedError
+
+    def setup_ev_manager(self):
+        self._manager.setup()
+
+    def enter(self, vms=None):
+        """
+        Careful if you redefine this:
+        one *HAS TO* bind the ev manager to self._manager and call .setup, somehow
+        """
+        self._manager = events.EvManager.instance()
+        self.init_video()
+        self.setup_ev_manager()
+
+        # gamestart event HAS TO be pushed so the game rly starts...
+        self._manager.post(EngineEvTypes.Gamestart)
+
+    def update(self, infot):
+        self._manager.post(EngineEvTypes.Update, curr_t=infot)
+        self._manager.post(EngineEvTypes.Paint, screen=vscreen.screen)
+        self._manager.update()
+        pyg = hub.kengi_inj['pygame']
+        pk = pyg.key.get_pressed()
+        if pk[pyg.K_ESCAPE] or self.gameover:
+            return 2, self.nxt_game
+        flip()
+        self.clock.tick(self.MAXFPS)
+
+    def exit(self, vms=None):
+        quit()
+
+    def loop(self):
+        """
+        its forbidden to call .loop() in the web ctx, but its convenient in the local ctx
+        if one wants to test a program without using the Kata VM
+        :return:
+        """
+        # lock mechanism, for extra safety so we never call .loop() in the web ctx
+        if self.SAFETY_LOCK:
+            raise ValueError(self.ERR_LOCK_MSG)
+
+        # use enter, update, exit to handle the global "run game logic"
+        self.enter()
+
+        while not self.gameover:
+            infot = time.time()
+            self.update(infot)
+        self.exit()
+        print(self.INFO_STOP_MSG)
+
+
+# ----------------------------
+#  init & quit
+# ----------------------------
+class _Config:
+    MAXFPS = 45
+    SCR_SIZE = (None, None)
+    UPSCALING = None  # not defined, yet
+
+
+config = _Config
+
+
+def init(gfc_mode=1, caption=None, maxfps=60, screen_dim=None):
+    global _gameticker, _joy, config
+    bootstrap_e()
+    config.MAXFPS = int(maxfps)
+    pygm = hub.pygame
+    pygm.init()
+    pygm.mixer.init()
+
+    jc = _stored_kbackend.joystick_count()
+    if jc > 0:
+        # ------ init the joystick ------
+        _joy = _stored_kbackend.joystick_init(0)
+        name = _stored_kbackend.joystick_info(0)
+        print(name + ' detected')
+        # numaxes = _joy.get_numaxes()
+        # numballs = _joy.get_numballs()
+        # numbuttons = _joy.get_numbuttons()
+        # numhats = _joy.get_numhats()
+        # print(numaxes, numballs, numbuttons, numhats)
+
+    screen_param(gfc_mode, screen_dim=screen_dim)
+    if caption is None:
+        caption = f'untitled demo, uses KENGI ver {_VER_CST}'
+    pygm.display.set_caption(caption)
+
+
+def quit():  # we keep the "quit" name bc of pygame
+    global _active_state
+    if _active_state:
+        if _state_sm.multistate_flag:
+            _state_sm.multistate_flag = False
+            _state_sm.stack_based_ctrl.turn_off()
+            _state_sm.stack_based_ctrl = None
+        if hub.kengi_inj.is_loaded('ascii') and hub.ascii.is_ready():
+            hub.ascii.reset()
+
+        events.EvManager.instance().hard_reset()
+        vscreen.init2_done = False
+        pyg = get_injector()['pygame']
+        pyg.mixer.quit()
+        pyg.quit()
+        _active_state = False
+
+
+# ----------------------------
+#  Related to lazy import
+# ----------------------------
+pygame = PygameIface()
+
+
+def get_injector():
+    return hub.kengi_inj
+
+
+def plugin_bind(plugin_name, pypath):
+    hub.kengi_inj.register(plugin_name, pypath)
+
+
+def bulk_plugin_bind(darg: dict):
+    """
+    :param darg: association extension(plug-in) name to a pypath
+    :return:
+    """
+    for pname, ppath in darg.items():
+        plugin_bind(ppath, ppath)
+
+
+def __getattr__(attr_name):
+    if attr_name in ('ver', 'vernum'):
+        return _VER_CST
+    if is_ready():
+        return getattr(hub, attr_name)
+    raise AttributeError(f"kengi cannot lazy load, it hasnt bootstrap yet! (user request: {attr_name})")
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/__version__.py` & `pyved-engine-23.6a1/src/pyved_engine/__version__.py`

 * *Files 21% similar despite different names*

```diff
@@ -1,17 +1,17 @@
-VYEAR_2DIG = 23  # remember to use only 2 digits
-VMONTH = 5
-_idx = 1  # 1 =alpha, 2 =beta, 3 =release candidate, 0 =legit release
-VRANK = 1
-
-"""
-We target this standard format:
-- Alpha release     yy.MMaN
-- Beta release      yy.MMbN
-- Release candidate yy.MMrcN
-- Final release     yy.MM
-
-So, to respect the PEP440 do not change anything pass this line!
-"""
-VRTYPE = ['', 'a', 'b', 'rc'][_idx]  # do not change this line
-_suffix = '' if '' == VRTYPE else VRTYPE + str(VRANK)
-ENGI_VERSION = f"{VYEAR_2DIG}.{VMONTH}{_suffix}"
+VYEAR_2DIG = 23  # remember to use only 2 digits
+VMONTH = 6
+_idx = 1  # 1 =alpha, 2 =beta, 3 =release candidate, 0 =legit release
+VRANK = 1
+
+"""
+We target this standard format:
+- Alpha release     yy.MMaN
+- Beta release      yy.MMbN
+- Release candidate yy.MMrcN
+- Final release     yy.MM
+
+So, to respect the PEP440 do not change anything pass this line!
+"""
+VRTYPE = ['', 'a', 'b', 'rc'][_idx]  # do not change this line
+_suffix = '' if '' == VRTYPE else VRTYPE + str(VRANK)
+ENGI_VERSION = f"{VYEAR_2DIG}.{VMONTH}{_suffix}"
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/_ecs_pattern.py` & `pyved-engine-23.6a1/src/pyved_engine/_ecs_pattern.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,161 +1,161 @@
-"""
-ECS - Entity Component system
-heavily inspired by other projects authored by:
- - Vladimir Kaukin [KaukinVK@ya.ru]
- - Rik Cross [rik@raspberrypi.org]
-"""
-# from typing import Iterable, Iterator, Any
-import dataclasses
-import collections
-import functools
-
-
-# any entity class must be decorated with this function
-entity = functools.partial(dataclasses.dataclass, slots=True)
-
-# any component class must be decorated with this function
-component = dataclasses.dataclass
-
-
-class EntityManager:
-    """Entity manager"""
-
-    def __init__(self):
-        self._entity_map = {}  # Person: [ent1, ent2]
-        self._entity_components_map = {}  # Person: (MoveCom, DamageCom, NameCom)
-        self._set_cache_map = {}  # (MoveCom, DamageCom, NameCom): {MoveCom, DamageCom, NameCom}
-        self._delete_entity_buffer = collections.deque()  # deque([Person1, Person2])
-
-    def add(self, *entity_value_list):
-        """Add entities to world"""
-        for entity_value in entity_value_list:
-            assert getattr(entity_value, '__dict__', None) in (None, {}), 'Data class with inefficient memory usage'
-            entity_value_class = entity_value.__class__
-            self._entity_map.setdefault(entity_value_class, []).append(entity_value)
-            if entity_value_class not in self._entity_components_map:
-                self._entity_components_map[entity_value_class] = tuple(sorted(
-                    (i for i in entity_value_class.__mro__ if i is not object),
-                    key=lambda x: x.__class__.__name__
-                ))
-
-    def delete(self, *entity_value_list):
-        """Delete entities from world"""
-        for entity_value in entity_value_list:
-            self._entity_map[entity_value.__class__].remove(entity_value)
-
-    def delete_buffer_add(self, *entity_value_list):
-        """Save entities into delete buffer for delete them from world later"""
-        for entity_value in entity_value_list:
-            self._delete_entity_buffer.append(entity_value)
-
-    def delete_buffer_purge(self):
-        """Delete all entities from delete buffer"""
-        for delete_entity in self._delete_entity_buffer:
-            self.delete(delete_entity)
-        self._delete_entity_buffer.clear()
-
-    def init(self, *entity_list):
-        """
-        Let entity manager to "know" about entities before work
-        If manager do not know about entity, it will raise KeyError on access to it.
-        event: SomeEvent = next(self.entities.get_by_class(SomeEvent), None)
-        """
-        for ent in entity_list:
-            self.add(ent)
-            self.delete(ent)
-
-    def get_by_class(self, *entity_class_val_list: type):
-        """
-        Get all entities by specified entity class in specified order
-        raise KeyError for uninitialized (never added) entities
-        type returned is
-        -> Iterator[Any]
-        """
-        for entity_class_val in entity_class_val_list:
-            yield from self._entity_map[entity_class_val]
-
-    def get_with_component(self, *component_class_val_list: type):
-        """
-        Get all entities that contains all specified component classes
-        Sometimes it will be useful to warm up the cache
-        raise KeyError for uninitialized (never added) entities
-        type returned is
-        -> Iterator[Any]
-        """
-        for entity_class, entity_component_list in self._entity_components_map.items():
-            entity_component_set = \
-                self._set_cache_map.setdefault(entity_component_list, set(entity_component_list))
-            component_class_val_set = \
-                self._set_cache_map.setdefault(component_class_val_list, set(component_class_val_list))
-            if component_class_val_set.issubset(entity_component_set):
-                yield from self._entity_map[entity_class]
-
-
-class System:
-    """
-    Abstract base class for system
-    All systems must be derived from this class
-    System should have data for work: implement __init__ method
-    """
-
-    def initialize(self):
-        """
-        Preparing system to work before starting SystemManager.systems_update loop
-        Runs by SystemManager.start_systems
-        """
-
-    def proc(self):
-        """
-        Run main system logic
-        Runs by SystemManager.update_systems
-        """
-
-    def cleanup(self):
-        """
-        Clean system resources after stop update loop
-        Runs by SystemManager.stop_systems
-        """
-
-
-class SystemManager:
-    """
-    System manager
-    """
-
-    def __init__(self, system_list):
-        """
-        :param system_list: an ordered sequence with systems, expected type is Iterable[System]
-        such that
-        for each pair of elements elt_i, elt_j we have classname(elt_i) != classname(elt_j)
-        """
-        self._system_list = tuple(system_list)
-
-        self._name_to_sys = dict()
-        for e in self._system_list:
-            cls_name = e.__class__.__name__
-            if cls_name in self._name_to_sys:
-                raise Exception('ERR: Duplicate name for system detected!', cls_name)
-            self._name_to_sys[cls_name] = e
-
-        self._system_with_start_list = tuple(e for e in self._system_list if hasattr(e, 'initialize'))
-        self._system_with_update_list = tuple(e for e in self._system_list if hasattr(e, 'proc'))
-        self._system_with_stop_list = tuple(e for e in self._system_list if hasattr(e, 'cleanup'))
-
-    # get by system name
-    def __getitem__(self, item):
-        return self._name_to_sys[item]
-
-    def init_all(self):
-        """Start all systems"""
-        for system in self._system_with_start_list:
-            system.initialize()
-
-    def proc_all(self):
-        """Update all systems"""
-        for system in self._system_with_update_list:
-            system.proc()
-
-    def cleanup_all(self):
-        """Stop all systems"""
-        for system in self._system_with_stop_list:
-            system.cleanup()
+"""
+ECS - Entity Component system
+heavily inspired by other projects authored by:
+ - Vladimir Kaukin [KaukinVK@ya.ru]
+ - Rik Cross [rik@raspberrypi.org]
+"""
+# from typing import Iterable, Iterator, Any
+import dataclasses
+import collections
+import functools
+
+
+# any entity class must be decorated with this function
+entity = functools.partial(dataclasses.dataclass, slots=True)
+
+# any component class must be decorated with this function
+component = dataclasses.dataclass
+
+
+class EntityManager:
+    """Entity manager"""
+
+    def __init__(self):
+        self._entity_map = {}  # Person: [ent1, ent2]
+        self._entity_components_map = {}  # Person: (MoveCom, DamageCom, NameCom)
+        self._set_cache_map = {}  # (MoveCom, DamageCom, NameCom): {MoveCom, DamageCom, NameCom}
+        self._delete_entity_buffer = collections.deque()  # deque([Person1, Person2])
+
+    def add(self, *entity_value_list):
+        """Add entities to world"""
+        for entity_value in entity_value_list:
+            assert getattr(entity_value, '__dict__', None) in (None, {}), 'Data class with inefficient memory usage'
+            entity_value_class = entity_value.__class__
+            self._entity_map.setdefault(entity_value_class, []).append(entity_value)
+            if entity_value_class not in self._entity_components_map:
+                self._entity_components_map[entity_value_class] = tuple(sorted(
+                    (i for i in entity_value_class.__mro__ if i is not object),
+                    key=lambda x: x.__class__.__name__
+                ))
+
+    def delete(self, *entity_value_list):
+        """Delete entities from world"""
+        for entity_value in entity_value_list:
+            self._entity_map[entity_value.__class__].remove(entity_value)
+
+    def delete_buffer_add(self, *entity_value_list):
+        """Save entities into delete buffer for delete them from world later"""
+        for entity_value in entity_value_list:
+            self._delete_entity_buffer.append(entity_value)
+
+    def delete_buffer_purge(self):
+        """Delete all entities from delete buffer"""
+        for delete_entity in self._delete_entity_buffer:
+            self.delete(delete_entity)
+        self._delete_entity_buffer.clear()
+
+    def init(self, *entity_list):
+        """
+        Let entity manager to "know" about entities before work
+        If manager do not know about entity, it will raise KeyError on access to it.
+        event: SomeEvent = next(self.entities.get_by_class(SomeEvent), None)
+        """
+        for ent in entity_list:
+            self.add(ent)
+            self.delete(ent)
+
+    def get_by_class(self, *entity_class_val_list: type):
+        """
+        Get all entities by specified entity class in specified order
+        raise KeyError for uninitialized (never added) entities
+        type returned is
+        -> Iterator[Any]
+        """
+        for entity_class_val in entity_class_val_list:
+            yield from self._entity_map[entity_class_val]
+
+    def get_with_component(self, *component_class_val_list: type):
+        """
+        Get all entities that contains all specified component classes
+        Sometimes it will be useful to warm up the cache
+        raise KeyError for uninitialized (never added) entities
+        type returned is
+        -> Iterator[Any]
+        """
+        for entity_class, entity_component_list in self._entity_components_map.items():
+            entity_component_set = \
+                self._set_cache_map.setdefault(entity_component_list, set(entity_component_list))
+            component_class_val_set = \
+                self._set_cache_map.setdefault(component_class_val_list, set(component_class_val_list))
+            if component_class_val_set.issubset(entity_component_set):
+                yield from self._entity_map[entity_class]
+
+
+class System:
+    """
+    Abstract base class for system
+    All systems must be derived from this class
+    System should have data for work: implement __init__ method
+    """
+
+    def initialize(self):
+        """
+        Preparing system to work before starting SystemManager.systems_update loop
+        Runs by SystemManager.start_systems
+        """
+
+    def proc(self):
+        """
+        Run main system logic
+        Runs by SystemManager.update_systems
+        """
+
+    def cleanup(self):
+        """
+        Clean system resources after stop update loop
+        Runs by SystemManager.stop_systems
+        """
+
+
+class SystemManager:
+    """
+    System manager
+    """
+
+    def __init__(self, system_list):
+        """
+        :param system_list: an ordered sequence with systems, expected type is Iterable[System]
+        such that
+        for each pair of elements elt_i, elt_j we have classname(elt_i) != classname(elt_j)
+        """
+        self._system_list = tuple(system_list)
+
+        self._name_to_sys = dict()
+        for e in self._system_list:
+            cls_name = e.__class__.__name__
+            if cls_name in self._name_to_sys:
+                raise Exception('ERR: Duplicate name for system detected!', cls_name)
+            self._name_to_sys[cls_name] = e
+
+        self._system_with_start_list = tuple(e for e in self._system_list if hasattr(e, 'initialize'))
+        self._system_with_update_list = tuple(e for e in self._system_list if hasattr(e, 'proc'))
+        self._system_with_stop_list = tuple(e for e in self._system_list if hasattr(e, 'cleanup'))
+
+    # get by system name
+    def __getitem__(self, item):
+        return self._name_to_sys[item]
+
+    def init_all(self):
+        """Start all systems"""
+        for system in self._system_with_start_list:
+            system.initialize()
+
+    def proc_all(self):
+        """Update all systems"""
+        for system in self._system_with_update_list:
+            system.proc()
+
+    def cleanup_all(self):
+        """Stop all systems"""
+        for system in self._system_with_stop_list:
+            system.cleanup()
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/_hub.py` & `pyved-engine-23.6a1/src/pyved_engine/_hub.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,33 +1,33 @@
-"""
-Keep this file separate from __init__.py!
-its important, bc all sub-modules in kengi may import _hub
-in order to refer to other dependencies/sub-modules
-"""
-from .core import events
-
-from .core.Injector import Injector as Injector
-
-
-kengi_inj = Injector({
-    'ai': '.looparts.ai',
-    'demolib': '.looparts.demolib',
-    'gui': '.looparts.gui',
-    'isometric': '.looparts.isometric',
-    'polarbear': '.looparts.polarbear',
-    'tmx': '.looparts.tmx',
-    'anim': '.looparts.anim',
-    'ascii': '.looparts.ascii',
-    'console': '.looparts.console',
-    'rogue': '.looparts.rogue',
-    'rpg': '.looparts.rpg',
-    'sysconsole': '.looparts.sysconsole',
-    'tabletop': '.looparts.tabletop',
-    'terrain': '.looparts.terrain',
-}, 'pyved_engine')
-
-
-def __getattr__(targ_sm_name):
-    if targ_sm_name in kengi_inj:
-        return kengi_inj[targ_sm_name]
-    else:
-        raise AttributeError(f"kengi has no attribute named {targ_sm_name}")
+"""
+Keep this file separate from __init__.py!
+its important, bc all sub-modules in kengi may import _hub
+in order to refer to other dependencies/sub-modules
+"""
+from .core import events
+
+from .core.Injector import Injector as Injector
+
+
+kengi_inj = Injector({
+    'ai': '.looparts.ai',
+    'demolib': '.looparts.demolib',
+    'gui': '.looparts.gui',
+    'isometric': '.looparts.isometric',
+    'polarbear': '.looparts.polarbear',
+    'tmx': '.looparts.tmx',
+    'anim': '.looparts.anim',
+    'ascii': '.looparts.ascii',
+    'console': '.looparts.console',
+    'rogue': '.looparts.rogue',
+    'rpg': '.looparts.rpg',
+    'sysconsole': '.looparts.sysconsole',
+    'tabletop': '.looparts.tabletop',
+    'terrain': '.looparts.terrain',
+}, 'pyved_engine')
+
+
+def __getattr__(targ_sm_name):
+    if targ_sm_name in kengi_inj:
+        return kengi_inj[targ_sm_name]
+    else:
+        raise AttributeError(f"kengi has no attribute named {targ_sm_name}")
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/compo/gfx.py` & `pyved-engine-23.6a1/src/pyved_engine/compo/gfx.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,330 +1,330 @@
-import base64
-import io
-import json
-from abc import abstractmethod
-from collections import defaultdict
-
-from . import packed_capello_ft
-from .. import _hub
-
-
-class JsonBasedSprSheet:
-    def __init__(self, required_infos, ck=None):
-
-        if isinstance(required_infos, str):
-            filename_no_ext = required_infos
-            self.sheet_surf = _hub.pygame.image.load(filename_no_ext + '.png')
-            json_def_file = open(required_infos + '.json', 'r')
-        else:
-            fptr, json_def_file = required_infos
-            self.sheet_surf = _hub.pygame.image.load(fptr)  # namehint="capello-ft.png"
-
-        if ck:
-            self.sheet_surf.set_colorkey(ck)
-
-        jsondata = json.load(json_def_file)
-        assoc_tmp = dict()
-        self.all_names = set()
-        if isinstance(jsondata['frames'], list):  # we support 2 formats of json desc
-            for infos in jsondata['frames']:
-                gname = infos['filename']
-                self.all_names.add(gname)
-                args = (infos['frame']['x'], infos['frame']['y'], infos['frame']['w'], infos['frame']['h'])
-                assoc_tmp[gname] = self.sheet_surf.subsurface(_hub.pygame.Rect(*args)).copy()
-        else:
-            for sprname, infos in jsondata['frames'].items():
-                self.all_names.add(sprname)
-                args = (infos['frame']['x'], infos['frame']['y'], infos['frame']['w'], infos['frame']['h'])
-                assoc_tmp[sprname] = self.sheet_surf.subsurface(_hub.pygame.Rect(*args)).copy()
-        self.assoc_name_spr = assoc_tmp
-
-    def __getitem__(self, item):
-        return self.assoc_name_spr[item]
-
-
-class BaseCfont:
-    UNKNOWN_CAR_RK = 123
-    SPAM_CAR = False
-
-    @abstractmethod
-    def _init_sheet_attr(self):
-        raise NotImplementedError
-
-    def __init__(self):
-        self.forcing_transparency = False
-
-        self._sheet = None
-        self._init_sheet_attr()
-
-        # specific to capello-ft.png and capello-ft.json...
-        # it maps ascii codes to the rank font000.png where 000 is the rank
-        mappingtable = {
-            174: 150,  # circled r car.
-            175: 151,
-        }
-        for e in range(32, 48):
-            mappingtable[e] = e - 32
-        for e in range(48, 64):
-            mappingtable[e] = e - 31
-        for e in range(64, 80):
-            mappingtable[e] = e - 30
-        for e in range(80, 96):
-            mappingtable[e] = e - 29
-        for e in range(96, 112):
-            mappingtable[e] = e - 28
-        for e in range(112, 127):
-            mappingtable[e] = e - 27
-        # upside-down !, cent ¢ , then £ symbol ... etc.
-        for e in range(160, 173):
-            mappingtable[e] = e - 24
-
-        for e in range(176, 176 + 16):
-            mappingtable[e] = e - 23
-        for e in range(192, 208):
-            mappingtable[e] = e - 22
-        # Ð 208 et suivants
-        for e in range(208, 224):
-            mappingtable[e] = e - 21
-        for e in range(224, 240):
-            mappingtable[e] = e - 20
-        # ð 240 et suivants
-        for e in range(240, 256):
-            mappingtable[e] = e - 19
-        self.car_height = defaultdict(lambda: 7)
-        # for my_asciicode in range(*alphabet_span):
-        #     self.car_height[chr(my_asciicode)] = 7  # CONST
-
-        # - generic
-        self.ascii2img = dict()
-        defaultw = self._sheet['tile{:03d}.png'.format(self.UNKNOWN_CAR_RK)].get_width()
-        self.car_width = defaultdict(lambda: defaultw)
-
-        for my_asciicode in mappingtable.keys():
-            ssurf = self._sheet['tile{:03d}.png'.format(mappingtable[my_asciicode])]
-            self.ascii2img[my_asciicode] = ssurf
-            self.car_width[chr(my_asciicode)] = ssurf.get_width()
-
-    @property
-    def sheet(self):
-        return self._sheet
-
-    def __getitem__(self, itemk):
-        ascii_tmp = ord(itemk)
-        if self.SPAM_CAR:
-            print(itemk, ascii_tmp)
-        try:
-            return self.ascii2img[ascii_tmp]
-        except KeyError:
-            return self._sheet['tile{:03d}.png'.format(self.UNKNOWN_CAR_RK)]
-
-    def text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None):
-        # fill background with a solid color, if requested
-        if bgcolor:
-            curr_pos = list(start_pos)
-            h = float('-inf')
-            for letter in w:
-                curr_pos[0] += self.car_width[letter] + spacing
-                if self.car_height[letter] > h:
-                    h = self.car_height[letter]
-            _hub.pygame.draw.rect(
-                refsurf, bgcolor, (start_pos[0], start_pos[1], curr_pos[0] - spacing - start_pos[0], h), 0
-            )
-        # draw the text
-        curr_pos = list(start_pos)
-        for letter in w:
-            refsurf.blit(self[letter], curr_pos)
-            curr_pos[0] += self.car_width[letter] + spacing
-
-    def compute_width(self, w, spacing=0):
-        res = 0
-        for letter in w:
-            res += self.car_width[letter] + spacing
-        return res
-
-    # ---------------
-    #  lets emulate the pygame API, too
-    # ---------------
-    def size(self, w):
-        fixspacing = 0
-        return self.compute_width(w, fixspacing), self.car_height[' ']
-
-    # signature. font.render(l, antialias, color)
-    def render(self, textstr, dummy_antialias, dummy_color, spacing=0):
-        """
-        :param spacing:
-        :param textstr:
-        :param dummy_antialias: unused, but must be here for API compliance
-        :param dummy_color: unused, but must be here for API compliance
-        :return: a pygame surface obj!
-        """
-        aw, ah = self.compute_width(textstr, spacing), self.car_height[' ']
-        res = _hub.pygame.Surface((aw, ah))
-
-        opt0 = self.forcing_transparency
-        ck_tmp_color = (255, 0, 255)
-        if opt0:
-            res.fill(ck_tmp_color)
-        self.text_to_surf(textstr, res, (0, 0), spacing)
-        if opt0:
-            res.set_colorkey(ck_tmp_color)
-
-        return res
-
-
-class JsonBasedCfont(BaseCfont):
-    def __init__(self, sourcejson):
-        self._known_source = sourcejson
-        super().__init__()
-
-    def _init_sheet_attr(self):
-        font_source_no_ext = self._known_source
-        self._sheet = JsonBasedSprSheet(
-            font_source_no_ext, ck=(127, 127, 127)  # font_source could be 'capello-ft' for example
-        )
-
-
-class EmbeddedCfont(BaseCfont):
-    def _init_sheet_attr(self):
-        # - meth2 : on ouvre du packed data, tt simplement!
-        filelike_png = io.BytesIO(base64.b64decode(packed_capello_ft.pngdata))
-        filelike_json = io.StringIO(packed_capello_ft.jsondata)
-        self._sheet = JsonBasedSprSheet(
-            (filelike_png, filelike_json), ck=(127, 127, 127)
-        )
-
-
-class Spritesheet:
-    """
-    handles sprite sheets in an optimized way!
-    REMARK: When calling images_at the rect is the format: (x, y, x + offset, y + offset)
-    """
-
-    def __init__(self, resource_info, chosen_scale=1):
-        """
-        :param resource_info: either pygame.Surface or filepath
-        :param chosen_scale:
-        """
-        if isinstance(resource_info, _hub.pygame.Surface):
-            self._sheet = resource_info
-        else:
-            self._sheet = _hub.pygame.image.load(resource_info).convert()
-
-        if float(chosen_scale) != 1.0:
-            homo = _hub.pygame.transform.scale
-            w, h = self._sheet.get_size()
-            self._sheet = homo(self._sheet, (chosen_scale * w, chosen_scale * h))
-
-        # can be init later
-        self._per_line_img_quant = 0
-        self._card = 0
-        self._tilesize = None
-
-        self._colorkey = None
-
-        # goal: speed-up
-        self.cache = defaultdict(lambda: None)
-        self._spacing = 0
-
-    @property
-    def colorkey(self):
-        return self._colorkey
-
-    @colorkey.setter
-    def colorkey(self, v):
-        self._colorkey = v
-        self._cache_update()
-
-    @property
-    def card(self):
-        return self._card
-
-    @property
-    def tilesize(self):
-        return self._tilesize
-
-    def set_infos(self, pair_wh, count_tiles=None, nb_columns=None, spacing=0):
-        self._tilesize = pair_wh[0], pair_wh[1]
-
-        if count_tiles is not None and nb_columns is not None:
-            self._per_line_img_quant = nb_columns
-            self._card = count_tiles
-        else:
-            sz = self._sheet.get_size()
-            self._per_line_img_quant = sz[0] // self._tilesize[0]
-            self._card = (sz[1] // self._tilesize[1]) * self._per_line_img_quant
-
-        self._spacing = spacing
-        # - debug
-        # print(
-        #     f'infos dans Spritesheet saisies depuis dehors:\n___tilesize {self._tilesize}\n'
-        #     + '___count_img {count_tiles}\n___nbcol {nb_columns}\n___spacing {spacing}'
-        # )
-        self._cache_update()
-
-    def _cache_update(self):
-        # re - populate the whole cache!
-        self.cache.clear()
-        pg = _hub.pygame
-
-        if self._tilesize is None:
-            return
-        tile_w, tile_h = self._tilesize
-        ident = 0
-        nb_lines = self._card // self._per_line_img_quant
-        for curr_line in range(1, nb_lines + 1):
-            for column in range(1, self._per_line_img_quant + 1):
-                adhocx = -tile_w + column * tile_w + (column - 1) * self._spacing
-                adhocy = -tile_h + curr_line * tile_h + (curr_line - 1) * self._spacing
-                decoupe = pg.Rect(adhocx, adhocy, tile_w, tile_h)
-                y = self._sheet.subsurface(decoupe)
-                if self._colorkey is not None:
-                    y.set_colorkey(self._colorkey)
-                self.cache[ident] = y
-                ident += 1
-
-    @property
-    def spacing(self):
-        return self._spacing
-
-    def __getitem__(self, item):
-        return self.image_by_rank(item)
-
-    def image_at(self, rectangle):
-        y = self._sheet.subsurface(rectangle).copy()
-        if self._colorkey:
-            y.set_colorkey(self._colorkey)
-        return y
-
-    # USE WITH CAUTION! This method provides no optimization
-    def images_at(self, rects, colorkey):
-        """
-        Loads a bunch of images at once
-        :param rects: a list of coordinates
-        :param colorkey:
-        :return: several images as a list
-        """
-        res = [self.image_at(rect) for rect in rects]
-        for e in res:
-            e.set_colorkey(colorkey)
-        return res
-
-    def image_by_rank(self, kval):
-        if self._tilesize is None:
-            raise ValueError('Spritesheet.image_by_rank call but tilesize hasnt been set!')
-        y = self.cache[kval]
-        if y is None:
-            tw, th = self._tilesize
-            # map kval -> to a rect
-            i, j = kval % self._per_line_img_quant, int(kval / self._per_line_img_quant)
-            rect_obj = _hub.pygame.Rect(i * tw, j * th, tw, th)
-            # crop from the sheet save & return the result
-            y = self.cache[kval] = self.image_at(rect_obj)
-        return y
-
-    # USE WITH CAUTION! This method provides no optimization
-    def load_strip(self, rect_img0, image_count, colorkey=None):
-        """Loads a strip of images and returns them as a list, rect must cut out the img rank 0"""
-        rect = rect_img0
-        tw, th = rect[2], rect[3]
-        tups = [(rect[0] + x * tw, rect[1], tw, th) for x in range(image_count)]
-        return self.images_at(tups, colorkey)
+import base64
+import io
+import json
+from abc import abstractmethod
+from collections import defaultdict
+
+from . import packed_capello_ft
+from .. import _hub
+
+
+class JsonBasedSprSheet:
+    def __init__(self, required_infos, ck=None):
+
+        if isinstance(required_infos, str):
+            filename_no_ext = required_infos
+            self.sheet_surf = _hub.pygame.image.load(filename_no_ext + '.png')
+            json_def_file = open(required_infos + '.json', 'r')
+        else:
+            fptr, json_def_file = required_infos
+            self.sheet_surf = _hub.pygame.image.load(fptr)  # namehint="capello-ft.png"
+
+        if ck:
+            self.sheet_surf.set_colorkey(ck)
+
+        jsondata = json.load(json_def_file)
+        assoc_tmp = dict()
+        self.all_names = set()
+        if isinstance(jsondata['frames'], list):  # we support 2 formats of json desc
+            for infos in jsondata['frames']:
+                gname = infos['filename']
+                self.all_names.add(gname)
+                args = (infos['frame']['x'], infos['frame']['y'], infos['frame']['w'], infos['frame']['h'])
+                assoc_tmp[gname] = self.sheet_surf.subsurface(_hub.pygame.Rect(*args)).copy()
+        else:
+            for sprname, infos in jsondata['frames'].items():
+                self.all_names.add(sprname)
+                args = (infos['frame']['x'], infos['frame']['y'], infos['frame']['w'], infos['frame']['h'])
+                assoc_tmp[sprname] = self.sheet_surf.subsurface(_hub.pygame.Rect(*args)).copy()
+        self.assoc_name_spr = assoc_tmp
+
+    def __getitem__(self, item):
+        return self.assoc_name_spr[item]
+
+
+class BaseCfont:
+    UNKNOWN_CAR_RK = 123
+    SPAM_CAR = False
+
+    @abstractmethod
+    def _init_sheet_attr(self):
+        raise NotImplementedError
+
+    def __init__(self):
+        self.forcing_transparency = False
+
+        self._sheet = None
+        self._init_sheet_attr()
+
+        # specific to capello-ft.png and capello-ft.json...
+        # it maps ascii codes to the rank font000.png where 000 is the rank
+        mappingtable = {
+            174: 150,  # circled r car.
+            175: 151,
+        }
+        for e in range(32, 48):
+            mappingtable[e] = e - 32
+        for e in range(48, 64):
+            mappingtable[e] = e - 31
+        for e in range(64, 80):
+            mappingtable[e] = e - 30
+        for e in range(80, 96):
+            mappingtable[e] = e - 29
+        for e in range(96, 112):
+            mappingtable[e] = e - 28
+        for e in range(112, 127):
+            mappingtable[e] = e - 27
+        # upside-down !, cent ¢ , then £ symbol ... etc.
+        for e in range(160, 173):
+            mappingtable[e] = e - 24
+
+        for e in range(176, 176 + 16):
+            mappingtable[e] = e - 23
+        for e in range(192, 208):
+            mappingtable[e] = e - 22
+        # Ð 208 et suivants
+        for e in range(208, 224):
+            mappingtable[e] = e - 21
+        for e in range(224, 240):
+            mappingtable[e] = e - 20
+        # ð 240 et suivants
+        for e in range(240, 256):
+            mappingtable[e] = e - 19
+        self.car_height = defaultdict(lambda: 7)
+        # for my_asciicode in range(*alphabet_span):
+        #     self.car_height[chr(my_asciicode)] = 7  # CONST
+
+        # - generic
+        self.ascii2img = dict()
+        defaultw = self._sheet['tile{:03d}.png'.format(self.UNKNOWN_CAR_RK)].get_width()
+        self.car_width = defaultdict(lambda: defaultw)
+
+        for my_asciicode in mappingtable.keys():
+            ssurf = self._sheet['tile{:03d}.png'.format(mappingtable[my_asciicode])]
+            self.ascii2img[my_asciicode] = ssurf
+            self.car_width[chr(my_asciicode)] = ssurf.get_width()
+
+    @property
+    def sheet(self):
+        return self._sheet
+
+    def __getitem__(self, itemk):
+        ascii_tmp = ord(itemk)
+        if self.SPAM_CAR:
+            print(itemk, ascii_tmp)
+        try:
+            return self.ascii2img[ascii_tmp]
+        except KeyError:
+            return self._sheet['tile{:03d}.png'.format(self.UNKNOWN_CAR_RK)]
+
+    def text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None):
+        # fill background with a solid color, if requested
+        if bgcolor:
+            curr_pos = list(start_pos)
+            h = float('-inf')
+            for letter in w:
+                curr_pos[0] += self.car_width[letter] + spacing
+                if self.car_height[letter] > h:
+                    h = self.car_height[letter]
+            _hub.pygame.draw.rect(
+                refsurf, bgcolor, (start_pos[0], start_pos[1], curr_pos[0] - spacing - start_pos[0], h), 0
+            )
+        # draw the text
+        curr_pos = list(start_pos)
+        for letter in w:
+            refsurf.blit(self[letter], curr_pos)
+            curr_pos[0] += self.car_width[letter] + spacing
+
+    def compute_width(self, w, spacing=0):
+        res = 0
+        for letter in w:
+            res += self.car_width[letter] + spacing
+        return res
+
+    # ---------------
+    #  lets emulate the pygame API, too
+    # ---------------
+    def size(self, w):
+        fixspacing = 0
+        return self.compute_width(w, fixspacing), self.car_height[' ']
+
+    # signature. font.render(l, antialias, color)
+    def render(self, textstr, dummy_antialias, dummy_color, spacing=0):
+        """
+        :param spacing:
+        :param textstr:
+        :param dummy_antialias: unused, but must be here for API compliance
+        :param dummy_color: unused, but must be here for API compliance
+        :return: a pygame surface obj!
+        """
+        aw, ah = self.compute_width(textstr, spacing), self.car_height[' ']
+        res = _hub.pygame.Surface((aw, ah))
+
+        opt0 = self.forcing_transparency
+        ck_tmp_color = (255, 0, 255)
+        if opt0:
+            res.fill(ck_tmp_color)
+        self.text_to_surf(textstr, res, (0, 0), spacing)
+        if opt0:
+            res.set_colorkey(ck_tmp_color)
+
+        return res
+
+
+class JsonBasedCfont(BaseCfont):
+    def __init__(self, sourcejson):
+        self._known_source = sourcejson
+        super().__init__()
+
+    def _init_sheet_attr(self):
+        font_source_no_ext = self._known_source
+        self._sheet = JsonBasedSprSheet(
+            font_source_no_ext, ck=(127, 127, 127)  # font_source could be 'capello-ft' for example
+        )
+
+
+class EmbeddedCfont(BaseCfont):
+    def _init_sheet_attr(self):
+        # - meth2 : on ouvre du packed data, tt simplement!
+        filelike_png = io.BytesIO(base64.b64decode(packed_capello_ft.pngdata))
+        filelike_json = io.StringIO(packed_capello_ft.jsondata)
+        self._sheet = JsonBasedSprSheet(
+            (filelike_png, filelike_json), ck=(127, 127, 127)
+        )
+
+
+class Spritesheet:
+    """
+    handles sprite sheets in an optimized way!
+    REMARK: When calling images_at the rect is the format: (x, y, x + offset, y + offset)
+    """
+
+    def __init__(self, resource_info, chosen_scale=1):
+        """
+        :param resource_info: either pygame.Surface or filepath
+        :param chosen_scale:
+        """
+        if isinstance(resource_info, _hub.pygame.Surface):
+            self._sheet = resource_info
+        else:
+            self._sheet = _hub.pygame.image.load(resource_info).convert()
+
+        if float(chosen_scale) != 1.0:
+            homo = _hub.pygame.transform.scale
+            w, h = self._sheet.get_size()
+            self._sheet = homo(self._sheet, (chosen_scale * w, chosen_scale * h))
+
+        # can be init later
+        self._per_line_img_quant = 0
+        self._card = 0
+        self._tilesize = None
+
+        self._colorkey = None
+
+        # goal: speed-up
+        self.cache = defaultdict(lambda: None)
+        self._spacing = 0
+
+    @property
+    def colorkey(self):
+        return self._colorkey
+
+    @colorkey.setter
+    def colorkey(self, v):
+        self._colorkey = v
+        self._cache_update()
+
+    @property
+    def card(self):
+        return self._card
+
+    @property
+    def tilesize(self):
+        return self._tilesize
+
+    def set_infos(self, pair_wh, count_tiles=None, nb_columns=None, spacing=0):
+        self._tilesize = pair_wh[0], pair_wh[1]
+
+        if count_tiles is not None and nb_columns is not None:
+            self._per_line_img_quant = nb_columns
+            self._card = count_tiles
+        else:
+            sz = self._sheet.get_size()
+            self._per_line_img_quant = sz[0] // self._tilesize[0]
+            self._card = (sz[1] // self._tilesize[1]) * self._per_line_img_quant
+
+        self._spacing = spacing
+        # - debug
+        # print(
+        #     f'infos dans Spritesheet saisies depuis dehors:\n___tilesize {self._tilesize}\n'
+        #     + '___count_img {count_tiles}\n___nbcol {nb_columns}\n___spacing {spacing}'
+        # )
+        self._cache_update()
+
+    def _cache_update(self):
+        # re - populate the whole cache!
+        self.cache.clear()
+        pg = _hub.pygame
+
+        if self._tilesize is None:
+            return
+        tile_w, tile_h = self._tilesize
+        ident = 0
+        nb_lines = self._card // self._per_line_img_quant
+        for curr_line in range(1, nb_lines + 1):
+            for column in range(1, self._per_line_img_quant + 1):
+                adhocx = -tile_w + column * tile_w + (column - 1) * self._spacing
+                adhocy = -tile_h + curr_line * tile_h + (curr_line - 1) * self._spacing
+                decoupe = pg.Rect(adhocx, adhocy, tile_w, tile_h)
+                y = self._sheet.subsurface(decoupe)
+                if self._colorkey is not None:
+                    y.set_colorkey(self._colorkey)
+                self.cache[ident] = y
+                ident += 1
+
+    @property
+    def spacing(self):
+        return self._spacing
+
+    def __getitem__(self, item):
+        return self.image_by_rank(item)
+
+    def image_at(self, rectangle):
+        y = self._sheet.subsurface(rectangle).copy()
+        if self._colorkey:
+            y.set_colorkey(self._colorkey)
+        return y
+
+    # USE WITH CAUTION! This method provides no optimization
+    def images_at(self, rects, colorkey):
+        """
+        Loads a bunch of images at once
+        :param rects: a list of coordinates
+        :param colorkey:
+        :return: several images as a list
+        """
+        res = [self.image_at(rect) for rect in rects]
+        for e in res:
+            e.set_colorkey(colorkey)
+        return res
+
+    def image_by_rank(self, kval):
+        if self._tilesize is None:
+            raise ValueError('Spritesheet.image_by_rank call but tilesize hasnt been set!')
+        y = self.cache[kval]
+        if y is None:
+            tw, th = self._tilesize
+            # map kval -> to a rect
+            i, j = kval % self._per_line_img_quant, int(kval / self._per_line_img_quant)
+            rect_obj = _hub.pygame.Rect(i * tw, j * th, tw, th)
+            # crop from the sheet save & return the result
+            y = self.cache[kval] = self.image_at(rect_obj)
+        return y
+
+    # USE WITH CAUTION! This method provides no optimization
+    def load_strip(self, rect_img0, image_count, colorkey=None):
+        """Loads a strip of images and returns them as a list, rect must cut out the img rank 0"""
+        rect = rect_img0
+        tw, th = rect[2], rect[3]
+        tups = [(rect[0] + x * tw, rect[1], tw, th) for x in range(image_count)]
+        return self.images_at(tups, colorkey)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/compo/packed_capello_ft.py` & `pyved-engine-23.6a1/src/pyved_engine/compo/packed_capello_ft.py`

 * *Ordering differences only*

 * *Files 0% similar despite different names*

```diff
@@ -1,2 +1,2 @@
-pngdata=b'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aHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmFiODkzNzczLWMwZTQtNDI1ZS05MTU4LWE4MWI0NDY1ZTU1MyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowM2I1OWZhMC01MjE4LTQ4NjMtODgyYi0yZWVhNWU4MTlmMmQiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4NzdiNjVkOC1mODZhLTQ3OGEtOWQ1Ny05NWM3YWYwZjhkMDUiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTY1OTI2MTU5MzM2NDIxMSIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjMwIgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjFlNGI3ZWFkLWNhZTQtNDYxYy04ODBmLTE5MjEwODM2NDU1YSIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMi0wNy0zMVQxMDo1NDowNyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmN2NjZWRiYS0wOWI5LTQzZDctYWFmMC0wYzhmZDY2YjkzMWYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjItMDctMzFUMTE6NTk6NTMiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+km841wAAAAZiS0dEAP8AAAAAMyd88wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+YHHwk7NdND2XIAAAkiSURBVHja7V3bkqQ6DKO35r97+stnX05XMRyaSMIiCSs97cUdjOP4FpM8fpblZwmCIAiCIAiCIAiCIAiCIAiCIAiCIAiCIJgYX8uyLN/P569//H69Pv7gsSzL8/k8pNnSvl6v5m+2PBzx8qZ9j3vEMzvuekyUtiULhvYts9Y8qDJjaJE5ZnRHGRfVndd//4/oAzMXb7TGZWgZ/WXHReXw2Pz9SB6KfBk5MPrg0kmEnh13LQeEh9eGZm2H3r9X55iZtxbP6rpgxmV0Ehn3CdoTxr+pdh3lAdG1Le3R2AwPe/L9xMdZPXONi+rZEf2ZeUPnYo2935wZt0XLrk1W15F4Eh13z29WxDsMv4y/YNax6oeQdcyOq8brlfbMaX+reTj8/9UYZ2KNEWgZfUBySDXHccmhMndy8Yvou5KjMzEtktNfJd8qOaj1h1ZscsYP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'
-jsondata='''{"meta":{"app":"http://www.codeandweb.com/texturepacker","version":"1.0","image":"capello-ft.png","format":"RGBA8888","size":{"w":2112,"h":11},"scale":"1"},"frames":{"tile000.png":{"frame":{"x":1,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":1,"y":1,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile001.png":{"frame":{"x":12,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":12,"y":1,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile002.png":{"frame":{"x":23,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile003.png":{"frame":{"x":34,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile004.png":{"frame":{"x":45,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile005.png":{"frame":{"x":56,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile006.png":{"frame":{"x":67,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile007.png":{"frame":{"x":78,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile008.png":{"frame":{"x":89,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile009.png":{"frame":{"x":100,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile010.png":{"frame":{"x":111,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile011.png":{"frame":{"x":122,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile012.png":{"frame":{"x":133,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile013.png":{"frame":{"x":144,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile014.png":{"frame":{"x":155,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile015.png":{"frame":{"x":166,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile017.png":{"frame":{"x":177,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile018.png":{"frame":{"x":188,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile019.png":{"frame":{"x":199,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile020.png":{"frame":{"x":210,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile021.png":{"frame":{"x":221,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile022.png":{"frame":{"x":232,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile023.png":{"frame":{"x":243,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile024.png":{"frame":{"x":254,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile025.png":{"frame":{"x":265,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile026.png":{"frame":{"x":276,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile027.png":{"frame":{"x":287,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile028.png":{"frame":{"x":298,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile029.png":{"frame":{"x":309,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile030.png":{"frame":{"x":320,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile031.png":{"frame":{"x":331,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile032.png":{"frame":{"x":342,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile034.png":{"frame":{"x":353,"y":1,"w":9,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":9,"h":7},"sourceSize":{"w":9,"h":7}},"tile035.png":{"frame":{"x":364,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile036.png":{"frame":{"x":375,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile037.png":{"frame":{"x":386,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile038.png":{"frame":{"x":397,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile039.png":{"frame":{"x":408,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile040.png":{"frame":{"x":419,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile041.png":{"frame":{"x":430,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile042.png":{"frame":{"x":441,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile043.png":{"frame":{"x":452,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile044.png":{"frame":{"x":463,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile045.png":{"frame":{"x":474,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile046.png":{"frame":{"x":485,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile047.png":{"frame":{"x":496,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile048.png":{"frame":{"x":507,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile049.png":{"frame":{"x":518,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile051.png":{"frame":{"x":529,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile052.png":{"frame":{"x":540,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile053.png":{"frame":{"x":551,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile054.png":{"frame":{"x":562,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile055.png":{"frame":{"x":573,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile056.png":{"frame":{"x":584,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile057.png":{"frame":{"x":595,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile058.png":{"frame":{"x":606,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile059.png":{"frame":{"x":617,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile060.png":{"frame":{"x":628,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile061.png":{"frame":{"x":639,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile062.png":{"frame":{"x":650,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile063.png":{"frame":{"x":661,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile064.png":{"frame":{"x":672,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile065.png":{"frame":{"x":683,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile066.png":{"frame":{"x":694,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile068.png":{"frame":{"x":705,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile069.png":{"frame":{"x":716,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile070.png":{"frame":{"x":727,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile071.png":{"frame":{"x":738,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile072.png":{"frame":{"x":749,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile073.png":{"frame":{"x":760,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile074.png":{"frame":{"x":771,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile075.png":{"frame":{"x":782,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile076.png":{"frame":{"x":793,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile077.png":{"frame":{"x":804,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile078.png":{"frame":{"x":815,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile079.png":{"frame":{"x":826,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile080.png":{"frame":{"x":837,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile081.png":{"frame":{"x":848,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile082.png":{"frame":{"x":859,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile083.png":{"frame":{"x":870,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile085.png":{"frame":{"x":881,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile086.png":{"frame":{"x":892,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile087.png":{"frame":{"x":903,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile088.png":{"frame":{"x":914,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile089.png":{"frame":{"x":925,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile090.png":{"frame":{"x":936,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile091.png":{"frame":{"x":947,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile092.png":{"frame":{"x":958,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile093.png":{"frame":{"x":969,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile094.png":{"frame":{"x":980,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile095.png":{"frame":{"x":991,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile096.png":{"frame":{"x":1002,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile097.png":{"frame":{"x":1013,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile098.png":{"frame":{"x":1024,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile099.png":{"frame":{"x":1035,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile100.png":{"frame":{"x":1045,"y":1,"w":11,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":11,"h":7},"sourceSize":{"w":11,"h":7}},"tile123.png":{"frame":{"x":1057,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile136.png":{"frame":{"x":1068,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile137.png":{"frame":{"x":1079,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile138.png":{"frame":{"x":1090,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile139.png":{"frame":{"x":1101,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile140.png":{"frame":{"x":1112,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile141.png":{"frame":{"x":1123,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile142.png":{"frame":{"x":1134,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile143.png":{"frame":{"x":1145,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile144.png":{"frame":{"x":1156,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile145.png":{"frame":{"x":1167,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile146.png":{"frame":{"x":1177,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile147.png":{"frame":{"x":1189,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile148.png":{"frame":{"x":1200,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile150.png":{"frame":{"x":1211,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile151.png":{"frame":{"x":1222,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile153.png":{"frame":{"x":1233,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile154.png":{"frame":{"x":1244,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile155.png":{"frame":{"x":1255,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile156.png":{"frame":{"x":1266,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile157.png":{"frame":{"x":1277,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile158.png":{"frame":{"x":1288,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile159.png":{"frame":{"x":1299,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile160.png":{"frame":{"x":1310,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile161.png":{"frame":{"x":1321,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile162.png":{"frame":{"x":1332,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile163.png":{"frame":{"x":1342,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile164.png":{"frame":{"x":1354,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile165.png":{"frame":{"x":1365,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile166.png":{"frame":{"x":1376,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile167.png":{"frame":{"x":1387,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile168.png":{"frame":{"x":1398,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile170.png":{"frame":{"x":1409,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile171.png":{"frame":{"x":1420,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile172.png":{"frame":{"x":1431,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile173.png":{"frame":{"x":1442,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile174.png":{"frame":{"x":1453,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile175.png":{"frame":{"x":1464,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile176.png":{"frame":{"x":1475,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile177.png":{"frame":{"x":1486,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile178.png":{"frame":{"x":1497,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile179.png":{"frame":{"x":1507,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile180.png":{"frame":{"x":1519,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile181.png":{"frame":{"x":1530,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile182.png":{"frame":{"x":1541,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile183.png":{"frame":{"x":1552,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile184.png":{"frame":{"x":1563,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile185.png":{"frame":{"x":1574,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile187.png":{"frame":{"x":1585,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile188.png":{"frame":{"x":1596,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile189.png":{"frame":{"x":1607,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile190.png":{"frame":{"x":1618,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile191.png":{"frame":{"x":1629,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile192.png":{"frame":{"x":1640,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile193.png":{"frame":{"x":1651,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile194.png":{"frame":{"x":1662,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile195.png":{"frame":{"x":1673,"y":1,"w":7,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":7,"h":7},"sourceSize":{"w":7,"h":7}},"tile196.png":{"frame":{"x":1683,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile197.png":{"frame":{"x":1695,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile198.png":{"frame":{"x":1706,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile199.png":{"frame":{"x":1717,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile200.png":{"frame":{"x":1728,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile201.png":{"frame":{"x":1739,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile202.png":{"frame":{"x":1750,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile204.png":{"frame":{"x":1761,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile205.png":{"frame":{"x":1772,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile206.png":{"frame":{"x":1783,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile207.png":{"frame":{"x":1794,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile208.png":{"frame":{"x":1805,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile209.png":{"frame":{"x":1816,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile210.png":{"frame":{"x":1827,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile211.png":{"frame":{"x":1838,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile212.png":{"frame":{"x":1849,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile213.png":{"frame":{"x":1859,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile214.png":{"frame":{"x":1871,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile215.png":{"frame":{"x":1882,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile216.png":{"frame":{"x":1893,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile217.png":{"frame":{"x":1904,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile218.png":{"frame":{"x":1915,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile219.png":{"frame":{"x":1926,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile221.png":{"frame":{"x":1937,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile222.png":{"frame":{"x":1948,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile223.png":{"frame":{"x":1959,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile224.png":{"frame":{"x":1970,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile225.png":{"frame":{"x":1981,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile226.png":{"frame":{"x":1992,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile227.png":{"frame":{"x":2003,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile228.png":{"frame":{"x":2014,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile229.png":{"frame":{"x":2025,"y":1,"w":7,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":7,"h":7},"sourceSize":{"w":7,"h":7}},"tile230.png":{"frame":{"x":2035,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile231.png":{"frame":{"x":2047,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile232.png":{"frame":{"x":2058,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile233.png":{"frame":{"x":2069,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile234.png":{"frame":{"x":2080,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile235.png":{"frame":{"x":2091,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile236.png":{"frame":{"x":2102,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}}}}'''
+pngdata=b'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aHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICB4bWxuczpHSU1QPSJodHRwOi8vd3d3LmdpbXAub3JnL3htcC8iCiAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgIHhtbG5zOnhtcD0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLyIKICAgeG1wTU06RG9jdW1lbnRJRD0iZ2ltcDpkb2NpZDpnaW1wOmFiODkzNzczLWMwZTQtNDI1ZS05MTU4LWE4MWI0NDY1ZTU1MyIKICAgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDowM2I1OWZhMC01MjE4LTQ4NjMtODgyYi0yZWVhNWU4MTlmMmQiCiAgIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo4NzdiNjVkOC1mODZhLTQ3OGEtOWQ1Ny05NWM3YWYwZjhkMDUiCiAgIGRjOkZvcm1hdD0iaW1hZ2UvcG5nIgogICBHSU1QOkFQST0iMi4wIgogICBHSU1QOlBsYXRmb3JtPSJXaW5kb3dzIgogICBHSU1QOlRpbWVTdGFtcD0iMTY1OTI2MTU5MzM2NDIxMSIKICAgR0lNUDpWZXJzaW9uPSIyLjEwLjMwIgogICB0aWZmOk9yaWVudGF0aW9uPSIxIgogICB4bXA6Q3JlYXRvclRvb2w9IkdJTVAgMi4xMCI+CiAgIDx4bXBNTTpIaXN0b3J5PgogICAgPHJkZjpTZXE+CiAgICAgPHJkZjpsaQogICAgICBzdEV2dDphY3Rpb249InNhdmVkIgogICAgICBzdEV2dDpjaGFuZ2VkPSIvIgogICAgICBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjFlNGI3ZWFkLWNhZTQtNDYxYy04ODBmLTE5MjEwODM2NDU1YSIKICAgICAgc3RFdnQ6c29mdHdhcmVBZ2VudD0iR2ltcCAyLjEwIChXaW5kb3dzKSIKICAgICAgc3RFdnQ6d2hlbj0iMjAyMi0wNy0zMVQxMDo1NDowNyIvPgogICAgIDxyZGY6bGkKICAgICAgc3RFdnQ6YWN0aW9uPSJzYXZlZCIKICAgICAgc3RFdnQ6Y2hhbmdlZD0iLyIKICAgICAgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDpmN2NjZWRiYS0wOWI5LTQzZDctYWFmMC0wYzhmZDY2YjkzMWYiCiAgICAgIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkdpbXAgMi4xMCAoV2luZG93cykiCiAgICAgIHN0RXZ0OndoZW49IjIwMjItMDctMzFUMTE6NTk6NTMiLz4KICAgIDwvcmRmOlNlcT4KICAgPC94bXBNTTpIaXN0b3J5PgogIDwvcmRmOkRlc2NyaXB0aW9uPgogPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+km841wAAAAZiS0dEAP8AAAAAMyd88wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB+YHHwk7NdND2XIAAAkiSURBVHja7V3bkqQ6DKO35r97+stnX05XMRyaSMIiCSs97cUdjOP4FpM8fpblZwmCIAiCIAiCIAiCIAiCIAiCIAiCIAiCIJgYX8uyLN/P569//H69Pv7gsSzL8/k8pNnSvl6v5m+2PBzx8qZ9j3vEMzvuekyUtiULhvYts9Y8qDJjaJE5ZnRHGRfVndd//4/oAzMXb7TGZWgZ/WXHReXw2Pz9SB6KfBk5MPrg0kmEnh13LQeEh9eGZm2H3r9X55iZtxbP6rpgxmV0Ehn3CdoTxr+pdh3lAdG1Le3R2AwPe/L9xMdZPXONi+rZEf2ZeUPnYo2935wZt0XLrk1W15F4Eh13z29WxDsMv4y/YNax6oeQdcyOq8brlfbMaX+reTj8/9UYZ2KNEWgZfUBySDXHccmhMndy8Yvou5KjMzEtktNfJd8qOaj1h1ZscsYP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'
+jsondata='''{"meta":{"app":"http://www.codeandweb.com/texturepacker","version":"1.0","image":"capello-ft.png","format":"RGBA8888","size":{"w":2112,"h":11},"scale":"1"},"frames":{"tile000.png":{"frame":{"x":1,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":1,"y":1,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile001.png":{"frame":{"x":12,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":12,"y":1,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile002.png":{"frame":{"x":23,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile003.png":{"frame":{"x":34,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile004.png":{"frame":{"x":45,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile005.png":{"frame":{"x":56,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile006.png":{"frame":{"x":67,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile007.png":{"frame":{"x":78,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile008.png":{"frame":{"x":89,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile009.png":{"frame":{"x":100,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile010.png":{"frame":{"x":111,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile011.png":{"frame":{"x":122,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile012.png":{"frame":{"x":133,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile013.png":{"frame":{"x":144,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile014.png":{"frame":{"x":155,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile015.png":{"frame":{"x":166,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile017.png":{"frame":{"x":177,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile018.png":{"frame":{"x":188,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile019.png":{"frame":{"x":199,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile020.png":{"frame":{"x":210,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile021.png":{"frame":{"x":221,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile022.png":{"frame":{"x":232,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile023.png":{"frame":{"x":243,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile024.png":{"frame":{"x":254,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile025.png":{"frame":{"x":265,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile026.png":{"frame":{"x":276,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile027.png":{"frame":{"x":287,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile028.png":{"frame":{"x":298,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile029.png":{"frame":{"x":309,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile030.png":{"frame":{"x":320,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile031.png":{"frame":{"x":331,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile032.png":{"frame":{"x":342,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile034.png":{"frame":{"x":353,"y":1,"w":9,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":9,"h":7},"sourceSize":{"w":9,"h":7}},"tile035.png":{"frame":{"x":364,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile036.png":{"frame":{"x":375,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile037.png":{"frame":{"x":386,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile038.png":{"frame":{"x":397,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile039.png":{"frame":{"x":408,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile040.png":{"frame":{"x":419,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile041.png":{"frame":{"x":430,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile042.png":{"frame":{"x":441,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile043.png":{"frame":{"x":452,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile044.png":{"frame":{"x":463,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile045.png":{"frame":{"x":474,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile046.png":{"frame":{"x":485,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile047.png":{"frame":{"x":496,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile048.png":{"frame":{"x":507,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile049.png":{"frame":{"x":518,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile051.png":{"frame":{"x":529,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile052.png":{"frame":{"x":540,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile053.png":{"frame":{"x":551,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile054.png":{"frame":{"x":562,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile055.png":{"frame":{"x":573,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile056.png":{"frame":{"x":584,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile057.png":{"frame":{"x":595,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile058.png":{"frame":{"x":606,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile059.png":{"frame":{"x":617,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile060.png":{"frame":{"x":628,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile061.png":{"frame":{"x":639,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile062.png":{"frame":{"x":650,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile063.png":{"frame":{"x":661,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile064.png":{"frame":{"x":672,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile065.png":{"frame":{"x":683,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile066.png":{"frame":{"x":694,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile068.png":{"frame":{"x":705,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile069.png":{"frame":{"x":716,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile070.png":{"frame":{"x":727,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile071.png":{"frame":{"x":738,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile072.png":{"frame":{"x":749,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile073.png":{"frame":{"x":760,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile074.png":{"frame":{"x":771,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile075.png":{"frame":{"x":782,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile076.png":{"frame":{"x":793,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile077.png":{"frame":{"x":804,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile078.png":{"frame":{"x":815,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile079.png":{"frame":{"x":826,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile080.png":{"frame":{"x":837,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile081.png":{"frame":{"x":848,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile082.png":{"frame":{"x":859,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile083.png":{"frame":{"x":870,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile085.png":{"frame":{"x":881,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile086.png":{"frame":{"x":892,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile087.png":{"frame":{"x":903,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile088.png":{"frame":{"x":914,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile089.png":{"frame":{"x":925,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile090.png":{"frame":{"x":936,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile091.png":{"frame":{"x":947,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile092.png":{"frame":{"x":958,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile093.png":{"frame":{"x":969,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile094.png":{"frame":{"x":980,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile095.png":{"frame":{"x":991,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile096.png":{"frame":{"x":1002,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile097.png":{"frame":{"x":1013,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile098.png":{"frame":{"x":1024,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile099.png":{"frame":{"x":1035,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile100.png":{"frame":{"x":1045,"y":1,"w":11,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":11,"h":7},"sourceSize":{"w":11,"h":7}},"tile123.png":{"frame":{"x":1057,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile136.png":{"frame":{"x":1068,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile137.png":{"frame":{"x":1079,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile138.png":{"frame":{"x":1090,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile139.png":{"frame":{"x":1101,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile140.png":{"frame":{"x":1112,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile141.png":{"frame":{"x":1123,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile142.png":{"frame":{"x":1134,"y":1,"w":2,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":2,"h":7},"sourceSize":{"w":2,"h":7}},"tile143.png":{"frame":{"x":1145,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile144.png":{"frame":{"x":1156,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile145.png":{"frame":{"x":1167,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile146.png":{"frame":{"x":1177,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile147.png":{"frame":{"x":1189,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile148.png":{"frame":{"x":1200,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile150.png":{"frame":{"x":1211,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile151.png":{"frame":{"x":1222,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile153.png":{"frame":{"x":1233,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile154.png":{"frame":{"x":1244,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile155.png":{"frame":{"x":1255,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile156.png":{"frame":{"x":1266,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile157.png":{"frame":{"x":1277,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile158.png":{"frame":{"x":1288,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile159.png":{"frame":{"x":1299,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile160.png":{"frame":{"x":1310,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile161.png":{"frame":{"x":1321,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile162.png":{"frame":{"x":1332,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile163.png":{"frame":{"x":1342,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile164.png":{"frame":{"x":1354,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile165.png":{"frame":{"x":1365,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile166.png":{"frame":{"x":1376,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile167.png":{"frame":{"x":1387,"y":1,"w":8,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":8,"h":7},"sourceSize":{"w":8,"h":7}},"tile168.png":{"frame":{"x":1398,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile170.png":{"frame":{"x":1409,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile171.png":{"frame":{"x":1420,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile172.png":{"frame":{"x":1431,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile173.png":{"frame":{"x":1442,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile174.png":{"frame":{"x":1453,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile175.png":{"frame":{"x":1464,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile176.png":{"frame":{"x":1475,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile177.png":{"frame":{"x":1486,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile178.png":{"frame":{"x":1497,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile179.png":{"frame":{"x":1507,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile180.png":{"frame":{"x":1519,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile181.png":{"frame":{"x":1530,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile182.png":{"frame":{"x":1541,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile183.png":{"frame":{"x":1552,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile184.png":{"frame":{"x":1563,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile185.png":{"frame":{"x":1574,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile187.png":{"frame":{"x":1585,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile188.png":{"frame":{"x":1596,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile189.png":{"frame":{"x":1607,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile190.png":{"frame":{"x":1618,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile191.png":{"frame":{"x":1629,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile192.png":{"frame":{"x":1640,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile193.png":{"frame":{"x":1651,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile194.png":{"frame":{"x":1662,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile195.png":{"frame":{"x":1673,"y":1,"w":7,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":7,"h":7},"sourceSize":{"w":7,"h":7}},"tile196.png":{"frame":{"x":1683,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile197.png":{"frame":{"x":1695,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile198.png":{"frame":{"x":1706,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile199.png":{"frame":{"x":1717,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile200.png":{"frame":{"x":1728,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile201.png":{"frame":{"x":1739,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile202.png":{"frame":{"x":1750,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile204.png":{"frame":{"x":1761,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile205.png":{"frame":{"x":1772,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile206.png":{"frame":{"x":1783,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile207.png":{"frame":{"x":1794,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile208.png":{"frame":{"x":1805,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile209.png":{"frame":{"x":1816,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile210.png":{"frame":{"x":1827,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile211.png":{"frame":{"x":1838,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile212.png":{"frame":{"x":1849,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile213.png":{"frame":{"x":1859,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile214.png":{"frame":{"x":1871,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile215.png":{"frame":{"x":1882,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile216.png":{"frame":{"x":1893,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile217.png":{"frame":{"x":1904,"y":1,"w":3,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":3,"h":7},"sourceSize":{"w":3,"h":7}},"tile218.png":{"frame":{"x":1915,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile219.png":{"frame":{"x":1926,"y":1,"w":4,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":4,"h":7},"sourceSize":{"w":4,"h":7}},"tile221.png":{"frame":{"x":1937,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile222.png":{"frame":{"x":1948,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile223.png":{"frame":{"x":1959,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile224.png":{"frame":{"x":1970,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile225.png":{"frame":{"x":1981,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile226.png":{"frame":{"x":1992,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile227.png":{"frame":{"x":2003,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile228.png":{"frame":{"x":2014,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}},"tile229.png":{"frame":{"x":2025,"y":1,"w":7,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":7,"h":7},"sourceSize":{"w":7,"h":7}},"tile230.png":{"frame":{"x":2035,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile231.png":{"frame":{"x":2047,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile232.png":{"frame":{"x":2058,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile233.png":{"frame":{"x":2069,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile234.png":{"frame":{"x":2080,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile235.png":{"frame":{"x":2091,"y":1,"w":5,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":5,"h":7},"sourceSize":{"w":5,"h":7}},"tile236.png":{"frame":{"x":2102,"y":1,"w":6,"h":7},"rotated":false,"trimmed":false,"spriteSourceSize":{"x":0,"y":0,"w":6,"h":7},"sourceSize":{"w":6,"h":7}}}}'''
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/compo/vscreen.py` & `pyved-engine-23.6a1/src/pyved_engine/compo/vscreen.py`

 * *Ordering differences only*

 * *Files 8% similar despite different names*

```diff
@@ -1,88 +1,88 @@
-from ..foundation import defs
-
-
-_vsurface = None
-_vsurface_required = True
-
-cached_pygame_mod = None  # init from outside when one calls kengi.bootstrap_e
-special_flip = 0  # flag, set it to 1 when using web ctx
-screen = None
-stored_upscaling = 1
-defacto_upscaling = None
-
-# hopefully i will be able to simplify this:
-ctx_emuvram = None
-canvas_emuvram = None
-canvas_rendering = None
-real_pygamescreen = None
-screen_rank = 1  # so we can detect whenever its required to update the var in the PAINT engine event
-
-
-def set_upscaling(new_upscal_val):
-    global stored_upscaling, _vsurface_required
-    if stored_upscaling is not None:
-        if int(stored_upscaling) != new_upscal_val:
-            stored_upscaling = int(new_upscal_val)
-            _vsurface_required = True
-
-
-def flip():
-    global _vsurface_required, _vsurface
-    if _vsurface_required:
-        # TODO
-        pass
-
-    if not special_flip:  # flag can be off if the extra blit/transform has to disabled (web ctx)
-        realscreen = cached_pygame_mod.display.get_surface()
-        if 1 == stored_upscaling:
-            realscreen.blit(screen, (0, 0))
-        else:
-            cached_pygame_mod.transform.scale(screen, defs.STD_SCR_SIZE, realscreen)
-
-    cached_pygame_mod.display.update()
-
-
-# ------------------------------------
-#   old code
-# ------------------------------------
-_curr_state = None
-_loaded_states = dict()
-init2_done = False
-state_stack = None
-
-
-def conv_to_vscreen(x, y):
-    return int(x / defacto_upscaling), int(y / defacto_upscaling)
-
-
-# def set_canvas_rendering(jsobj):
-#     shared.canvas_rendering = jsobj
-#
-#
-# def set_canvas_emu_vram(jsobj):
-#     shared.canvas_emuvram = jsobj
-#     shared.ctx_emuvram = jsobj.getContext('2d')
-
-
-def set_realpygame_screen(ref_surf):
-    global real_pygamescreen
-    if real_pygamescreen:
-        print('warning: set_realpygame_scneen called a 2nd time. Ignoring request')
-        return
-    real_pygamescreen = ref_surf
-
-
-def set_virtual_screen(ref_surface):
-    global screen, screen_rank, defacto_upscaling
-    screen = ref_surface
-    w = screen.get_size()[0]
-    defacto_upscaling = 960/w
-    screen_rank += 1
-
-
-def get_screen():
-    return screen
-
-
-def proj_to_vscreen(org_screen_pos):
-    return conv_to_vscreen(*org_screen_pos)
+from ..foundation import defs
+
+
+_vsurface = None
+_vsurface_required = True
+
+cached_pygame_mod = None  # init from outside when one calls kengi.bootstrap_e
+special_flip = 0  # flag, set it to 1 when using web ctx
+screen = None
+stored_upscaling = 1
+defacto_upscaling = None
+
+# hopefully i will be able to simplify this:
+ctx_emuvram = None
+canvas_emuvram = None
+canvas_rendering = None
+real_pygamescreen = None
+screen_rank = 1  # so we can detect whenever its required to update the var in the PAINT engine event
+
+
+def set_upscaling(new_upscal_val):
+    global stored_upscaling, _vsurface_required
+    if stored_upscaling is not None:
+        if int(stored_upscaling) != new_upscal_val:
+            stored_upscaling = int(new_upscal_val)
+            _vsurface_required = True
+
+
+def flip():
+    global _vsurface_required, _vsurface
+    if _vsurface_required:
+        # TODO
+        pass
+
+    if not special_flip:  # flag can be off if the extra blit/transform has to disabled (web ctx)
+        realscreen = cached_pygame_mod.display.get_surface()
+        if 1 == stored_upscaling:
+            realscreen.blit(screen, (0, 0))
+        else:
+            cached_pygame_mod.transform.scale(screen, defs.STD_SCR_SIZE, realscreen)
+
+    cached_pygame_mod.display.update()
+
+
+# ------------------------------------
+#   old code
+# ------------------------------------
+_curr_state = None
+_loaded_states = dict()
+init2_done = False
+state_stack = None
+
+
+def conv_to_vscreen(x, y):
+    return int(x / defacto_upscaling), int(y / defacto_upscaling)
+
+
+# def set_canvas_rendering(jsobj):
+#     shared.canvas_rendering = jsobj
+#
+#
+# def set_canvas_emu_vram(jsobj):
+#     shared.canvas_emuvram = jsobj
+#     shared.ctx_emuvram = jsobj.getContext('2d')
+
+
+def set_realpygame_screen(ref_surf):
+    global real_pygamescreen
+    if real_pygamescreen:
+        print('warning: set_realpygame_scneen called a 2nd time. Ignoring request')
+        return
+    real_pygamescreen = ref_surf
+
+
+def set_virtual_screen(ref_surface):
+    global screen, screen_rank, defacto_upscaling
+    screen = ref_surface
+    w = screen.get_size()[0]
+    defacto_upscaling = 960/w
+    screen_rank += 1
+
+
+def get_screen():
+    return screen
+
+
+def proj_to_vscreen(org_screen_pos):
+    return conv_to_vscreen(*org_screen_pos)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/foundation/defs.py` & `pyved-engine-23.6a1/src/pyved_engine/foundation/defs.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,230 +1,230 @@
-"""
-code (c) 2018-2022, by Thomas Iwaszko
-contact - tom@kata.games
-
-That file contains everything that's needed to implement
-kengi.event... That is:
-
-  - to_camelcase, and to_snakecase
-  - (classes) CircularBuffer, EnumSeed, PseudoEnum, Singleton
-  - EngineEvTypes (the enum)
-
-"""
-import re
-from collections import deque
-
-
-# DECLARE CONSTANTS
-# in regard to display options, within KENGI there are only 4 canonical modes for display:
-#  three that are displayed in a 960 x 720 -pixel canvas
-# 'super_retro' (upscaling x3), 'old_school', (upscaling x2), 'hd' (no upscaling)
-# one that is displayed in a user-defined size canvas and also uses a pixel-to-pixel mapping just like the 'hd' option
-
-STD_SCR_SIZE = (960, 720)
-
-# USEREVENT = 32850  # pygame userevent 2.1.1
-# FIRST_ENGIN_TYPE = USEREVENT + 1
-# FIRST_CUSTO_TYPE = FIRST_ENGIN_TYPE + 20  # therefore, 20 is the maximal amount of engine events
-
-
-def to_camelcase(str_with_underscore):
-    words = [word.capitalize() for word in str_with_underscore.split('_')]
-    return "".join(words)
-
-
-def to_snakecase(gname):
-    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', gname)
-    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
-
-
-class _CustomIter:
-    """
-    to make PseudoEnum instances -iterable-
-    """
-
-    def __init__(self, ref_penum):
-        self._ref = ref_penum
-        self._curr_idx = 0
-
-    def __iter__(self):
-        return self
-
-    def __next__(self):
-        if self._curr_idx >= self._ref.size:
-            raise StopIteration
-        else:
-            idx = self._ref.order[self._curr_idx]
-            self._curr_idx += 1
-            return self._ref.content[idx]
-
-
-def _enum_seed_implem(gt, c0):
-    return {i: ename for (i, ename) in zip(gt, range(c0, c0 + len(gt)))}
-
-
-class CircularBuffer:
-
-    def __init__(self, gmax_len=128):
-        """
-        Initialize the CircularBuffer with a gmax_len if given. Default size is 128
-        """
-        self.deque_obj = deque(maxlen=gmax_len)
-
-    def __str__(self):
-        """Return a formatted string representation of this CircularBuffer."""
-        items = ['{!r}'.format(item) for item in self.deque_obj]
-        return '[' + ', '.join(items) + ']'
-
-    def get_size(self):
-        return len(self.deque_obj)
-
-    def is_empty(self):
-        """Return True if the head of the CircularBuffer is equal to the tail,
-        otherwise return False"""
-        return len(self.deque_obj) == 0
-
-    def is_full(self):
-        """Return True if the tail of the CircularBuffer is one before the head,
-        otherwise return False"""
-        return len(self.deque_obj) == self.deque_obj.maxlen
-
-    def enqueue(self, item):
-        """Insert an item at the back of the CircularBuffer
-        Runtime: O(1) Space: O(1)"""
-        self.deque_obj.append(item)
-
-    def dequeue(self):
-        """Return the item at the front of the Circular Buffer and remove it
-        Runtime: O(1) Space: O(1)"""
-        return self.deque_obj.popleft()
-
-    def front(self):
-        """Return the item at the front of the CircularBuffer
-        Runtime: O(1) Space: O(1)"""
-        if len(self.deque_obj):
-            return self.deque_obj[len(self.deque_obj) - 1]
-        raise IndexError('circular buffer is currently empty!')
-
-
-# set an alias to define a "fake" class
-EnumSeed = _enum_seed_implem
-
-
-class PseudoEnum:
-    def __init__(self, given_str_iterable, enumcode0=0):
-        self._order = tuple(given_str_iterable)
-        self._size = len(self._order)
-
-        self._first = enumcode0
-        self.content = EnumSeed(given_str_iterable, enumcode0)  # name to code
-        print(self.content)
-        self.inv_map = {v: k for k, v in self.content.items()}  # code to name
-
-        tmp_omega = list()
-        tmp_names_pep8f = list()
-        for k in self._order:
-            tmp_omega.append(self.content[k])
-            tmp_names_pep8f.append(to_snakecase(k))
-        self.omega = tuple(tmp_omega)
-        self._names_pep8f = tuple(tmp_names_pep8f)
-
-    def __getattr__(self, name):
-        if name in self.content:
-            return self.content[name]
-        raise AttributeError("object has no attribute '{}'".format(name))
-
-    @property
-    def underscored_names(self):
-        return self._names_pep8f
-
-    @property
-    def first(self):
-        return self._first
-
-    @property
-    def order(self):
-        return self._order
-
-    @property
-    def size(self):
-        return self._size
-
-    def __iter__(self):
-        return _CustomIter(self)
-
-
-class Singleton:
-    """
-    A non-thread-safe helper class to ease implementing singletons. This should be used
-    as a decorator -not a metaclass- to the class that should be a singleton.
-    The decorated class can define one `__init__` function that takes only the `self`
-    argument. Also, the decorated class cannot be inherited from.
-    Other than that, there are no restrictions that apply to the decorated class.
-    To get the singleton instance, use the `instance` method.
-    Trying to use `__call__` will result in a `TypeError` being raised.
-    """
-
-    def __init__(self, decorated):
-        self._decorated = decorated
-        self._instance = None
-
-    def instance(self):
-        if self._instance is None:
-            self._instance = self._decorated()
-        return self._instance
-
-    def __call__(self):
-        err_msg = 'Singletons must be accessed through `instance()`'
-        raise TypeError(err_msg)
-
-    def __instancecheck__(self, inst):
-        return isinstance(inst, self._decorated)
-
-
-# --- declare all engine events ---
-_TRADITIONAL_1ST_ETYPE = 32866+1  # 32866 == pygame.USEREVENT
-
-EngineEvTypes = PseudoEnum((
-    'Quit',
-    'Activation',
-    'FocusGained',
-    'FocusLost',
-    'BasicTextinput',
-
-    'Keydown',
-    'Keyup',
-    'Mousemotion',
-    'Mousedown',
-    'Mouseup',
-
-    'Stickmotion',  # has event.axis; event.value
-    'GamepadDir',
-    'Gamepaddown',
-    'Gamepadup',
-
-    'Update',
-    'Paint',
-
-    'Gamestart',
-    'Gameover',
-    # (used in RPGs like niobepolis, conv<- conversation)
-    'ConvStart',  # contains convo_obj, portrait
-    'ConvFinish',
-    'ConvStep',  # contains value
-
-    'StateChange',  # contains code state_ident
-    'StatePush',  # contains code state_ident
-    'StatePop',
-
-    'RpcReceive',  # two-level reception (->tunelling if we use the json-rpc). Has num and raw_rpc_resp attributes
-    'RpcError',  # contains: code, msg
-
-    'NetwSend',  # [num] un N°identification & [msg] un string (Async network comms)
-    'NetwReceive'  # [num] un N°identification & [msg] un string (Async network comms)
-), _TRADITIONAL_1ST_ETYPE)
-
-
-class KengiEv:
-    def __init__(self, etype, **entries):
-        self.__dict__.update(entries)
-        self.type = etype
+"""
+code (c) 2018-2022, by Thomas Iwaszko
+contact - tom@kata.games
+
+That file contains everything that's needed to implement
+kengi.event... That is:
+
+  - to_camelcase, and to_snakecase
+  - (classes) CircularBuffer, EnumSeed, PseudoEnum, Singleton
+  - EngineEvTypes (the enum)
+
+"""
+import re
+from collections import deque
+
+
+# DECLARE CONSTANTS
+# in regard to display options, within KENGI there are only 4 canonical modes for display:
+#  three that are displayed in a 960 x 720 -pixel canvas
+# 'super_retro' (upscaling x3), 'old_school', (upscaling x2), 'hd' (no upscaling)
+# one that is displayed in a user-defined size canvas and also uses a pixel-to-pixel mapping just like the 'hd' option
+
+STD_SCR_SIZE = (960, 720)
+
+# USEREVENT = 32850  # pygame userevent 2.1.1
+# FIRST_ENGIN_TYPE = USEREVENT + 1
+# FIRST_CUSTO_TYPE = FIRST_ENGIN_TYPE + 20  # therefore, 20 is the maximal amount of engine events
+
+
+def to_camelcase(str_with_underscore):
+    words = [word.capitalize() for word in str_with_underscore.split('_')]
+    return "".join(words)
+
+
+def to_snakecase(gname):
+    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', gname)
+    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()
+
+
+class _CustomIter:
+    """
+    to make PseudoEnum instances -iterable-
+    """
+
+    def __init__(self, ref_penum):
+        self._ref = ref_penum
+        self._curr_idx = 0
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        if self._curr_idx >= self._ref.size:
+            raise StopIteration
+        else:
+            idx = self._ref.order[self._curr_idx]
+            self._curr_idx += 1
+            return self._ref.content[idx]
+
+
+def _enum_seed_implem(gt, c0):
+    return {i: ename for (i, ename) in zip(gt, range(c0, c0 + len(gt)))}
+
+
+class CircularBuffer:
+
+    def __init__(self, gmax_len=128):
+        """
+        Initialize the CircularBuffer with a gmax_len if given. Default size is 128
+        """
+        self.deque_obj = deque(maxlen=gmax_len)
+
+    def __str__(self):
+        """Return a formatted string representation of this CircularBuffer."""
+        items = ['{!r}'.format(item) for item in self.deque_obj]
+        return '[' + ', '.join(items) + ']'
+
+    def get_size(self):
+        return len(self.deque_obj)
+
+    def is_empty(self):
+        """Return True if the head of the CircularBuffer is equal to the tail,
+        otherwise return False"""
+        return len(self.deque_obj) == 0
+
+    def is_full(self):
+        """Return True if the tail of the CircularBuffer is one before the head,
+        otherwise return False"""
+        return len(self.deque_obj) == self.deque_obj.maxlen
+
+    def enqueue(self, item):
+        """Insert an item at the back of the CircularBuffer
+        Runtime: O(1) Space: O(1)"""
+        self.deque_obj.append(item)
+
+    def dequeue(self):
+        """Return the item at the front of the Circular Buffer and remove it
+        Runtime: O(1) Space: O(1)"""
+        return self.deque_obj.popleft()
+
+    def front(self):
+        """Return the item at the front of the CircularBuffer
+        Runtime: O(1) Space: O(1)"""
+        if len(self.deque_obj):
+            return self.deque_obj[len(self.deque_obj) - 1]
+        raise IndexError('circular buffer is currently empty!')
+
+
+# set an alias to define a "fake" class
+EnumSeed = _enum_seed_implem
+
+
+class PseudoEnum:
+    def __init__(self, given_str_iterable, enumcode0=0):
+        self._order = tuple(given_str_iterable)
+        self._size = len(self._order)
+
+        self._first = enumcode0
+        self.content = EnumSeed(given_str_iterable, enumcode0)  # name to code
+        print(self.content)
+        self.inv_map = {v: k for k, v in self.content.items()}  # code to name
+
+        tmp_omega = list()
+        tmp_names_pep8f = list()
+        for k in self._order:
+            tmp_omega.append(self.content[k])
+            tmp_names_pep8f.append(to_snakecase(k))
+        self.omega = tuple(tmp_omega)
+        self._names_pep8f = tuple(tmp_names_pep8f)
+
+    def __getattr__(self, name):
+        if name in self.content:
+            return self.content[name]
+        raise AttributeError("object has no attribute '{}'".format(name))
+
+    @property
+    def underscored_names(self):
+        return self._names_pep8f
+
+    @property
+    def first(self):
+        return self._first
+
+    @property
+    def order(self):
+        return self._order
+
+    @property
+    def size(self):
+        return self._size
+
+    def __iter__(self):
+        return _CustomIter(self)
+
+
+class Singleton:
+    """
+    A non-thread-safe helper class to ease implementing singletons. This should be used
+    as a decorator -not a metaclass- to the class that should be a singleton.
+    The decorated class can define one `__init__` function that takes only the `self`
+    argument. Also, the decorated class cannot be inherited from.
+    Other than that, there are no restrictions that apply to the decorated class.
+    To get the singleton instance, use the `instance` method.
+    Trying to use `__call__` will result in a `TypeError` being raised.
+    """
+
+    def __init__(self, decorated):
+        self._decorated = decorated
+        self._instance = None
+
+    def instance(self):
+        if self._instance is None:
+            self._instance = self._decorated()
+        return self._instance
+
+    def __call__(self):
+        err_msg = 'Singletons must be accessed through `instance()`'
+        raise TypeError(err_msg)
+
+    def __instancecheck__(self, inst):
+        return isinstance(inst, self._decorated)
+
+
+# --- declare all engine events ---
+_TRADITIONAL_1ST_ETYPE = 32866+1  # 32866 == pygame.USEREVENT
+
+EngineEvTypes = PseudoEnum((
+    'Quit',
+    'Activation',
+    'FocusGained',
+    'FocusLost',
+    'BasicTextinput',
+
+    'Keydown',
+    'Keyup',
+    'Mousemotion',
+    'Mousedown',
+    'Mouseup',
+
+    'Stickmotion',  # has event.axis; event.value
+    'GamepadDir',
+    'Gamepaddown',
+    'Gamepadup',
+
+    'Update',
+    'Paint',
+
+    'Gamestart',
+    'Gameover',
+    # (used in RPGs like niobepolis, conv<- conversation)
+    'ConvStart',  # contains convo_obj, portrait
+    'ConvFinish',
+    'ConvStep',  # contains value
+
+    'StateChange',  # contains code state_ident
+    'StatePush',  # contains code state_ident
+    'StatePop',
+
+    'RpcReceive',  # two-level reception (->tunelling if we use the json-rpc). Has num and raw_rpc_resp attributes
+    'RpcError',  # contains: code, msg
+
+    'NetwSend',  # [num] un N°identification & [msg] un string (Async network comms)
+    'NetwReceive'  # [num] un N°identification & [msg] un string (Async network comms)
+), _TRADITIONAL_1ST_ETYPE)
+
+
+class KengiEv:
+    def __init__(self, etype, **entries):
+        self.__dict__.update(entries)
+        self.type = etype
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/foundation/interfaces.py` & `pyved-engine-23.6a1/src/pyved_engine/foundation/interfaces.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,70 +1,70 @@
-"""
-code (c) 2018-2022, by Thomas Iwaszko
-contact - tom@kata.games
-
-TL;DR - KENGI does not use 100% of pygame capabilities. How much of pygame do we use?
-
-More precisely: this file is here so I can:
-(A) specify (for this I propose an informal interface) a SUBSET of pygame
-
-(B) offer a formal interface for the so-called "PRIMAL backend". Such a backend can
-be implemented in various ways. Interestingly, one possible way is to use a SUBSET of pygame.
-Since I consider that it wouldn't be great to use a subset of pygame without "exposing" it
-to the end-user too (pygame is a nice tool, after all)
-it is decided that the subset used is equal to the one I specified in A.
-
-Having a formal interface is important as it enables me to "plug" into a different system/
-another software environment. Components like KENGI, the KataSDK, etc. need to be
-adaptive because at the end of the day, we wish to execute games in a browser.
-"""
-
-from abc import abstractmethod, ABCMeta
-
-
-class BaseKenBackend(metaclass=ABCMeta):
-    @abstractmethod
-    def fetch_kengi_events(self):
-        raise NotImplementedError
-
-    @abstractmethod
-    def joystick_init(self, idj):
-        raise NotImplementedError
-
-    @abstractmethod
-    def joystick_info(self, idj):
-        raise NotImplementedError
-
-    @abstractmethod
-    def joystick_count(self):
-        raise NotImplementedError
-
-
-class _pygameDrawIface:
-
-    @staticmethod
-    def circle(surface, color, pos, radius):
-        pass
-
-    @staticmethod
-    def rect(surface, bidule):
-        pass
-
-
-class _pygameMathIface:
-
-    def Vector2(self, **args):
-        pass
-
-
-class PygameIface:
-
-    draw = _pygameDrawIface
-    math = _pygameMathIface
-
-    KEYDOWN = -1
-    KEYUP = 2
-    K_LEFT = 3
-
-    @staticmethod
-    def Color(rgb):
-        pass
+"""
+code (c) 2018-2022, by Thomas Iwaszko
+contact - tom@kata.games
+
+TL;DR - KENGI does not use 100% of pygame capabilities. How much of pygame do we use?
+
+More precisely: this file is here so I can:
+(A) specify (for this I propose an informal interface) a SUBSET of pygame
+
+(B) offer a formal interface for the so-called "PRIMAL backend". Such a backend can
+be implemented in various ways. Interestingly, one possible way is to use a SUBSET of pygame.
+Since I consider that it wouldn't be great to use a subset of pygame without "exposing" it
+to the end-user too (pygame is a nice tool, after all)
+it is decided that the subset used is equal to the one I specified in A.
+
+Having a formal interface is important as it enables me to "plug" into a different system/
+another software environment. Components like KENGI, the KataSDK, etc. need to be
+adaptive because at the end of the day, we wish to execute games in a browser.
+"""
+
+from abc import abstractmethod, ABCMeta
+
+
+class BaseKenBackend(metaclass=ABCMeta):
+    @abstractmethod
+    def fetch_kengi_events(self):
+        raise NotImplementedError
+
+    @abstractmethod
+    def joystick_init(self, idj):
+        raise NotImplementedError
+
+    @abstractmethod
+    def joystick_info(self, idj):
+        raise NotImplementedError
+
+    @abstractmethod
+    def joystick_count(self):
+        raise NotImplementedError
+
+
+class _pygameDrawIface:
+
+    @staticmethod
+    def circle(surface, color, pos, radius):
+        pass
+
+    @staticmethod
+    def rect(surface, bidule):
+        pass
+
+
+class _pygameMathIface:
+
+    def Vector2(self, **args):
+        pass
+
+
+class PygameIface:
+
+    draw = _pygameDrawIface
+    math = _pygameMathIface
+
+    KEYDOWN = -1
+    KEYUP = 2
+    K_LEFT = 3
+
+    @staticmethod
+    def Color(rgb):
+        pass
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/foundation/pbackends.py` & `pyved-engine-23.6a1/src/pyved_engine/foundation/pbackends.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,177 +1,177 @@
-from .defs import EngineEvTypes, to_camelcase
-from .interfaces import BaseKenBackend
-from .. import _hub
-
-
-class PygameKenBackend(BaseKenBackend):
-    """
-    Important architecture change:
-    instead of:
-
-                   /-->pygame_API(full)- -+---->pygameSDL
-                 /                       /
-               /                       /
-    kengiCore +----> pygame_API(subset) -----> pygameEm
-
-
-    Tom has chosen:                     /----> web pbackend -----> pygameEm+JS
-                                       /
-    pygame_API(subset) ---> kengiCore +
-                                       \
-                                        \\--> default pbackend ----> pygameSDL
-
-    Main benefits are:
-
-     * expliciting the subset
-     * no more flawed emulation-related errors, if smth runs in local (Imagine that Bob is calling kengi.pygame.*)
-       it should never crash in web ctx
-     * from now on, our own low-level API can differ a lot from pygame's API. Our low-level API is freely defined
-       in the abstract backend/ backend interface
-     * less code coupling. If we ever drop the pygame support/if pygame_API receives heavy patches,
-     it won't become a disaster
-    """
-    static_mapping = {
-        256: EngineEvTypes.Quit,  # pygame.QUIT is 256
-        32787: EngineEvTypes.Quit,  # for pygame2.0.1+ we also have 32787 -> pygame.WINDOWCLOSE
-        771: EngineEvTypes.BasicTextinput,  # pygame.TEXTINPUT
-
-        32768: EngineEvTypes.Activation,  # pygame.ACTIVEEVENT, has "gain" and "state" attributes
-        32783: EngineEvTypes.FocusGained,  # pygame.WINDOWFOCUSGAINED
-        32784: EngineEvTypes.FocusLost,  # pygame.WINDOWFOCUSLOST
-
-        768: EngineEvTypes.Keydown,  # pygame.KEYDOWN
-        769: EngineEvTypes.Keyup,  # pygame.KEYUP
-        1024: EngineEvTypes.Mousemotion,  # pygame.MOUSEMOTION
-        1025: EngineEvTypes.Mousedown,  # pygame.MOUSEBUTTONDOWN
-        1026: EngineEvTypes.Mouseup,  # pygame.MOUSEBUTTONUP
-
-        # gamepad support
-        1536: EngineEvTypes.Stickmotion,  # JOYAXISMOTION:  self.joy[event.joy].axis[event.axis] = event.value
-        1537: None,  # JOYBALLMOTION:  self.joy[event.joy].ball[event.ball] = event.rel
-        1538: EngineEvTypes.GamepadDir,  # JOYHATMOTION:  self.joy[event.joy].hat[event.hat] = event.value
-        1539: EngineEvTypes.Gamepaddown,  # JOYBUTTONDOWN: self.joy[event.joy].button[event.button] = 1
-        1540: EngineEvTypes.Gamepadup,  # JOYBUTTONUP:  self.joy[event.joy].button[event.button] = 0
-    }
-    joypad_events_bounds = [1536, 1540]
-
-    joy_bt_map = {
-        0: 'A',
-        1: 'B',
-        2: 'X',
-        3: 'Y',
-        4: 'lB',
-        5: 'rB',
-        6: 'Back',
-        7: 'Start'
-    }
-    dpad_mapping = {
-        (0, 0): None,
-        (0, 1): 'north',
-        (1, 0): 'east',
-        (0, -1): 'south',
-        (-1, 0): 'west',
-        (1, 1): 'north-east',
-        (-1, 1): 'north-west',
-        (-1, -1): 'south-west',
-        (1, -1): 'south-east'
-    }
-
-    def __init__(self):
-        import pygame as _genuine_pyg
-        _hub.kengi_inj.set('pygame', _genuine_pyg)
-        self._pygame_mod = _hub.kengi_inj['pygame']
-        self.debug_mode = False
-        self._ev_storage = list()
-        self.pyg_jm = None  # model for joystickS
-        self.lstick_val_cache = [0.0, 0.0]
-        self.rstick_val_cache = [0.0, 0.0]
-
-    def joystick_init(self, idj):
-        self.pyg_jm = self._pygame_mod.joystick.Joystick(idj)
-        self.pyg_jm.init()
-
-    def joystick_info(self, idj):
-        return self.pyg_jm.get_name()
-
-    def joystick_count(self):
-        return self._pygame_mod.joystick.get_count()
-
-    def _map_etype2kengi(self, alien_etype):
-        if alien_etype not in self.__class__.static_mapping:
-            if self.debug_mode:  # notify that there's no conversion
-                print('[no conversion] pygame etype=', alien_etype)  # alien_etype.dict)
-        else:
-            if self.joypad_events_bounds[0] <= alien_etype <= self.joypad_events_bounds[1]:
-                pass
-                # for convenient gamepad support, we map pygame JOY* in a more specialized way (xbox360 pad support) 2/2
-                # else:
-            return self.__class__.static_mapping[alien_etype]
-
-    def fetch_kengi_events(self):
-        cst_joyaxismotion = 1536
-        cst_joyballmotion = 1537
-        cst_hatmotion = 1538
-        cst_joydown = 1539
-        cst_joyup = 1540
-
-        raw_pyg_events = self._pygame_mod.event.get()
-        del self._ev_storage[:]
-
-        for pyev in raw_pyg_events:
-            # for convenient gamepad support, we will
-            # map pygame JOY* in a specialized way (xbox360 pad support)
-            if pyev.type == cst_joyaxismotion:
-                if pyev.axis in (0, 1):
-                    self.lstick_val_cache[pyev.axis] = pyev.value
-                    self._ev_storage.append(
-                        (EngineEvTypes.Stickmotion, {'side': 'left', 'pos': tuple(self.lstick_val_cache)})
-                    )
-                elif pyev.axis in (2, 3):
-                    self.rstick_val_cache[-2+pyev.axis] = pyev.value
-                    self._ev_storage.append(
-                        (EngineEvTypes.Stickmotion, {'side': 'right', 'pos': tuple(self.rstick_val_cache)})
-                    )
-                elif pyev.axis == 4:
-                    self._ev_storage.append(
-                        (EngineEvTypes.Gamepaddown, {'button': 'lTrigger', 'value': pyev.value})
-                    )
-                elif pyev.axis == 5:
-                    self._ev_storage.append(
-                        (EngineEvTypes.Gamepaddown, {'button': 'rTrigger', 'value': pyev.value})
-                    )
-
-            elif pyev.type == cst_joyballmotion:
-                # ignore
-                pass
-
-            elif pyev.type == cst_hatmotion:  # joy Dpad has been activated
-                # <Event(1538-JoyHatMotion {'joy': 0, 'instance_id': 0, 'hat': 0, 'value': (0, 0)})>
-                setattr(pyev, 'dir', self.dpad_mapping[pyev.value])  # east, west, etc.
-                tmp = list(pyev.value)
-                if tmp[1] != 0:
-                    tmp[1] *= -1
-                pyev.value = pyev.dict['value'] = tuple(tmp)
-                self._ev_storage.append((self._map_etype2kengi(pyev.type), pyev.dict))
-
-            elif pyev.type == cst_joydown or pyev.type == cst_joyup:  # joybtdown/joybtup
-                pyev.button = self.joy_bt_map[pyev.button]  # change name of the button
-                setattr(pyev, 'value', int(pyev.type == cst_joydown))
-                self._ev_storage.append((self._map_etype2kengi(pyev.type), pyev.dict))
-
-            else:
-                k_event = (self._map_etype2kengi(pyev.type), pyev.dict)
-                self._ev_storage.append(k_event)
-
-        return self._ev_storage
-
-
-def build_primalbackend(pbe_identifier: str):
-    if pbe_identifier == '':  # default
-        return PygameKenBackend()
-
-    else:
-        # it's assumed that (injector entry 'web_pbackend')
-        #  => (module==web_pbackend.py & cls==WebPbackend)
-        # for example
-        inj_e, cls_name = pbe_identifier+'_pbackend', to_camelcase(pbe_identifier+'_pbackend')
-        return getattr(_hub.kengi_inj[inj_e], cls_name)()
+from .defs import EngineEvTypes, to_camelcase
+from .interfaces import BaseKenBackend
+from .. import _hub
+
+
+class PygameKenBackend(BaseKenBackend):
+    """
+    Important architecture change:
+    instead of:
+
+                   /-->pygame_API(full)- -+---->pygameSDL
+                 /                       /
+               /                       /
+    kengiCore +----> pygame_API(subset) -----> pygameEm
+
+
+    Tom has chosen:                     /----> web pbackend -----> pygameEm+JS
+                                       /
+    pygame_API(subset) ---> kengiCore +
+                                       \
+                                        \\--> default pbackend ----> pygameSDL
+
+    Main benefits are:
+
+     * expliciting the subset
+     * no more flawed emulation-related errors, if smth runs in local (Imagine that Bob is calling kengi.pygame.*)
+       it should never crash in web ctx
+     * from now on, our own low-level API can differ a lot from pygame's API. Our low-level API is freely defined
+       in the abstract backend/ backend interface
+     * less code coupling. If we ever drop the pygame support/if pygame_API receives heavy patches,
+     it won't become a disaster
+    """
+    static_mapping = {
+        256: EngineEvTypes.Quit,  # pygame.QUIT is 256
+        32787: EngineEvTypes.Quit,  # for pygame2.0.1+ we also have 32787 -> pygame.WINDOWCLOSE
+        771: EngineEvTypes.BasicTextinput,  # pygame.TEXTINPUT
+
+        32768: EngineEvTypes.Activation,  # pygame.ACTIVEEVENT, has "gain" and "state" attributes
+        32783: EngineEvTypes.FocusGained,  # pygame.WINDOWFOCUSGAINED
+        32784: EngineEvTypes.FocusLost,  # pygame.WINDOWFOCUSLOST
+
+        768: EngineEvTypes.Keydown,  # pygame.KEYDOWN
+        769: EngineEvTypes.Keyup,  # pygame.KEYUP
+        1024: EngineEvTypes.Mousemotion,  # pygame.MOUSEMOTION
+        1025: EngineEvTypes.Mousedown,  # pygame.MOUSEBUTTONDOWN
+        1026: EngineEvTypes.Mouseup,  # pygame.MOUSEBUTTONUP
+
+        # gamepad support
+        1536: EngineEvTypes.Stickmotion,  # JOYAXISMOTION:  self.joy[event.joy].axis[event.axis] = event.value
+        1537: None,  # JOYBALLMOTION:  self.joy[event.joy].ball[event.ball] = event.rel
+        1538: EngineEvTypes.GamepadDir,  # JOYHATMOTION:  self.joy[event.joy].hat[event.hat] = event.value
+        1539: EngineEvTypes.Gamepaddown,  # JOYBUTTONDOWN: self.joy[event.joy].button[event.button] = 1
+        1540: EngineEvTypes.Gamepadup,  # JOYBUTTONUP:  self.joy[event.joy].button[event.button] = 0
+    }
+    joypad_events_bounds = [1536, 1540]
+
+    joy_bt_map = {
+        0: 'A',
+        1: 'B',
+        2: 'X',
+        3: 'Y',
+        4: 'lB',
+        5: 'rB',
+        6: 'Back',
+        7: 'Start'
+    }
+    dpad_mapping = {
+        (0, 0): None,
+        (0, 1): 'north',
+        (1, 0): 'east',
+        (0, -1): 'south',
+        (-1, 0): 'west',
+        (1, 1): 'north-east',
+        (-1, 1): 'north-west',
+        (-1, -1): 'south-west',
+        (1, -1): 'south-east'
+    }
+
+    def __init__(self):
+        import pygame as _genuine_pyg
+        _hub.kengi_inj.set('pygame', _genuine_pyg)
+        self._pygame_mod = _hub.kengi_inj['pygame']
+        self.debug_mode = False
+        self._ev_storage = list()
+        self.pyg_jm = None  # model for joystickS
+        self.lstick_val_cache = [0.0, 0.0]
+        self.rstick_val_cache = [0.0, 0.0]
+
+    def joystick_init(self, idj):
+        self.pyg_jm = self._pygame_mod.joystick.Joystick(idj)
+        self.pyg_jm.init()
+
+    def joystick_info(self, idj):
+        return self.pyg_jm.get_name()
+
+    def joystick_count(self):
+        return self._pygame_mod.joystick.get_count()
+
+    def _map_etype2kengi(self, alien_etype):
+        if alien_etype not in self.__class__.static_mapping:
+            if self.debug_mode:  # notify that there's no conversion
+                print('[no conversion] pygame etype=', alien_etype)  # alien_etype.dict)
+        else:
+            if self.joypad_events_bounds[0] <= alien_etype <= self.joypad_events_bounds[1]:
+                pass
+                # for convenient gamepad support, we map pygame JOY* in a more specialized way (xbox360 pad support) 2/2
+                # else:
+            return self.__class__.static_mapping[alien_etype]
+
+    def fetch_kengi_events(self):
+        cst_joyaxismotion = 1536
+        cst_joyballmotion = 1537
+        cst_hatmotion = 1538
+        cst_joydown = 1539
+        cst_joyup = 1540
+
+        raw_pyg_events = self._pygame_mod.event.get()
+        del self._ev_storage[:]
+
+        for pyev in raw_pyg_events:
+            # for convenient gamepad support, we will
+            # map pygame JOY* in a specialized way (xbox360 pad support)
+            if pyev.type == cst_joyaxismotion:
+                if pyev.axis in (0, 1):
+                    self.lstick_val_cache[pyev.axis] = pyev.value
+                    self._ev_storage.append(
+                        (EngineEvTypes.Stickmotion, {'side': 'left', 'pos': tuple(self.lstick_val_cache)})
+                    )
+                elif pyev.axis in (2, 3):
+                    self.rstick_val_cache[-2+pyev.axis] = pyev.value
+                    self._ev_storage.append(
+                        (EngineEvTypes.Stickmotion, {'side': 'right', 'pos': tuple(self.rstick_val_cache)})
+                    )
+                elif pyev.axis == 4:
+                    self._ev_storage.append(
+                        (EngineEvTypes.Gamepaddown, {'button': 'lTrigger', 'value': pyev.value})
+                    )
+                elif pyev.axis == 5:
+                    self._ev_storage.append(
+                        (EngineEvTypes.Gamepaddown, {'button': 'rTrigger', 'value': pyev.value})
+                    )
+
+            elif pyev.type == cst_joyballmotion:
+                # ignore
+                pass
+
+            elif pyev.type == cst_hatmotion:  # joy Dpad has been activated
+                # <Event(1538-JoyHatMotion {'joy': 0, 'instance_id': 0, 'hat': 0, 'value': (0, 0)})>
+                setattr(pyev, 'dir', self.dpad_mapping[pyev.value])  # east, west, etc.
+                tmp = list(pyev.value)
+                if tmp[1] != 0:
+                    tmp[1] *= -1
+                pyev.value = pyev.dict['value'] = tuple(tmp)
+                self._ev_storage.append((self._map_etype2kengi(pyev.type), pyev.dict))
+
+            elif pyev.type == cst_joydown or pyev.type == cst_joyup:  # joybtdown/joybtup
+                pyev.button = self.joy_bt_map[pyev.button]  # change name of the button
+                setattr(pyev, 'value', int(pyev.type == cst_joydown))
+                self._ev_storage.append((self._map_etype2kengi(pyev.type), pyev.dict))
+
+            else:
+                k_event = (self._map_etype2kengi(pyev.type), pyev.dict)
+                self._ev_storage.append(k_event)
+
+        return self._ev_storage
+
+
+def build_primalbackend(pbe_identifier: str):
+    if pbe_identifier == '':  # default
+        return PygameKenBackend()
+
+    else:
+        # it's assumed that (injector entry 'web_pbackend')
+        #  => (module==web_pbackend.py & cls==WebPbackend)
+        # for example
+        inj_e, cls_name = pbe_identifier+'_pbackend', to_camelcase(pbe_identifier+'_pbackend')
+        return getattr(_hub.kengi_inj[inj_e], cls_name)()
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/ai/FSA_classes_base.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/ai/FSA_classes_base.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,146 +1,146 @@
-
-
-class Transition:
-    '''
-    classe modélisant la transition dun FSA,
-    on suppose que le déclencheur est un mot-clé
-    si le déclencheur est repéré dans les info. reçues,
-    la transition est déclenchée
-    '''
-    
-    def __init__(self, info_decl, label_etat_suiv ):
-        self.declencheur = info_decl
-        self.label_etat_suiv = label_etat_suiv
-
-    def est_declenchee(self, info):
-        if self.declencheur in info:
-            return True
-        return False
-
-    def get_label_etat_suiv(self):
-        return self.label_etat_suiv
-
-
-class Etat:
-    '''
-    classe modélisant un état de FSA,
-    un état peut être initial ou terminal
-    un état exploite des info. reçues pour déclencher ou non ses transitions
-    vers un autre état
-    '''
-
-    def __init__(self, label, li_transitions, est_init=False, est_term=False):
-        self.label = label
-        self.li_transitions = li_transitions
-        self.est_init = est_init
-        self.est_term = est_term
-
-    def exploite_info(self, info):
-        '''retourne le label de l'état suivant OU None,
-        selon qu'une transition est déclenchée OU non'''
-        if self.est_terminal():
-            return None
-        for transition in self.li_transitions:
-            #print( transition.label_etat_suiv )
-            if transition.est_declenchee( info):
-                return transition.get_label_etat_suiv()
-        return None
-        
-    def est_terminal(self):
-        return self.est_term
-
-    def est_initial(self):
-        return self.est_init
-
-    def get_label(self):
-        return self.label
-
-
-class Automate:
-    '''
-    classe modélisant un FSA pour Finite States Automaton
-    concept très utilisé en IA dans les jeux commerciaux,
-    malgré sa simplicité c'est la base du comportement des PNJs
-    '''
-
-    def __init__(self, li_etats):
-        self.etats = dict()
-        for etat in li_etats:
-            self.etats[etat.get_label() ] = etat
-
-        self.reset()
-
-    def entree_info(self, info):
-        '''permet le changement detat '''
-        res = self.get_etat_courant().exploite_info(info)
-        if res!=None:
-            self.label_etat_courant = res
-
-    def get_etat_courant(self):
-        return self.etats[self.label_etat_courant]
-
-    def reset(self):
-        init_st_trouve = False
-        #initialisation de l'etat courant
-        for etat in self.etats.values():
-            if etat.est_initial():
-                if init_st_trouve: #doublon
-                    raise Exception("definition FSA non valide, il ne peut y avoir qu'un état initial")
-                self.label_etat_courant = etat.get_label()
-                init_st_trouve = True
-
-
-
-
-#--- essais definition
-
-s1 =  Etat( 's1', [ Transition( 'hello', 's2') ] , True, False )
-s2 = Etat('s2', [ Transition('news','s4') , Transition('bye','s3') ] )
-s4 = Etat('s4', [Transition('ok','s2')] )
-s3 = Etat('s3', [] , False, True )
-
-fsa_exemple1 = Automate( [s1,s2,s3,s4]  )
-
-
-
-# pour tester, on peut interagir avec le FSA directement dans la console python
-# (dessiner le FSA sur papier pour bien le comprendre )
-# voici la trace de mes propres tests :
-
-
-# >>> fsa_exemple1.getEtatCourant().estInitial()
-# True
-# >>> fsa_exemple1.getEtatCourant().getLabel()
-#'s1'
-
-# >>> fsa_exemple1.entreeInfo('hello')
-# >>> fsa_exemple1.entreeInfo('news')
-# >>> fsa_exemple1.getEtatCourant().getLabel()
-#'s4'
-# >>> fsa_exemple1.entreeInfo('ok')
-# >>> fsa_exemple1.getEtatCourant().getLabel()
-# 's2'
-# >>> fsa_exemple1.entreeInfo('bye')
-# >>> fsa_exemple1.getEtatCourant().getLabel()
-# 's3'
-
-# >>> fsa_exemple1.entreeInfo('hello')
-# >>> fsa_exemple1.entreeInfo('bye')
-# >>> fsa_exemple1.entreeInfo('nimporte quoi')
-# >>> fsa_exemple1.getEtatCourant().getLabel()
-# 's3'
-# >>> fsa_exemple1.getEtatCourant().estTerminal()
-# True
-
-# >>> fsa_exemple1.reset()
-# >>> fsa_exemple1.getEtatCourant().estInitial()
-# True
-
-       
-
-              
-        
-
-    
-
-    
+
+
+class Transition:
+    '''
+    classe modélisant la transition dun FSA,
+    on suppose que le déclencheur est un mot-clé
+    si le déclencheur est repéré dans les info. reçues,
+    la transition est déclenchée
+    '''
+    
+    def __init__(self, info_decl, label_etat_suiv ):
+        self.declencheur = info_decl
+        self.label_etat_suiv = label_etat_suiv
+
+    def est_declenchee(self, info):
+        if self.declencheur in info:
+            return True
+        return False
+
+    def get_label_etat_suiv(self):
+        return self.label_etat_suiv
+
+
+class Etat:
+    '''
+    classe modélisant un état de FSA,
+    un état peut être initial ou terminal
+    un état exploite des info. reçues pour déclencher ou non ses transitions
+    vers un autre état
+    '''
+
+    def __init__(self, label, li_transitions, est_init=False, est_term=False):
+        self.label = label
+        self.li_transitions = li_transitions
+        self.est_init = est_init
+        self.est_term = est_term
+
+    def exploite_info(self, info):
+        '''retourne le label de l'état suivant OU None,
+        selon qu'une transition est déclenchée OU non'''
+        if self.est_terminal():
+            return None
+        for transition in self.li_transitions:
+            #print( transition.label_etat_suiv )
+            if transition.est_declenchee( info):
+                return transition.get_label_etat_suiv()
+        return None
+        
+    def est_terminal(self):
+        return self.est_term
+
+    def est_initial(self):
+        return self.est_init
+
+    def get_label(self):
+        return self.label
+
+
+class Automate:
+    '''
+    classe modélisant un FSA pour Finite States Automaton
+    concept très utilisé en IA dans les jeux commerciaux,
+    malgré sa simplicité c'est la base du comportement des PNJs
+    '''
+
+    def __init__(self, li_etats):
+        self.etats = dict()
+        for etat in li_etats:
+            self.etats[etat.get_label() ] = etat
+
+        self.reset()
+
+    def entree_info(self, info):
+        '''permet le changement detat '''
+        res = self.get_etat_courant().exploite_info(info)
+        if res!=None:
+            self.label_etat_courant = res
+
+    def get_etat_courant(self):
+        return self.etats[self.label_etat_courant]
+
+    def reset(self):
+        init_st_trouve = False
+        #initialisation de l'etat courant
+        for etat in self.etats.values():
+            if etat.est_initial():
+                if init_st_trouve: #doublon
+                    raise Exception("definition FSA non valide, il ne peut y avoir qu'un état initial")
+                self.label_etat_courant = etat.get_label()
+                init_st_trouve = True
+
+
+
+
+#--- essais definition
+
+s1 =  Etat( 's1', [ Transition( 'hello', 's2') ] , True, False )
+s2 = Etat('s2', [ Transition('news','s4') , Transition('bye','s3') ] )
+s4 = Etat('s4', [Transition('ok','s2')] )
+s3 = Etat('s3', [] , False, True )
+
+fsa_exemple1 = Automate( [s1,s2,s3,s4]  )
+
+
+
+# pour tester, on peut interagir avec le FSA directement dans la console python
+# (dessiner le FSA sur papier pour bien le comprendre )
+# voici la trace de mes propres tests :
+
+
+# >>> fsa_exemple1.getEtatCourant().estInitial()
+# True
+# >>> fsa_exemple1.getEtatCourant().getLabel()
+#'s1'
+
+# >>> fsa_exemple1.entreeInfo('hello')
+# >>> fsa_exemple1.entreeInfo('news')
+# >>> fsa_exemple1.getEtatCourant().getLabel()
+#'s4'
+# >>> fsa_exemple1.entreeInfo('ok')
+# >>> fsa_exemple1.getEtatCourant().getLabel()
+# 's2'
+# >>> fsa_exemple1.entreeInfo('bye')
+# >>> fsa_exemple1.getEtatCourant().getLabel()
+# 's3'
+
+# >>> fsa_exemple1.entreeInfo('hello')
+# >>> fsa_exemple1.entreeInfo('bye')
+# >>> fsa_exemple1.entreeInfo('nimporte quoi')
+# >>> fsa_exemple1.getEtatCourant().getLabel()
+# 's3'
+# >>> fsa_exemple1.getEtatCourant().estTerminal()
+# True
+
+# >>> fsa_exemple1.reset()
+# >>> fsa_exemple1.getEtatCourant().estInitial()
+# True
+
+       
+
+              
+        
+
+    
+
+
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/ai/NorrecBrain.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/ai/NorrecBrain.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,113 +1,113 @@
-import random
-
-from .FSA_classes_base import Automate, Etat, Transition
-
-MSG_NEUTRES = [
-    "Qu'est-ce que vous m'racontez bon sang ?",
-    "J'en sais fichtre rien...",
-    "J'vois pas de quoi vous causez, là."
-]
-MSG_BLOCAGE_NEG = [
-    "...",
-    "Les aigles ne volent pas avec les pigeons.",
-    "Peu importe. Z'êtes pas quelqu'un dont les dires m'intéressent.",
-    "Voilà ce qu'on va faire : vous allez là-bas, moi j'reste ici.",
-    "Adieu."
-]
-MSG_BLOCAGE_POS = [
-    "On parle, on parle, concentrons-nous plutôt sur l'action !",
-    "Suis encor' en train de préparer les armes pour notre prochaine quête...",
-    "Ah vous revoilà l'ami !",
-    "Hola ! Revoilà le champion !",
-    "Suis en train de réunir des pièces pour partir à l'aventure avec vous."
-]
-
-
-class NorrecBrain(Automate):
-
-    def __init__(self):
-
-        self.assoc_etat_msg = {
-            'bourru': "Ghhrrn qu'est-ce que c'est... Moi c'est Norrec l'guerrier. J'vous ai déjà vu vous ?",
-            'faux_oui': "Ça m'étonnerait ! **non** serait la réponse appropriée, cessez de **mentir**",
-            'faux_non': "Ça m'étonnerait ! **oui** serait la réponse appropriée, cessez de **mentir**",
-            'suspicieux': "Mentir c'est la pire abomination ! C'est l'attitude reservée aux rats ! Vous êt' d'accord avec moi ?",
-            'neutre': "Par ici on aime pas trop les vagabonds surtout ceux qui se promènent en **armure** comme la vôtre.",
-            'curieux': "Ah c'est sûr que j'en vois pas souvent des comme ça, **oui** remarquez ce doit être **utile**, **non** ?",
-            'demandeur': "Vous dites oui c'est utile ! Comme j'vous comprends. Un bel acier comme ça. J'vous connais pas m'enfin... "
-                         + "Vous parlez comme quelqu'un de vrai. "
-                         + "Vous pouvez peut-être me **renseigner** sur où acheter une telle armure ?",
-            'chaud': "Fantastique ! On dirait bien que je me suis trompé sur vot' compte. "
-                     + "Vous êtes bien brave. Si vous avez besoin de recruter un homme fort, ma hache est à vot' service.",
-            'froid': "Ah, c'est bien ce que j'pensais : une crapule de plus dans not' ville ! Pouah ! (Norrec crache à vos pieds)"
-        }
-
-        # --- définition de 9 états, avec les transitions sortantes respectives
-        et1 = Etat('bourru', [
-            Transition('oui', 'faux_oui'),
-            Transition('non', 'neutre')
-        ], True, False)
-
-        et2 = Etat('faux_oui', [
-            Transition('mentir', 'suspicieux'),
-            Transition('oui', 'neutre')
-        ])
-
-        et3 = Etat('suspicieux', [
-            Transition('oui', 'neutre'),
-            Transition('non', 'froid')
-        ])
-
-        et4 = Etat('froid', [], False, True)
-
-        et5 = Etat('neutre', [
-            Transition('armure', 'curieux')
-        ])
-
-        et6 = Etat('curieux', [
-            Transition('non', 'faux_non'),
-            Transition('utile', 'demandeur'),
-            Transition('oui', 'demandeur')
-        ])
-
-        et7 = Etat('faux_non', [
-            Transition('mentir', 'suspicieux'),
-            Transition('oui', 'demandeur')
-        ])
-
-        et8 = Etat('demandeur', [
-            Transition('non', 'froid'),
-            Transition('oui', 'chaud'),
-            Transition('renseigner', 'chaud')
-        ])
-
-        et9 = Etat('chaud', [], False, True)
-
-        etats_norrec = [et1, et2, et3, et4, et5, et6, et7, et8, et9]
-        super().__init__(etats_norrec)
-
-        self.adhoc_msg = self.assoc_etat_msg[
-            self.get_etat_courant().get_label()
-        ]
-
-    # redéfinition
-    def entree_info(self, info):
-        etat_avant = self.get_etat_courant()
-        super().entree_info(info)
-        nouvel_etat = self.get_etat_courant()
-
-        if nouvel_etat == etat_avant:
-            if etat_avant.est_terminal():
-                if etat_avant.get_label() == 'froid':
-                    self.adhoc_msg = random.choice(MSG_BLOCAGE_NEG)
-                else:
-                    self.adhoc_msg = random.choice(MSG_BLOCAGE_POS)
-                return
-
-            self.adhoc_msg = random.choice(MSG_NEUTRES)
-            return
-
-        self.adhoc_msg = self.assoc_etat_msg[nouvel_etat.get_label()]
-
-    def say_something(self):
-        print(self.adhoc_msg)
+import random
+
+from .FSA_classes_base import Automate, Etat, Transition
+
+MSG_NEUTRES = [
+    "Qu'est-ce que vous m'racontez bon sang ?",
+    "J'en sais fichtre rien...",
+    "J'vois pas de quoi vous causez, là."
+]
+MSG_BLOCAGE_NEG = [
+    "...",
+    "Les aigles ne volent pas avec les pigeons.",
+    "Peu importe. Z'êtes pas quelqu'un dont les dires m'intéressent.",
+    "Voilà ce qu'on va faire : vous allez là-bas, moi j'reste ici.",
+    "Adieu."
+]
+MSG_BLOCAGE_POS = [
+    "On parle, on parle, concentrons-nous plutôt sur l'action !",
+    "Suis encor' en train de préparer les armes pour notre prochaine quête...",
+    "Ah vous revoilà l'ami !",
+    "Hola ! Revoilà le champion !",
+    "Suis en train de réunir des pièces pour partir à l'aventure avec vous."
+]
+
+
+class NorrecBrain(Automate):
+
+    def __init__(self):
+
+        self.assoc_etat_msg = {
+            'bourru': "Ghhrrn qu'est-ce que c'est... Moi c'est Norrec l'guerrier. J'vous ai déjà vu vous ?",
+            'faux_oui': "Ça m'étonnerait ! **non** serait la réponse appropriée, cessez de **mentir**",
+            'faux_non': "Ça m'étonnerait ! **oui** serait la réponse appropriée, cessez de **mentir**",
+            'suspicieux': "Mentir c'est la pire abomination ! C'est l'attitude reservée aux rats ! Vous êt' d'accord avec moi ?",
+            'neutre': "Par ici on aime pas trop les vagabonds surtout ceux qui se promènent en **armure** comme la vôtre.",
+            'curieux': "Ah c'est sûr que j'en vois pas souvent des comme ça, **oui** remarquez ce doit être **utile**, **non** ?",
+            'demandeur': "Vous dites oui c'est utile ! Comme j'vous comprends. Un bel acier comme ça. J'vous connais pas m'enfin... "
+                         + "Vous parlez comme quelqu'un de vrai. "
+                         + "Vous pouvez peut-être me **renseigner** sur où acheter une telle armure ?",
+            'chaud': "Fantastique ! On dirait bien que je me suis trompé sur vot' compte. "
+                     + "Vous êtes bien brave. Si vous avez besoin de recruter un homme fort, ma hache est à vot' service.",
+            'froid': "Ah, c'est bien ce que j'pensais : une crapule de plus dans not' ville ! Pouah ! (Norrec crache à vos pieds)"
+        }
+
+        # --- définition de 9 états, avec les transitions sortantes respectives
+        et1 = Etat('bourru', [
+            Transition('oui', 'faux_oui'),
+            Transition('non', 'neutre')
+        ], True, False)
+
+        et2 = Etat('faux_oui', [
+            Transition('mentir', 'suspicieux'),
+            Transition('oui', 'neutre')
+        ])
+
+        et3 = Etat('suspicieux', [
+            Transition('oui', 'neutre'),
+            Transition('non', 'froid')
+        ])
+
+        et4 = Etat('froid', [], False, True)
+
+        et5 = Etat('neutre', [
+            Transition('armure', 'curieux')
+        ])
+
+        et6 = Etat('curieux', [
+            Transition('non', 'faux_non'),
+            Transition('utile', 'demandeur'),
+            Transition('oui', 'demandeur')
+        ])
+
+        et7 = Etat('faux_non', [
+            Transition('mentir', 'suspicieux'),
+            Transition('oui', 'demandeur')
+        ])
+
+        et8 = Etat('demandeur', [
+            Transition('non', 'froid'),
+            Transition('oui', 'chaud'),
+            Transition('renseigner', 'chaud')
+        ])
+
+        et9 = Etat('chaud', [], False, True)
+
+        etats_norrec = [et1, et2, et3, et4, et5, et6, et7, et8, et9]
+        super().__init__(etats_norrec)
+
+        self.adhoc_msg = self.assoc_etat_msg[
+            self.get_etat_courant().get_label()
+        ]
+
+    # redéfinition
+    def entree_info(self, info):
+        etat_avant = self.get_etat_courant()
+        super().entree_info(info)
+        nouvel_etat = self.get_etat_courant()
+
+        if nouvel_etat == etat_avant:
+            if etat_avant.est_terminal():
+                if etat_avant.get_label() == 'froid':
+                    self.adhoc_msg = random.choice(MSG_BLOCAGE_NEG)
+                else:
+                    self.adhoc_msg = random.choice(MSG_BLOCAGE_POS)
+                return
+
+            self.adhoc_msg = random.choice(MSG_NEUTRES)
+            return
+
+        self.adhoc_msg = self.assoc_etat_msg[nouvel_etat.get_label()]
+
+    def say_something(self):
+        print(self.adhoc_msg)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/ai/tests.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/ai/tests.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,25 +1,25 @@
-from .NorrecBrain import NorrecBrain
-
-
-def run_test():
-    npcs2class = {
-        'norrec': NorrecBrain
-    }
-    curr_npc_name = 'norrec'
-    pnj_courant = npcs2class[curr_npc_name]()  # build npc instance
-    CODE_EXIT = 'Q'
-
-    # print tutorial
-    print("simulateur de dialogue, à tout moment vous pouvez saisir '" + CODE_EXIT + "' pour quitter")
-    print("le dialogue commence...")
-    print('\n' + '-'*44)
-
-    # loop
-    SYM_PROMPT = '>>> '
-    pnj_courant.say_something()
-    saisie = input(SYM_PROMPT)
-    while saisie != CODE_EXIT:
-        pnj_courant.entree_info(saisie)
-        pnj_courant.say_something()
-        saisie = input(SYM_PROMPT)
-    print('done!')
+from .NorrecBrain import NorrecBrain
+
+
+def run_test():
+    npcs2class = {
+        'norrec': NorrecBrain
+    }
+    curr_npc_name = 'norrec'
+    pnj_courant = npcs2class[curr_npc_name]()  # build npc instance
+    CODE_EXIT = 'Q'
+
+    # print tutorial
+    print("simulateur de dialogue, à tout moment vous pouvez saisir '" + CODE_EXIT + "' pour quitter")
+    print("le dialogue commence...")
+    print('\n' + '-'*44)
+
+    # loop
+    SYM_PROMPT = '>>> '
+    pnj_courant.say_something()
+    saisie = input(SYM_PROMPT)
+    while saisie != CODE_EXIT:
+        pnj_courant.entree_info(saisie)
+        pnj_courant.say_something()
+        saisie = input(SYM_PROMPT)
+    print('done!')
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/anim.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/anim.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,150 +1,150 @@
-import json
-
-from .. import _hub
-from ..compo import gfx
-
-
-pygame = _hub.pygame
-
-# - check your .json file to be sure the format is well-specified in the code
-# cf it matches what's written below
-ENUM_FRAMES_ENTRY = 'seq'
-DELAY_ENTRY = 'delay'
-
-
-class AnimatedSprite(pygame.sprite.Sprite):
-    def __init__(self, srcpath):
-        super().__init__()
-        self.image = None
-
-        self.img_source = srcpath + '.png'
-        self.infospath = srcpath + '.json'
-
-        self._twidth, self._theight = None, None
-        self._ck_desc = None
-        self.total_nb_img = 0
-
-        self._data = None
-        self._animations = dict()  # the default anim always has the name "idle"
-
-        self.rect = None
-
-        # for one given animation
-        self._curr_anim_name = None
-        self._curr_img_list = None
-        self._curr_nb_frames = 0
-        self.k = 0
-        self.delay_per_frame = 100 / 1000  # 100ms by default
-        self.stack_time = 0
-
-    def __getattr__(self, name):
-        print('warning! no preloading has been done on AnimatedSprite inst. ({})'.format(self.img_source))
-        if name == 'image':
-            self.preload()
-            return self.image
-
-    def preload(self):
-        fullsheet = pygame.image.load(self.img_source)
-        fs_width, fs_height = fullsheet.get_size()
-
-        with open(self.infospath, 'r') as fptr:
-            infos_obj = json.load(fptr)
-            self._twidth, self._theight = infos_obj['tilesize']
-            self._ck_desc = infos_obj['colorkey']
-            padding = int(infos_obj['padding'])
-
-            self.total_nb_img = 12  # TODO is this a bug ?
-
-            # -- algorithm:
-            # 1) find how many lines & colums
-            # 2) put everything in a temp list
-            # 3) filter out empty frames (thx to the given padding value)
-            # step one
-            ncolumns, nlines = fs_width // self._twidth, fs_height // self._theight
-            # step two
-            tmp = list()
-            colork = pygame.color.Color(self._ck_desc)
-            for lrank in range(nlines):
-                tmp.extend(
-                    gfx.Spritesheet(fullsheet, 1).load_strip(
-                        (0, lrank * self._theight, self._twidth, self._theight), ncolumns, colork
-                    )
-                )
-            # step three
-            if padding > 0:
-                self._data = tmp[:-padding]
-            else:
-                self._data = tmp
-            # done --
-
-            self.total_nb_img = len(self._data)
-            print('total_nb_img -- ', self.total_nb_img)
-            self._load_anims(infos_obj['animations'])
-            self.play('idle')
-
-    def _ensure_list(self, obj):
-        if isinstance(obj, str):
-            tmp = obj.split('-')
-            if len(tmp[1]) == 0:
-                a = int(tmp[0])
-                b = self.total_nb_img-1
-            else:
-                a = int(tmp[0])
-                b = int(tmp[1])
-
-            return list(range(a, b + 1))
-        else:
-            return obj
-
-    def _load_anims(self, obj):
-        """
-        being given a JSON-like structure, example:
-        "animations":{
-            "idle":{"set":"0-5","delay":100},
-            "attack":{"set":[6,7,8,9,10,11],"delay":250}
-        }
-        this method returns a dict name <> pair a,b
-        where a is the list of images,
-        b is the interframe delay
-        """
-        self._animations.clear()
-
-        for k, v in obj.items():
-            tmp = list()
-            enum_frames = self._ensure_list(v[ENUM_FRAMES_ENTRY])
-            for idx in enum_frames:
-
-                if idx >= self.total_nb_img:
-                    err_m = 'in animation "{}" given range is {} but, no corresp. data in the SpriteSheet!'.format(
-                        k, v[ENUM_FRAMES_ENTRY]
-                    )
-                    raise ValueError(err_m)
-                tmp.append(self._data[idx])
-            print('anim {} , img count -- {}'.format(k, len(tmp)))
-            self._animations[k] = (tmp, v[DELAY_ENTRY] / 1000)  # defined as millisec
-
-    def play(self, anim_name):
-        self._curr_anim_name = anim_name
-        self._curr_img_list, self.delay_per_frame = self._animations[anim_name]
-        self._curr_nb_frames = len(self._curr_img_list)
-        self.image = self._curr_img_list[0]
-        if self.rect is None:
-            self.rect = self.image.get_rect()
-
-        self.k = 0
-        self.stack_time = 0
-
-    def draw(self, screenref):
-        # this will bug bc of pygame.transform.scale not properly implemented in pygame_emu (v. 007+)
-        screenref.blit(self.image, self.rect.topleft)
-        # pygame.draw.rect(screenref, 'red', (self.rect.topleft, (89, 89)))
-
-    def update(self, dt):
-        self.stack_time += dt
-
-        if self.stack_time > self.delay_per_frame:
-            self.stack_time -= self.delay_per_frame
-            self.k += 1
-            if self.k >= self._curr_nb_frames:
-                self.play('idle')
-            self.image = self._curr_img_list[self.k]
+import json
+
+from .. import _hub
+from ..compo import gfx
+
+
+pygame = _hub.pygame
+
+# - check your .json file to be sure the format is well-specified in the code
+# cf it matches what's written below
+ENUM_FRAMES_ENTRY = 'seq'
+DELAY_ENTRY = 'delay'
+
+
+class AnimatedSprite(pygame.sprite.Sprite):
+    def __init__(self, srcpath):
+        super().__init__()
+        self.image = None
+
+        self.img_source = srcpath + '.png'
+        self.infospath = srcpath + '.json'
+
+        self._twidth, self._theight = None, None
+        self._ck_desc = None
+        self.total_nb_img = 0
+
+        self._data = None
+        self._animations = dict()  # the default anim always has the name "idle"
+
+        self.rect = None
+
+        # for one given animation
+        self._curr_anim_name = None
+        self._curr_img_list = None
+        self._curr_nb_frames = 0
+        self.k = 0
+        self.delay_per_frame = 100 / 1000  # 100ms by default
+        self.stack_time = 0
+
+    def __getattr__(self, name):
+        print('warning! no preloading has been done on AnimatedSprite inst. ({})'.format(self.img_source))
+        if name == 'image':
+            self.preload()
+            return self.image
+
+    def preload(self):
+        fullsheet = pygame.image.load(self.img_source)
+        fs_width, fs_height = fullsheet.get_size()
+
+        with open(self.infospath, 'r') as fptr:
+            infos_obj = json.load(fptr)
+            self._twidth, self._theight = infos_obj['tilesize']
+            self._ck_desc = infos_obj['colorkey']
+            padding = int(infos_obj['padding'])
+
+            self.total_nb_img = 12  # TODO is this a bug ?
+
+            # -- algorithm:
+            # 1) find how many lines & colums
+            # 2) put everything in a temp list
+            # 3) filter out empty frames (thx to the given padding value)
+            # step one
+            ncolumns, nlines = fs_width // self._twidth, fs_height // self._theight
+            # step two
+            tmp = list()
+            colork = pygame.color.Color(self._ck_desc)
+            for lrank in range(nlines):
+                tmp.extend(
+                    gfx.Spritesheet(fullsheet, 1).load_strip(
+                        (0, lrank * self._theight, self._twidth, self._theight), ncolumns, colork
+                    )
+                )
+            # step three
+            if padding > 0:
+                self._data = tmp[:-padding]
+            else:
+                self._data = tmp
+            # done --
+
+            self.total_nb_img = len(self._data)
+            print('total_nb_img -- ', self.total_nb_img)
+            self._load_anims(infos_obj['animations'])
+            self.play('idle')
+
+    def _ensure_list(self, obj):
+        if isinstance(obj, str):
+            tmp = obj.split('-')
+            if len(tmp[1]) == 0:
+                a = int(tmp[0])
+                b = self.total_nb_img-1
+            else:
+                a = int(tmp[0])
+                b = int(tmp[1])
+
+            return list(range(a, b + 1))
+        else:
+            return obj
+
+    def _load_anims(self, obj):
+        """
+        being given a JSON-like structure, example:
+        "animations":{
+            "idle":{"set":"0-5","delay":100},
+            "attack":{"set":[6,7,8,9,10,11],"delay":250}
+        }
+        this method returns a dict name <> pair a,b
+        where a is the list of images,
+        b is the interframe delay
+        """
+        self._animations.clear()
+
+        for k, v in obj.items():
+            tmp = list()
+            enum_frames = self._ensure_list(v[ENUM_FRAMES_ENTRY])
+            for idx in enum_frames:
+
+                if idx >= self.total_nb_img:
+                    err_m = 'in animation "{}" given range is {} but, no corresp. data in the SpriteSheet!'.format(
+                        k, v[ENUM_FRAMES_ENTRY]
+                    )
+                    raise ValueError(err_m)
+                tmp.append(self._data[idx])
+            print('anim {} , img count -- {}'.format(k, len(tmp)))
+            self._animations[k] = (tmp, v[DELAY_ENTRY] / 1000)  # defined as millisec
+
+    def play(self, anim_name):
+        self._curr_anim_name = anim_name
+        self._curr_img_list, self.delay_per_frame = self._animations[anim_name]
+        self._curr_nb_frames = len(self._curr_img_list)
+        self.image = self._curr_img_list[0]
+        if self.rect is None:
+            self.rect = self.image.get_rect()
+
+        self.k = 0
+        self.stack_time = 0
+
+    def draw(self, screenref):
+        # this will bug bc of pygame.transform.scale not properly implemented in pygame_emu (v. 007+)
+        screenref.blit(self.image, self.rect.topleft)
+        # pygame.draw.rect(screenref, 'red', (self.rect.topleft, (89, 89)))
+
+    def update(self, dt):
+        self.stack_time += dt
+
+        if self.stack_time > self.delay_per_frame:
+            self.stack_time -= self.delay_per_frame
+            self.k += 1
+            if self.k >= self._curr_nb_frames:
+                self.play('idle')
+            self.image = self._curr_img_list[self.k]
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/ascii.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/ascii.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,243 +1,243 @@
-from .. import _hub
-from .. import struct
-from ..compo import vscreen
-from ..foundation import defs
-
-# - constants
-# character set that allows to draw a box with single line around it
-CODE_LINE_VERT = 16 * 11 + 3
-CODE_LINE_NE = 16 * 12 - 1
-CODE_LINE_SW = 16 * 12 + 0
-CODE_LINE_NW = 16 * 13 + 10
-CODE_LINE_HORZ = 16 * 12 + 4
-CODE_LINE_SE = 16 * 13 + 9
-
-# the character that allows to fill the space
-CODE_FILL = 13 * 16 + 11
-# all
-KNOWN_CODES = (
-    CODE_LINE_VERT, CODE_LINE_HORZ,
-    CODE_LINE_NE, CODE_LINE_SW, CODE_LINE_SE, CODE_LINE_NW,
-    CODE_FILL
-)
-
-# embedded png files white fg, black bg. I used base64.b64encode(fptr)...
-# Use base64.b64decode(encoded) to decode!
-_EMB_TILEMAPS_PNGF = {
-    8: b'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',
-    10: b'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',
-    12: b'iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAIAAADdvvtQAAAOd0lEQVR42u1d27LjugrUcvn/fznnYapyvCUbNdBg2YGHqTWJoiviLvhrBSJ8Pp9pm7+/v7R+VoPduZvjmpE2EWcsj4K0WRlxT2d+bCMsTe7qCrPBvdo95/T5fD6fT/fJ6Q/HNt9P5KOdHvx3xG4UbZuIg78aa7pj3zYC3TruzHgQ2g6RKZ2exabane7HhsM4nuX4X7kx5Sp7uqKMBe7hP5xIo5qfA1zN5PSTzYkBMp4hbMV8GPLCELwEd/C4ri8I3R4bXLGP40CCGEDEHvPSOtLVobUagRDk8FOO6cF3nAKhwDmUw78/4zJPuzoyLwTVBNQHN+f0YmxEWoejc5oCImz94vDdPT+lD4UbKBCCVdODP06jEyFHUnH8CkGpqcozlTQTDv54h6/us3zPtYr2KdtVq/ECg8flm3+nPqVJskaDkzczrbItSpj2F9GdPLcTTRCMN/Pu7xDHP/6/kBvtQIhSjSj5oXYprQHwCntUn4MGHnx/cDPSFCN7at0KqAgU3U/E6jzj7oUivwxPdJ4UvAsFcXFEJcfgDoqrlogGx/W7sXxqj/O7cdR4v/1NpcqqznLq5UGsJuBaENUy1B+ylKj3uYYTOxBuNhBaZvqeOqSxWVpV2ixxXfJuG0w4EXOeGn43+sIQw13EBfJsN2hs5K5LIJlIDMJ0vSo/YNPEdRw/2XFGnkm3v9YqnNMhIQ1rcoqrkBgkJMjAbbm7tOO0yylkXHUuE8mXSRunSsDoSPGL4aednHbb+W6vqO+VTXLX2gbAQKccfaQjVKAqN91E85xV/ciedoSgykpo5wsKMvz8eXYN0cCnSj6o8NsCF3G+rgoPBeNH19fkQW+3QJ82z2o9MTFcwdnP71hzXiHEgmWFUVCg11gvKGp8Kxt/QUEBwcBTEA0b/VBVkXIJ+DENwNUiq2yF/xF0j32VQZ+l+WBGdY8ypZ+yXcki43bj8MjjhOlLmqunGnEz99vJwIuxJj3zPuvR6vaCJ4Wr8QomDUoMBm4qQ96AJr8bjLtCf0EXEewBD3m2Hf/oTvJEPuGrdho2KWYF56N3cFFLh7R2D0rM7+dP30vcuKIcazW356tNvoF+qsznUxTxhz7SiRBrSuvwOMlttywLw/ObCIfRDeQ/D6KoxBqLtSjbFd3aqtAFcNkI9YhbTi4md8KlGWnheMncMJt4liW6dqagoKDglLuphNZjY2dQFeX5t+od/lUDXCvkritHS+KqluO6ziMSPeol/mgQV2VtCoJhws45c60G+Uox0qBrvIN2mulXEVJ9gvvzRrMKRUWnrG4agi30v6vODNGEWUc1mnBW0FGXejmkCtCWF6sK45dY2L8uKBZSjx0M5AXaZMqNlG6nwSmL4rAtgrIazn2L4FANjnyY2uWm2fLAh/FIG4OoJAwUzTfpsUc2jNwjGBDlXVyyEKOK1nAeG0sGmvIdrZaKmPUlBKJjD6KtvExATp6VjEPO4BOkmc4ORMxJaKjzEGqbwYPOzAanOERMsAO1H8t79HgoV1dBQUHBVAgzGDC4zqmGxTIjYzWsGJZNljKYpmyy3emDf2FdHhcN7sK6ku227peIbQY5G7mf43Ay2gmddGPJaogcnDWdj8EAAarEtnz7uKmJEgwuRORtto48G60V5vGxkIo1z1IuKHOzJcM7ncN4Frt2sAhLBmuvketoQ7JfUPpsC99Dr05LjGfwt2GNtRT56fyb9KXxkysgMhCdhoHl1sClIT61BOuOagOR6lIRRNfiC+NiBksEUcme8n19IgPy714eBaKcND5dra09ej4r71XEDTzOYTyL/YiA/njeUcmXs5BO7UCIZQIsToC4tYnE4HTE6cK1Il0abj00G0RBQUFBwevBzAovAzT9ZTjBfpo79sj51CbzWQ/LN4fb/aJjmLbul6APqwX7wsbe3nTdcWOS0BKkGdOxnJknNi2Vu/KJRGuVr8Ghjj7Z1sXaf/+Z7ots6CMOfqqBZy4WfMkVfUu3ESVZHmC5Gk1bL2oT8c/IGw0m0OQa3+/dw+2UZaqe2tuuWqazjI5hiOMpJ3Hd7Xu4RdzU6dq6O3ovDn3ngKTco+M9xY114x5unok+QnxZKi8z+Lz1QTi04cQZYXBa4gS+RXcm7c40B4AeOm75DnkPY5VlJ9Ut19q7IScTS0FBCrkreB/sdBTkErecXNrcnzvzJ6lyk93OSjauMM+vKh2TMOT2dfnHWiQN+X7jTt2l0q+DAT/HwrS5eRs1nCOOkh9n66mGwcpZY2CIyAZ6UgBezXnT3i3QFOsM5wCd1Yh1GCng+u0EwR45mgV8HMJN/TSlc84UgMI+706kXoGtTFGZaIPO5DuPCGLfbetZStt/q9xGCdhI1cJuAeJ7Gue7sAVtYOsHLGy2jZ7KLqp4oKsUJ/JYDfOFgTEYFB/ftCIzgqassYgU+tGFglNJYDQdyhwriUYWArVcq265ogsKigI9jTR6Sm81TUp8rZSzPWL7fhl7PD4vMONl10Y13FbYUwDaC84V4VH9FtBw6jPCnUqqNL/NXRLK+bSZ/vx5qmazamqpmhmY6dYhIOifku03U7RVpfldIW5BTrJk4yw2f+0Vk/ITGBD/XGl+VUPKCZ0oPD6TabIqoSJZvfHzxoPzG6Mai9eZqt0mHId+UzqWN5DlCAvd5O2uHcRds06LLe42AR8WNt8zo6CnYTlHdiJsXBFwW/CRIeLMY8bQyuzTb8EKeaygM62RJsIOxKcK9MY/aL/5nc3501KOVt6c2pZTFpYsLbIsE9pMb5TnQWnTdmq7xLGuroeiChVouNPKAf7iXLgZzbmhadMGJ4y7usAGBgPpNjaiRMHl5EnJDNhbbdqgGouH09tscn9mAvNQAaWENg+hGvdwF9DWzMKSa3XjbVhmheg2mZNpcEEIr/IJhmOqojbBGGFKmyY+DUOej6W1ydwc55zDC86ZqQKxjJxK2sDtnwkzXx/2IPVPJfbHtWns52yUqmQLimJmpN+ip/W4q/abRnZz1UddNXLQ90Tph9VG2xUuj5tzFahcijltnDVAfv3+1doJMtAv713hzSMvon8gSrJc4nq5avwzhCe6/mWQAxL8Sohwoy2LlPOG1bM0Vf0yVVnjE19YBPZcyfZpfiVVYTJikhCWoRVBL+fkvxH+YNaHbrh9PHVKADaeoHqaXr4B4cOegcD7h3TVbbHHM6ByLyRblS59YXKgLl6u0UCogtoQddRMFkZExGjYcIzuXjOx0hI2R1nMoAo6jzPxTfm7fDGmOIr6wlSpVeUQk8pElGN3UNVAPsWSI9uZFtIbB9pxfsSK6yvw62LgKWjDRw0nu5VhjcgOVhvLkAbPGJGocqx0Stax5akWdm/MFNGnhmip9Dgv/5MEuZ/xsVvHy2TOU2yIbNzLGUulEYMI1Ez1XwqBaEaHH+XstkvGSkvDemdTov0qCLQO9oDJrPCkWH6hJIeFjUPYPsmZ87Yy9sha6NfCJuRrepw1UsjrpWpToNNRG5AZ/inxFflzlnuTv/2L0z9lc4AqkeBUP2++nIQUFia7+rVtwGRFfqbhdBe6Xm7bJsRycHanfot04ucjYEYi+beIFEh5LDq2fHxI67Gwi81eAtpUbrEACaQRjJzhvDq9hv0Kvx6HQ1PWIPx8QZtTl2Syc5iPLMxc6urbs5CVEcrO8WxrRC4SnGcLNMVdnD+2ErNUc7n2iBajEC2wuT+VUc5Qx9WTsByXkzItNMko60+3GLozZTlY3VQBEtoyBRW8CNnHv6f/fsUC4W9EkqC3Wa0gIfFVRnIqmVPYBIGjCxCR/xV+3ipC7b2wyajTDinc5X+nWFh7/UrY21CkZ/wbwaH23xDM07+DRMtMMVZQs0PXRS+NwOqnKFDBuygQ0hIhAM48c1dB5tzXlVqjWlO+YHcSUeSHRYEK3kWBWNQFERpOrdjI9fUTCXM/BgodSumLAhX8nhYWpASZx2KpSCqqGSFvlRZWcIchsSzRBUy7GauuAGWsnDmv5sNas5/Tb7e6MwVeFlZQ4NLCfopBEzWR8S2EjY+wasHkuMm6b4sCFQRQoKCCRWbTKou64CRHfmnlTPhKN8bc2E9RoAIqBSKWo25Zz7LwsXAZSFVAM4iynprQMscqClRQWhgVgmow0n8FPvi6cayiQAUcKAQq8BH1U1E0uRZEY+dMuXc+5jnHBYuxQsyKAhUUCyt4nBbGIq1OFnM1VuhLCSQo+5fD5YoCFfgokPAIYVr9yUml8LE8VhCnhzxI/HxNiOZed+hZkIl5yOXZ6dQFzBFOlIGQNuZUwKHyX+bzkpKBCh7LwpCcjzdS0VBV6Ma1FwUqKAQqKCgoCJQxPGqkLXkxmFXeGaeSoD87c2RPF5WZlto8lr0yiL9OijaP+AqiK7HQTMutEucc6wrDtmOLLj3vzbQx8VE9uPbjE+Dbl4/M+XMAP/ac1uTbrq6O5yIedyH6xclngNMG498qctjSCxvKyDqmT2lijYs4vN+uzgl5+hS9icgtbEPtS8Mo/6kewngl4i8hyEVWpETp1Q18sBqvlQMWcQUIeHxEiMxgS3DOhhu43cjmIzYigRyuYIw+ZV6n7r8gkfwL+3ewLikdcpY31pe869jWmdVU2MDl1Ks6c7FqPLGNoPFy7S5TDBDuBmU+Y6G05ih3n2YHYj64WEHDf/eECwp7CgpRClRCdIFfUAgdUZBLwKKqsTVTVWWzp2KUNt8K4lB0Su4q2dlcBzgCgZBFmZePnLvcZo9AT1AzxJft0TNxJA4d5XbCyc1M8sWqTTsVMKcw7oVIs5ogFpH2uqDV6OXsBhaWD6z6N6cdgo6wruhHXAVuIhXs/Aqxlmj8ICnmxKVYBiIDtazoHByHpsbohL3d484j2ogOomm+DOTMJvYsaczCwkBhIpQ3ReD0WHboRpb9FMuWjoUh/iBWG+1GU56HrnPppy7tuwxgD9Mgyr68ONS7sAIX/A/JbE+WwZUqUwAAAABJRU5ErkJggg==',
-    16: b'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',
-    20: b'iVBORw0KGgoAAAANSUhEUgAAAUAAAAFACAIAAABC8jL9AAAZJ0lEQVR42u1dybKtOA4Egv//5duLqjpBA7Y1WzKZi47q+47xpNGWpX0Dlsbf35+47b7v5fr9Gs5IQmltjKatOa3LOvpNQdBc0y+E0XDpZK2qYA/j3taqadreml9/0Po7ZQrcrb1NgdVc0+83NfDzy53f94dBnCBXBChJmkUbuy2JUKbUYjPBhFt7ydpjwe+HuyWmDHMetmUkOinTpyZYBKLE9BDurjrpZsc9x/k09A5Lbd5eizDd8vf31/o79ztTDMKAfj1kwXDYVrRx3d8pNvB+AZG9b7CljSOAezO7HBqinN7v3wV6QlRq8s4PrGjjqZHmEhVrAblMdFvPltVwOtFlS+NTRn871PFjJApRUoiP6wOb9PvcYDol3X75nEJyUTuRb23Nbwo59ffu3L4K4sq2GOMqm66LPpRcyn77JhZLUMp4WOPyiX3+DttMZ2bzAfz24qmQn32d4F4BL12bc//V2/zud9f3RWWuLJH5xUKnZUzO8oFvI+lPgS7v+nbcP4v8FGSn3/Q2xYXKXMu5T2fP5jeOZbVVGtJfFrUUafVrrrksyHysc2wAUMTvfR4ahZ1+p8Xpt+LcxeJei7OOXq4fF5zZQBPWRetO1dxMU37zJphu9kXLBz48Fkt/UOFtSLMYcugX3KSD7F/7Da20ivL6SrNHGtrIfERya0h0cSm9P68Jnx85PXhDfOL/KnXofXkcvQzbvjKe7F/7DYeDpwtK25PktIYMhZc0S2ErHIm/vG2f5WOGjjLZONcnGnnB1VeatmJKNXHMIgUlEGNy3za09X+v23fazkEf3q3X+Sx+0LR9nR336Ph1VwIUWqSgHE4twFGiCzsTklBaTHSbsfxrpM53NA8S9AGGYnfU1s6s/pjB5DmRySGWYEM7AQJWL+T2SELxfg9s9SRQ+RRpYQae0q/JQsVEYsbHe+J25L76i90YISPH2jixBKAbAAAAAPjP+sLFRsBaYZ1XMBsj3T9KL1YnddxEPwLrWhOIa+7fxhza6dt+U8huFq/EX6nriBHJxC+HPUjSf1wceOg0fu47p7BxWul/2AuvOLxXiv61yFjo5zOXm2zjBku3Uh8FjJ+7VqlycTnF52VTv+b22jipnZ6NWV+YlZvK0TkJuWzkrlXCddaMOd5MyGYIHB52i8A6KieAn4+/nvnlpuR5dmLvWTysGZIm6Z/JqLiuCpFg2I8Z6EdcspXS5Oydy8Mdc9QpbaJ4rUxycbnysOHDoBhBmYE+T+6UpjxXyOzbtJgKCXE2XQohrq9uuNoTEw+6Z6Vs5cv7LKqkaFUG1gfr4VS6V5OXK5EGLsE/RKIcpjsDZN5gdaNDmfDQhOdZ7xlPPcNMF5m2Hqxy/7zXQZZlopw4nmXIlMuXxriutDrEyhOJ1f/O8Auyp6r698/mFfdidnb4Qc2jYtsxd8wKisVhslbEuZ+2MkamjWtplZ/K7UzWdbQeKSP0qskjx3JyPVzgFFo2RC4bexOHHw+3Doe8zzY0Se0SCg5lvQgPshHTpNV1HTHn2dFpr98Vcbmt/Ociw/AAb9UxpUSQR2rYtHUtS9DkHmOsEr8fr1VsT5IE/pVH85zph14/ws1elPx8zvwAbDjrw1brKiVWnsJzeuNi4SiOfv5gDwPNlTiBaOsUAAAAAOpbQ1iCmFMAAPDACWYApshKEEZSBn6+gWQFnWjyWr3mwUhLKPojd/00PWoFADFk85ITy4MotxVfCwxfig/fkWdYKAE34hVaNqF/YFFaaVM8Mjm8cs4UrhDrUsFoh7IMskBMVwcWJfkHEx5ScHm4E1rL8oeVgnUlQnUpL7pJY3RlcafEh9cdEjH36CIfx2qKA+tH2CpX2//9rQ4rfGk9XWV50D/lhY1mtEW5N9sWg3uVWmGvTl7KU2irHEsC7qXUxZ0Yl27yHdvY4A+egQ/p6uvVCTuan/4k0Fz34lBnuBTT0/cGK6dN86DfxMLMzMOtheNeYm+67B//dLeSczgs1Q0TWklXqA8cscp0Q2Bh3StLszrLcZgrWeh0VdgHZtG6R3lBMfda5fGauEGyEK6rufH8b9dhz/KfBf2y6AqBHPbcm/+6Uhk6ouHe15HA5xdrhbM6g2lOoa3KlHAlOiUrdWRWLVZfygDM6icm2TwyaGBfRc1tFRlWKQuKrMh4FR+3EMeJU+hpM5XVlJg7/slJzEPc9czyfSkTOi0lwSZMJQXKbQfoBwAAAAAAAAAc7W0sAfAphEWqxnR0djoW+9aycz9Nv1ZPEenBurZ1GPWtvPu1Xefp3BvcqZ4OW+t80GcouCo0WVlWhhrNYCJ312rMFdc5A/cGSBzxlT5rnXfKDDUvP71r/HrUB+ZqYKu4XO/5Zljnj3CvCR1S1nmde2Crt+lzp7B8VPCUBwkTpYw4ZNUsEktQic+8RptT29bu6guUa94VCn6AdM05uVfAw9wRnmlVU/ybRMNewp65gnsDlLae2cR6WMXAv1dg8WxsdY7tl2Np6CsS90mpvVlTuGX/YPVLeUEF3evEw52JnFj3bH6sLBdXzLGqnnXnuks5+9Ls8jlUv4W49+mH02fRT57mtw6vZwdOFnj/hJMy007+sOTCNNKpcTIq2UntanEvsLxZK8sloM9boGcQJ+7tMXAV7tUErGnueL9WWKDufKfrYZMyVC2c2eijZVVS0txMoa1bv1+4yP0CD1vN0duo5Lk0nRFoTA6luSIes3LRNf2ajFmf8bDEmK2YId5BCxjwQd+GtHJ31pg1/X52zPsFwewXbCjFyAscFAGVPHA9Myz2nBAAAAAAAAAAAAAAAAAA0oNxD+wROGYSsCYbs7g0If0GQhM5LBu57PWVfr88Mp9R3kt1Ru6RIsb7XylEcmt10FvKcmJ5X7iZjNm8bcX5Aub0rKz8SPnBzpUc3pkWWZqhX+OTq81YxQ0pst+8rXK+HvnDvOsVEXWsbeqylvLnGgXcpRb86+Enq4I1w23CE9+dxnT98fCA4LhITbVnV+I/vRfU7yHIcAuVjPR7JWv4zknTFm8t6y6F3wuQc5bkWJu2NIald0FKcO9KPHxm3p4qm1TxqKyidJaVwNa7ZjeRkcqWPjYAAGjWTcJ66C4pdTSSRpPXavoGb7qc2FZVabgP1v20sa25ezsKjkwtoEn07WrsQAPb77Rms/H0LInoycD80xhY/GjbdiP//oNGdYiPo8xpq3Od+DW2t+Jhj20K5uF1NLBhBJg+sXP8fKGHky+gEw/v3CnZRvn4VbtlDZjV1iMWOibd6ZRYaMMsayax0NxtCo6F5u7vEWasTxFsVeoAVB+VbMBw+AVrgkUDAAAAAAAAAAAAAAAAAAAAwvCSg6L5U4fCOVZFHPWZQDQjD8uMYXjHGJnNw4+6vGtH6u/tN+dg/kM/mY2fyMdkEU0GBqyN6QRwfXrh8f3zKlFkWTWIauG1raZfomYYvllpjQHM72LyqUMgBVXRNM9LNKN9hvea6+ED9GRFKEWZJzLBxazXf1NkceuBDRiYuoXDF1EfDFu78fBE7nWvfD2VhzvPxWxHgvfAMDoW5N65PPw6OycePlkGQEz+Tq6h2zon+ELYt+yE85nnidXk58sRPzKFe19nGpDEozO71zWM08Cz+EFs6OIUKqH5HZ9TcpYejrF0Tld2FSyWQDl0NikybVI5vS3QS68ZnjJzb7weDj5YOcKoRCzpp3zhO9zLXSVxBYy5+ZwznEt74LBdmr8Lbr9h7RmdA1s9FrJF6fTdMmLpBm3Y6ShLQExJTLUGDx8eS+NH5fAnzc9XAtY5T0XF9Xh4EAutrz3X/5qmlBtxG8TlhTV1iTdpCLesOKCmFOPmXx84PhaatewC0spzsOKVVnaiexM2En2/hhUVgW/qYVAM8FFkK5Imq+mBSCwAehgAAAAAAAAAgM84AiX8ewAAXnHO7V4TWLvGeMJ6NOzISr4LCgUJklG9aK2FdBJOoXPJrw3B20A5EzrzjVxkYGNAvxWdI5Mxr+oVHkMbAwoBAOr5wNzsAVb+hj482KptvJdFbNVaItcX9n77q1kxq/zPApLwC85nrdLR72mYF86VPYhfSJiw2s9sabnNJlXqa1lbc0cr7t2WnveYGdLfmsyqGJCnUsGU50QsFRF2Ct35GXcMrN+3jieIlk4kXa1zCo2XPbJFU1pY07Xfxzf69FjTnCydx5oKO3NOsj5+Sw0xfazKvQAADayyZ/LUlVqpYoh3saz8Nn9wnudPaOCExtVE+nZNsgejcdX8ksLViDShKTmxBFSruXYbDsDjus88Rld29C0uTcydskk95NvPKM6weMwT6zBz6co3K6XJCacmU7Zrlu34XFwVc+hWd1tSTe2lQC+OAYq6CbJ74CQODvyCXCY0AE4QjxzcCwYGD4MTAAAAAAAAAAAA4AMzHUu4keX8f8EjauW761Q4QRMbYrmxTeQBmNSsMwzyBQODe+ttU4wmbJVxFsT2XVux6G1oGJ4gC/AGEEBOAoOcIjXOlnjj9idL1ERptelK9bKCTumznpLNwypGt9M2PgNJWvfSXHtrSLrFwwfLDOCaDVZiTFPiHToW9nMAQ3aY8yWAWaSQXv94PvXe0+zuq/KObB7K9ae+vTah8B5Xw3NthBKULUgNGf9yu9OjLGWauHfxF4Y2bZ/OxdKq02/S98DKJKPX7+BmaHgqEyC/xNwLW6O/emdmIqNs7TNFAyiDrkZiGEnJvdwU5U5qfG7djNYiHGsQZevMBg5wWvXCYoPpqZrSKoZ1rpFaeyyT2a75tF6lKYVEWvqTzhgs/4qoumUHM7f9grkkQ3kN/KpmldQQIONbp31bbDk1lnIzLNCB4ltmhMQiXPFFH7ehrLSP+FOyYegTeukLQbEO0jX3wBqr0uoeWKb5xTawpjtvzSHxgeNTQClHRR8Y60pg2Erm2m04dbNg8rUHwNDA+rHiQHglyGLdAPjAALQiMNLATlVbsdkAAA0MAADBB/bweNN6whkGXCLng9VyKc+BC+XBNhk2kTbOWuSSihOUZHS7ufm9JAkeedhymUREBs93lqSg08bx2riFKty7zQjG0OzQ1q76E0DNW4IHSTnnKxvwfgHl7xraOFgTC1h0DffeliY5D2cwbaY8KqQQcZ75Jt/iXiRWreo75fBqJmF5V93lTRTlNqQNRiAHKGwNXxQosb/EtmY61vaUkjVnzbVzxbafmnLRDQrr/Ugrq/SOh8ZjydxWs1YV266he53WKoUGNr/u08wledtZ65xhf6tsa+RaIRJrEcB5/ibSBXIIDKpVTWVXHl5p4l/GChk5wL0ANPA40i3mGsnE19UklM7clvhlYqrHKeb610x9b0F/dhpniEHB5XOMVtes86y2wPZ8jaRJMaXJESVOp+bXac62my71XLm2mnxaGdpGn0JrUkxpckSJE26Zd5q87aZLTlaxLcDQwBRhACQ0m7FB3wTugQGgME7bsxAgUusCAEkDwzzL7ghhg+ADw4dc3rf8ciz0V0zouutV8W0t3gMDLgw8hXXNb+0CMqdZvXHhjjl+gzS1503q1pvTlSyHJjHpheFM+1L+aPUXmbjIlosiA8jEfSnHjOp+eq0QuW62b9r/j3hYPQUUJp8lp2fp4Vr9Rmqzuf1qNDD979z9ff5lnQLfEzFLxAT329dmMWWNTfq9vttZ0wd+EocmDwjRZzBJsywg8bl5npbJquHEw079Fj0slOfEMpmwk9hDnidYPdlcqmdFBKcBn8QBDQ+0hhJ9WDqkRfT0cz+uhJ7VFvDm4SctcW/sbs/jlRJEn8uyRW9nmA5ZyfEAPiIgZC6S1SGWmQa2khx0KYWYG4BOci/1Chpntlbunh9Dcrng5H4ILh+QinsLjdNDLZ10qdBy6ii3VUA2m7AKA9j6on6acBYOgSARi6LIGqWAwHkrN2Z9DpOAwb8WGTX7PotR6RmeiAcA3Htg23xaH2w7/KA4PVXAmMWvlzpXCbY5sfqRWLdWrbyRr9WAW+M8TGTM619amZ9SSWjkl8q/zkrnU8Oi+X14OKifQ4d0khvY+thp2ZS5/RLtRJPHTMiJBRR2j+suL90+xb4AAAAAAAAAgKVlbuK727bd5pVjvrXqn2SKGwLc3RyeJHc2SNa2Ck5w7/X31ydTdO5lNaTwv0DobEaFHRNyb/y/FlqrA9x7/b1A97Iaauh1+LPFotzoHEi/jykkvAxMaGAKvRL1ditlymJG+6sZzAodk7XVMzw3/4ksXwpyYhkoBw15AZltNPNBdgZwe7bx+9fW398ZeFZyqW12fimNSylIvjGde/VHffQV07TNwL1WHQ0HIODhIwnBJcwvJT7n4G5wfP7tok7gqrq3JSxInwp2AFy1aFjbvrGgV/5i29uvqoMHA5gQibgj+qmBLAbbowrU8++IhdZClg239YRLY9EtXB/Mj3urA/WBbXhYkOnCg4c/wr39Q0Rb7r39OFuy0RPca87DVt4y93pTz+EVuXfjJHtaj8iP/skKIgFltnRFPkmY8Kh/6XKlz34iaHGYzbC2GNGfEqeIHH4Q98DReljD51OKy2XjXgozmHCviT9FvM6Vce92O4UmbqTHdZ9fviWiRSo+haZ/NhtXJDciWDlxhnFplL/Ql8vpYkXQ6hgOK8aQ9si3BBfAdp1TDZgiJVvCN8BZENjSMp4HfQMlPXau3BFfnmsejUUIOFADUJd7NXzlEcgRDxxiAYDc7wAAAFCb0NdzbdZ//3JQcP/3J9sE/6052PAwk/wiXfO7nd7x6tXH7D3H4/roWfDfMu79nQ/LegcA4F8G1jCSmHt/5/iy3gEAgAYGgPI4r6wo+G8TH/iqzyn/ncEPrALvTBoZ1ln2onMN2oAGBgD4wPCBAQAaGBoYAOADe/kqGl9R06/GJwzIFGmOgBSorG96nyNovg8NDADwgeEDAwB8YGhgAIAPnNGP1dxVajItefje3naQR3kQK98729kKNDAAwAeGDwwA8IGhgQEAPrAXssUMe495Voyx1XlBhnWGBoYGBgD4wAAAHxgaGAByuUitfyhRTHmBfiPzaVXMTfXlfim/R31gAKhsQmMJAAAMDADABKAyQyLMij3m+m+Rc+dCcwaRYa+5v4cGBgCY0AAAgIEBALD3gSPzOVn5Odl8G8qYrXxd7n0jt1+rcX4tbtmlNhJkGADAhAYAAAwMAICJDzzLT7CKU60Yg211D2x1RpDtrIFyL11xzNDAAAATGgAAMDAAAPN9YCAe3n57xe9713CqOGZoYACACQ0AABgYAAC5C9Cy3SNzCFn5G975hzDfmLXKWd9oVuUkaGAAgAkNAAAYGAAAQ6jugWf5KpF+JmXMkfd+HnuUIRcXAA0MAGBgAADAwAAARPjALf+H8vdZN2NcX9Q7RxS3bWSO5Wy3lyhPBw0MAMB/GhhLAKyEihpeYyVBAwNAZQ2cwY/VxPdGxuJq/FvK+Lk1frlrG6kZNN+HnwwNDABgYAAAwMAAAHj5wN4+TJV42ur1fr6wRwA0MACAgQEAAAMDAAAAAAAAQEEYHz/KYpjEGS3oITvi5iud0OrnK45RM0n4mCpzyD+DEU/cap2PGPpAcNza/N/f3+Hua/L+pBWF4jGz1nkf/PO+b/wYXU18ryDX8fNn4obPf8qcB/s2QtbVrlUe6eF3+j/Q79REXqVrUfqYuet89gf69/f3zVv+fd8TWg0U2bzkfl23g06TGoU0hXsFOIdKTEzH+WN9+mRB4WGZVynTZq090uhSljuXR3JRpBUx1UxHHDyXRWA5e6/q1++B+9ujP3vzHjP3LOdK+j8kP6cQ+N43FrrN8foXb4fWG2efSjSy5KklZF/Ib549qcFj5P1vRurPSFIeWisxXt5V8LGm731yjkis8iQORHJvGQ1c0VNK5asvfP7Hsj87Bk6JF1FK7oUPPJN711OkV2/wB29Sa5m+flR+6/Gme66z3vwzDUdo4JuYbElQjQGZcAm+xr1WpxtVpmmYU+3JFOanKloT+pVRV33mPhwenNjFTH0uHYpvgIN52NLlE7OrUhu8NvfI8MhqLm7IohWWZpgyX0o0hWabXNOSKj8ukALcGIFlfWCr1Koy0hEfeChv2m7eXfL51u03j+Fp2QHSLGGhgGBYauAApQcAgJcGBqB+ATDwJ7gXrAuAgaFaAfjAAACUBeoDv+jP5bUo6/a47maJU7UUoorTe331yUQCep+YjSTe8H59prK8zW8162xrtQ/pWCCBxESpp2Yl92rihGNaDXVC/5zs+a8Vz9VYD+Pi91fDR9y2uXxg5U3y8sdILUuBu2jXxcF5W2nSOrPZ9+Io8G9y7wcd+C9wL10/n97kJZi8gIfrcq9gtEM7hfIEIn8qLOhetgYG8ouAYepM4lNVzUF0DE1n4BxBNsyZDKxxvg1TpcQo7ZzGcGfiyifpYp4v50x9Cmdm4mbtGfa7hInB2l+TPdU8689PRbkOsZSquwoPW91yb91cImuIMMjlMhrYxOcJ2+8pHtowGiHmREozX71cBtO6M/DcBJy1hLQ+PKBKCkErPQw0Gfhr9XKre7Cp6uWCh11NLXcNHBk+9mWhcwui+lQIB/TwgIGhXU0cM6dlfP3s17asxHwjzwjAsWYJcSEEgckaGFhSIQALAxk5AKAw/gcfIslSBBX7zgAAAABJRU5ErkJggg=='
-}
-
-# global vars
-_lastcol = _lastrow = None
-_sm_ready = False
-
-
-# -------------------------------------------------
-#  PUBLIC module-level functions
-# -------------------------------------------------
-def cpos_to_screen(cpos):
-    i, j = cpos
-    return i * _char_size, j * _char_size
-
-
-def get_char_size():
-    return _char_size
-
-
-def increm_char_size():
-    loop = [8, 10, 12, 16, 20]
-    pos = loop.index(_char_size)
-    pos = (pos + 1) % len(loop)
-    set_char_size(loop[pos])
-
-
-def init(upscaling_int):
-    global _screen, _matrix, _sm_ready, _lastcol, _lastrow
-    _sm_ready = True
-    _screen = vscreen.get_screen()
-    scrw, scrh = _screen.get_size()
-    adhocw = scrw // _char_size
-    adhoch = scrh // _char_size
-    if adhocw != scrw / _char_size:
-        raise ValueError('div tombe pas juste pour calculer w')
-    if adhoch != scrh / _char_size:
-        raise ValueError('div tombe pas juste pour calculer h')
-    _matrix = struct.IntegerMatrix((adhocw, adhoch))
-    _lastcol = -1 + adhocw
-    _lastrow = -1 + adhoch
-
-
-def is_ready():
-    global _sm_ready
-    return _sm_ready
-
-
-def reset():
-    global _sm_ready
-    _sm_ready = False
-    # TODO permettre de remettre a zero le buffer
-
-
-def flush():
-    pass  # TODO use a buffer for put_char, then use flush to draw everything on screen
-
-
-def get_bounds():
-    return _lastcol + 1, _lastrow + 1
-
-
-def is_inside(ij_coords):
-    i, j = ij_coords
-    return -1 < i < _lastcol + 1 and -1 < j < _lastrow + 1
-
-
-def put_char(identifier, arraypos, fgcolor, bgcolor=None, dest_surf=None):
-    if bgcolor is None and identifier == ' ':  # skip if nothing to show
-        return
-
-    if _screen is None:
-        raise Exception('put_char called but the .ascii submodule has not been init!')
-    if fgcolor == (255, 255, 255):
-        good_s = _alphabet.fetch(identifier)
-    else:
-        good_s = _alphabet.render([identifier, ], fgcolor, bgcolor)
-    if dest_surf:
-        target_s = dest_surf
-    else:
-        target_s = _screen
-    target_s.blit(good_s, (_char_size * arraypos[0], _char_size * arraypos[1]))
-
-
-def get_charsize():  # like a property, but on module => read-only var.
-    return _char_size
-
-
-# def paste(self, src_surf, pos):
-#     self.screen.blit(src_surf, (pos[0]*_char_size, pos[1]*_char_size))
-_corresp_table = dict()
-
-
-def mapping_letter_tileset_idx(lettre):
-    global _corresp_table
-    # corresp caracteres & indice tile
-    nbparcol = 16
-    if not len(_corresp_table):  # empty dict
-        for y in range(32, 32 + nbparcol * 9):
-            _corresp_table[chr(y)] = y
-
-    if lettre in KNOWN_CODES:
-        return lettre
-    if lettre == '/':
-        return 3 * nbparcol - 1
-    if lettre == '\\':
-        return 6 * nbparcol - 4
-    if lettre in _corresp_table:
-        return _corresp_table[lettre]
-    import binascii
-    print('*warning:couldnt map letter to tileset idx: {}[{}]'.format(lettre, str(binascii.hexlify(lettre.encode()))))
-
-    return 0
-
-
-def screen_to_cpos(pos):
-    a, b = pos[0] // _char_size, pos[1] // _char_size
-    return a, b
-
-
-def set_char_size(v):
-    global _char_size, _curr_spritesheet, _lastcol, _lastrow
-    if v not in _EMB_TILEMAPS_PNGF.keys():
-        raise ValueError('cannot set size ', v)
-    _char_size = v
-
-    import base64  # to decode images
-    import io  # to read from binary buffers
-
-    decoded = base64.b64decode(_EMB_TILEMAPS_PNGF[_char_size])
-    filelike_bdata = io.BytesIO(decoded)
-    _curr_spritesheet = _hub.pygame.image.load(filelike_bdata)
-    _curr_spritesheet.set_colorkey('black')
-
-    if _KFont.inst:
-        _KFont.inst.surf = _curr_spritesheet
-        _KFont.inst.cached_letters.clear()  # reset cache!
-
-    # refresh gl variables
-    _last_col = -1 + defs.STD_SCR_SIZE[0] // _char_size
-    _last_row = -1 + defs.STD_SCR_SIZE[1] // _char_size
-
-
-# -------------------------------------------------
-#  hidden module elements
-# -------------------------------------------------
-class _AsciiArt:
-    def __init__(self, w, h, data=None):
-        self.size = (w, h)
-        self.data = data
-
-
-class _KFont:
-    inst = None
-
-    def __init__(self):
-        self.cached_letters = dict()
-
-        self.__class__.inst = self
-        if _curr_spritesheet is None:
-            set_char_size(_char_size)  # initialize tileset
-        self.surf = _curr_spritesheet
-
-    def render(self, karray_or_txt, fg_color, bg_color=None):
-        if isinstance(karray_or_txt, str):
-            inp = list(karray_or_txt)
-        else:
-            inp = karray_or_txt
-        rez = _hub.pygame.surface.Surface((_char_size * len(inp), _char_size))
-        rez.fill((0, 0, 0))
-        char_destpos = [0, 0]
-        for elt in inp:
-            s = self.fetch(elt)
-            rez.blit(s, char_destpos)
-            char_destpos[0] += _char_size
-        # replace fg color
-        fres = _hub.pygame.surface.Surface((_char_size * len(inp), _char_size))
-        if bg_color is None:
-            fres.fill((255, 0, 255))
-            fres.set_colorkey((255, 0, 255))
-        else:
-            fres.fill(bg_color)
-
-        _hub.pygame.transform.threshold(
-            fres, rez, (255, 255, 255), (0, 0, 0), _hub.pygame.Color(fg_color), inverse_set=True
-        )
-        return fres
-
-    def fetch(self, k):
-        k = mapping_letter_tileset_idx(k)
-
-        nbparcol = 16
-
-        if not isinstance(k, int):
-            raise ValueError('try to fetch by char code but that is not an int')
-
-        if k in self.cached_letters:
-            r = self.cached_letters[k]
-        else:
-            r = _hub.pygame.surface.Surface((_char_size, _char_size)).convert()
-            r.fill((255, 0, 255))
-            r.blit(
-                self.surf, (0, 0), (_char_size * (k % nbparcol), _char_size * (k // nbparcol), _char_size, _char_size)
-            )
-            r.set_colorkey((255, 0, 255))
-            self.cached_letters[k] = r
-        return r
-
-
-_char_size = 12  # default
-_curr_spritesheet = None
-_alphabet = _KFont()
-_screen = _matrix = None
+from .. import _hub
+from .. import struct
+from ..compo import vscreen
+from ..foundation import defs
+
+# - constants
+# character set that allows to draw a box with single line around it
+CODE_LINE_VERT = 16 * 11 + 3
+CODE_LINE_NE = 16 * 12 - 1
+CODE_LINE_SW = 16 * 12 + 0
+CODE_LINE_NW = 16 * 13 + 10
+CODE_LINE_HORZ = 16 * 12 + 4
+CODE_LINE_SE = 16 * 13 + 9
+
+# the character that allows to fill the space
+CODE_FILL = 13 * 16 + 11
+# all
+KNOWN_CODES = (
+    CODE_LINE_VERT, CODE_LINE_HORZ,
+    CODE_LINE_NE, CODE_LINE_SW, CODE_LINE_SE, CODE_LINE_NW,
+    CODE_FILL
+)
+
+# embedded png files white fg, black bg. I used base64.b64encode(fptr)...
+# Use base64.b64decode(encoded) to decode!
+_EMB_TILEMAPS_PNGF = {
+    8: b'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',
+    10: b'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',
+    12: b'iVBORw0KGgoAAAANSUhEUgAAAMAAAADACAIAAADdvvtQAAAOd0lEQVR42u1d27LjugrUcvn/fznnYapyvCUbNdBg2YGHqTWJoiviLvhrBSJ8Pp9pm7+/v7R+VoPduZvjmpE2EWcsj4K0WRlxT2d+bCMsTe7qCrPBvdo95/T5fD6fT/fJ6Q/HNt9P5KOdHvx3xG4UbZuIg78aa7pj3zYC3TruzHgQ2g6RKZ2exabane7HhsM4nuX4X7kx5Sp7uqKMBe7hP5xIo5qfA1zN5PSTzYkBMp4hbMV8GPLCELwEd/C4ri8I3R4bXLGP40CCGEDEHvPSOtLVobUagRDk8FOO6cF3nAKhwDmUw78/4zJPuzoyLwTVBNQHN+f0YmxEWoejc5oCImz94vDdPT+lD4UbKBCCVdODP06jEyFHUnH8CkGpqcozlTQTDv54h6/us3zPtYr2KdtVq/ECg8flm3+nPqVJskaDkzczrbItSpj2F9GdPLcTTRCMN/Pu7xDHP/6/kBvtQIhSjSj5oXYprQHwCntUn4MGHnx/cDPSFCN7at0KqAgU3U/E6jzj7oUivwxPdJ4UvAsFcXFEJcfgDoqrlogGx/W7sXxqj/O7cdR4v/1NpcqqznLq5UGsJuBaENUy1B+ylKj3uYYTOxBuNhBaZvqeOqSxWVpV2ixxXfJuG0w4EXOeGn43+sIQw13EBfJsN2hs5K5LIJlIDMJ0vSo/YNPEdRw/2XFGnkm3v9YqnNMhIQ1rcoqrkBgkJMjAbbm7tOO0yylkXHUuE8mXSRunSsDoSPGL4aednHbb+W6vqO+VTXLX2gbAQKccfaQjVKAqN91E85xV/ciedoSgykpo5wsKMvz8eXYN0cCnSj6o8NsCF3G+rgoPBeNH19fkQW+3QJ82z2o9MTFcwdnP71hzXiHEgmWFUVCg11gvKGp8Kxt/QUEBwcBTEA0b/VBVkXIJ+DENwNUiq2yF/xF0j32VQZ+l+WBGdY8ypZ+yXcki43bj8MjjhOlLmqunGnEz99vJwIuxJj3zPuvR6vaCJ4Wr8QomDUoMBm4qQ96AJr8bjLtCf0EXEewBD3m2Hf/oTvJEPuGrdho2KWYF56N3cFFLh7R2D0rM7+dP30vcuKIcazW356tNvoF+qsznUxTxhz7SiRBrSuvwOMlttywLw/ObCIfRDeQ/D6KoxBqLtSjbFd3aqtAFcNkI9YhbTi4md8KlGWnheMncMJt4liW6dqagoKDglLuphNZjY2dQFeX5t+od/lUDXCvkritHS+KqluO6ziMSPeol/mgQV2VtCoJhws45c60G+Uox0qBrvIN2mulXEVJ9gvvzRrMKRUWnrG4agi30v6vODNGEWUc1mnBW0FGXejmkCtCWF6sK45dY2L8uKBZSjx0M5AXaZMqNlG6nwSmL4rAtgrIazn2L4FANjnyY2uWm2fLAh/FIG4OoJAwUzTfpsUc2jNwjGBDlXVyyEKOK1nAeG0sGmvIdrZaKmPUlBKJjD6KtvExATp6VjEPO4BOkmc4ORMxJaKjzEGqbwYPOzAanOERMsAO1H8t79HgoV1dBQUHBVAgzGDC4zqmGxTIjYzWsGJZNljKYpmyy3emDf2FdHhcN7sK6ku227peIbQY5G7mf43Ay2gmddGPJaogcnDWdj8EAAarEtnz7uKmJEgwuRORtto48G60V5vGxkIo1z1IuKHOzJcM7ncN4Frt2sAhLBmuvketoQ7JfUPpsC99Dr05LjGfwt2GNtRT56fyb9KXxkysgMhCdhoHl1sClIT61BOuOagOR6lIRRNfiC+NiBksEUcme8n19IgPy714eBaKcND5dra09ej4r71XEDTzOYTyL/YiA/njeUcmXs5BO7UCIZQIsToC4tYnE4HTE6cK1Il0abj00G0RBQUFBwevBzAovAzT9ZTjBfpo79sj51CbzWQ/LN4fb/aJjmLbul6APqwX7wsbe3nTdcWOS0BKkGdOxnJknNi2Vu/KJRGuVr8Ghjj7Z1sXaf/+Z7ots6CMOfqqBZy4WfMkVfUu3ESVZHmC5Gk1bL2oT8c/IGw0m0OQa3+/dw+2UZaqe2tuuWqazjI5hiOMpJ3Hd7Xu4RdzU6dq6O3ovDn3ngKTco+M9xY114x5unok+QnxZKi8z+Lz1QTi04cQZYXBa4gS+RXcm7c40B4AeOm75DnkPY5VlJ9Ut19q7IScTS0FBCrkreB/sdBTkErecXNrcnzvzJ6lyk93OSjauMM+vKh2TMOT2dfnHWiQN+X7jTt2l0q+DAT/HwrS5eRs1nCOOkh9n66mGwcpZY2CIyAZ6UgBezXnT3i3QFOsM5wCd1Yh1GCng+u0EwR45mgV8HMJN/TSlc84UgMI+706kXoGtTFGZaIPO5DuPCGLfbetZStt/q9xGCdhI1cJuAeJ7Gue7sAVtYOsHLGy2jZ7KLqp4oKsUJ/JYDfOFgTEYFB/ftCIzgqassYgU+tGFglNJYDQdyhwriUYWArVcq265ogsKigI9jTR6Sm81TUp8rZSzPWL7fhl7PD4vMONl10Y13FbYUwDaC84V4VH9FtBw6jPCnUqqNL/NXRLK+bSZ/vx5qmazamqpmhmY6dYhIOifku03U7RVpfldIW5BTrJk4yw2f+0Vk/ITGBD/XGl+VUPKCZ0oPD6TabIqoSJZvfHzxoPzG6Mai9eZqt0mHId+UzqWN5DlCAvd5O2uHcRds06LLe42AR8WNt8zo6CnYTlHdiJsXBFwW/CRIeLMY8bQyuzTb8EKeaygM62RJsIOxKcK9MY/aL/5nc3501KOVt6c2pZTFpYsLbIsE9pMb5TnQWnTdmq7xLGuroeiChVouNPKAf7iXLgZzbmhadMGJ4y7usAGBgPpNjaiRMHl5EnJDNhbbdqgGouH09tscn9mAvNQAaWENg+hGvdwF9DWzMKSa3XjbVhmheg2mZNpcEEIr/IJhmOqojbBGGFKmyY+DUOej6W1ydwc55zDC86ZqQKxjJxK2sDtnwkzXx/2IPVPJfbHtWns52yUqmQLimJmpN+ip/W4q/abRnZz1UddNXLQ90Tph9VG2xUuj5tzFahcijltnDVAfv3+1doJMtAv713hzSMvon8gSrJc4nq5avwzhCe6/mWQAxL8Sohwoy2LlPOG1bM0Vf0yVVnjE19YBPZcyfZpfiVVYTJikhCWoRVBL+fkvxH+YNaHbrh9PHVKADaeoHqaXr4B4cOegcD7h3TVbbHHM6ByLyRblS59YXKgLl6u0UCogtoQddRMFkZExGjYcIzuXjOx0hI2R1nMoAo6jzPxTfm7fDGmOIr6wlSpVeUQk8pElGN3UNVAPsWSI9uZFtIbB9pxfsSK6yvw62LgKWjDRw0nu5VhjcgOVhvLkAbPGJGocqx0Stax5akWdm/MFNGnhmip9Dgv/5MEuZ/xsVvHy2TOU2yIbNzLGUulEYMI1Ez1XwqBaEaHH+XstkvGSkvDemdTov0qCLQO9oDJrPCkWH6hJIeFjUPYPsmZ87Yy9sha6NfCJuRrepw1UsjrpWpToNNRG5AZ/inxFflzlnuTv/2L0z9lc4AqkeBUP2++nIQUFia7+rVtwGRFfqbhdBe6Xm7bJsRycHanfot04ucjYEYi+beIFEh5LDq2fHxI67Gwi81eAtpUbrEACaQRjJzhvDq9hv0Kvx6HQ1PWIPx8QZtTl2Syc5iPLMxc6urbs5CVEcrO8WxrRC4SnGcLNMVdnD+2ErNUc7n2iBajEC2wuT+VUc5Qx9WTsByXkzItNMko60+3GLozZTlY3VQBEtoyBRW8CNnHv6f/fsUC4W9EkqC3Wa0gIfFVRnIqmVPYBIGjCxCR/xV+3ipC7b2wyajTDinc5X+nWFh7/UrY21CkZ/wbwaH23xDM07+DRMtMMVZQs0PXRS+NwOqnKFDBuygQ0hIhAM48c1dB5tzXlVqjWlO+YHcSUeSHRYEK3kWBWNQFERpOrdjI9fUTCXM/BgodSumLAhX8nhYWpASZx2KpSCqqGSFvlRZWcIchsSzRBUy7GauuAGWsnDmv5sNas5/Tb7e6MwVeFlZQ4NLCfopBEzWR8S2EjY+wasHkuMm6b4sCFQRQoKCCRWbTKou64CRHfmnlTPhKN8bc2E9RoAIqBSKWo25Zz7LwsXAZSFVAM4iynprQMscqClRQWhgVgmow0n8FPvi6cayiQAUcKAQq8BH1U1E0uRZEY+dMuXc+5jnHBYuxQsyKAhUUCyt4nBbGIq1OFnM1VuhLCSQo+5fD5YoCFfgokPAIYVr9yUml8LE8VhCnhzxI/HxNiOZed+hZkIl5yOXZ6dQFzBFOlIGQNuZUwKHyX+bzkpKBCh7LwpCcjzdS0VBV6Ma1FwUqKAQqKCgoCJQxPGqkLXkxmFXeGaeSoD87c2RPF5WZlto8lr0yiL9OijaP+AqiK7HQTMutEucc6wrDtmOLLj3vzbQx8VE9uPbjE+Dbl4/M+XMAP/ac1uTbrq6O5yIedyH6xclngNMG498qctjSCxvKyDqmT2lijYs4vN+uzgl5+hS9icgtbEPtS8Mo/6kewngl4i8hyEVWpETp1Q18sBqvlQMWcQUIeHxEiMxgS3DOhhu43cjmIzYigRyuYIw+ZV6n7r8gkfwL+3ewLikdcpY31pe869jWmdVU2MDl1Ks6c7FqPLGNoPFy7S5TDBDuBmU+Y6G05ih3n2YHYj64WEHDf/eECwp7CgpRClRCdIFfUAgdUZBLwKKqsTVTVWWzp2KUNt8K4lB0Su4q2dlcBzgCgZBFmZePnLvcZo9AT1AzxJft0TNxJA4d5XbCyc1M8sWqTTsVMKcw7oVIs5ogFpH2uqDV6OXsBhaWD6z6N6cdgo6wruhHXAVuIhXs/Aqxlmj8ICnmxKVYBiIDtazoHByHpsbohL3d484j2ogOomm+DOTMJvYsaczCwkBhIpQ3ReD0WHboRpb9FMuWjoUh/iBWG+1GU56HrnPppy7tuwxgD9Mgyr68ONS7sAIX/A/JbE+WwZUqUwAAAABJRU5ErkJggg==',
+    16: b'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',
+    20: b'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'
+}
+
+# global vars
+_lastcol = _lastrow = None
+_sm_ready = False
+
+
+# -------------------------------------------------
+#  PUBLIC module-level functions
+# -------------------------------------------------
+def cpos_to_screen(cpos):
+    i, j = cpos
+    return i * _char_size, j * _char_size
+
+
+def get_char_size():
+    return _char_size
+
+
+def increm_char_size():
+    loop = [8, 10, 12, 16, 20]
+    pos = loop.index(_char_size)
+    pos = (pos + 1) % len(loop)
+    set_char_size(loop[pos])
+
+
+def init(upscaling_int):
+    global _screen, _matrix, _sm_ready, _lastcol, _lastrow
+    _sm_ready = True
+    _screen = vscreen.get_screen()
+    scrw, scrh = _screen.get_size()
+    adhocw = scrw // _char_size
+    adhoch = scrh // _char_size
+    if adhocw != scrw / _char_size:
+        raise ValueError('div tombe pas juste pour calculer w')
+    if adhoch != scrh / _char_size:
+        raise ValueError('div tombe pas juste pour calculer h')
+    _matrix = struct.IntegerMatrix((adhocw, adhoch))
+    _lastcol = -1 + adhocw
+    _lastrow = -1 + adhoch
+
+
+def is_ready():
+    global _sm_ready
+    return _sm_ready
+
+
+def reset():
+    global _sm_ready
+    _sm_ready = False
+    # TODO permettre de remettre a zero le buffer
+
+
+def flush():
+    pass  # TODO use a buffer for put_char, then use flush to draw everything on screen
+
+
+def get_bounds():
+    return _lastcol + 1, _lastrow + 1
+
+
+def is_inside(ij_coords):
+    i, j = ij_coords
+    return -1 < i < _lastcol + 1 and -1 < j < _lastrow + 1
+
+
+def put_char(identifier, arraypos, fgcolor, bgcolor=None, dest_surf=None):
+    if bgcolor is None and identifier == ' ':  # skip if nothing to show
+        return
+
+    if _screen is None:
+        raise Exception('put_char called but the .ascii submodule has not been init!')
+    if fgcolor == (255, 255, 255):
+        good_s = _alphabet.fetch(identifier)
+    else:
+        good_s = _alphabet.render([identifier, ], fgcolor, bgcolor)
+    if dest_surf:
+        target_s = dest_surf
+    else:
+        target_s = _screen
+    target_s.blit(good_s, (_char_size * arraypos[0], _char_size * arraypos[1]))
+
+
+def get_charsize():  # like a property, but on module => read-only var.
+    return _char_size
+
+
+# def paste(self, src_surf, pos):
+#     self.screen.blit(src_surf, (pos[0]*_char_size, pos[1]*_char_size))
+_corresp_table = dict()
+
+
+def mapping_letter_tileset_idx(lettre):
+    global _corresp_table
+    # corresp caracteres & indice tile
+    nbparcol = 16
+    if not len(_corresp_table):  # empty dict
+        for y in range(32, 32 + nbparcol * 9):
+            _corresp_table[chr(y)] = y
+
+    if lettre in KNOWN_CODES:
+        return lettre
+    if lettre == '/':
+        return 3 * nbparcol - 1
+    if lettre == '\\':
+        return 6 * nbparcol - 4
+    if lettre in _corresp_table:
+        return _corresp_table[lettre]
+    import binascii
+    print('*warning:couldnt map letter to tileset idx: {}[{}]'.format(lettre, str(binascii.hexlify(lettre.encode()))))
+
+    return 0
+
+
+def screen_to_cpos(pos):
+    a, b = pos[0] // _char_size, pos[1] // _char_size
+    return a, b
+
+
+def set_char_size(v):
+    global _char_size, _curr_spritesheet, _lastcol, _lastrow
+    if v not in _EMB_TILEMAPS_PNGF.keys():
+        raise ValueError('cannot set size ', v)
+    _char_size = v
+
+    import base64  # to decode images
+    import io  # to read from binary buffers
+
+    decoded = base64.b64decode(_EMB_TILEMAPS_PNGF[_char_size])
+    filelike_bdata = io.BytesIO(decoded)
+    _curr_spritesheet = _hub.pygame.image.load(filelike_bdata)
+    _curr_spritesheet.set_colorkey('black')
+
+    if _KFont.inst:
+        _KFont.inst.surf = _curr_spritesheet
+        _KFont.inst.cached_letters.clear()  # reset cache!
+
+    # refresh gl variables
+    _last_col = -1 + defs.STD_SCR_SIZE[0] // _char_size
+    _last_row = -1 + defs.STD_SCR_SIZE[1] // _char_size
+
+
+# -------------------------------------------------
+#  hidden module elements
+# -------------------------------------------------
+class _AsciiArt:
+    def __init__(self, w, h, data=None):
+        self.size = (w, h)
+        self.data = data
+
+
+class _KFont:
+    inst = None
+
+    def __init__(self):
+        self.cached_letters = dict()
+
+        self.__class__.inst = self
+        if _curr_spritesheet is None:
+            set_char_size(_char_size)  # initialize tileset
+        self.surf = _curr_spritesheet
+
+    def render(self, karray_or_txt, fg_color, bg_color=None):
+        if isinstance(karray_or_txt, str):
+            inp = list(karray_or_txt)
+        else:
+            inp = karray_or_txt
+        rez = _hub.pygame.surface.Surface((_char_size * len(inp), _char_size))
+        rez.fill((0, 0, 0))
+        char_destpos = [0, 0]
+        for elt in inp:
+            s = self.fetch(elt)
+            rez.blit(s, char_destpos)
+            char_destpos[0] += _char_size
+        # replace fg color
+        fres = _hub.pygame.surface.Surface((_char_size * len(inp), _char_size))
+        if bg_color is None:
+            fres.fill((255, 0, 255))
+            fres.set_colorkey((255, 0, 255))
+        else:
+            fres.fill(bg_color)
+
+        _hub.pygame.transform.threshold(
+            fres, rez, (255, 255, 255), (0, 0, 0), _hub.pygame.Color(fg_color), inverse_set=True
+        )
+        return fres
+
+    def fetch(self, k):
+        k = mapping_letter_tileset_idx(k)
+
+        nbparcol = 16
+
+        if not isinstance(k, int):
+            raise ValueError('try to fetch by char code but that is not an int')
+
+        if k in self.cached_letters:
+            r = self.cached_letters[k]
+        else:
+            r = _hub.pygame.surface.Surface((_char_size, _char_size)).convert()
+            r.fill((255, 0, 255))
+            r.blit(
+                self.surf, (0, 0), (_char_size * (k % nbparcol), _char_size * (k // nbparcol), _char_size, _char_size)
+            )
+            r.set_colorkey((255, 0, 255))
+            self.cached_letters[k] = r
+        return r
+
+
+_char_size = 12  # default
+_curr_spritesheet = None
+_alphabet = _KFont()
+_screen = _matrix = None
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/dialogue.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/dialogue.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,239 +1,239 @@
-import json
-
-from . import rpgmenu
-from ... import _hub
-from ... import pal
-from ...core.events import EvListener, EngineEvTypes
-
-
-frects = _hub.polarbear.frects
-pygame = _hub.pygame
-
-
-class Offer:
-    """
-    An Offer is a single line spoken by the NPC, "effect" is
-    a callable with no parameters.
-    "replies" is a list of replies.
-    """
-    def __init__(self, msg, effect=None, replies=()):
-        self.msg = msg
-        self.effect = effect
-        self.replies = list(replies)
-
-    def __str__(self):
-        return self.msg
-
-    @classmethod
-    def from_json(cls, jdict):
-        # We spoke about not needing a json loader yet. But, in terms of hardcoding
-        # a conversation, it was just as easy to write this as to hand-code a dialogue tree.
-        msg = jdict.get("msg", "Hello there!")
-        effect = None
-        replies = list()
-        for rdict in jdict.get("replies", ()):
-            replies.append(Reply.from_json(rdict))
-        return cls(msg, effect, replies)
-
-    @classmethod
-    def load_jsondata(cls, jsondata):
-        return cls.from_json(json.loads(jsondata))
-
-
-class Reply:
-    """
-    A Reply is a single line spoken by the PC, leading to a new offer
-    """
-    def __init__(self, msg, destination=None):
-        self.msg = msg
-        self.destination = destination
-
-    def __str__(self):
-        return self.msg
-
-    def apply_to_menu(self, mymenu):
-        mymenu.add_item(self.msg, self.destination)
-
-    @classmethod
-    def from_json(cls, jdict):
-        msg = jdict.get("msg", "And you too!")
-        destination = jdict.get("destination")
-        if destination:
-            destination = Offer.from_json(destination)
-        return cls(msg, destination)
-
-
-class ConversationView(EvListener):
-    """
-    The View is used by the conversation when conversing.
-    It has a "text" property and "render", "get_menu" methods.
-    """
-    TEXT_AREA = frects.Frect(-75, -100, 300, 100)
-    MENU_AREA = frects.Frect(-75, 30, 300, 80)
-    PORTRAIT_AREA = frects.Frect(-240, -110, 150, 225)
-    CONV_BG_COL = pal.niobe['darkgreen']
-    MENU_BORDER_COL = pal.punk['gray']
-    DEBUG = True
-
-    def __init__(self, root_offer, chosen_font, ft_size, portrait_fn=None, pre_render=None, li_alt_font_obj=None):
-        # --------------------
-        #  constructor
-        # --------------------
-        super().__init__()
-
-        # n.b: need to use EmbeddedCfont, or no?
-        if li_alt_font_obj:  # defaults to capello ft
-            self._capfont = li_alt_font_obj
-            # self.capfont = [
-            #     gfx.JsonBasedCfont(capfont_path_prfix + '-b'),  # blue-ish
-            #     gfx.JsonBasedCfont(capfont_path_prfix+'-a'),  # orange
-            # ]
-        else:
-            self._capfont = None
-
-        # - slight optim:
-        self.text_rect = None
-        self.menu_rect = None
-        self.portrait_rect = None
-
-        # can be used to make things faster for webctx
-        self._primitive_style = False
-
-        self.text = ''
-        self.root_offer = root_offer
-        self.pre_render = pre_render
-        self._pg_font = pygame.font.Font(chosen_font, ft_size)
-        if portrait_fn:
-            self.portrait = pygame.image.load(portrait_fn).convert_alpha()
-        else:
-            self.portrait = None
-        self.curr_offer = root_offer
-
-        self.existing_menu = None
-
-        if self._capfont:
-            self.activefont = self._capfont[0]
-            self.alternative_menu_flag = True
-        else:
-            self.activefont = self._pg_font
-            self.alternative_menu_flag = False
-
-    def refresh(self):
-        # get the repr zero ready
-        self.update_dialog_repr()
-
-    def on_paint(self, ev):
-        if self.primitive_style:
-            self._primitiv_render(ev.screen)
-        else:
-            self._reg_render(ev.screen)
-
-    def on_conv_step(self, ev):  # iterate over the conversation
-        print('CONV step RECV in dialogue')
-        self.curr_offer = ev.value
-        self.update_dialog_repr()
-
-    def on_mousemotion(self, ev):
-        if self.existing_menu:
-            self.existing_menu.proc_event(ev, None)
-
-    def on_mousedown(self, ev):
-        if self.existing_menu:
-            self.existing_menu.proc_event(ev, None)
-
-    def on_mouseup(self, ev):
-        # /!\ its the mouse_up that allows to switch the rpgmenu state
-        if self.existing_menu:
-            self.existing_menu.proc_event(ev, None)
-
-    def _primitiv_render(self, refscreen):
-        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.glob_rect)  # fond de fenetre
-        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.text_rect)
-
-        #if not self.capfont:
-            # old fashion
-
-        _hub.polarbear.draw_text(
-            self.activefont, self.text, self.text_rect, dest_surface=refscreen
-        )
-        # refscreen.blit(newsurf, (self.text_rect[0], self.text_rect[1]))
-
-        #else:  # we've overriden the basic behavior
-            # signatur is:
-            #  text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None)
-        #    self.capfont[0].text_to_surf(self.text, refscreen, (self.text_rect[0], self.text_rect[1]))
-
-        if self.portrait:
-            refscreen.blit(self.portrait, self.portrait_rect)
-        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.menu_rect)
-
-        if self.existing_menu:  # draw what the player can SAY
-            if self.alternative_menu_flag:  # we have overriden the default behavior, when using a special kengi font
-                self.existing_menu.alt_render(refscreen, self._capfont[0], self._capfont[1])
-
-            else:  # the old fashion
-                self.existing_menu.render(refscreen)
-
-        # pourtour menu
-        pygame.draw.rect(refscreen, self.MENU_BORDER_COL, (self.taquet_portrait, 148, self.dim_menux, 88), 2)
-
-    def _reg_render(self, refscreen):
-        if self.pre_render:
-            self.pre_render()
-        text_rect = self.TEXT_AREA.get_rect()
-        dborder = _hub.polarbear.default_border
-        dborder.render(text_rect)
-        _hub.polarbear.draw_text(self.activefont, self.text, text_rect)
-        dborder.render(self.MENU_AREA.get_rect())
-        if self.existing_menu:
-            self.existing_menu.render(refscreen)
-        if self.portrait:
-            refscreen.blit(self.portrait, self.PORTRAIT_AREA.get_rect())
-
-    @property
-    def primitive_style(self):
-        return self._primitive_style
-
-    @primitive_style.setter
-    def primitive_style(self, use_new_layout: bool):
-        self._primitive_style = use_new_layout
-
-        if use_new_layout:
-            print('ConversationView -> use_new_layout!')
-            # modify locations as we know that (Primitive style => upscaling is set to x3)
-            x = 48
-            w = 192
-            self.TEXT_AREA = frects.Frect(-x, -66, w, 80)
-            self.MENU_AREA = frects.Frect(-x, 33, w, 80)
-            self.PORTRAIT_AREA = frects.Frect(-x-100, -66, 90, 128)
-
-            # optim:
-            self.dim_menux = w+100
-            self.text_rect = self.TEXT_AREA.get_rect()
-            self.menu_rect = self.MENU_AREA.get_rect()
-            self.portrait_rect = self.PORTRAIT_AREA.get_rect()
-            self.taquet_portrait = self.portrait_rect[0]
-            self.glob_rect = pygame.Rect(self.portrait_rect[0], 53, self.dim_menux, 182)
-
-    def update_dialog_repr(self):
-        if self.curr_offer:
-            self.text = self.curr_offer.msg
-            # create a new Menu inst.
-            self.existing_menu = rpgmenu.Menu(
-                self.MENU_AREA.dx, self.MENU_AREA.dy, self.MENU_AREA.w, self.MENU_AREA.h,
-                border=None, predraw=None, font=self.activefont
-            )
-            # predraw: self.render
-            mymenu = self.existing_menu
-            for i in self.curr_offer.replies:
-                i.apply_to_menu(mymenu)
-            if self.text and not mymenu.items:
-                mymenu.add_item("[Continue]", None)
-            else:
-                mymenu.sort()
-            nextfx = self.curr_offer.effect
-            if nextfx:
-                nextfx()
-        else:
-            # auto-close everything
-            self.pev(EngineEvTypes.ConvFinish)
+import json
+
+from . import rpgmenu
+from ... import _hub
+from ... import pal
+from ...core.events import EvListener, EngineEvTypes
+
+
+frects = _hub.polarbear.frects
+pygame = _hub.pygame
+
+
+class Offer:
+    """
+    An Offer is a single line spoken by the NPC, "effect" is
+    a callable with no parameters.
+    "replies" is a list of replies.
+    """
+    def __init__(self, msg, effect=None, replies=()):
+        self.msg = msg
+        self.effect = effect
+        self.replies = list(replies)
+
+    def __str__(self):
+        return self.msg
+
+    @classmethod
+    def from_json(cls, jdict):
+        # We spoke about not needing a json loader yet. But, in terms of hardcoding
+        # a conversation, it was just as easy to write this as to hand-code a dialogue tree.
+        msg = jdict.get("msg", "Hello there!")
+        effect = None
+        replies = list()
+        for rdict in jdict.get("replies", ()):
+            replies.append(Reply.from_json(rdict))
+        return cls(msg, effect, replies)
+
+    @classmethod
+    def load_jsondata(cls, jsondata):
+        return cls.from_json(json.loads(jsondata))
+
+
+class Reply:
+    """
+    A Reply is a single line spoken by the PC, leading to a new offer
+    """
+    def __init__(self, msg, destination=None):
+        self.msg = msg
+        self.destination = destination
+
+    def __str__(self):
+        return self.msg
+
+    def apply_to_menu(self, mymenu):
+        mymenu.add_item(self.msg, self.destination)
+
+    @classmethod
+    def from_json(cls, jdict):
+        msg = jdict.get("msg", "And you too!")
+        destination = jdict.get("destination")
+        if destination:
+            destination = Offer.from_json(destination)
+        return cls(msg, destination)
+
+
+class ConversationView(EvListener):
+    """
+    The View is used by the conversation when conversing.
+    It has a "text" property and "render", "get_menu" methods.
+    """
+    TEXT_AREA = frects.Frect(-75, -100, 300, 100)
+    MENU_AREA = frects.Frect(-75, 30, 300, 80)
+    PORTRAIT_AREA = frects.Frect(-240, -110, 150, 225)
+    CONV_BG_COL = pal.niobe['darkgreen']
+    MENU_BORDER_COL = pal.punk['gray']
+    DEBUG = True
+
+    def __init__(self, root_offer, chosen_font, ft_size, portrait_fn=None, pre_render=None, li_alt_font_obj=None):
+        # --------------------
+        #  constructor
+        # --------------------
+        super().__init__()
+
+        # n.b: need to use EmbeddedCfont, or no?
+        if li_alt_font_obj:  # defaults to capello ft
+            self._capfont = li_alt_font_obj
+            # self.capfont = [
+            #     gfx.JsonBasedCfont(capfont_path_prfix + '-b'),  # blue-ish
+            #     gfx.JsonBasedCfont(capfont_path_prfix+'-a'),  # orange
+            # ]
+        else:
+            self._capfont = None
+
+        # - slight optim:
+        self.text_rect = None
+        self.menu_rect = None
+        self.portrait_rect = None
+
+        # can be used to make things faster for webctx
+        self._primitive_style = False
+
+        self.text = ''
+        self.root_offer = root_offer
+        self.pre_render = pre_render
+        self._pg_font = pygame.font.Font(chosen_font, ft_size)
+        if portrait_fn:
+            self.portrait = pygame.image.load(portrait_fn).convert_alpha()
+        else:
+            self.portrait = None
+        self.curr_offer = root_offer
+
+        self.existing_menu = None
+
+        if self._capfont:
+            self.activefont = self._capfont[0]
+            self.alternative_menu_flag = True
+        else:
+            self.activefont = self._pg_font
+            self.alternative_menu_flag = False
+
+    def refresh(self):
+        # get the repr zero ready
+        self.update_dialog_repr()
+
+    def on_paint(self, ev):
+        if self.primitive_style:
+            self._primitiv_render(ev.screen)
+        else:
+            self._reg_render(ev.screen)
+
+    def on_conv_step(self, ev):  # iterate over the conversation
+        print('CONV step RECV in dialogue')
+        self.curr_offer = ev.value
+        self.update_dialog_repr()
+
+    def on_mousemotion(self, ev):
+        if self.existing_menu:
+            self.existing_menu.proc_event(ev, None)
+
+    def on_mousedown(self, ev):
+        if self.existing_menu:
+            self.existing_menu.proc_event(ev, None)
+
+    def on_mouseup(self, ev):
+        # /!\ its the mouse_up that allows to switch the rpgmenu state
+        if self.existing_menu:
+            self.existing_menu.proc_event(ev, None)
+
+    def _primitiv_render(self, refscreen):
+        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.glob_rect)  # fond de fenetre
+        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.text_rect)
+
+        #if not self.capfont:
+            # old fashion
+
+        _hub.polarbear.draw_text(
+            self.activefont, self.text, self.text_rect, dest_surface=refscreen
+        )
+        # refscreen.blit(newsurf, (self.text_rect[0], self.text_rect[1]))
+
+        #else:  # we've overriden the basic behavior
+            # signatur is:
+            #  text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None)
+        #    self.capfont[0].text_to_surf(self.text, refscreen, (self.text_rect[0], self.text_rect[1]))
+
+        if self.portrait:
+            refscreen.blit(self.portrait, self.portrait_rect)
+        pygame.draw.rect(refscreen, self.CONV_BG_COL, self.menu_rect)
+
+        if self.existing_menu:  # draw what the player can SAY
+            if self.alternative_menu_flag:  # we have overriden the default behavior, when using a special kengi font
+                self.existing_menu.alt_render(refscreen, self._capfont[0], self._capfont[1])
+
+            else:  # the old fashion
+                self.existing_menu.render(refscreen)
+
+        # pourtour menu
+        pygame.draw.rect(refscreen, self.MENU_BORDER_COL, (self.taquet_portrait, 148, self.dim_menux, 88), 2)
+
+    def _reg_render(self, refscreen):
+        if self.pre_render:
+            self.pre_render()
+        text_rect = self.TEXT_AREA.get_rect()
+        dborder = _hub.polarbear.default_border
+        dborder.render(text_rect)
+        _hub.polarbear.draw_text(self.activefont, self.text, text_rect)
+        dborder.render(self.MENU_AREA.get_rect())
+        if self.existing_menu:
+            self.existing_menu.render(refscreen)
+        if self.portrait:
+            refscreen.blit(self.portrait, self.PORTRAIT_AREA.get_rect())
+
+    @property
+    def primitive_style(self):
+        return self._primitive_style
+
+    @primitive_style.setter
+    def primitive_style(self, use_new_layout: bool):
+        self._primitive_style = use_new_layout
+
+        if use_new_layout:
+            print('ConversationView -> use_new_layout!')
+            # modify locations as we know that (Primitive style => upscaling is set to x3)
+            x = 48
+            w = 192
+            self.TEXT_AREA = frects.Frect(-x, -66, w, 80)
+            self.MENU_AREA = frects.Frect(-x, 33, w, 80)
+            self.PORTRAIT_AREA = frects.Frect(-x-100, -66, 90, 128)
+
+            # optim:
+            self.dim_menux = w+100
+            self.text_rect = self.TEXT_AREA.get_rect()
+            self.menu_rect = self.MENU_AREA.get_rect()
+            self.portrait_rect = self.PORTRAIT_AREA.get_rect()
+            self.taquet_portrait = self.portrait_rect[0]
+            self.glob_rect = pygame.Rect(self.portrait_rect[0], 53, self.dim_menux, 182)
+
+    def update_dialog_repr(self):
+        if self.curr_offer:
+            self.text = self.curr_offer.msg
+            # create a new Menu inst.
+            self.existing_menu = rpgmenu.Menu(
+                self.MENU_AREA.dx, self.MENU_AREA.dy, self.MENU_AREA.w, self.MENU_AREA.h,
+                border=None, predraw=None, font=self.activefont
+            )
+            # predraw: self.render
+            mymenu = self.existing_menu
+            for i in self.curr_offer.replies:
+                i.apply_to_menu(mymenu)
+            if self.text and not mymenu.items:
+                mymenu.add_item("[Continue]", None)
+            else:
+                mymenu.sort()
+            nextfx = self.curr_offer.effect
+            if nextfx:
+                nextfx()
+        else:
+            # auto-close everything
+            self.pev(EngineEvTypes.ConvFinish)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/pathfinding.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/pathfinding.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,109 +1,109 @@
-# Cribbed from the Red Blob Games tutorial.
-import heapq
-
-
-class PriorityQueue:
-    def __init__(self):
-        self.elements = []
-
-    def empty(self):
-        return len(self.elements) == 0
-
-    def put(self, item, priority):
-        heapq.heappush(self.elements, (priority, item))
-
-    def get(self):
-        return heapq.heappop(self.elements)[1]
-
-
-class AStarPath(object):
-    DELTA8 = (
-        (-1, -1),
-        (0, -1),
-        (1, -1),
-
-        (-1, 0),
-        (1, 0),
-
-        (-1, 1),
-        (0, 1),
-        (1, 1))
-    # DELTA4 = ((0, -1), (-1, 0), (1, 0), (0, 1))
-
-    def __init__(self, mymap, start, goal, blocked_fun, clamp_fun, wrap_x=False, wrap_y=False, blocked_tiles=()):
-        # blocked_fun is a function that takes mymap, x, y and returns True if movement into that tile is blocked.y
-        # clamp_fun is a function that takes (x,y) and clamps the values if needed.
-
-        # TEMP disabled clamp bc it creates BUGS! in niobe
-
-        # start = clamp_fun(start)
-        self.start = start
-        # goal = clamp_fun(goal)
-        self.goal = goal
-        self.blocked_tiles = set(blocked_tiles)
-        self.mymap = mymap
-        self.blocked_fun = blocked_fun
-        self.clamp_fun = lambda x:x  # clamp_fun
-        self.wrap_x = wrap_x
-        self.wrap_y = wrap_y
-        frontier = PriorityQueue()
-        frontier.put(self.start, 0)
-        self.came_from = {}
-        self.cost_to_tile = {}
-        self.came_from[self.start] = None
-        self.cost_to_tile[self.start] = 0
-        self.cpt = 0
-        while not frontier.empty() and self.cpt < 256:
-            current = frontier.get()
-            if current == goal:
-                break
-            for next in self.neighbors(mymap, current):
-                new_cost = self.cost_to_tile[current] + self.movecost(current, next)
-                if next not in self.cost_to_tile or new_cost < self.cost_to_tile[next]:
-                    self.cost_to_tile[next] = new_cost
-                    priority = new_cost + self.heuristic(goal, next)
-                    frontier.put(next, priority)
-                    self.came_from[next] = current
-        self.results = self.get_path(goal)
-
-    def get_path(self, goal):
-        results = list()
-        p = goal
-        while p:
-            results.append(p)
-            p = self.came_from.get(p)
-        results.reverse()
-        if results[0] != self.start:
-            results = list()
-        return results
-
-    def neighbors(self, mymap, pos):
-        self.cpt += 1
-        x, y = pos
-        for dx, dy in self.DELTA8:
-            #x2, y2 = x + dx, y + dy
-            x2, y2 = self.clamp_fun((x + dx/2, y + dy/2))
-            #x2, y2 = int(x2), int(y2)
-            if not( ((x2, y2) in self.blocked_tiles) or self.blocked_fun(mymap, int(x2), int(y2)) ):
-                yield (x2, y2)
-            elif (x2, y2) == self.goal:
-                yield self.goal
-
-    def movecost(self, a, b):
-        xcost = abs(a[0] - b[0])
-        ycost = abs(a[1] - b[1])
-        if self.wrap_x:
-            xcost = min(xcost, self.mymap.width - xcost)
-        if self.wrap_y:
-            ycost = min(ycost, self.mymap.height - ycost)
-        return 1 + xcost + ycost
-
-    def heuristic(self, a, b):
-        # Manhattan distance on a square grid
-        dx = abs(a[0] - b[0])
-        dy = abs(a[1] - b[1])
-        if self.wrap_x:
-            dx = min(dx, self.mymap.width - dx)
-        if self.wrap_y:
-            dy = min(dy, self.mymap.height - dy)
-        return dx + dy
+# Cribbed from the Red Blob Games tutorial.
+import heapq
+
+
+class PriorityQueue:
+    def __init__(self):
+        self.elements = []
+
+    def empty(self):
+        return len(self.elements) == 0
+
+    def put(self, item, priority):
+        heapq.heappush(self.elements, (priority, item))
+
+    def get(self):
+        return heapq.heappop(self.elements)[1]
+
+
+class AStarPath(object):
+    DELTA8 = (
+        (-1, -1),
+        (0, -1),
+        (1, -1),
+
+        (-1, 0),
+        (1, 0),
+
+        (-1, 1),
+        (0, 1),
+        (1, 1))
+    # DELTA4 = ((0, -1), (-1, 0), (1, 0), (0, 1))
+
+    def __init__(self, mymap, start, goal, blocked_fun, clamp_fun, wrap_x=False, wrap_y=False, blocked_tiles=()):
+        # blocked_fun is a function that takes mymap, x, y and returns True if movement into that tile is blocked.y
+        # clamp_fun is a function that takes (x,y) and clamps the values if needed.
+
+        # TEMP disabled clamp bc it creates BUGS! in niobe
+
+        # start = clamp_fun(start)
+        self.start = start
+        # goal = clamp_fun(goal)
+        self.goal = goal
+        self.blocked_tiles = set(blocked_tiles)
+        self.mymap = mymap
+        self.blocked_fun = blocked_fun
+        self.clamp_fun = lambda x:x  # clamp_fun
+        self.wrap_x = wrap_x
+        self.wrap_y = wrap_y
+        frontier = PriorityQueue()
+        frontier.put(self.start, 0)
+        self.came_from = {}
+        self.cost_to_tile = {}
+        self.came_from[self.start] = None
+        self.cost_to_tile[self.start] = 0
+        self.cpt = 0
+        while not frontier.empty() and self.cpt < 256:
+            current = frontier.get()
+            if current == goal:
+                break
+            for next in self.neighbors(mymap, current):
+                new_cost = self.cost_to_tile[current] + self.movecost(current, next)
+                if next not in self.cost_to_tile or new_cost < self.cost_to_tile[next]:
+                    self.cost_to_tile[next] = new_cost
+                    priority = new_cost + self.heuristic(goal, next)
+                    frontier.put(next, priority)
+                    self.came_from[next] = current
+        self.results = self.get_path(goal)
+
+    def get_path(self, goal):
+        results = list()
+        p = goal
+        while p:
+            results.append(p)
+            p = self.came_from.get(p)
+        results.reverse()
+        if results[0] != self.start:
+            results = list()
+        return results
+
+    def neighbors(self, mymap, pos):
+        self.cpt += 1
+        x, y = pos
+        for dx, dy in self.DELTA8:
+            #x2, y2 = x + dx, y + dy
+            x2, y2 = self.clamp_fun((x + dx/2, y + dy/2))
+            #x2, y2 = int(x2), int(y2)
+            if not( ((x2, y2) in self.blocked_tiles) or self.blocked_fun(mymap, int(x2), int(y2)) ):
+                yield (x2, y2)
+            elif (x2, y2) == self.goal:
+                yield self.goal
+
+    def movecost(self, a, b):
+        xcost = abs(a[0] - b[0])
+        ycost = abs(a[1] - b[1])
+        if self.wrap_x:
+            xcost = min(xcost, self.mymap.width - xcost)
+        if self.wrap_y:
+            ycost = min(ycost, self.mymap.height - ycost)
+        return 1 + xcost + ycost
+
+    def heuristic(self, a, b):
+        # Manhattan distance on a square grid
+        dx = abs(a[0] - b[0])
+        dy = abs(a[1] - b[1])
+        if self.wrap_x:
+            dx = min(dx, self.mymap.width - dx)
+        if self.wrap_y:
+            dy = min(dy, self.mymap.height - dy)
+        return dx + dy
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/demolib/rpgmenu.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/demolib/rpgmenu.py`

 * *Ordering differences only*

 * *Files 14% similar despite different names*

```diff
@@ -1,426 +1,426 @@
-import collections
-import glob
-import random
-
-from ... import _hub
-from ...compo import vscreen as core
-from ...core import events
-
-
-Emitter = events.Emitter
-EngineEvTypes = events.EngineEvTypes
-pygame = _hub.pygame  # alias to keep on using pygame, easily
-Frect = _hub.polarbear.frects.Frect
-ANCHOR_CENTER = _hub.polarbear.frects.ANCHOR_CENTER
-ANCHOR_UPPERLEFT = _hub.polarbear.frects.ANCHOR_UPPERLEFT
-default_border = _hub.polarbear.default_border
-render_text = _hub.polarbear.render_text
-draw_text = _hub.polarbear.draw_text
-wait_event = _hub.polarbear.wait_event
-TIMEREVENT = _hub.polarbear.TIMEREVENT
-INFO_GREEN = _hub.polarbear.INFO_GREEN
-DEFAULT_FONT_SIZE = 11
-MENU_ITEM_COLOR = pygame.Color(150, 145, 130)
-MENU_SELECT_COLOR = pygame.Color(128, 250, 230)
-
-ReceiverObj = events.EvListener
-
-
-class MenuItem(object):
-    def __init__(self, msg, value, desc, menu):
-        self.value = value
-        self.desc = desc
-        self._font = menu.font
-        self.width = menu.w
-        self.justify = -1
-        self.menuitem = menu.menuitem
-        self.menuselect = menu.menuselect
-        self.item_image = None
-        self.select_image = None
-        self.height = 0
-        self._msg = msg
-
-    @property
-    def font(self):
-        return self._font
-
-    @font.setter
-    def font(self, v):
-        self._font = v
-        self._set_msg(self._msg)  # force refresh
-
-    def _get_msg(self):
-        return self._msg
-
-    def _set_msg(self, msg):
-        self._msg = msg
-        # - remove the pre-computation so the webctx accepts this as well
-        #self.item_image = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuitem)
-        #self.select_image = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuselect)
-        tmp = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuselect)
-        self.height = tmp.get_size()[1]
-
-        # before tinkenig web ctx:
-        # self.select_image.get_height()
-
-    msg = property(_get_msg, _set_msg)
-
-    SORT_LAYER = 0
-
-    def sort_order(self):
-        return self.SORT_LAYER, self._msg
-
-    def __lt__(self, other):
-        """ Comparison of menu items done by sort order, as defined above """
-        return self.sort_order() < other.sort_order()
-
-    def __str__(self):
-        return self._msg
-
-    def render(self, screen, dest, selected=False):
-        # signature draw_text(font, text, rect, color=TEXT_COLOR, justify=-1, antialias=True, dest_surface=None):
-        #if selected:
-        draw_text(self._font, self._msg, pygame.Rect(dest[0], dest[1], self.width, 256), justify=self.justify, dest_surface=screen)
-        #else:
-        #    draw_text(self._font, self._msg, (dest[0], dest[1], self.width, 256), justify=self.justify, color=self.menuitem)
-
-        # - before tinkering for the web ctx compat...
-        # if selected:
-        #     screen.blit(self.select_image, dest)
-        # else:
-        #     screen.blit(self.item_image, dest)
-
-
-# The DescBox is the default MenuDesc. It takes a string stored in the menu
-# item and displays it. However, it is not the only menu description possible!
-# Any object with a render_desc(menu_item) method will work.
-# Also note that the desc associated with each menu item doesn't need to be
-# a string- it all depends on the needs of the descobj you're using.
-
-class DescBox(Frect):
-    # The DescBox inherits from Frect, since that's basically what it is.
-    def __init__(self, menu, dx, dy, w=300, h=100, anchor=ANCHOR_CENTER, border=default_border, justify=-1, font=None,
-                 color=None, **kwargs):
-        self.menu = menu
-        self.border = border
-        self.justify = justify
-        if not anchor:
-            anchor = menu.anchor
-        self.font = font or pygame.font.Font("assets/DejaVuSansCondensed-Bold.ttf", DEFAULT_FONT_SIZE)
-        self.color = color or INFO_GREEN
-        super(DescBox, self).__init__(dx, dy, w, h, anchor, **kwargs)
-
-    def __call__(self, menu_item):
-        mydest = self.get_rect()
-        if self.border:
-            self.border.render(mydest)
-        if menu_item and menu_item.desc:
-            img = render_text(self.font, menu_item.desc, self.w, justify=self.justify, color=self.color)
-            screen.blit(img, mydest)
-
-
-class Menu(Emitter, Frect):
-    """
-    N.B (tom) it would be much better to inherit from CogObj
-    + have a Frect attribute
-    """
-    # TODO refactor
-
-    def __init__(self, dx, dy, w=300, h=100, anchor=ANCHOR_CENTER, menuitem=MENU_ITEM_COLOR,
-                 menuselect=MENU_SELECT_COLOR, border=default_border, predraw=None, font=None, padding=0,
-                 item_class=MenuItem):
-        # usin multiple inheritance
-        Emitter.__init__(self)
-        Frect.__init__(self, dx, dy, w, h, anchor)
-
-        self.menuitem = menuitem
-        self.menuselect = menuselect
-        self.border = border
-        self.font = font or pygame.font.Font("assets/DejaVuSansCondensed-Bold.ttf", DEFAULT_FONT_SIZE)
-        self.more_image = self.font.render("+", True, menuselect)
-        self.padding = padding
-        self.item_class = item_class
-
-        self.items = []
-        self.top_item = 0
-        self.selected_item = 0
-        self.can_cancel = True
-        self.descobj = None
-        self.quick_keys = {}
-
-        self._item_rects = collections.OrderedDict()
-        self._the_highest_top = 0
-
-        # predraw is a function that
-        # redraws/clears the screen before the menu is rendered.
-        self.predraw = predraw
-
-        # -> to the model
-        self.no_choice_made = True
-        self.choice = False
-
-    def add_item(self, msg, value, desc=None):
-        item = self.item_class(msg, value, desc, self)
-        self.items.append(item)
-
-    def add_descbox(self, x, y, w=30, h=10, justify=-1, font=None, **kwargs):
-        self.descobj = DescBox(self, x, y, w, h, border=self.border, justify=justify, font=font or self.font, **kwargs)
-
-    def arrange(self):
-        # Set the position of all on-screen menu items.
-        mydest = self.get_rect()
-        item_num = self.top_item
-        self._item_rects.clear()
-        y = mydest.top
-        while y < mydest.bottom:
-            if item_num < len(self.items):
-                itemdest = pygame.Rect(mydest.x, y, self.w, self.items[item_num].height)
-                # Only add this item to the menu if it fits inside the menu or is the first menu item.
-                if itemdest.bottom <= mydest.bottom or not self._item_rects:
-                    self._item_rects[item_num] = itemdest
-                y += self.items[item_num].height + self.padding
-            else:
-                break
-            item_num += 1
-
-        # While we're here, might as well calculate the highest top.
-        self._the_highest_top = len(self.items) - 1
-        item_num = self._the_highest_top
-        y = mydest.bottom
-        while y >= mydest.top and item_num >= 0:
-            y -= self.items[item_num].height
-            if y >= mydest.top:
-                self._the_highest_top = item_num
-            item_num -= 1
-            y -= self.padding
-
-    def alt_render(self, scr, capft, select_capft, do_extras=True):
-        mydest = self.get_rect()
-        if do_extras:
-            if self.predraw:
-                self.predraw(scr)
-            if self.border:
-                self.border.render(mydest)
-
-        scr.set_clip(mydest)
-        self.arrange()
-        for item_num, area in list(self._item_rects.items()):
-            # THIS IS THE LINE THAT's rly different
-            # signatur is:
-            #  text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None)
-            # debug - print(type(self.items[item_num]))
-
-            #TODO if selected then use the select_capft to render txt !
-            if item_num == self.selected_item:
-                pfont = select_capft
-            else:
-                pfont = capft
-            self.items[item_num].font = pfont
-            self.items[item_num].render(scr, area, False)
-            # pfont.text_to_surf(self.items[item_num].msg, scr, (area[0], area[1]))
-
-        scr.set_clip(None)
-        # tom: dunno what its for?
-        # if self.descobj:
-        #     self.descobj(self.get_current_item())
-
-    def render(self, scr, do_extras=True):
-        mydest = self.get_rect()
-        if do_extras:
-            if self.predraw:
-                self.predraw(scr)
-            if self.border:
-                self.border.render(mydest)
-
-        scr.set_clip(mydest)
-        self.arrange()
-        for item_num, area in list(self._item_rects.items()):
-            self.items[item_num].render(scr, area, (item_num == self.selected_item) and do_extras)
-        scr.set_clip(None)
-        if self.descobj:
-            self.descobj(self.get_current_item())
-
-    def get_mouseover_item(self, pos):
-        # Return the menu item under this mouse position.
-        # self.arrange must have been called previously!
-        for item_num, area in list(self._item_rects.items()):
-            if area.collidepoint(pos):
-                return item_num
-
-    def query(self):
-        # TODO refactor this, so it doesnt hook the game loop anymore
-
-        # A return of False means selection was cancelled.
-        # pygame.event.clear()
-        if not self.items:
-            return False
-        elif self.selected_item >= len(self.items):
-            self.selected_item = 0
-        self.no_choice_made = True
-        self.choice = False
-
-        # Do an initial arrangement of the menu.
-        self.arrange()
-
-    def proc_event(self, kengi_ev, source):
-        """
-        since may 2022,
-        the new way to return "choice" values, is via posting an event
-        """
-        # while no_choice_made:
-        #     pc_input = wait_event()
-
-        # if pc_input.type == TIMEREVENT:
-        #     # Redraw the menu on each timer event.
-        #     self.render()
-        #     kengi.flip()
-
-        if kengi_ev.type == EngineEvTypes.Keydown:
-            # A key was pressed, oh happy day! See what key it was and act
-            # accordingly.
-            if kengi_ev.key == pygame.K_UP:
-                self.selected_item -= 1
-                if self.selected_item < 0:
-                    self.selected_item = len(self.items) - 1
-                if self.selected_item not in self._item_rects:
-                    self.top_item = min(self.selected_item, self._the_highest_top)
-            elif kengi_ev.key == pygame.K_DOWN:
-                self.selected_item += 1
-                if self.selected_item >= len(self.items):
-                    self.selected_item = 0
-                if self.selected_item not in self._item_rects:
-                    self.top_item = min(self.selected_item, self._the_highest_top)
-            elif kengi_ev.key == pygame.K_SPACE or kengi_ev.key == pygame.K_RETURN:
-                self.pev(EngineEvTypes.ConvStart, value=self.items[self.selected_item].value)
-                self.no_choice_made = False
-            elif (kengi_ev.key == pygame.K_ESCAPE or kengi_ev.key == pygame.K_BACKSPACE) and self.can_cancel:
-                self.no_choice_made = False
-            elif 0 <= kengi_ev.key < 256 and chr(kengi_ev.key) in self.quick_keys:
-                self.pev(EngineEvTypes.ConvStep, value=self.quick_keys[chr(kengi_ev.key)])
-                self.no_choice_made = False
-            elif kengi_ev.key > 255 and kengi_ev.key in self.quick_keys:
-                self.pev(EngineEvTypes.ConvStep, value=self.quick_keys[kengi_ev.key])
-                self.no_choice_made = False
-
-        elif kengi_ev.type == EngineEvTypes.Mousedown:
-            if kengi_ev.button == 1:
-                mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
-                moi = self.get_mouseover_item(mouse_pos)
-                if moi is not None:
-                    self.set_item_by_position(moi)
-            elif kengi_ev.button == 4:
-                self.top_item = max(self.top_item - 1, 0)
-            elif kengi_ev.button == 5:
-                self.top_item = min(self.top_item + 1, self._the_highest_top)
-
-        elif kengi_ev.type == EngineEvTypes.Mouseup:
-            mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
-
-            if kengi_ev.button == 1:
-                moi = self.get_mouseover_item(mouse_pos)
-                if moi is self.selected_item:
-                    self.pev(EngineEvTypes.ConvStep, value=self.items[self.selected_item].value)
-                    self.no_choice_made = False
-
-            elif kengi_ev.button == 3 and self.can_cancel:
-                self.no_choice_made = False
-
-        elif kengi_ev.type == EngineEvTypes.Mousemotion:
-            mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
-            moi = self.get_mouseover_item(mouse_pos)
-            if moi is not None:
-                self.set_item_by_position(moi)
-
-    def sort(self):
-        self.items.sort()
-
-    alpha_key_sequence = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
-
-    def add_alpha_keys(self):
-        # Adds a quick key for every item currently in the menu.
-        key_num = 0
-        for item in self.items:
-            item.msg = self.alpha_key_sequence[key_num] + ') ' + item.msg
-            self.quick_keys[self.alpha_key_sequence[key_num]] = item.value
-            key_num += 1
-            if key_num >= len(self.alpha_key_sequence):
-                break
-
-    def add_files(self, filepat):
-        file_list = glob.glob(filepat)
-
-        for f in file_list:
-            self.add_item(f, f)
-        self.sort()
-
-    def reposition(self):
-        self.arrange()
-        if self.selected_item < self.top_item:
-            self.top_item = self.selected_item
-        elif self.selected_item > max(self._item_rects.keys()):
-            self.top_item = max(list(self._item_rects.keys()) + [self._the_highest_top])
-        self.arrange()
-
-    def has_value(self, v):
-        for i in self.items:
-            if i.value == v:
-                return True
-
-    def set_item_by_value(self, v):
-        for n, i in enumerate(self.items):
-            if i.value == v:
-                self.selected_item = n
-        self.reposition()
-
-    def set_item_by_position(self, n):
-        if n < len(self.items):
-            self.selected_item = n
-        self.reposition()
-
-    def set_random_item(self):
-        if self.items:
-            n = random.randint(0, len(self.items) - 1)
-            self.set_item_by_position(n)
-
-    def get_current_item(self):
-        if self.selected_item < len(self.items):
-            return self.items[self.selected_item]
-
-    def get_current_value(self):
-        if self.selected_item < len(self.items):
-            return self.items[self.selected_item].value
-
-
-class PopUpMenu(Menu):
-    """Creates a small menu at the current mouse position."""
-
-    def __init__(self, w=200, h=250, predraw=None, border=default_border, **kwargs):
-        mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
-        x, y = mouse_pos
-        x += 8
-        y += 8
-        sw, sh = core.get_screen().get_size()
-        if x + w + 32 > sw:
-            x += -w - 32
-        if y + h + 32 > sh:
-            y += -h - 32
-
-        super().__init__(x, y, w, h, ANCHOR_UPPERLEFT, border=border, predraw=predraw, **kwargs)
-
-
-class AlertMenu(Menu):
-    WIDTH = 350
-    HEIGHT = 250
-    MENU_HEIGHT = 75
-
-    FULL_RECT = Frect(-175, -125, 350, 250)
-    TEXT_RECT = Frect(-175, -125, 350, 165)
-
-    def __init__(self, desc):
-        super().__init__(-self.WIDTH // 2, self.HEIGHT // 2 - self.MENU_HEIGHT, self.WIDTH, self.MENU_HEIGHT,
-                         border=None, predraw=self.pre)
-        self.desc = desc
-
-    def pre(self):
-        default_border.render(self.FULL_RECT.get_rect())
-        draw_text(self.font, self.desc, self.TEXT_RECT.get_rect(), justify=0)
+import collections
+import glob
+import random
+
+from ... import _hub
+from ...compo import vscreen as core
+from ...core import events
+
+
+Emitter = events.Emitter
+EngineEvTypes = events.EngineEvTypes
+pygame = _hub.pygame  # alias to keep on using pygame, easily
+Frect = _hub.polarbear.frects.Frect
+ANCHOR_CENTER = _hub.polarbear.frects.ANCHOR_CENTER
+ANCHOR_UPPERLEFT = _hub.polarbear.frects.ANCHOR_UPPERLEFT
+default_border = _hub.polarbear.default_border
+render_text = _hub.polarbear.render_text
+draw_text = _hub.polarbear.draw_text
+wait_event = _hub.polarbear.wait_event
+TIMEREVENT = _hub.polarbear.TIMEREVENT
+INFO_GREEN = _hub.polarbear.INFO_GREEN
+DEFAULT_FONT_SIZE = 11
+MENU_ITEM_COLOR = pygame.Color(150, 145, 130)
+MENU_SELECT_COLOR = pygame.Color(128, 250, 230)
+
+ReceiverObj = events.EvListener
+
+
+class MenuItem(object):
+    def __init__(self, msg, value, desc, menu):
+        self.value = value
+        self.desc = desc
+        self._font = menu.font
+        self.width = menu.w
+        self.justify = -1
+        self.menuitem = menu.menuitem
+        self.menuselect = menu.menuselect
+        self.item_image = None
+        self.select_image = None
+        self.height = 0
+        self._msg = msg
+
+    @property
+    def font(self):
+        return self._font
+
+    @font.setter
+    def font(self, v):
+        self._font = v
+        self._set_msg(self._msg)  # force refresh
+
+    def _get_msg(self):
+        return self._msg
+
+    def _set_msg(self, msg):
+        self._msg = msg
+        # - remove the pre-computation so the webctx accepts this as well
+        #self.item_image = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuitem)
+        #self.select_image = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuselect)
+        tmp = render_text(self._font, self._msg, self.width, justify=self.justify, color=self.menuselect)
+        self.height = tmp.get_size()[1]
+
+        # before tinkenig web ctx:
+        # self.select_image.get_height()
+
+    msg = property(_get_msg, _set_msg)
+
+    SORT_LAYER = 0
+
+    def sort_order(self):
+        return self.SORT_LAYER, self._msg
+
+    def __lt__(self, other):
+        """ Comparison of menu items done by sort order, as defined above """
+        return self.sort_order() < other.sort_order()
+
+    def __str__(self):
+        return self._msg
+
+    def render(self, screen, dest, selected=False):
+        # signature draw_text(font, text, rect, color=TEXT_COLOR, justify=-1, antialias=True, dest_surface=None):
+        #if selected:
+        draw_text(self._font, self._msg, pygame.Rect(dest[0], dest[1], self.width, 256), justify=self.justify, dest_surface=screen)
+        #else:
+        #    draw_text(self._font, self._msg, (dest[0], dest[1], self.width, 256), justify=self.justify, color=self.menuitem)
+
+        # - before tinkering for the web ctx compat...
+        # if selected:
+        #     screen.blit(self.select_image, dest)
+        # else:
+        #     screen.blit(self.item_image, dest)
+
+
+# The DescBox is the default MenuDesc. It takes a string stored in the menu
+# item and displays it. However, it is not the only menu description possible!
+# Any object with a render_desc(menu_item) method will work.
+# Also note that the desc associated with each menu item doesn't need to be
+# a string- it all depends on the needs of the descobj you're using.
+
+class DescBox(Frect):
+    # The DescBox inherits from Frect, since that's basically what it is.
+    def __init__(self, menu, dx, dy, w=300, h=100, anchor=ANCHOR_CENTER, border=default_border, justify=-1, font=None,
+                 color=None, **kwargs):
+        self.menu = menu
+        self.border = border
+        self.justify = justify
+        if not anchor:
+            anchor = menu.anchor
+        self.font = font or pygame.font.Font("assets/DejaVuSansCondensed-Bold.ttf", DEFAULT_FONT_SIZE)
+        self.color = color or INFO_GREEN
+        super(DescBox, self).__init__(dx, dy, w, h, anchor, **kwargs)
+
+    def __call__(self, menu_item):
+        mydest = self.get_rect()
+        if self.border:
+            self.border.render(mydest)
+        if menu_item and menu_item.desc:
+            img = render_text(self.font, menu_item.desc, self.w, justify=self.justify, color=self.color)
+            screen.blit(img, mydest)
+
+
+class Menu(Emitter, Frect):
+    """
+    N.B (tom) it would be much better to inherit from CogObj
+    + have a Frect attribute
+    """
+    # TODO refactor
+
+    def __init__(self, dx, dy, w=300, h=100, anchor=ANCHOR_CENTER, menuitem=MENU_ITEM_COLOR,
+                 menuselect=MENU_SELECT_COLOR, border=default_border, predraw=None, font=None, padding=0,
+                 item_class=MenuItem):
+        # usin multiple inheritance
+        Emitter.__init__(self)
+        Frect.__init__(self, dx, dy, w, h, anchor)
+
+        self.menuitem = menuitem
+        self.menuselect = menuselect
+        self.border = border
+        self.font = font or pygame.font.Font("assets/DejaVuSansCondensed-Bold.ttf", DEFAULT_FONT_SIZE)
+        self.more_image = self.font.render("+", True, menuselect)
+        self.padding = padding
+        self.item_class = item_class
+
+        self.items = []
+        self.top_item = 0
+        self.selected_item = 0
+        self.can_cancel = True
+        self.descobj = None
+        self.quick_keys = {}
+
+        self._item_rects = collections.OrderedDict()
+        self._the_highest_top = 0
+
+        # predraw is a function that
+        # redraws/clears the screen before the menu is rendered.
+        self.predraw = predraw
+
+        # -> to the model
+        self.no_choice_made = True
+        self.choice = False
+
+    def add_item(self, msg, value, desc=None):
+        item = self.item_class(msg, value, desc, self)
+        self.items.append(item)
+
+    def add_descbox(self, x, y, w=30, h=10, justify=-1, font=None, **kwargs):
+        self.descobj = DescBox(self, x, y, w, h, border=self.border, justify=justify, font=font or self.font, **kwargs)
+
+    def arrange(self):
+        # Set the position of all on-screen menu items.
+        mydest = self.get_rect()
+        item_num = self.top_item
+        self._item_rects.clear()
+        y = mydest.top
+        while y < mydest.bottom:
+            if item_num < len(self.items):
+                itemdest = pygame.Rect(mydest.x, y, self.w, self.items[item_num].height)
+                # Only add this item to the menu if it fits inside the menu or is the first menu item.
+                if itemdest.bottom <= mydest.bottom or not self._item_rects:
+                    self._item_rects[item_num] = itemdest
+                y += self.items[item_num].height + self.padding
+            else:
+                break
+            item_num += 1
+
+        # While we're here, might as well calculate the highest top.
+        self._the_highest_top = len(self.items) - 1
+        item_num = self._the_highest_top
+        y = mydest.bottom
+        while y >= mydest.top and item_num >= 0:
+            y -= self.items[item_num].height
+            if y >= mydest.top:
+                self._the_highest_top = item_num
+            item_num -= 1
+            y -= self.padding
+
+    def alt_render(self, scr, capft, select_capft, do_extras=True):
+        mydest = self.get_rect()
+        if do_extras:
+            if self.predraw:
+                self.predraw(scr)
+            if self.border:
+                self.border.render(mydest)
+
+        scr.set_clip(mydest)
+        self.arrange()
+        for item_num, area in list(self._item_rects.items()):
+            # THIS IS THE LINE THAT's rly different
+            # signatur is:
+            #  text_to_surf(self, w, refsurf, start_pos, spacing=0, bgcolor=None)
+            # debug - print(type(self.items[item_num]))
+
+            #TODO if selected then use the select_capft to render txt !
+            if item_num == self.selected_item:
+                pfont = select_capft
+            else:
+                pfont = capft
+            self.items[item_num].font = pfont
+            self.items[item_num].render(scr, area, False)
+            # pfont.text_to_surf(self.items[item_num].msg, scr, (area[0], area[1]))
+
+        scr.set_clip(None)
+        # tom: dunno what its for?
+        # if self.descobj:
+        #     self.descobj(self.get_current_item())
+
+    def render(self, scr, do_extras=True):
+        mydest = self.get_rect()
+        if do_extras:
+            if self.predraw:
+                self.predraw(scr)
+            if self.border:
+                self.border.render(mydest)
+
+        scr.set_clip(mydest)
+        self.arrange()
+        for item_num, area in list(self._item_rects.items()):
+            self.items[item_num].render(scr, area, (item_num == self.selected_item) and do_extras)
+        scr.set_clip(None)
+        if self.descobj:
+            self.descobj(self.get_current_item())
+
+    def get_mouseover_item(self, pos):
+        # Return the menu item under this mouse position.
+        # self.arrange must have been called previously!
+        for item_num, area in list(self._item_rects.items()):
+            if area.collidepoint(pos):
+                return item_num
+
+    def query(self):
+        # TODO refactor this, so it doesnt hook the game loop anymore
+
+        # A return of False means selection was cancelled.
+        # pygame.event.clear()
+        if not self.items:
+            return False
+        elif self.selected_item >= len(self.items):
+            self.selected_item = 0
+        self.no_choice_made = True
+        self.choice = False
+
+        # Do an initial arrangement of the menu.
+        self.arrange()
+
+    def proc_event(self, kengi_ev, source):
+        """
+        since may 2022,
+        the new way to return "choice" values, is via posting an event
+        """
+        # while no_choice_made:
+        #     pc_input = wait_event()
+
+        # if pc_input.type == TIMEREVENT:
+        #     # Redraw the menu on each timer event.
+        #     self.render()
+        #     kengi.flip()
+
+        if kengi_ev.type == EngineEvTypes.Keydown:
+            # A key was pressed, oh happy day! See what key it was and act
+            # accordingly.
+            if kengi_ev.key == pygame.K_UP:
+                self.selected_item -= 1
+                if self.selected_item < 0:
+                    self.selected_item = len(self.items) - 1
+                if self.selected_item not in self._item_rects:
+                    self.top_item = min(self.selected_item, self._the_highest_top)
+            elif kengi_ev.key == pygame.K_DOWN:
+                self.selected_item += 1
+                if self.selected_item >= len(self.items):
+                    self.selected_item = 0
+                if self.selected_item not in self._item_rects:
+                    self.top_item = min(self.selected_item, self._the_highest_top)
+            elif kengi_ev.key == pygame.K_SPACE or kengi_ev.key == pygame.K_RETURN:
+                self.pev(EngineEvTypes.ConvStart, value=self.items[self.selected_item].value)
+                self.no_choice_made = False
+            elif (kengi_ev.key == pygame.K_ESCAPE or kengi_ev.key == pygame.K_BACKSPACE) and self.can_cancel:
+                self.no_choice_made = False
+            elif 0 <= kengi_ev.key < 256 and chr(kengi_ev.key) in self.quick_keys:
+                self.pev(EngineEvTypes.ConvStep, value=self.quick_keys[chr(kengi_ev.key)])
+                self.no_choice_made = False
+            elif kengi_ev.key > 255 and kengi_ev.key in self.quick_keys:
+                self.pev(EngineEvTypes.ConvStep, value=self.quick_keys[kengi_ev.key])
+                self.no_choice_made = False
+
+        elif kengi_ev.type == EngineEvTypes.Mousedown:
+            if kengi_ev.button == 1:
+                mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
+                moi = self.get_mouseover_item(mouse_pos)
+                if moi is not None:
+                    self.set_item_by_position(moi)
+            elif kengi_ev.button == 4:
+                self.top_item = max(self.top_item - 1, 0)
+            elif kengi_ev.button == 5:
+                self.top_item = min(self.top_item + 1, self._the_highest_top)
+
+        elif kengi_ev.type == EngineEvTypes.Mouseup:
+            mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
+
+            if kengi_ev.button == 1:
+                moi = self.get_mouseover_item(mouse_pos)
+                if moi is self.selected_item:
+                    self.pev(EngineEvTypes.ConvStep, value=self.items[self.selected_item].value)
+                    self.no_choice_made = False
+
+            elif kengi_ev.button == 3 and self.can_cancel:
+                self.no_choice_made = False
+
+        elif kengi_ev.type == EngineEvTypes.Mousemotion:
+            mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
+            moi = self.get_mouseover_item(mouse_pos)
+            if moi is not None:
+                self.set_item_by_position(moi)
+
+    def sort(self):
+        self.items.sort()
+
+    alpha_key_sequence = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
+
+    def add_alpha_keys(self):
+        # Adds a quick key for every item currently in the menu.
+        key_num = 0
+        for item in self.items:
+            item.msg = self.alpha_key_sequence[key_num] + ') ' + item.msg
+            self.quick_keys[self.alpha_key_sequence[key_num]] = item.value
+            key_num += 1
+            if key_num >= len(self.alpha_key_sequence):
+                break
+
+    def add_files(self, filepat):
+        file_list = glob.glob(filepat)
+
+        for f in file_list:
+            self.add_item(f, f)
+        self.sort()
+
+    def reposition(self):
+        self.arrange()
+        if self.selected_item < self.top_item:
+            self.top_item = self.selected_item
+        elif self.selected_item > max(self._item_rects.keys()):
+            self.top_item = max(list(self._item_rects.keys()) + [self._the_highest_top])
+        self.arrange()
+
+    def has_value(self, v):
+        for i in self.items:
+            if i.value == v:
+                return True
+
+    def set_item_by_value(self, v):
+        for n, i in enumerate(self.items):
+            if i.value == v:
+                self.selected_item = n
+        self.reposition()
+
+    def set_item_by_position(self, n):
+        if n < len(self.items):
+            self.selected_item = n
+        self.reposition()
+
+    def set_random_item(self):
+        if self.items:
+            n = random.randint(0, len(self.items) - 1)
+            self.set_item_by_position(n)
+
+    def get_current_item(self):
+        if self.selected_item < len(self.items):
+            return self.items[self.selected_item]
+
+    def get_current_value(self):
+        if self.selected_item < len(self.items):
+            return self.items[self.selected_item].value
+
+
+class PopUpMenu(Menu):
+    """Creates a small menu at the current mouse position."""
+
+    def __init__(self, w=200, h=250, predraw=None, border=default_border, **kwargs):
+        mouse_pos = core.proj_to_vscreen(pygame.mouse.get_pos())
+        x, y = mouse_pos
+        x += 8
+        y += 8
+        sw, sh = core.get_screen().get_size()
+        if x + w + 32 > sw:
+            x += -w - 32
+        if y + h + 32 > sh:
+            y += -h - 32
+
+        super().__init__(x, y, w, h, ANCHOR_UPPERLEFT, border=border, predraw=predraw, **kwargs)
+
+
+class AlertMenu(Menu):
+    WIDTH = 350
+    HEIGHT = 250
+    MENU_HEIGHT = 75
+
+    FULL_RECT = Frect(-175, -125, 350, 250)
+    TEXT_RECT = Frect(-175, -125, 350, 165)
+
+    def __init__(self, desc):
+        super().__init__(-self.WIDTH // 2, self.HEIGHT // 2 - self.MENU_HEIGHT, self.WIDTH, self.MENU_HEIGHT,
+                         border=None, predraw=self.pre)
+        self.desc = desc
+
+    def pre(self):
+        default_border.render(self.FULL_RECT.get_rect())
+        draw_text(self.font, self.desc, self.TEXT_RECT.get_rect(), justify=0)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/BaseGuiElement.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/BaseGuiElement.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,215 +1,215 @@
-from abc import ABCMeta, abstractmethod
-from ...compo.vscreen import get_screen
-
-
-ANCHOR_LEFT, ANCHOR_RIGHT, ANCHOR_CENTER = range(34151, 34151+3)
-
-
-class BaseGuiElement(metaclass=ABCMeta):
-    """
-    Base cls for any Gui element class
-    """
-    free_gui_id = 821798
-
-    def __init__(self):
-        self._id = self.__class__.free_gui_id
-        self.__class__.free_gui_id -= 1
-
-        self._parent = None
-
-        self._scrref = get_screen()
-
-        self._debug = 0
-        self._abs_pos = [0, 0]
-        self._dim = [None, None]
-        self._anchor_type = ANCHOR_LEFT
-        self._debug = False
-
-        # not all widgets can be de-activated
-        self._active = True
-
-    @property
-    def active(self):
-        return self._active
-
-    def get_abs_rect(self):
-        """
-        The absolute positioning rect.
-        :return: A pygame rect.
-        """
-        return self._abs_pos[0], self._abs_pos[1], self._dim[0], self._dim[1]
-
-    @abstractmethod
-    def get_relative_rect(self):
-        """
-        The relative positioning rect.
-        :return: A pygame rect.
-        """
-
-    @abstractmethod
-    def set_relative_pos(self, position):
-        """
-        Method to directly set the relative rect position of an element.
-        :param position: The new position to set.
-        """
-
-    def get_pos(self):
-        """
-        getter (takes into account anchoring!)
-        :return:
-        """
-        return self._abs_pos
-
-    def set_position(self, position):
-        """
-        Method to directly set the absolute screen rect position of an element.
-        Warning! This can impact parent container if one is defined
-        :param position: The new position to set.
-        """
-        if not isinstance(position[0], int):
-            raise ValueError
-        if not isinstance(position[1], int):
-            raise ValueError
-
-        self._abs_pos[0], self._abs_pos[1] = position
-
-        if self._parent:
-            self._parent.update_pos_from_child(position, self)
-
-    def get_dimensions(self):
-        """
-        getter
-        :return: w, h
-        """
-        return tuple(self._dim)
-
-    def set_dimensions(self, dimensions):
-        """
-        setter tho change the dimensions of an element.
-        NOTE: Using this on elements inside containers with non-default anchoring arrangements ay make a mess of them.
-        :param dimensions: The new dimensions to set.
-        """
-        self._dim[0], self._dim[1] = dimensions
-
-    def rebuild(self) -> None:
-        """
-        refresh element/rebuild
-        """
-        pass
-
-    def update(self, time_delta: float):
-        """
-        Updates this element's drawable shape, if it has one.
-        :param time_delta: The time passed between frames, measured in seconds.
-        """
-        pass
-
-    @abstractmethod
-    def draw(self):
-        """
-        draw itself
-        :return:
-        """
-
-    @abstractmethod
-    def kill(self):
-        """
-        Overriding regular sprite kill() method to remove the element from it's container.
-        """
-
-    @abstractmethod
-    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
-        """
-        A method that helps us to determine which, if any, UI Element is currently being hovered
-        by the mouse.
-
-        :param time_delta: A float, the time in seconds between the last call to this function
-                           and now (roughly).
-        :param hovered_higher_element: A boolean, representing whether we have already hovered a
-                                       'higher' element.
-        :return bool: A boolean that is true if we have hovered a UI element, either just now or
-                      before this method.
-        """
-
-    @abstractmethod
-    def hover_point(self, hover_x: float, hover_y: float) -> bool:
-        """
-        Test if a given point counts as 'hovering' this UI element. Normally that is a
-        straightforward matter of seeing if a point is inside the rectangle. Occasionally it
-        will also check if we are in a wider zone around a UI element once it is already active,
-        this makes it easier to move scroll bars and the like.
-
-        :param hover_x: The x (horizontal) position of the point.
-        :param hover_y: The y (vertical) position of the point.
-        :return: Returns True if we are hovering this element.
-        """
-
-    @abstractmethod
-    def proc_event(self, event) -> bool:
-        """
-        A stub to override. Gives UI Elements access to pygame events.
-        :param event: The event to process.
-        :return: Should return True if this element makes use of this event.
-        """
-
-    # TODO fix system -> non-compatibility with event sys4
-
-    # def on_hover(self):
-    #     """
-    #     Can be overriden, called when this UI element first enters the 'hovered' state.
-    #     """
-    #     pass
-    #
-    # def on_unhover(self):
-    #     """
-    #     Can be overriden, called when this UI element leaves the 'hovered' state.
-    #     """
-    #     pass
-    #
-    # def on_focus(self):
-    #     """
-    #     Can be overriden, called when we focus this UI element.
-    #     """
-    #     pass
-    #
-    # @abstractmethod
-    # def on_unfocus(self):
-    #     """
-    #     Can be overriden, called when we stop focusing this UI element.
-    #     """
-    #     pass
-
-    def get_debug_flag(self):
-        return self._debug
-
-    def set_debug_flag(self, v=True):
-        self._debug = bool(v)
-
-    @abstractmethod
-    def set_image(self, new_image):
-        """
-        Wraps setting the image variable of this element so that we also set the current image
-        clip on the image at the same time.
-        :param new_image: The new image to set.
-        """
-
-    def set_active(self, activate_mode=True):
-        """
-        tag the widget as active/inactive,
-        which determines if the widget will draw itself and process events or not
-        """
-        self._active = activate_mode
-
-    def set_anchoring(self, anch_code: int):
-        """
-        Set the current anchoring mode
-        :type anch_code: anchoring code (int)
-        """
-        self._anchor_type = anch_code
-
-    def get_anchoring(self) -> int:
-        """
-        Get the current anchoring mode that's used by this element so we can position it
-        :return: anchoring_code
-        """
-        return self._anchor_type
+from abc import ABCMeta, abstractmethod
+from ...compo.vscreen import get_screen
+
+
+ANCHOR_LEFT, ANCHOR_RIGHT, ANCHOR_CENTER = range(34151, 34151+3)
+
+
+class BaseGuiElement(metaclass=ABCMeta):
+    """
+    Base cls for any Gui element class
+    """
+    free_gui_id = 821798
+
+    def __init__(self):
+        self._id = self.__class__.free_gui_id
+        self.__class__.free_gui_id -= 1
+
+        self._parent = None
+
+        self._scrref = get_screen()
+
+        self._debug = 0
+        self._abs_pos = [0, 0]
+        self._dim = [None, None]
+        self._anchor_type = ANCHOR_LEFT
+        self._debug = False
+
+        # not all widgets can be de-activated
+        self._active = True
+
+    @property
+    def active(self):
+        return self._active
+
+    def get_abs_rect(self):
+        """
+        The absolute positioning rect.
+        :return: A pygame rect.
+        """
+        return self._abs_pos[0], self._abs_pos[1], self._dim[0], self._dim[1]
+
+    @abstractmethod
+    def get_relative_rect(self):
+        """
+        The relative positioning rect.
+        :return: A pygame rect.
+        """
+
+    @abstractmethod
+    def set_relative_pos(self, position):
+        """
+        Method to directly set the relative rect position of an element.
+        :param position: The new position to set.
+        """
+
+    def get_pos(self):
+        """
+        getter (takes into account anchoring!)
+        :return:
+        """
+        return self._abs_pos
+
+    def set_position(self, position):
+        """
+        Method to directly set the absolute screen rect position of an element.
+        Warning! This can impact parent container if one is defined
+        :param position: The new position to set.
+        """
+        if not isinstance(position[0], int):
+            raise ValueError
+        if not isinstance(position[1], int):
+            raise ValueError
+
+        self._abs_pos[0], self._abs_pos[1] = position
+
+        if self._parent:
+            self._parent.update_pos_from_child(position, self)
+
+    def get_dimensions(self):
+        """
+        getter
+        :return: w, h
+        """
+        return tuple(self._dim)
+
+    def set_dimensions(self, dimensions):
+        """
+        setter tho change the dimensions of an element.
+        NOTE: Using this on elements inside containers with non-default anchoring arrangements ay make a mess of them.
+        :param dimensions: The new dimensions to set.
+        """
+        self._dim[0], self._dim[1] = dimensions
+
+    def rebuild(self) -> None:
+        """
+        refresh element/rebuild
+        """
+        pass
+
+    def update(self, time_delta: float):
+        """
+        Updates this element's drawable shape, if it has one.
+        :param time_delta: The time passed between frames, measured in seconds.
+        """
+        pass
+
+    @abstractmethod
+    def draw(self):
+        """
+        draw itself
+        :return:
+        """
+
+    @abstractmethod
+    def kill(self):
+        """
+        Overriding regular sprite kill() method to remove the element from it's container.
+        """
+
+    @abstractmethod
+    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
+        """
+        A method that helps us to determine which, if any, UI Element is currently being hovered
+        by the mouse.
+
+        :param time_delta: A float, the time in seconds between the last call to this function
+                           and now (roughly).
+        :param hovered_higher_element: A boolean, representing whether we have already hovered a
+                                       'higher' element.
+        :return bool: A boolean that is true if we have hovered a UI element, either just now or
+                      before this method.
+        """
+
+    @abstractmethod
+    def hover_point(self, hover_x: float, hover_y: float) -> bool:
+        """
+        Test if a given point counts as 'hovering' this UI element. Normally that is a
+        straightforward matter of seeing if a point is inside the rectangle. Occasionally it
+        will also check if we are in a wider zone around a UI element once it is already active,
+        this makes it easier to move scroll bars and the like.
+
+        :param hover_x: The x (horizontal) position of the point.
+        :param hover_y: The y (vertical) position of the point.
+        :return: Returns True if we are hovering this element.
+        """
+
+    @abstractmethod
+    def proc_event(self, event) -> bool:
+        """
+        A stub to override. Gives UI Elements access to pygame events.
+        :param event: The event to process.
+        :return: Should return True if this element makes use of this event.
+        """
+
+    # TODO fix system -> non-compatibility with event sys4
+
+    # def on_hover(self):
+    #     """
+    #     Can be overriden, called when this UI element first enters the 'hovered' state.
+    #     """
+    #     pass
+    #
+    # def on_unhover(self):
+    #     """
+    #     Can be overriden, called when this UI element leaves the 'hovered' state.
+    #     """
+    #     pass
+    #
+    # def on_focus(self):
+    #     """
+    #     Can be overriden, called when we focus this UI element.
+    #     """
+    #     pass
+    #
+    # @abstractmethod
+    # def on_unfocus(self):
+    #     """
+    #     Can be overriden, called when we stop focusing this UI element.
+    #     """
+    #     pass
+
+    def get_debug_flag(self):
+        return self._debug
+
+    def set_debug_flag(self, v=True):
+        self._debug = bool(v)
+
+    @abstractmethod
+    def set_image(self, new_image):
+        """
+        Wraps setting the image variable of this element so that we also set the current image
+        clip on the image at the same time.
+        :param new_image: The new image to set.
+        """
+
+    def set_active(self, activate_mode=True):
+        """
+        tag the widget as active/inactive,
+        which determines if the widget will draw itself and process events or not
+        """
+        self._active = activate_mode
+
+    def set_anchoring(self, anch_code: int):
+        """
+        Set the current anchoring mode
+        :type anch_code: anchoring code (int)
+        """
+        self._anchor_type = anch_code
+
+    def get_anchoring(self) -> int:
+        """
+        Get the current anchoring mode that's used by this element so we can position it
+        :return: anchoring_code
+        """
+        return self._anchor_type
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/DispCenteredPopup.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/DispCenteredPopup.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,133 +1,133 @@
-from .DispPopup import DispPopup
-from .Trigger import Trigger
-from ... import _hub
-from ... import vscreen
-
-
-pygame = _hub.pygame
-
-
-class DispCenteredPopup(DispPopup):
-
-    def __init__(self, decoree, titre, txt, wanted_buttons=DispPopup.AUCUN, ppsize=(294, 140)):
-        super().__init__(
-            decoree, (0, 0), titre, txt, ppsize[0], ppsize[1]
-        )  # der. => forcer hauteur fenetre
-
-        scrw, scrh = vscreen.screen.get_size()
-        self.actualize_position((
-            int((scrw / 2) - (self.width / 2)),
-            int((scrh / 2) - (self.height / 2))
-        ))
-
-        self.ft = pygame.font.Font(None, 18)  # glvars.gl_fonts['pxled_med_font_big']  # police par défaut
-        self.white = (255, 255, 255)
-        self.gris = (66, 66, 66)  # glvars.gl_colors['gris_fonce']
-        self.txt_img = self.ft.render(txt, True, self.white)
-
-        self.xt = scrw // 2 - self.txt_img.get_size()[0] // 2
-        self.yt = scrh // 2 - self.txt_img.get_size()[1] // 2
-
-        self.xoui = self.xt - 25
-        self.youi = self.yt + (ppsize[1] // 2) - 25
-
-        self.xnon = self.xt + self.width - self.TAILLE_BOUTONS[0]
-        self.ynon = self.youi
-
-        self.bouton_oui_ok = Trigger((self.xoui, self.youi), self.TAILLE_BOUTONS)
-        self.bouton_oui_ok.set_visible(False)
-        self.bouton_non_annuler = Trigger((self.xnon, self.ynon), self.TAILLE_BOUTONS)
-        self.bouton_non_annuler.set_visible(False)
-
-        self._construction_boutons_ona(wanted_buttons)
-
-        self._idtrig_reserve_ok_oui = None
-
-    def is_active(self):
-        return self._presence
-
-    def connect_ok(self, trigid):
-        assert isinstance(trigid, int)
-        self._idtrig_reserve_ok_oui = trigid
-
-    def _construction_boutons_ona(self, boutons):
-        # print("Boutons: {0}".format(boutons))
-        if boutons in (self.OUI, self.OUINON):
-            self.bouton_oui_ok.setLabel("Oui")
-            self.bouton_oui_ok.set_visible(True)
-
-        if boutons in (self.OK_BUTTON, self.OKANNULER):
-            print('ajout bt OK ..............')
-            self.bouton_oui_ok.setLabel("Ok")
-            self.bouton_oui_ok.set_visible(True)
-
-        if boutons in (self.NON, self.OUINON):
-            self.bouton_non_annuler.setLabel("Non")
-            self.bouton_non_annuler.set_visible(True)
-
-        if boutons in (self.CANCEL_BUTTON, self.OKANNULER):
-            self.bouton_non_annuler.setLabel("Annuler")
-            self.bouton_non_annuler.set_visible(True)
-
-    def draw_specific(self, screen):
-        if self._presence:
-            super().draw_specific(screen)
-            self._dessin_boutons_ona(screen)
-
-    def _dessin_boutons_ona(self, screen):
-
-        for trig in (self.bouton_oui_ok, self.bouton_non_annuler):
-            if trig.is_visible():
-                tmp_x = trig.getPos()[0]
-                tmp_y = trig.getPos()[1]
-                size_x = super().TAILLE_BOUTONS[0]
-                size_y = super().TAILLE_BOUTONS[1]
-
-                rect = (
-                    tmp_x,
-                    tmp_y,
-                    size_x,
-                    size_y
-                )
-                pygame.draw.rect(
-                    screen,
-                    self.gris,
-                    rect
-                )
-                pygame.draw.line(
-                    screen,
-                    self.bg_clair,
-                    (tmp_x, tmp_y + size_y),
-                    (tmp_x + size_x, tmp_y + size_y),
-                    2
-                )
-
-                trig.draw(screen)
-
-    def get_absolute_position(self, pos):
-        # Retourne un couple de coordonnées correspondant à la position absolue d'un composant dans l'écran
-        # par rapport à sa position relative au coin supérieur gauche de son conteneur
-        return [pos[0] + self.x, pos[1] + self.y]
-
-    def lookup_ft_specific(self, mouse_buttons, clickpos):
-        clickpos = vscreen.proj_to_vscreen(clickpos)
-        print(mouse_buttons, clickpos)
-
-        if not self._presence:
-            print('no presence to catch mouseclick')
-            return
-
-        if self.bouton_oui_ok.contains(clickpos):
-            cbf = self.callbacks[self.OK_BUTTON]
-            if cbf:
-                cbf()
-            return True
-
-        if self.bouton_non_annuler.contains(clickpos):
-            cbf = self.callbacks[self.CANCEL_BUTTON]
-            if cbf:
-                cbf()
-            return True
-
-        tmp = super().lookup_ft_specific(mouse_buttons, clickpos)
-        return tmp
+from .DispPopup import DispPopup
+from .Trigger import Trigger
+from ... import _hub
+from ... import vscreen
+
+
+pygame = _hub.pygame
+
+
+class DispCenteredPopup(DispPopup):
+
+    def __init__(self, decoree, titre, txt, wanted_buttons=DispPopup.AUCUN, ppsize=(294, 140)):
+        super().__init__(
+            decoree, (0, 0), titre, txt, ppsize[0], ppsize[1]
+        )  # der. => forcer hauteur fenetre
+
+        scrw, scrh = vscreen.screen.get_size()
+        self.actualize_position((
+            int((scrw / 2) - (self.width / 2)),
+            int((scrh / 2) - (self.height / 2))
+        ))
+
+        self.ft = pygame.font.Font(None, 18)  # glvars.gl_fonts['pxled_med_font_big']  # police par défaut
+        self.white = (255, 255, 255)
+        self.gris = (66, 66, 66)  # glvars.gl_colors['gris_fonce']
+        self.txt_img = self.ft.render(txt, True, self.white)
+
+        self.xt = scrw // 2 - self.txt_img.get_size()[0] // 2
+        self.yt = scrh // 2 - self.txt_img.get_size()[1] // 2
+
+        self.xoui = self.xt - 25
+        self.youi = self.yt + (ppsize[1] // 2) - 25
+
+        self.xnon = self.xt + self.width - self.TAILLE_BOUTONS[0]
+        self.ynon = self.youi
+
+        self.bouton_oui_ok = Trigger((self.xoui, self.youi), self.TAILLE_BOUTONS)
+        self.bouton_oui_ok.set_visible(False)
+        self.bouton_non_annuler = Trigger((self.xnon, self.ynon), self.TAILLE_BOUTONS)
+        self.bouton_non_annuler.set_visible(False)
+
+        self._construction_boutons_ona(wanted_buttons)
+
+        self._idtrig_reserve_ok_oui = None
+
+    def is_active(self):
+        return self._presence
+
+    def connect_ok(self, trigid):
+        assert isinstance(trigid, int)
+        self._idtrig_reserve_ok_oui = trigid
+
+    def _construction_boutons_ona(self, boutons):
+        # print("Boutons: {0}".format(boutons))
+        if boutons in (self.OUI, self.OUINON):
+            self.bouton_oui_ok.setLabel("Oui")
+            self.bouton_oui_ok.set_visible(True)
+
+        if boutons in (self.OK_BUTTON, self.OKANNULER):
+            print('ajout bt OK ..............')
+            self.bouton_oui_ok.setLabel("Ok")
+            self.bouton_oui_ok.set_visible(True)
+
+        if boutons in (self.NON, self.OUINON):
+            self.bouton_non_annuler.setLabel("Non")
+            self.bouton_non_annuler.set_visible(True)
+
+        if boutons in (self.CANCEL_BUTTON, self.OKANNULER):
+            self.bouton_non_annuler.setLabel("Annuler")
+            self.bouton_non_annuler.set_visible(True)
+
+    def draw_specific(self, screen):
+        if self._presence:
+            super().draw_specific(screen)
+            self._dessin_boutons_ona(screen)
+
+    def _dessin_boutons_ona(self, screen):
+
+        for trig in (self.bouton_oui_ok, self.bouton_non_annuler):
+            if trig.is_visible():
+                tmp_x = trig.getPos()[0]
+                tmp_y = trig.getPos()[1]
+                size_x = super().TAILLE_BOUTONS[0]
+                size_y = super().TAILLE_BOUTONS[1]
+
+                rect = (
+                    tmp_x,
+                    tmp_y,
+                    size_x,
+                    size_y
+                )
+                pygame.draw.rect(
+                    screen,
+                    self.gris,
+                    rect
+                )
+                pygame.draw.line(
+                    screen,
+                    self.bg_clair,
+                    (tmp_x, tmp_y + size_y),
+                    (tmp_x + size_x, tmp_y + size_y),
+                    2
+                )
+
+                trig.draw(screen)
+
+    def get_absolute_position(self, pos):
+        # Retourne un couple de coordonnées correspondant à la position absolue d'un composant dans l'écran
+        # par rapport à sa position relative au coin supérieur gauche de son conteneur
+        return [pos[0] + self.x, pos[1] + self.y]
+
+    def lookup_ft_specific(self, mouse_buttons, clickpos):
+        clickpos = vscreen.proj_to_vscreen(clickpos)
+        print(mouse_buttons, clickpos)
+
+        if not self._presence:
+            print('no presence to catch mouseclick')
+            return
+
+        if self.bouton_oui_ok.contains(clickpos):
+            cbf = self.callbacks[self.OK_BUTTON]
+            if cbf:
+                cbf()
+            return True
+
+        if self.bouton_non_annuler.contains(clickpos):
+            cbf = self.callbacks[self.CANCEL_BUTTON]
+            if cbf:
+                cbf()
+            return True
+
+        tmp = super().lookup_ft_specific(mouse_buttons, clickpos)
+        return tmp
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Label.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Label.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,138 +1,138 @@
-from ... import _hub
-from .BaseGuiElement import BaseGuiElement
-
-pygame = _hub.pygame
-
-
-class Label(BaseGuiElement):
-
-    def __init__(self, position, txt_string, txt_size=10, color=None, anchoring=None, replacemt_ft=None):
-        
-        if replacemt_ft is not None:
-            self.small_font = replacemt_ft
-        else:
-            self.small_font = pygame.font.Font(None, txt_size)
-
-        super().__init__()
-        self.set_position(position)
-        self._text = txt_string
-        self._txtsize = txt_size
-        self._used_color = 'black'
-        if color:
-            self._used_color = color
-
-        self.image = self._dim = None
-        self._debug = False
-        self.rebuild()
-
-    def rebuild(self):
-        self.image = self.small_font.render(self._text, False, self._used_color)
-        self._dim = self.image.get_size()
-        if self._parent:
-            self._parent.recompute()
-
-    @property
-    def text(self):
-        return self._text
-
-    @text.setter
-    def text(self, v):
-        self._text = v
-        self.rebuild()
-
-    def get_relative_rect(self):
-        pass
-
-    def set_relative_pos(self, position):
-        pass
-
-    def kill(self):
-        pass
-
-    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
-        pass
-
-    def hover_point(self, hover_x: float, hover_y: float) -> bool:
-        pass
-
-    def proc_event(self, event) -> bool:
-        pass
-
-    def set_image(self, new_image):
-        pass
-
-    # def __init__(self, position, text, txtsize=35, color=None, anchoring=ANCHOR_LEFT, debugmode=False):
-    #     self._used_text = text
-    #     self._used_color = color
-    #     self._txtsize = txtsize
-    #     self._inner_spr = _SprLikeLabel(text, txtsize, color)
-    #     super().__init__(position, self._inner_spr.rect.size, anchoring, debugmode)
-
-    # --- define all properties ---
-    @property
-    def textsize(self):
-        return self._txtsize
-
-    @textsize.setter
-    def textsize(self, newv):
-        self._txtsize = newv
-        self.rebuild()
-
-    # @property
-    # def text(self):
-    #     return self._used_text
-    #
-    # # modifiying text => rebuild step
-    # @text.setter
-    # def text(self, newtext):
-    #     self._used_text = newtext
-    #     self.rebuild()
-
-    @property
-    def color(self):
-        return self._used_color
-
-    @color.setter
-    def color(self, newval):
-        self._used_color = newval
-        self.rebuild()
-
-    # --- all properties defined ---
-
-    # def rebuild(self) -> None:
-    #     """
-    #     called if the spr has changed (or the color)
-    #     :return:
-    #     """
-    #     self._inner_spr = _SprLikeLabel(self._used_text, self._txtsize, self._used_color)
-    #     super().__init__(self.get_position(), self._inner_spr.rect.size, self._curr_anchor, self._debug_mode)
-
-    def draw(self):
-        # super().draw()
-        self._scrref.blit(self.image, self._abs_pos)
-        if self._debug:
-            pygame.draw.rect(self._scrref, 'red', self.get_abs_rect(), 1)
-        # self._cached_scr_ref.blit(self._inner_spr.image, topleft_coords)
-
-
-if __name__ == '__main__':
-    pygame.init()
-    scr = pygame.display.set_mode((400, 300))
-    gameover = False
-    cl = pygame.time.Clock()
-    central_obj = _SprLikeLabel('salut', 'steelblue')
-
-    while not gameover:
-        for ev in pygame.event.get():
-            if ev.type == pygame.QUIT:
-                gameover = True
-            elif ev.type == pygame.KEYDOWN:
-                central_obj.color = random.choice(('antiquewhite2', 'orange', 'pink', 'yellow'))
-
-            scr.fill('grey22')
-            scr.blit(central_obj.image, central_obj.rect.topleft)
-            pygame.display.update()
-            cl.tick(60)
-
-    pygame.quit()
-    print('test over')
+from ... import _hub
+from .BaseGuiElement import BaseGuiElement
+
+pygame = _hub.pygame
+
+
+class Label(BaseGuiElement):
+
+    def __init__(self, position, txt_string, txt_size=10, color=None, anchoring=None, replacemt_ft=None):
+        
+        if replacemt_ft is not None:
+            self.small_font = replacemt_ft
+        else:
+            self.small_font = pygame.font.Font(None, txt_size)
+
+        super().__init__()
+        self.set_position(position)
+        self._text = txt_string
+        self._txtsize = txt_size
+        self._used_color = 'black'
+        if color:
+            self._used_color = color
+
+        self.image = self._dim = None
+        self._debug = False
+        self.rebuild()
+
+    def rebuild(self):
+        self.image = self.small_font.render(self._text, False, self._used_color)
+        self._dim = self.image.get_size()
+        if self._parent:
+            self._parent.recompute()
+
+    @property
+    def text(self):
+        return self._text
+
+    @text.setter
+    def text(self, v):
+        self._text = v
+        self.rebuild()
+
+    def get_relative_rect(self):
+        pass
+
+    def set_relative_pos(self, position):
+        pass
+
+    def kill(self):
+        pass
+
+    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
+        pass
+
+    def hover_point(self, hover_x: float, hover_y: float) -> bool:
+        pass
+
+    def proc_event(self, event) -> bool:
+        pass
+
+    def set_image(self, new_image):
+        pass
+
+    # def __init__(self, position, text, txtsize=35, color=None, anchoring=ANCHOR_LEFT, debugmode=False):
+    #     self._used_text = text
+    #     self._used_color = color
+    #     self._txtsize = txtsize
+    #     self._inner_spr = _SprLikeLabel(text, txtsize, color)
+    #     super().__init__(position, self._inner_spr.rect.size, anchoring, debugmode)
+
+    # --- define all properties ---
+    @property
+    def textsize(self):
+        return self._txtsize
+
+    @textsize.setter
+    def textsize(self, newv):
+        self._txtsize = newv
+        self.rebuild()
+
+    # @property
+    # def text(self):
+    #     return self._used_text
+    #
+    # # modifiying text => rebuild step
+    # @text.setter
+    # def text(self, newtext):
+    #     self._used_text = newtext
+    #     self.rebuild()
+
+    @property
+    def color(self):
+        return self._used_color
+
+    @color.setter
+    def color(self, newval):
+        self._used_color = newval
+        self.rebuild()
+
+    # --- all properties defined ---
+
+    # def rebuild(self) -> None:
+    #     """
+    #     called if the spr has changed (or the color)
+    #     :return:
+    #     """
+    #     self._inner_spr = _SprLikeLabel(self._used_text, self._txtsize, self._used_color)
+    #     super().__init__(self.get_position(), self._inner_spr.rect.size, self._curr_anchor, self._debug_mode)
+
+    def draw(self):
+        # super().draw()
+        self._scrref.blit(self.image, self._abs_pos)
+        if self._debug:
+            pygame.draw.rect(self._scrref, 'red', self.get_abs_rect(), 1)
+        # self._cached_scr_ref.blit(self._inner_spr.image, topleft_coords)
+
+
+if __name__ == '__main__':
+    pygame.init()
+    scr = pygame.display.set_mode((400, 300))
+    gameover = False
+    cl = pygame.time.Clock()
+    central_obj = _SprLikeLabel('salut', 'steelblue')
+
+    while not gameover:
+        for ev in pygame.event.get():
+            if ev.type == pygame.QUIT:
+                gameover = True
+            elif ev.type == pygame.KEYDOWN:
+                central_obj.color = random.choice(('antiquewhite2', 'orange', 'pink', 'yellow'))
+
+            scr.fill('grey22')
+            scr.blit(central_obj.image, central_obj.rect.topleft)
+            pygame.display.update()
+            cl.tick(60)
+
+    pygame.quit()
+    print('test over')
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/Trigger.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/Trigger.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,126 +1,126 @@
-from ... import _hub
-
-
-pygame = _hub.pygame
-
-
-class Trigger:
-    """
-    This class has been copied for better retro-compatibility with old projects
-    (e.g. Brutos), but it's also used in VmSelector kartridge
-    """
-    class_ready_to_draw = False
-    RED = None
-    small_font = None
-    med_font = None
-
-    def __init__(self, pos_topleft, size):
-        self.pos = pos_topleft
-        self.size = size
-        self.active = True
-        self.visibility = True
-        self.label = None
-        self.spr_label = None
-        self.drawing_color = pygame.Color('purple')
-        sm_ft = pygame.font.Font(None, 24)
-        self.med_font = sm_ft
-
-    def set_active(self, val):
-        self.active = val
-
-    def is_active(self):
-        return self.active
-
-    def set_visible(self, val):
-        assert (isinstance(val, bool))
-        self.visibility = val
-
-    def is_visible(self):
-        return self.visibility
-
-    def getSize(self):
-        return self.size
-
-    def setSize(self, new_size):
-        self.size = new_size
-
-    def setPos(self, new_pos):
-        self.pos = new_pos
-
-    def getPos(self):
-        return self.pos
-
-    def getLabel(self):
-        return self.label
-
-    def getRect(self):
-        return [self.pos, self.size]
-
-    def getCollisionBox(self):
-        repr_cb = [self.pos, self.size]
-
-        pt_topleft = repr_cb[0]
-
-        taille_util = repr_cb[1]
-        pt_botright = list(pt_topleft)
-        pt_botright[0] += taille_util[0]
-        pt_botright[1] += taille_util[1]
-
-        res = list()
-        res.extend(pt_topleft)
-        res.extend(pt_botright)
-        return res
-
-    def setCollisionBox(self, new_cb_borders):
-        # --- conversion
-        taille = (
-            new_cb_borders[2] - new_cb_borders[0],
-            new_cb_borders[3] - new_cb_borders[1])
-        pt_topleft = (new_cb_borders[0], new_cb_borders[1])
-        self.setPos(pt_topleft)
-        self.setSize(taille)
-
-    def contains(self, point2d):
-        if not self.active:
-            return False
-        tx, ty = point2d
-        xbinf, ybinf, xbsup, ybsup = self.getCollisionBox()
-        return (xbinf < tx < xbsup) and (ybinf < ty < ybsup)
-
-    def setLabel(self, nouveau_label=None):
-        self.label = nouveau_label
-        if nouveau_label is None:
-            self.spr_label = None
-        else:
-            self.spr_label = self.med_font.render(nouveau_label, False, self.drawing_color)
-
-    def draw(self, screen, forced_color=None):
-        if not self.visibility:  # invisible trigger
-            return
-
-        if forced_color is not None:
-            self.drawing_color = forced_color
-            self.setLabel(self.label)
-
-        c1, c2, t, tt = self.getCollisionBox()
-        c3 = t - c1
-        c4 = tt - c2
-        rect = ((c1, c2), (c3, c4))
-        pygame.draw.rect(screen, self.drawing_color, rect, 1)
-
-        if self.label is not None:
-            # --- le but est dafficher ce txt au centre de la collision box
-            pt_centrage = [
-                (t - c1) // 2,
-                (tt - c2) // 2,
-            ]
-            pt_centrage[0] += c1
-            pt_centrage[1] += c2
-
-            img = self.spr_label
-            tmp_pt = (pt_centrage[0] - img.get_width() // 2, pt_centrage[1] - img.get_height() // 2)
-            screen.blit(self.spr_label, tmp_pt)
-
-        if forced_color is not None:
-            self.drawing_color = self.RED
-            self.setLabel(self.label)
+from ... import _hub
+
+
+pygame = _hub.pygame
+
+
+class Trigger:
+    """
+    This class has been copied for better retro-compatibility with old projects
+    (e.g. Brutos), but it's also used in VmSelector kartridge
+    """
+    class_ready_to_draw = False
+    RED = None
+    small_font = None
+    med_font = None
+
+    def __init__(self, pos_topleft, size):
+        self.pos = pos_topleft
+        self.size = size
+        self.active = True
+        self.visibility = True
+        self.label = None
+        self.spr_label = None
+        self.drawing_color = pygame.Color('purple')
+        sm_ft = pygame.font.Font(None, 24)
+        self.med_font = sm_ft
+
+    def set_active(self, val):
+        self.active = val
+
+    def is_active(self):
+        return self.active
+
+    def set_visible(self, val):
+        assert (isinstance(val, bool))
+        self.visibility = val
+
+    def is_visible(self):
+        return self.visibility
+
+    def getSize(self):
+        return self.size
+
+    def setSize(self, new_size):
+        self.size = new_size
+
+    def setPos(self, new_pos):
+        self.pos = new_pos
+
+    def getPos(self):
+        return self.pos
+
+    def getLabel(self):
+        return self.label
+
+    def getRect(self):
+        return [self.pos, self.size]
+
+    def getCollisionBox(self):
+        repr_cb = [self.pos, self.size]
+
+        pt_topleft = repr_cb[0]
+
+        taille_util = repr_cb[1]
+        pt_botright = list(pt_topleft)
+        pt_botright[0] += taille_util[0]
+        pt_botright[1] += taille_util[1]
+
+        res = list()
+        res.extend(pt_topleft)
+        res.extend(pt_botright)
+        return res
+
+    def setCollisionBox(self, new_cb_borders):
+        # --- conversion
+        taille = (
+            new_cb_borders[2] - new_cb_borders[0],
+            new_cb_borders[3] - new_cb_borders[1])
+        pt_topleft = (new_cb_borders[0], new_cb_borders[1])
+        self.setPos(pt_topleft)
+        self.setSize(taille)
+
+    def contains(self, point2d):
+        if not self.active:
+            return False
+        tx, ty = point2d
+        xbinf, ybinf, xbsup, ybsup = self.getCollisionBox()
+        return (xbinf < tx < xbsup) and (ybinf < ty < ybsup)
+
+    def setLabel(self, nouveau_label=None):
+        self.label = nouveau_label
+        if nouveau_label is None:
+            self.spr_label = None
+        else:
+            self.spr_label = self.med_font.render(nouveau_label, False, self.drawing_color)
+
+    def draw(self, screen, forced_color=None):
+        if not self.visibility:  # invisible trigger
+            return
+
+        if forced_color is not None:
+            self.drawing_color = forced_color
+            self.setLabel(self.label)
+
+        c1, c2, t, tt = self.getCollisionBox()
+        c3 = t - c1
+        c4 = tt - c2
+        rect = ((c1, c2), (c3, c4))
+        pygame.draw.rect(screen, self.drawing_color, rect, 1)
+
+        if self.label is not None:
+            # --- le but est dafficher ce txt au centre de la collision box
+            pt_centrage = [
+                (t - c1) // 2,
+                (tt - c2) // 2,
+            ]
+            pt_centrage[0] += c1
+            pt_centrage[1] += c2
+
+            img = self.spr_label
+            tmp_pt = (pt_centrage[0] - img.get_width() // 2, pt_centrage[1] - img.get_height() // 2)
+            screen.blit(self.spr_label, tmp_pt)
+
+        if forced_color is not None:
+            self.drawing_color = self.RED
+            self.setLabel(self.label)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/WidgetBo.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/WidgetBo.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,141 +1,141 @@
-from .Trigger import Trigger
-
-from ... import _hub as inj
-
-
-pygame = inj.pygame
-
-
-class SpriteBo:
-    """
-    on définit un sprite comme un élément graphique connu,
-    et déjà présent en mémoire,
-    dont on place une copie qq part sur lécran...
-    Chaque sprite a sa position propre !
-    """
-
-    current_z_index = 0
-
-    loaded_surfaces = {}
-
-    @classmethod
-    def link_resource(cls, gfxelt_id, filename):
-        # this method is new (2022), it has been introduced so we can remove the use to GfxManager.
-        cls.loaded_surfaces[gfxelt_id] = pygame.image.load(filename)
-
-    def __init__(self, gfxelt_id, position2):
-        self.pos = tuple(position2)
-        self.ref_gfxelt_id = gfxelt_id
-        self.z_index = self.__class__.current_z_index
-        self.__class__.current_z_index += 1
-
-    def getSurface(self):
-        return self.__class__.loaded_surfaces[self.ref_gfxelt_id]  # assuming the link has been done
-
-    def draw(self, surf):
-        # self.gfx_manager.pasteGfxTo(self.ref_gfxelt_id, self.pos, surf)
-        s = self.getSurface()
-        surf.blit(s, self.pos)
-
-    def getSize(self):
-        # return self.gfx_manager.getSize(self.ref_gfxelt_id)
-        return self.getSurface().get_size()
-
-    def getOriginPt(self):
-        # return self.gfx_manager.getOrigin(self.ref_gfxelt_id)
-        return 0, 0
-
-    def getPos(self):
-        return self.pos
-
-    def setPos(self, nouv_position2):
-        self.pos = nouv_position2
-
-    def setZIndex(self, new_val):
-        self.z_index = new_val
-
-    def getZIndex(self):
-        return self.z_index
-
-    def getGfx(self):
-        return self.ref_gfxelt_id
-
-    def setGfx(self, nouv_gfxelt_id):
-        self.ref_gfxelt_id = nouv_gfxelt_id
-
-
-class WidgetBo(SpriteBo):
-    # classe qui utilise indirectement (via Sprite)
-    # les méthodes statiques de atoms.GfxElementManage
-    # pour son affichage
-
-    def __init__(self, gfxelt_id, position2):
-        super().__init__(gfxelt_id, position2)
-        self.__trigger_behavior = Trigger((0, 0), (32, 32))  # position, taille
-        self.hidden = False
-        self.debugOff()
-        self.autoResizeCollisionBox()
-        self.__auto_translate_cbox()
-
-    def setGfx(self, nouvel_id):
-        super().setGfx(nouvel_id)
-
-    def setPos(self, position2):
-        super().setPos(position2)  # position sprite
-
-        self.__auto_translate_cbox()
-
-    def draw(self, screen):
-        if not self.hidden:
-            super().draw(screen)
-            self.__trigger_behavior.draw(screen)
-
-    # --- méthodes agissant sur le trigger interne
-    # ----------------------------------------------
-    def autoResizeCollisionBox(self):
-        current_img_size = self.getSize()
-        self.__trigger_behavior.setSize(current_img_size)
-
-    def contains(self, point2):
-        return self.__trigger_behavior.contains(point2)
-
-    def __auto_translate_cbox(self):
-        tmp = [0, 0]
-
-        obj_pos = self.getPos()
-        tmp[0] += obj_pos[0]
-        tmp[1] += obj_pos[1]
-
-        org = self.getOriginPt()
-        tmp[0] -= org[0]
-        tmp[1] -= org[1]
-
-        self.__trigger_behavior.setPos(tmp)
-
-    def set_active(self, val):
-        self.__trigger_behavior.active = val
-        if val:
-            self.hidden = False
-        else:
-            self.hidden = True
-
-    def is_active(self):
-        return self.__trigger_behavior.active
-
-    def debugOn(self):
-        self.__trigger_behavior.set_visible(True)
-
-    def debugOff(self):
-        self.__trigger_behavior.set_visible(False)
-
-    def getLabel(self):
-        return self.__trigger_behavior.getLabel()
-
-    def setLabel(self, label=None):
-        self.__trigger_behavior.setLabel(label)
-
-    def getCollisionBox(self):
-        return self.__trigger_behavior.getCollisionBox()
-
-    def setCollisionBox(self, li4_coord):
-        self.__trigger_behavior.setCollisionBox(li4_coord)
+from .Trigger import Trigger
+
+from ... import _hub as inj
+
+
+pygame = inj.pygame
+
+
+class SpriteBo:
+    """
+    on définit un sprite comme un élément graphique connu,
+    et déjà présent en mémoire,
+    dont on place une copie qq part sur lécran...
+    Chaque sprite a sa position propre !
+    """
+
+    current_z_index = 0
+
+    loaded_surfaces = {}
+
+    @classmethod
+    def link_resource(cls, gfxelt_id, filename):
+        # this method is new (2022), it has been introduced so we can remove the use to GfxManager.
+        cls.loaded_surfaces[gfxelt_id] = pygame.image.load(filename)
+
+    def __init__(self, gfxelt_id, position2):
+        self.pos = tuple(position2)
+        self.ref_gfxelt_id = gfxelt_id
+        self.z_index = self.__class__.current_z_index
+        self.__class__.current_z_index += 1
+
+    def getSurface(self):
+        return self.__class__.loaded_surfaces[self.ref_gfxelt_id]  # assuming the link has been done
+
+    def draw(self, surf):
+        # self.gfx_manager.pasteGfxTo(self.ref_gfxelt_id, self.pos, surf)
+        s = self.getSurface()
+        surf.blit(s, self.pos)
+
+    def getSize(self):
+        # return self.gfx_manager.getSize(self.ref_gfxelt_id)
+        return self.getSurface().get_size()
+
+    def getOriginPt(self):
+        # return self.gfx_manager.getOrigin(self.ref_gfxelt_id)
+        return 0, 0
+
+    def getPos(self):
+        return self.pos
+
+    def setPos(self, nouv_position2):
+        self.pos = nouv_position2
+
+    def setZIndex(self, new_val):
+        self.z_index = new_val
+
+    def getZIndex(self):
+        return self.z_index
+
+    def getGfx(self):
+        return self.ref_gfxelt_id
+
+    def setGfx(self, nouv_gfxelt_id):
+        self.ref_gfxelt_id = nouv_gfxelt_id
+
+
+class WidgetBo(SpriteBo):
+    # classe qui utilise indirectement (via Sprite)
+    # les méthodes statiques de atoms.GfxElementManage
+    # pour son affichage
+
+    def __init__(self, gfxelt_id, position2):
+        super().__init__(gfxelt_id, position2)
+        self.__trigger_behavior = Trigger((0, 0), (32, 32))  # position, taille
+        self.hidden = False
+        self.debugOff()
+        self.autoResizeCollisionBox()
+        self.__auto_translate_cbox()
+
+    def setGfx(self, nouvel_id):
+        super().setGfx(nouvel_id)
+
+    def setPos(self, position2):
+        super().setPos(position2)  # position sprite
+
+        self.__auto_translate_cbox()
+
+    def draw(self, screen):
+        if not self.hidden:
+            super().draw(screen)
+            self.__trigger_behavior.draw(screen)
+
+    # --- méthodes agissant sur le trigger interne
+    # ----------------------------------------------
+    def autoResizeCollisionBox(self):
+        current_img_size = self.getSize()
+        self.__trigger_behavior.setSize(current_img_size)
+
+    def contains(self, point2):
+        return self.__trigger_behavior.contains(point2)
+
+    def __auto_translate_cbox(self):
+        tmp = [0, 0]
+
+        obj_pos = self.getPos()
+        tmp[0] += obj_pos[0]
+        tmp[1] += obj_pos[1]
+
+        org = self.getOriginPt()
+        tmp[0] -= org[0]
+        tmp[1] -= org[1]
+
+        self.__trigger_behavior.setPos(tmp)
+
+    def set_active(self, val):
+        self.__trigger_behavior.active = val
+        if val:
+            self.hidden = False
+        else:
+            self.hidden = True
+
+    def is_active(self):
+        return self.__trigger_behavior.active
+
+    def debugOn(self):
+        self.__trigger_behavior.set_visible(True)
+
+    def debugOff(self):
+        self.__trigger_behavior.set_visible(False)
+
+    def getLabel(self):
+        return self.__trigger_behavior.getLabel()
+
+    def setLabel(self, label=None):
+        self.__trigger_behavior.setLabel(label)
+
+    def getCollisionBox(self):
+        return self.__trigger_behavior.getCollisionBox()
+
+    def setCollisionBox(self, li4_coord):
+        self.__trigger_behavior.setCollisionBox(li4_coord)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/WidgetContainer.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/WidgetContainer.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,147 +1,147 @@
-import math
-
-from .BaseGuiElement import BaseGuiElement
-from ... import _hub
-
-
-pygame = _hub.pygame
-
-
-class WidgetContainer(BaseGuiElement):
-    LTR = 1
-    EXPAND = 2
-    FLOW = 3
-
-    def __init__(self, pos, size, layout_type, widget_list=None, spacing=0, vspacing=0):
-        super().__init__()
-        assert isinstance(layout_type, int)
-
-        self._active = False
-
-        self.set_position(pos)
-        self.set_dimensions(size)
-        self.content = list()
-        if widget_list is not None:
-            if isinstance(widget_list, dict):
-                self.dictmode = 1
-                self.cpdict = dict(widget_list)
-                self.content.extend(widget_list.values())
-            else:
-                self.dictmode = 0
-                self.content.extend(widget_list)
-
-        for elt in self.content:
-            elt._parent = self
-        # reposition elements that belong to this(self) container
-        self.spacing = spacing
-        self.vspacing = vspacing
-        self.layout_type = layout_type
-        self.recompute()
-
-    # -- redef!
-    def set_active(self, activate_mode=True):
-        if activate_mode:
-            print('xxx Activation de l\'element', self)
-        else:
-            print(self, ' est désactivé!')
-
-        super().set_active(activate_mode)
-
-        for e in self.content:
-            e.set_active(activate_mode)
-
-    def recompute(self):
-        print(self.get_abs_rect(), 'recomputing positions...')
-        print('layout?', self.layout_type, '//', self.LTR,  self.EXPAND, self.FLOW,)
-        print(len(self.content), 'elements')
-
-        # adjust positions automatically!
-        if self.layout_type == self.LTR:
-            c_pos = [0, 0]
-            for w in self.content:
-                w.set_position(
-                    (self._abs_pos[0] + c_pos[0], self._abs_pos[1])
-                )
-                c_pos[0] += w.get_dimensions()[0] + self.spacing
-
-        # ----------------------
-        # the 'expand' layout
-        elif self.layout_type == self.EXPAND:
-            px, py, bsupx, bsupy = self.get_abs_rect()
-
-            delta = 0  # use (bsupy//2), if u want vertical align:center of the anchor point(topleft)
-            c_pos = [px+1, py+delta]
-            s = 0
-            for w in self.content:
-                s += w.get_dimensions()[0]
-            blank_total_space = bsupx - s
-            auto_spacing = math.floor(blank_total_space / (len(self.content)-1))
-
-            for w in self.content:
-                w.set_position(c_pos)
-                c_pos[0] += w.get_dimensions()[0]+auto_spacing
-
-        # ----------------------
-        # the 'flow' layout
-        elif self.layout_type == self.FLOW:
-            basex, basey, container_w, container_h = self.get_abs_rect()
-            curr_p = [basex, basey]
-
-            prevwidget_w, prevwidget_h = 0, 0
-            k = 0
-            for w in self.content:
-                if k:
-                    curr_p[0] += (prevwidget_w + self.spacing)
-                if w.get_dimensions()[0]+curr_p[0] > container_w+basex:
-                    curr_p[0] = basex
-                    curr_p[1] += prevwidget_h + self.vspacing
-
-                w.set_position(curr_p)
-                prevwidget_w, prevwidget_h = w.get_dimensions()
-                k += 1
-
-    # redef!
-    def set_debug_flag(self, v=True):
-        super().set_debug_flag(v)
-        for elt in self.content:
-            elt.set_debug_flag(v)
-
-    def update_pos_from_child(self, a, b):
-        pass
-
-    def __getitem__(self, item):
-        if not self.dictmode:
-            raise RuntimeError
-        return self.cpdict[item]
-
-    def get_relative_rect(self):
-        pass
-
-    def set_relative_pos(self, position):
-        pass
-
-    def draw(self):
-        if self._active:
-            if self._debug:
-                pygame.draw.rect(self._scrref, 'red', self.get_abs_rect(), 1)
-            for elt in self.content:
-                elt.draw()
-
-    def kill(self):
-        pass
-
-    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
-        pass
-
-    def hover_point(self, hover_x: float, hover_y: float) -> bool:
-        pass
-
-    def proc_event(self, event) -> bool:
-        pass
-
-    def on_unfocus(self):
-        pass
-
-    def set_image(self, new_image):
-        pass
-
+import math
+
+from .BaseGuiElement import BaseGuiElement
+from ... import _hub
+
+
+pygame = _hub.pygame
+
+
+class WidgetContainer(BaseGuiElement):
+    LTR = 1
+    EXPAND = 2
+    FLOW = 3
+
+    def __init__(self, pos, size, layout_type, widget_list=None, spacing=0, vspacing=0):
+        super().__init__()
+        assert isinstance(layout_type, int)
+
+        self._active = False
+
+        self.set_position(pos)
+        self.set_dimensions(size)
+        self.content = list()
+        if widget_list is not None:
+            if isinstance(widget_list, dict):
+                self.dictmode = 1
+                self.cpdict = dict(widget_list)
+                self.content.extend(widget_list.values())
+            else:
+                self.dictmode = 0
+                self.content.extend(widget_list)
+
+        for elt in self.content:
+            elt._parent = self
+        # reposition elements that belong to this(self) container
+        self.spacing = spacing
+        self.vspacing = vspacing
+        self.layout_type = layout_type
+        self.recompute()
+
+    # -- redef!
+    def set_active(self, activate_mode=True):
+        if activate_mode:
+            print('xxx Activation de l\'element', self)
+        else:
+            print(self, ' est désactivé!')
+
+        super().set_active(activate_mode)
+
+        for e in self.content:
+            e.set_active(activate_mode)
+
+    def recompute(self):
+        print(self.get_abs_rect(), 'recomputing positions...')
+        print('layout?', self.layout_type, '//', self.LTR,  self.EXPAND, self.FLOW,)
+        print(len(self.content), 'elements')
+
+        # adjust positions automatically!
+        if self.layout_type == self.LTR:
+            c_pos = [0, 0]
+            for w in self.content:
+                w.set_position(
+                    (self._abs_pos[0] + c_pos[0], self._abs_pos[1])
+                )
+                c_pos[0] += w.get_dimensions()[0] + self.spacing
+
+        # ----------------------
+        # the 'expand' layout
+        elif self.layout_type == self.EXPAND:
+            px, py, bsupx, bsupy = self.get_abs_rect()
+
+            delta = 0  # use (bsupy//2), if u want vertical align:center of the anchor point(topleft)
+            c_pos = [px+1, py+delta]
+            s = 0
+            for w in self.content:
+                s += w.get_dimensions()[0]
+            blank_total_space = bsupx - s
+            auto_spacing = math.floor(blank_total_space / (len(self.content)-1))
+
+            for w in self.content:
+                w.set_position(c_pos)
+                c_pos[0] += w.get_dimensions()[0]+auto_spacing
+
+        # ----------------------
+        # the 'flow' layout
+        elif self.layout_type == self.FLOW:
+            basex, basey, container_w, container_h = self.get_abs_rect()
+            curr_p = [basex, basey]
+
+            prevwidget_w, prevwidget_h = 0, 0
+            k = 0
+            for w in self.content:
+                if k:
+                    curr_p[0] += (prevwidget_w + self.spacing)
+                if w.get_dimensions()[0]+curr_p[0] > container_w+basex:
+                    curr_p[0] = basex
+                    curr_p[1] += prevwidget_h + self.vspacing
+
+                w.set_position(curr_p)
+                prevwidget_w, prevwidget_h = w.get_dimensions()
+                k += 1
+
+    # redef!
+    def set_debug_flag(self, v=True):
+        super().set_debug_flag(v)
+        for elt in self.content:
+            elt.set_debug_flag(v)
+
+    def update_pos_from_child(self, a, b):
+        pass
+
+    def __getitem__(self, item):
+        if not self.dictmode:
+            raise RuntimeError
+        return self.cpdict[item]
+
+    def get_relative_rect(self):
+        pass
+
+    def set_relative_pos(self, position):
+        pass
+
+    def draw(self):
+        if self._active:
+            if self._debug:
+                pygame.draw.rect(self._scrref, 'red', self.get_abs_rect(), 1)
+            for elt in self.content:
+                elt.draw()
+
+    def kill(self):
+        pass
+
+    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
+        pass
+
+    def hover_point(self, hover_x: float, hover_y: float) -> bool:
+        pass
+
+    def proc_event(self, event) -> bool:
+        pass
+
+    def on_unfocus(self):
+        pass
+
+    def set_image(self, new_image):
+        pass
+
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/__init__.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/__init__.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,219 +1,219 @@
-"""
-sub-module dedicated to GUI management/creation. This belongs to the 'Kengi' engine
-"""
-from .Button import Button
-from .Button2 import Button2
-from .DispCenteredPopup import DispCenteredPopup
-from .Label import Label
-from .TextBlock import TextBlock
-from .Trigger import Trigger
-from .WidgetBo import WidgetBo
-from .WidgetContainer import WidgetContainer
-from .base import ANCHOR_CENTER, ANCHOR_RIGHT, ANCHOR_LEFT  # bring codes here
-from .base import AugmentedSprite
-from .text import ImgBasedFont
-from ... import _hub
-
-
-pygame = _hub.pygame
-
-
-class Etiquette:
-    # TODO on a un souci avec classe Etiquette-> doublon, faut fusionner ou en retirer un!
-    ft_obj = None
-
-    def __init__(self, text, pos, rgb_color):
-        if self.ft_obj is None:
-            raise ValueError('use set_font(...) first! ')
-
-        self._text = text
-        self.pos = pos
-        self._color = rgb_color
-        self.img = self.ft_obj.render(self._text, True, self._color)
-
-    @classmethod
-    def set_font(cls, ft_obj):
-        cls.ft_obj = ft_obj
-
-    def get_text(self):
-        return self._text
-
-    def set_text(self, t):
-        self._text = t
-        self.img = self.ft_obj.render(self._text, True, self._color)
-
-
-class TextInput:
-    # TODO fix bugs: avant on utilisait EvListener juste pr un bouton/widget, ca a été retiré mais bug probable now!
-    # utiliser des Container de préférence + eventuellement structure hierarchique
-    """
-    Simple text entry component.
-    """
-
-    _caret_color = (90, 90, 90)
-    _padding = 4  # en px
-
-    def __init__(self, nickname, font, how_to_process_cb, pos, width=300):
-        """
-        nickname: nickname, all messages will be prefixed with the nickname
-        font    : pygame.font.Font object
-        width   : in pixel that this element can use (this restricts the number
-                  of char you can enter
-
-        events:
-        in : pygame.KEYDOWN
-        out: eventtypes.CHATMSG
-        """
-        super().__init__()
-
-        self.position = pos
-        # test que le 3e arg est callable...
-        assert hasattr(how_to_process_cb, '__call__')
-        self.on_enter_func = how_to_process_cb
-
-        self.pwd_field = False
-
-        # data
-        self.__txt_content = ""
-        self.caretpos = 0
-        self.max = 255
-        self.nickname = nickname
-
-        # drawing
-        self.dirty = True
-        self.font = font
-        height = self.font.get_ascent() - self.font.get_descent() + 8
-        self.image = pygame.Surface((width, height)).convert()
-        self.size = (width, height)
-
-        self.text_color = (1, 1, 1)
-        self.text_field_rect = pygame.Rect(0, 0, width - 1, height - 1)
-        self.text_img = pygame.Surface((2, 2))
-        self.pixel_width = width - 4
-
-        self._focus = None
-        self.fill_color = None
-        self.no_focus()
-
-    def has_focus(self):
-        return self._focus
-
-    def get_disp_text(self):
-        if self.pwd_field:
-            return TextInput.hide_text(self.__txt_content)
-        return self.__txt_content
-
-    def focus(self):
-        self._focus = True
-        self.fill_color = (220, 220, 220)
-        self.render_field()
-
-    def no_focus(self):
-        self._focus = False
-        self.fill_color = (100, 100, 100)
-        self.render_field()
-
-    def contains(self, scr_pos):
-        w, h = self.image.get_size()
-        a, b = self.position[0], self.position[0] + w
-        c, d = self.position[1], self.position[1] + h
-        x, y = scr_pos
-        if (a < x < b) and (c < y < d):
-            return True
-        return False
-
-    @staticmethod
-    def hide_text(txt_content):
-        tmp = ['*' for i in range(len(txt_content))]
-        return ''.join(tmp)
-
-    def proc_event(self, event, source):
-        if event.type != pygame.KEYDOWN:
-            return
-
-        # - traitement touche pressée
-        if event.key == pygame.K_RETURN:
-            # self.on_enter()
-            self.on_enter_func(self.__txt_content)
-            self.__txt_content = ''
-            self.caretpos = 0
-
-        elif event.key == pygame.K_RIGHT:
-            self.move_caret(+1)
-
-        elif event.key == pygame.K_LEFT:
-            self.move_caret(-1)
-
-        elif event.key == pygame.K_HOME:
-            self.move_caret('home')
-
-        elif event.key == pygame.K_END:
-            self.move_caret('end')
-
-        elif event.key == pygame.K_BACKSPACE:
-            self.backspace_char()
-
-        elif event.key == pygame.K_DELETE:
-            self.delete_char()
-
-        elif event.key == pygame.K_TAB:
-            pass
-
-        else:
-            if event.unicode != '':
-                if len(self.__txt_content) < self.max:
-                    self.__txt_content = self.__txt_content[:self.caretpos] + event.unicode + self.__txt_content[
-                                                                                              self.caretpos:]
-                    self.caretpos += 1
-        self.render_field()
-
-    def move_caret(self, steps):
-        """
-        Moves the caret about steps. Positive numbers moves it right, negative
-        numbers left.
-        """
-        if steps == 'home':
-            self.caretpos = 0
-        elif steps == 'end':
-            self.caretpos = len(self.__txt_content)
-        else:
-            assert isinstance(steps, int)
-            self.caretpos += steps
-
-        if self.caretpos < 0:
-            self.caretpos = 0
-        if self.caretpos > len(self.__txt_content):
-            self.caretpos = len(self.__txt_content)
-
-    def backspace_char(self):
-        """
-        Deltes the char befor the caret position.
-        """
-        if self.caretpos > 0:
-            self.__txt_content = self.__txt_content[:self.caretpos - 1] + self.__txt_content[self.caretpos:]
-            self.caretpos -= 1
-
-    def delete_char(self):
-        """
-        Deltes the char after the caret position.
-        """
-        self.__txt_content = self.__txt_content[:self.caretpos] + self.__txt_content[self.caretpos + 1:]
-
-    def render_field(self):
-        """
-        Renders the string to self.image.
-        """
-        self.image.fill(self.fill_color)
-        content = self.get_disp_text()
-
-        if len(content):
-            # while self.font.size(content)[0] > self.pixel_width:
-            #    self.backspace_char()
-            self.text_img = self.font.render(content, 1, self.text_color, self.fill_color)
-            self.image.blit(self.text_img, (2, 2))
-            # - draw caret
-            # TODO fix pygame draw line
-            # xpos = self.font.size(content[:self.caretpos])[0] + 2
-            # pygame.draw.line(self.image, self._caret_color, (xpos, self._padding),
-            #                  (xpos, self.image.get_height() - self._padding), 2)
-        pygame.draw.rect(self.image, (100, 100, 100), self.text_field_rect, 2)
+"""
+sub-module dedicated to GUI management/creation. This belongs to the 'Kengi' engine
+"""
+from .Button import Button
+from .Button2 import Button2
+from .DispCenteredPopup import DispCenteredPopup
+from .Label import Label
+from .TextBlock import TextBlock
+from .Trigger import Trigger
+from .WidgetBo import WidgetBo
+from .WidgetContainer import WidgetContainer
+from .base import ANCHOR_CENTER, ANCHOR_RIGHT, ANCHOR_LEFT  # bring codes here
+from .base import AugmentedSprite
+from .text import ImgBasedFont
+from ... import _hub
+
+
+pygame = _hub.pygame
+
+
+class Etiquette:
+    # TODO on a un souci avec classe Etiquette-> doublon, faut fusionner ou en retirer un!
+    ft_obj = None
+
+    def __init__(self, text, pos, rgb_color):
+        if self.ft_obj is None:
+            raise ValueError('use set_font(...) first! ')
+
+        self._text = text
+        self.pos = pos
+        self._color = rgb_color
+        self.img = self.ft_obj.render(self._text, True, self._color)
+
+    @classmethod
+    def set_font(cls, ft_obj):
+        cls.ft_obj = ft_obj
+
+    def get_text(self):
+        return self._text
+
+    def set_text(self, t):
+        self._text = t
+        self.img = self.ft_obj.render(self._text, True, self._color)
+
+
+class TextInput:
+    # TODO fix bugs: avant on utilisait EvListener juste pr un bouton/widget, ca a été retiré mais bug probable now!
+    # utiliser des Container de préférence + eventuellement structure hierarchique
+    """
+    Simple text entry component.
+    """
+
+    _caret_color = (90, 90, 90)
+    _padding = 4  # en px
+
+    def __init__(self, nickname, font, how_to_process_cb, pos, width=300):
+        """
+        nickname: nickname, all messages will be prefixed with the nickname
+        font    : pygame.font.Font object
+        width   : in pixel that this element can use (this restricts the number
+                  of char you can enter
+
+        events:
+        in : pygame.KEYDOWN
+        out: eventtypes.CHATMSG
+        """
+        super().__init__()
+
+        self.position = pos
+        # test que le 3e arg est callable...
+        assert hasattr(how_to_process_cb, '__call__')
+        self.on_enter_func = how_to_process_cb
+
+        self.pwd_field = False
+
+        # data
+        self.__txt_content = ""
+        self.caretpos = 0
+        self.max = 255
+        self.nickname = nickname
+
+        # drawing
+        self.dirty = True
+        self.font = font
+        height = self.font.get_ascent() - self.font.get_descent() + 8
+        self.image = pygame.Surface((width, height)).convert()
+        self.size = (width, height)
+
+        self.text_color = (1, 1, 1)
+        self.text_field_rect = pygame.Rect(0, 0, width - 1, height - 1)
+        self.text_img = pygame.Surface((2, 2))
+        self.pixel_width = width - 4
+
+        self._focus = None
+        self.fill_color = None
+        self.no_focus()
+
+    def has_focus(self):
+        return self._focus
+
+    def get_disp_text(self):
+        if self.pwd_field:
+            return TextInput.hide_text(self.__txt_content)
+        return self.__txt_content
+
+    def focus(self):
+        self._focus = True
+        self.fill_color = (220, 220, 220)
+        self.render_field()
+
+    def no_focus(self):
+        self._focus = False
+        self.fill_color = (100, 100, 100)
+        self.render_field()
+
+    def contains(self, scr_pos):
+        w, h = self.image.get_size()
+        a, b = self.position[0], self.position[0] + w
+        c, d = self.position[1], self.position[1] + h
+        x, y = scr_pos
+        if (a < x < b) and (c < y < d):
+            return True
+        return False
+
+    @staticmethod
+    def hide_text(txt_content):
+        tmp = ['*' for i in range(len(txt_content))]
+        return ''.join(tmp)
+
+    def proc_event(self, event, source):
+        if event.type != pygame.KEYDOWN:
+            return
+
+        # - traitement touche pressée
+        if event.key == pygame.K_RETURN:
+            # self.on_enter()
+            self.on_enter_func(self.__txt_content)
+            self.__txt_content = ''
+            self.caretpos = 0
+
+        elif event.key == pygame.K_RIGHT:
+            self.move_caret(+1)
+
+        elif event.key == pygame.K_LEFT:
+            self.move_caret(-1)
+
+        elif event.key == pygame.K_HOME:
+            self.move_caret('home')
+
+        elif event.key == pygame.K_END:
+            self.move_caret('end')
+
+        elif event.key == pygame.K_BACKSPACE:
+            self.backspace_char()
+
+        elif event.key == pygame.K_DELETE:
+            self.delete_char()
+
+        elif event.key == pygame.K_TAB:
+            pass
+
+        else:
+            if event.unicode != '':
+                if len(self.__txt_content) < self.max:
+                    self.__txt_content = self.__txt_content[:self.caretpos] + event.unicode + self.__txt_content[
+                                                                                              self.caretpos:]
+                    self.caretpos += 1
+        self.render_field()
+
+    def move_caret(self, steps):
+        """
+        Moves the caret about steps. Positive numbers moves it right, negative
+        numbers left.
+        """
+        if steps == 'home':
+            self.caretpos = 0
+        elif steps == 'end':
+            self.caretpos = len(self.__txt_content)
+        else:
+            assert isinstance(steps, int)
+            self.caretpos += steps
+
+        if self.caretpos < 0:
+            self.caretpos = 0
+        if self.caretpos > len(self.__txt_content):
+            self.caretpos = len(self.__txt_content)
+
+    def backspace_char(self):
+        """
+        Deltes the char befor the caret position.
+        """
+        if self.caretpos > 0:
+            self.__txt_content = self.__txt_content[:self.caretpos - 1] + self.__txt_content[self.caretpos:]
+            self.caretpos -= 1
+
+    def delete_char(self):
+        """
+        Deltes the char after the caret position.
+        """
+        self.__txt_content = self.__txt_content[:self.caretpos] + self.__txt_content[self.caretpos + 1:]
+
+    def render_field(self):
+        """
+        Renders the string to self.image.
+        """
+        self.image.fill(self.fill_color)
+        content = self.get_disp_text()
+
+        if len(content):
+            # while self.font.size(content)[0] > self.pixel_width:
+            #    self.backspace_char()
+            self.text_img = self.font.render(content, 1, self.text_color, self.fill_color)
+            self.image.blit(self.text_img, (2, 2))
+            # - draw caret
+            # TODO fix pygame draw line
+            # xpos = self.font.size(content[:self.caretpos])[0] + 2
+            # pygame.draw.line(self.image, self._caret_color, (xpos, self._padding),
+            #                  (xpos, self.image.get_height() - self._padding), 2)
+        pygame.draw.rect(self.image, (100, 100, 100), self.text_field_rect, 2)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/base.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/base.py`

 * *Ordering differences only*

 * *Files 24% similar despite different names*

```diff
@@ -1,267 +1,267 @@
-from .BaseGuiElement import BaseGuiElement, ANCHOR_LEFT, ANCHOR_RIGHT, ANCHOR_CENTER
-from ... import _hub
-from ...compo import vscreen
-
-
-pygame = _hub.pygame
-EngineEvTypes = _hub.events.EngineEvTypes
-
-# pose pb en web context , parce que pygame used
-# SPATIAL_INFO = Union[pygame.math.Vector2, Tuple[int, int], Tuple[float, float]]
-
-
-class GenericUIElement(BaseGuiElement):
-    """
-    almost abstract element, all it contains is the minimal code,
-    so it can be visually debugged
-    """
-
-    def set_relative_pos(self, position):
-        pass
-
-    def __init__(self, position0, dimensions0, anchoring=None, debugmode=False):
-        super().__init__()
-
-        # state/sys
-        self._debug_mode = debugmode
-        self._is_active = True
-        self._cached_scr_ref = None
-
-        # regular attributes
-        self._dim = [-1, -1]
-        self.set_dimensions(dimensions0)
-
-        self._curr_anchor = ANCHOR_LEFT  # the default one
-        if anchoring:
-            self.set_anchoring(anchoring)
-
-        self._xy_coords = [0, 0]
-        self.set_position(position0)
-
-        self._hovered_rn = False
-
-    # ----------------------------
-    #  handy, even if not made explicit by the iface
-    # ----------------------------
-    @property
-    def x(self):
-        return self.get_position()[0]
-
-    @x.setter
-    def x(self, newx):
-        self.set_position((newx, self.y))
-
-    @property
-    def y(self):
-        return self.get_position()[1]
-
-    @y.setter
-    def y(self, newy):
-        self.set_position((self.x, newy))
-
-    # ----------
-    #  reg methods implem
-    # ----------
-    def rebuild(self) -> None:
-        pass
-
-    def get_position(self):
-        if self._curr_anchor == ANCHOR_LEFT:
-            return self._xy_coords
-        elif self._curr_anchor == ANCHOR_CENTER:
-            hw, hh = self._dim
-            hw = int(hw / 2)
-            hh = int(hh / 2)
-            return self._xy_coords[0] + hw, self._xy_coords[1] + hh
-
-    def set_position(self, position):
-        # args passed are absolute!
-        if self._curr_anchor == ANCHOR_LEFT:
-            self._xy_coords[0], self._xy_coords[1] = position
-
-        elif self._curr_anchor == ANCHOR_CENTER:
-            hw, hh = self._dim
-            hw = int(hw/2)
-            hh = int(hh/2)
-            self._xy_coords[0] = position[0] - hw
-            self._xy_coords[1] = position[1] - hh
-
-    def set_relative_position(self, position):
-        # TODO
-        raise Exception
-
-    def get_dimensions(self):
-        return self._dim
-
-    def set_dimensions(self, dimensions):
-        self._dim[0], self._dim[1] = dimensions
-
-    def get_relative_rect(self):# -> pygame.Rect:
-        pass
-
-    def get_abs_rect(self):  # -> pygame.Rect:
-        pass
-
-    def update(self, time_delta: float):
-        # GenericUIElement doesnt react
-        pass
-
-    def draw(self):
-        if self._cached_scr_ref is None:
-            self._cached_scr_ref = vscreen.get_screen()
-
-        if self._debug_mode:
-            pygame.draw.rect(
-                self._cached_scr_ref,
-                'red',
-                (self._xy_coords[0]-1, self._xy_coords[1]-1, self._dim[0]+1, self._dim[1]+1),
-                2  # line width
-            )
-
-    def kill(self):
-        pass
-
-    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
-        pass
-
-    def hover_point(self, hover_x: float, hover_y: float) -> bool:
-        pass
-
-    def proc_event(self, event) -> bool:
-        if event.type == pygame.MOUSEMOTION:
-            mx, my = vscreen.proj_to_vscreen(event.pos)
-            if not self._hovered_rn:
-                if self._xy_coords[0] < mx < self._xy_coords[0]+self._dim[0]:
-                    if self._xy_coords[1] < my < self._xy_coords[1]+self._dim[1]:
-                        self._hovered_rn = True
-                        self.on_hover()
-
-            if self._hovered_rn:
-                hit = False
-                if self._xy_coords[0] < mx < self._xy_coords[0]+self._dim[0]:
-                    if self._xy_coords[1] < my < self._xy_coords[1]+self._dim[1]:
-                        hit = True
-                if not hit:
-                    self._hovered_rn = False
-                    self.on_unhover()
-            return True
-        else:
-            return False
-
-    def set_debug_mode(self, activate_mode: bool):
-        self._debug_mode = activate_mode
-
-    def set_image(self, new_image):  #: Union[pygame.surface.Surface, None]
-        pass
-
-    def set_active(self, activate_mode: bool):
-        self._is_active = True
-
-    def set_anchoring(self, anch_code):
-        self._curr_anchor = anch_code
-
-    def get_anchoring(self) -> int:
-        pass
-
-    # ---------------------------
-    #  CAN be re-defined later (callbacks)
-    # ---------------------------
-    def on_hover(self):
-        pass
-
-    def on_unhover(self):
-        pass
-
-    def on_focus(self):
-        pass
-
-    def on_unfocus(self):
-        pass
-
-
-class Button(GenericUIElement):
-    pass  # TODO
-
-
-class AugmentedSprite(GenericUIElement):
-    """
-    it's like a sprite but can be clicked/hovered/focused
-    """
-    def __init__(self, img, anchoring=None):
-        img_dim = img.get_size()
-        self._inner_sprite = pygame.sprite.Sprite()
-        self._inner_sprite.image = img
-        self._inner_sprite.rect = img.get_rect()
-
-        super().__init__((0, 0), img_dim, anchoring)
-        self.callback = None  # can be used whenever the element is clicked!
-        self.hovered = False
-
-    @property
-    def rect(self):
-        return self._inner_sprite.rect
-
-    def get_position(self):
-        return self._inner_sprite.rect.topleft
-
-    def set_position(self, pos):
-        self._xy_coords[0], self._xy_coords[1] = pos
-        self._inner_sprite.rect.topleft = pos
-
-    def draw(self):
-        scr = vscreen.get_screen()
-        scr.blit(self._inner_sprite.image, self._inner_sprite.rect.topleft)
-        if self._debug:
-            pygame.draw.rect(scr, 'red', (self._inner_sprite.rect.topleft, self._inner_sprite.image.get_size()), 1)
-
-    def proc_event(self, event) -> bool:  # event: pygame.event.Event
-        if self._is_active:
-            super().proc_event(event)
-
-            if event.type == EngineEvTypes.Paint:
-                self.draw()
-
-            if event.type == pygame.MOUSEBUTTONDOWN:
-                print('augmented spr knows click')
-                updated_pos = vscreen.proj_to_vscreen(event.pos)
-
-                if self._inner_sprite.rect.collidepoint(updated_pos):  # hit
-                    print('HIT on augmented sprite detected...')
-                    if self.callback is not None:
-                        self.callback(event.button)
-            return True
-        else:
-            return False
-
-
-
-class _SprLikeLabel(pygame.sprite.Sprite):
-    # TODO make it a UIelement
-
-    def __init__(self, txt, txtsize, color=None):
-        self._font = pygame.font.Font(None, txtsize)
-
-        super().__init__()
-
-        self._txt = txt
-
-        self._color = [0, 0, 0]
-        if color:
-            try:
-                self._color[0], self._color[1], self._color[2] = color.r, color.g, color.b
-            except (ValueError, AttributeError):
-                # force conversion to color
-                c = pygame.color.Color(color)
-                self._color[0], self._color[1], self._color[2] = c.r, c.g, c.b
-        # init image & rect, as well!
-        self.color = self._color
-
-    @property
-    def color(self):
-        return self._color
-
-    @color.setter
-    def color(self, value):
-        self._color = value
-        self.image = self._font.render(self._txt, False, value)
-        self.rect = self.image.get_rect()
+from .BaseGuiElement import BaseGuiElement, ANCHOR_LEFT, ANCHOR_RIGHT, ANCHOR_CENTER
+from ... import _hub
+from ...compo import vscreen
+
+
+pygame = _hub.pygame
+EngineEvTypes = _hub.events.EngineEvTypes
+
+# pose pb en web context , parce que pygame used
+# SPATIAL_INFO = Union[pygame.math.Vector2, Tuple[int, int], Tuple[float, float]]
+
+
+class GenericUIElement(BaseGuiElement):
+    """
+    almost abstract element, all it contains is the minimal code,
+    so it can be visually debugged
+    """
+
+    def set_relative_pos(self, position):
+        pass
+
+    def __init__(self, position0, dimensions0, anchoring=None, debugmode=False):
+        super().__init__()
+
+        # state/sys
+        self._debug_mode = debugmode
+        self._is_active = True
+        self._cached_scr_ref = None
+
+        # regular attributes
+        self._dim = [-1, -1]
+        self.set_dimensions(dimensions0)
+
+        self._curr_anchor = ANCHOR_LEFT  # the default one
+        if anchoring:
+            self.set_anchoring(anchoring)
+
+        self._xy_coords = [0, 0]
+        self.set_position(position0)
+
+        self._hovered_rn = False
+
+    # ----------------------------
+    #  handy, even if not made explicit by the iface
+    # ----------------------------
+    @property
+    def x(self):
+        return self.get_position()[0]
+
+    @x.setter
+    def x(self, newx):
+        self.set_position((newx, self.y))
+
+    @property
+    def y(self):
+        return self.get_position()[1]
+
+    @y.setter
+    def y(self, newy):
+        self.set_position((self.x, newy))
+
+    # ----------
+    #  reg methods implem
+    # ----------
+    def rebuild(self) -> None:
+        pass
+
+    def get_position(self):
+        if self._curr_anchor == ANCHOR_LEFT:
+            return self._xy_coords
+        elif self._curr_anchor == ANCHOR_CENTER:
+            hw, hh = self._dim
+            hw = int(hw / 2)
+            hh = int(hh / 2)
+            return self._xy_coords[0] + hw, self._xy_coords[1] + hh
+
+    def set_position(self, position):
+        # args passed are absolute!
+        if self._curr_anchor == ANCHOR_LEFT:
+            self._xy_coords[0], self._xy_coords[1] = position
+
+        elif self._curr_anchor == ANCHOR_CENTER:
+            hw, hh = self._dim
+            hw = int(hw/2)
+            hh = int(hh/2)
+            self._xy_coords[0] = position[0] - hw
+            self._xy_coords[1] = position[1] - hh
+
+    def set_relative_position(self, position):
+        # TODO
+        raise Exception
+
+    def get_dimensions(self):
+        return self._dim
+
+    def set_dimensions(self, dimensions):
+        self._dim[0], self._dim[1] = dimensions
+
+    def get_relative_rect(self):# -> pygame.Rect:
+        pass
+
+    def get_abs_rect(self):  # -> pygame.Rect:
+        pass
+
+    def update(self, time_delta: float):
+        # GenericUIElement doesnt react
+        pass
+
+    def draw(self):
+        if self._cached_scr_ref is None:
+            self._cached_scr_ref = vscreen.get_screen()
+
+        if self._debug_mode:
+            pygame.draw.rect(
+                self._cached_scr_ref,
+                'red',
+                (self._xy_coords[0]-1, self._xy_coords[1]-1, self._dim[0]+1, self._dim[1]+1),
+                2  # line width
+            )
+
+    def kill(self):
+        pass
+
+    def check_hover(self, time_delta: float, hovered_higher_element: bool) -> bool:
+        pass
+
+    def hover_point(self, hover_x: float, hover_y: float) -> bool:
+        pass
+
+    def proc_event(self, event) -> bool:
+        if event.type == pygame.MOUSEMOTION:
+            mx, my = vscreen.proj_to_vscreen(event.pos)
+            if not self._hovered_rn:
+                if self._xy_coords[0] < mx < self._xy_coords[0]+self._dim[0]:
+                    if self._xy_coords[1] < my < self._xy_coords[1]+self._dim[1]:
+                        self._hovered_rn = True
+                        self.on_hover()
+
+            if self._hovered_rn:
+                hit = False
+                if self._xy_coords[0] < mx < self._xy_coords[0]+self._dim[0]:
+                    if self._xy_coords[1] < my < self._xy_coords[1]+self._dim[1]:
+                        hit = True
+                if not hit:
+                    self._hovered_rn = False
+                    self.on_unhover()
+            return True
+        else:
+            return False
+
+    def set_debug_mode(self, activate_mode: bool):
+        self._debug_mode = activate_mode
+
+    def set_image(self, new_image):  #: Union[pygame.surface.Surface, None]
+        pass
+
+    def set_active(self, activate_mode: bool):
+        self._is_active = True
+
+    def set_anchoring(self, anch_code):
+        self._curr_anchor = anch_code
+
+    def get_anchoring(self) -> int:
+        pass
+
+    # ---------------------------
+    #  CAN be re-defined later (callbacks)
+    # ---------------------------
+    def on_hover(self):
+        pass
+
+    def on_unhover(self):
+        pass
+
+    def on_focus(self):
+        pass
+
+    def on_unfocus(self):
+        pass
+
+
+class Button(GenericUIElement):
+    pass  # TODO
+
+
+class AugmentedSprite(GenericUIElement):
+    """
+    it's like a sprite but can be clicked/hovered/focused
+    """
+    def __init__(self, img, anchoring=None):
+        img_dim = img.get_size()
+        self._inner_sprite = pygame.sprite.Sprite()
+        self._inner_sprite.image = img
+        self._inner_sprite.rect = img.get_rect()
+
+        super().__init__((0, 0), img_dim, anchoring)
+        self.callback = None  # can be used whenever the element is clicked!
+        self.hovered = False
+
+    @property
+    def rect(self):
+        return self._inner_sprite.rect
+
+    def get_position(self):
+        return self._inner_sprite.rect.topleft
+
+    def set_position(self, pos):
+        self._xy_coords[0], self._xy_coords[1] = pos
+        self._inner_sprite.rect.topleft = pos
+
+    def draw(self):
+        scr = vscreen.get_screen()
+        scr.blit(self._inner_sprite.image, self._inner_sprite.rect.topleft)
+        if self._debug:
+            pygame.draw.rect(scr, 'red', (self._inner_sprite.rect.topleft, self._inner_sprite.image.get_size()), 1)
+
+    def proc_event(self, event) -> bool:  # event: pygame.event.Event
+        if self._is_active:
+            super().proc_event(event)
+
+            if event.type == EngineEvTypes.Paint:
+                self.draw()
+
+            if event.type == pygame.MOUSEBUTTONDOWN:
+                print('augmented spr knows click')
+                updated_pos = vscreen.proj_to_vscreen(event.pos)
+
+                if self._inner_sprite.rect.collidepoint(updated_pos):  # hit
+                    print('HIT on augmented sprite detected...')
+                    if self.callback is not None:
+                        self.callback(event.button)
+            return True
+        else:
+            return False
+
+
+
+class _SprLikeLabel(pygame.sprite.Sprite):
+    # TODO make it a UIelement
+
+    def __init__(self, txt, txtsize, color=None):
+        self._font = pygame.font.Font(None, txtsize)
+
+        super().__init__()
+
+        self._txt = txt
+
+        self._color = [0, 0, 0]
+        if color:
+            try:
+                self._color[0], self._color[1], self._color[2] = color.r, color.g, color.b
+            except (ValueError, AttributeError):
+                # force conversion to color
+                c = pygame.color.Color(color)
+                self._color[0], self._color[1], self._color[2] = c.r, c.g, c.b
+        # init image & rect, as well!
+        self.color = self._color
+
+    @property
+    def color(self):
+        return self._color
+
+    @color.setter
+    def color(self, value):
+        self._color = value
+        self.image = self._font.render(self._txt, False, value)
+        self.rect = self.image.get_rect()
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/gui/text.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/gui/text.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,188 +1,188 @@
-from ... import _hub
-
-pygame = _hub.pygame
-
-
-def clip(surf, x, y, x_size, y_size):
-    # WTF bro? Part of original code commented:
-    # handle_surf = surf.copy()
-    clip_r = pygame.Rect(x, y, x_size, y_size)
-    # handle_surf.set_clip(clipR)
-    image = surf.subsurface(clip_r)  # handle_surf.get_clip())
-
-    # pr port ca vers Web Ctx
-    # ya donc que 2 operations a emuler convenablement: .subsurface & .copy
-    return image.copy()
-
-
-def swap_color(img, old_c, new_c):
-    img.set_colorkey(old_c)
-    surf = img.copy()
-    surf.fill(new_c)
-    surf.blit(img, (0, 0))
-    return surf
-
-
-def load_font_img(path, font_color, precomp_letter_widths=None, verbose=False):
-    fg_color = (255, 0, 0)
-    bg_color = (0, 0, 0)
-    font_img = pygame.image.load(path).convert()
-    valid_letter_h = font_img.get_height()
-
-    # N.B. theres a BUG when interactin with KataSDK, thats why I have
-    # commetend the line below.
-    # Hence ktg-webapp does not crash but it cannot swap color.
-    # TODO: fix the bug Asap!
-
-    # font_img = swap_color(font_img, fg_color, font_color)
-    last_x = 0
-
-    letter_widths = list()
-    if precomp_letter_widths:
-        letter_widths.extend(precomp_letter_widths)
-    else:
-        # compute dynamically, by using >>Surface.get_at(xy_coords)<<
-        print('*** ------------ Dyn computing letters_widths -------------- ***')
-        for x in range(0, font_img.get_width()):
-            colorinfos = font_img.get_at((x, 0))
-            if colorinfos[0] == 127:
-                tmpw = x - last_x
-                letter_widths.append(tmpw)
-                last_x = x + 1
-            x += 1
-
-    # algo (STEP2) use the letter_width to produce letter_rects
-    letter_rects = list()
-    cumul = 0
-    for given_letter_w in letter_widths:
-        letter_rects.append([cumul, 0, given_letter_w, valid_letter_h])
-        # - deprec
-        # letters.append(
-        #     clip(font_img, last_x, 0, tmpw, tmph)
-        # )
-        cumul += given_letter_w + 1
-
-    # - deprec
-    # for letter in letters:
-    #     letter.set_colorkey(bg_color)
-
-    # - verbose output, useful to DEBUG
-    if verbose:
-        card_l = len(letter_rects)
-        print('*debug ImgBasedText*')
-        print(f' ... source={path}')
-        print(f' ... num of letters={card_l}')
-        print(f' ... rects={letter_rects}')
-        print(f' ... letter_spacings {letter_widths}')
-    return letter_rects, letter_widths, font_img.get_height()
-
-
-class ImgBasedFont:
-    # use_colorkey_flag = True  # this is a hotfix for the webctx where on needs to not use colorkey val
-    precomputed_widths_data = None
-    debugmode_flag = False
-
-    def __init__(self, path, color):
-        self._spr_sheet_like = pygame.image.load(path)
-
-        if self.precomputed_widths_data:
-            triplet = load_font_img(path, color, precomp_letter_widths=self.precomputed_widths_data,
-                                    verbose=self.debugmode_flag)
-        else:
-            triplet = load_font_img(path, color)
-
-        self.letters_rects, self.letter_spacing, self.line_height = triplet
-        self.font_order = [
-            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
-            'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
-            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', '-',
-            ',', ':', '+', '\'', '!', '?', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '(', ')',
-            '/', '_', '=', '\\', '[', ']', '*', '"', '<', '>', ';', '#', '$', '%', '@', '{', '}', '`',
-            '~'
-        ]
-        self.letter_to_idx = dict()
-        for idx, one_char in enumerate(self.font_order):
-            self.letter_to_idx[one_char] = idx
-
-        self.space_width = self.letter_spacing[self.font_order.index('_')]
-        self.base_spacing = 1
-        self.line_spacing = 2
-
-    def get_linesize(self):  # stick to pygame interface
-        return 11  # TODO implement properly plz! 11 is hardset comes from 11px the PNG height gibson0_font
-
-    def size(self, sample_txt):  # stick to pygame interface
-        return self.width(sample_txt), self.get_linesize()
-
-    def width(self, text):
-        text_width = 0
-        for char in text:
-            if char == ' ':
-                text_width += self.space_width + self.base_spacing
-            else:
-                try:
-                    idx = self.font_order.index(char)
-                except ValueError:
-                    # generic char
-                    print('cannot comp width for: ', char)
-                    idx = self.font_order.index('_')
-                text_width += self.letter_spacing[idx] + self.base_spacing
-
-        return text_width
-
-    # ---
-    # add-on, only to be compatible with the pygame interface
-    def render(self, gtext, antialias, color, bgcolor=None):
-        rez = pygame.Surface((self.width(gtext), self.get_linesize()), pygame.SRCALPHA)
-
-        # ancien code -
-
-        # if not self.NO_CK_MODE:
-        #     upink = (255, 0, 255)  # ugly pink
-        #    rez.fill(upink)
-        # self._xrender(gtext, rez, (0, 0))
-        # if not self.NO_CK_MODE:
-        #     rez.set_colorkey(upink)
-
-        # nouveau code -
-        # avant, tt ce bout cetait dans
-        # def _xrender(self, text, targ_surf, loc, line_width=0)
-
-        text = gtext
-        targ_surf = rez
-        loc = (0, 0)
-
-        # - deprec for now, DO NOT DELETE, it could be useful someday soon (today is november 1st)
-        # if line_width:
-        #     spaces = []
-        #     x = 0
-        #     for i, char in enumerate(text):
-        #         if char == ' ':
-        #             spaces.append((x, i))
-        #             x += self.space_width + self.base_spacing
-        #         else:
-        #             x += self.letter_spacing[self.font_order.index(char)] + self.base_spacing
-        #     line_offset = 0
-        #     for i, space in enumerate(spaces):
-        #         if (space[0] - line_offset) > line_width:
-        #             line_offset += spaces[i - 1][0] - line_offset
-        #             if i != 0:
-        #                 text = text[:spaces[i - 1][1]] + '\n' + text[spaces[i - 1][1] + 1:]
-
-        # escaped_chars ARE ['\n', ' ', '\r']
-        x_offset = y_offset = 0
-        for char in text:
-            if char == '\n':
-                y_offset += self.line_spacing + self.line_height
-                x_offset = 0
-            elif char == ' ':
-                x_offset += self.space_width + self.base_spacing
-            elif char == '\r':
-                pass
-            else:
-                # surf.blit(self.letters[self.font_order.index(char)], (loc[0] + x_offset, loc[1] + y_offset))
-                tmpr = self.letters_rects[self.letter_to_idx[char]]
-                targ_surf.blit(self._spr_sheet_like, (loc[0] + x_offset, loc[1] + y_offset), area=tmpr)
-                x_offset += self.letter_spacing[self.font_order.index(char)] + self.base_spacing
-
-        return rez
+from ... import _hub
+
+pygame = _hub.pygame
+
+
+def clip(surf, x, y, x_size, y_size):
+    # WTF bro? Part of original code commented:
+    # handle_surf = surf.copy()
+    clip_r = pygame.Rect(x, y, x_size, y_size)
+    # handle_surf.set_clip(clipR)
+    image = surf.subsurface(clip_r)  # handle_surf.get_clip())
+
+    # pr port ca vers Web Ctx
+    # ya donc que 2 operations a emuler convenablement: .subsurface & .copy
+    return image.copy()
+
+
+def swap_color(img, old_c, new_c):
+    img.set_colorkey(old_c)
+    surf = img.copy()
+    surf.fill(new_c)
+    surf.blit(img, (0, 0))
+    return surf
+
+
+def load_font_img(path, font_color, precomp_letter_widths=None, verbose=False):
+    fg_color = (255, 0, 0)
+    bg_color = (0, 0, 0)
+    font_img = pygame.image.load(path).convert()
+    valid_letter_h = font_img.get_height()
+
+    # N.B. theres a BUG when interactin with KataSDK, thats why I have
+    # commetend the line below.
+    # Hence ktg-webapp does not crash but it cannot swap color.
+    # TODO: fix the bug Asap!
+
+    # font_img = swap_color(font_img, fg_color, font_color)
+    last_x = 0
+
+    letter_widths = list()
+    if precomp_letter_widths:
+        letter_widths.extend(precomp_letter_widths)
+    else:
+        # compute dynamically, by using >>Surface.get_at(xy_coords)<<
+        print('*** ------------ Dyn computing letters_widths -------------- ***')
+        for x in range(0, font_img.get_width()):
+            colorinfos = font_img.get_at((x, 0))
+            if colorinfos[0] == 127:
+                tmpw = x - last_x
+                letter_widths.append(tmpw)
+                last_x = x + 1
+            x += 1
+
+    # algo (STEP2) use the letter_width to produce letter_rects
+    letter_rects = list()
+    cumul = 0
+    for given_letter_w in letter_widths:
+        letter_rects.append([cumul, 0, given_letter_w, valid_letter_h])
+        # - deprec
+        # letters.append(
+        #     clip(font_img, last_x, 0, tmpw, tmph)
+        # )
+        cumul += given_letter_w + 1
+
+    # - deprec
+    # for letter in letters:
+    #     letter.set_colorkey(bg_color)
+
+    # - verbose output, useful to DEBUG
+    if verbose:
+        card_l = len(letter_rects)
+        print('*debug ImgBasedText*')
+        print(f' ... source={path}')
+        print(f' ... num of letters={card_l}')
+        print(f' ... rects={letter_rects}')
+        print(f' ... letter_spacings {letter_widths}')
+    return letter_rects, letter_widths, font_img.get_height()
+
+
+class ImgBasedFont:
+    # use_colorkey_flag = True  # this is a hotfix for the webctx where on needs to not use colorkey val
+    precomputed_widths_data = None
+    debugmode_flag = False
+
+    def __init__(self, path, color):
+        self._spr_sheet_like = pygame.image.load(path)
+
+        if self.precomputed_widths_data:
+            triplet = load_font_img(path, color, precomp_letter_widths=self.precomputed_widths_data,
+                                    verbose=self.debugmode_flag)
+        else:
+            triplet = load_font_img(path, color)
+
+        self.letters_rects, self.letter_spacing, self.line_height = triplet
+        self.font_order = [
+            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R',
+            'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j',
+            'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '.', '-',
+            ',', ':', '+', '\'', '!', '?', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '(', ')',
+            '/', '_', '=', '\\', '[', ']', '*', '"', '<', '>', ';', '#', '$', '%', '@', '{', '}', '`',
+            '~'
+        ]
+        self.letter_to_idx = dict()
+        for idx, one_char in enumerate(self.font_order):
+            self.letter_to_idx[one_char] = idx
+
+        self.space_width = self.letter_spacing[self.font_order.index('_')]
+        self.base_spacing = 1
+        self.line_spacing = 2
+
+    def get_linesize(self):  # stick to pygame interface
+        return 11  # TODO implement properly plz! 11 is hardset comes from 11px the PNG height gibson0_font
+
+    def size(self, sample_txt):  # stick to pygame interface
+        return self.width(sample_txt), self.get_linesize()
+
+    def width(self, text):
+        text_width = 0
+        for char in text:
+            if char == ' ':
+                text_width += self.space_width + self.base_spacing
+            else:
+                try:
+                    idx = self.font_order.index(char)
+                except ValueError:
+                    # generic char
+                    print('cannot comp width for: ', char)
+                    idx = self.font_order.index('_')
+                text_width += self.letter_spacing[idx] + self.base_spacing
+
+        return text_width
+
+    # ---
+    # add-on, only to be compatible with the pygame interface
+    def render(self, gtext, antialias, color, bgcolor=None):
+        rez = pygame.Surface((self.width(gtext), self.get_linesize()), pygame.SRCALPHA)
+
+        # ancien code -
+
+        # if not self.NO_CK_MODE:
+        #     upink = (255, 0, 255)  # ugly pink
+        #    rez.fill(upink)
+        # self._xrender(gtext, rez, (0, 0))
+        # if not self.NO_CK_MODE:
+        #     rez.set_colorkey(upink)
+
+        # nouveau code -
+        # avant, tt ce bout cetait dans
+        # def _xrender(self, text, targ_surf, loc, line_width=0)
+
+        text = gtext
+        targ_surf = rez
+        loc = (0, 0)
+
+        # - deprec for now, DO NOT DELETE, it could be useful someday soon (today is november 1st)
+        # if line_width:
+        #     spaces = []
+        #     x = 0
+        #     for i, char in enumerate(text):
+        #         if char == ' ':
+        #             spaces.append((x, i))
+        #             x += self.space_width + self.base_spacing
+        #         else:
+        #             x += self.letter_spacing[self.font_order.index(char)] + self.base_spacing
+        #     line_offset = 0
+        #     for i, space in enumerate(spaces):
+        #         if (space[0] - line_offset) > line_width:
+        #             line_offset += spaces[i - 1][0] - line_offset
+        #             if i != 0:
+        #                 text = text[:spaces[i - 1][1]] + '\n' + text[spaces[i - 1][1] + 1:]
+
+        # escaped_chars ARE ['\n', ' ', '\r']
+        x_offset = y_offset = 0
+        for char in text:
+            if char == '\n':
+                y_offset += self.line_spacing + self.line_height
+                x_offset = 0
+            elif char == ' ':
+                x_offset += self.space_width + self.base_spacing
+            elif char == '\r':
+                pass
+            else:
+                # surf.blit(self.letters[self.font_order.index(char)], (loc[0] + x_offset, loc[1] + y_offset))
+                tmpr = self.letters_rects[self.letter_to_idx[char]]
+                targ_surf.blit(self._spr_sheet_like, (loc[0] + x_offset, loc[1] + y_offset), area=tmpr)
+                x_offset += self.letter_spacing[self.font_order.index(char)] + self.base_spacing
+
+        return rez
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/IsometricMapViewer.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/IsometricMapViewer.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,562 +1,562 @@
-import math
-
-from .isosm_config import NOT_ALL_FLAGS, FLIPPED_VERTICALLY_FLAG, FLIPPED_HORIZONTALLY_FLAG, SCROLL_STEP
-from ... import _hub
-from ...compo import vscreen as core
-
-
-# - aliases
-EngineEvTypes = _hub.events.EngineEvTypes
-EvListener = _hub.events.EvListener
-
-# --------------------------------------------
-# optimization
-_gl_halftile_w = _gl_halftile_h = None
-_buffer_relx = dict()
-_buffer_rely = dict()
-
-
-def relative_x(x, y):
-    """Return the relative x position of this tile, ignoring offset."""
-    try:
-        return _buffer_relx[x][y]
-    except KeyError:
-        if x not in _buffer_relx:
-            _buffer_relx[x] = dict()
-        _buffer_relx[x][y] = int(x * _gl_halftile_w - y * _gl_halftile_w)
-        return _buffer_relx[x][y]
-
-
-def relative_y(x, y):
-    """Return the relative y position of this tile, ignoring offset."""
-    try:
-        return _buffer_rely[x][y]
-    except KeyError:
-        if x not in _buffer_rely:
-            _buffer_rely[x] = dict()
-        _buffer_rely[x][y] = int(y * _gl_halftile_h + x * _gl_halftile_h)
-        return _buffer_rely[x][y]
-
-
-def rel_set_info(halftile_w, halftile_h):
-    global _gl_halftile_w, _gl_halftile_h, _buffer_relx, _buffer_rely
-    _gl_halftile_w = float(halftile_w)
-    _gl_halftile_h = float(halftile_h)
-    _buffer_relx.clear()
-    _buffer_rely.clear()
-
-
-# ----------------------------------------------
-
-
-class IsometricMapViewer(EvListener):
-    MEGAOPTIM = False
-    SOLID_COLOR = 'navyblue'
-    FLOORS = {}
-    FLOOR_MAN_OFFSET = {
-        0: (1617 + 305, 240 - 128),  # what offset one needs to apply so the floor img is aligned, map 0 (city.png)
-        1: (522 + 300, 100 - 92)
-    }
-    UPINK = (255, 0, 255)
-
-    @property
-    def show_avatar(self):
-        return self._show_avatar
-
-    @show_avatar.setter
-    def show_avatar(self, newval):
-        self._show_avatar = newval
-        self.force_redraw_flag = True
-
-    def set_av_anim_speed(self, v):
-        self.av_phase_thresh = int(100/v)
-
-    def __init__(self, isometric_map, screen, postfx=None, cursor=None,
-                 left_scroll_key=None, right_scroll_key=None, up_scroll_key=None, down_scroll_key=None):
-        super().__init__()
-
-        # RELATED to avatar {{ -- player character class --
-        self.pc_cls = int  # this needs to be set from outside, related to perf optimization
-        self._show_avatar = True
-        self.force_redraw_flag = False
-        self.av_phase_thresh = 3
-        self.av_phase = self.av_phase_thresh - 1
-        self.av_frame = 1
-        self.anim_av_offset = [2.0, -1.0]
-        self.cutav = None
-        self.cutav_cpt = 1
-
-        self.extra_anim = None
-        # done }}
-        self.animated_wallpaper = False
-        self.block_wallpaper = False
-        self.info_draw_mapobj = dict()
-
-        self.isometric_map = isometric_map
-
-        self.manoffset = (0, 0)
-        self.scrollable_floor = None
-
-        self.screen = screen
-        self.mid = (
-            self.screen.get_width() // 2, self.screen.get_height() // 2
-        )
-        # self.prevx = float('NaN')
-        # self.prevy = float('NaN')
-
-        self.floor_rect = _hub.pygame.Rect(0, 0, self.screen.get_width(), self.screen.get_height())
-        self.gfx_data_buffer = _hub.pygame.Surface(self.screen.get_size())
-        self.gfx_data_buffer.set_colorkey(self.UPINK)
-
-        if isometric_map.wallpaper:
-            self.screen_rect = self.screen.get_rect()
-            wp_width, wp_height = self.isometric_map.wallpaper.get_size()
-            self.wp_temp_rect = _hub.pygame.Rect(0, 0, wp_width, wp_height)
-            self.wp_grid_w = self.screen_rect.w // wp_width + 1
-            self.wp_grid_h = self.screen_rect.h // wp_height + 1
-
-        # The focus is defined by map coordinates, so a lot of the back and forth between screen and map coords
-        # can be cut.
-        self._focus_x = 0
-        self._focus_y = 0
-        self._focused_object_x0 = 0
-        self._focused_object_y0 = 0
-        self._focused_object = None
-
-        self.phase = 0
-
-        self.tile_width = isometric_map.tile_width
-        self.tile_height = isometric_map.tile_height
-
-        self.half_tile_width = isometric_map.tile_width // 2
-        self.half_tile_height = isometric_map.tile_height // 2
-        rel_set_info(
-            self.half_tile_width, self.half_tile_height
-        )
-        self.visible_area = None
-        self._init_visible_area_init(self.screen)
-
-        # _mouse_tile contains the actual tile the mouse is hovering over. However, in most cases what we really want
-        # is the location of the mouse cursor. Time to make a property!
-        self._mouse_tile = (-1, -1)
-        self.postfx = postfx
-        self.cursor = cursor
-        self.left_scroll_key = left_scroll_key
-        self.right_scroll_key = right_scroll_key
-        self.up_scroll_key = up_scroll_key
-        self.down_scroll_key = down_scroll_key
-        self.debug_sprite = None
-        self.lastmousepos = None
-
-        # util for the drawing of tiles
-        self.line_cache = list()
-        self.objgroup_contents = dict()
-        self.objgroup_modified_mappos = dict()
-        self._camera_updated_this_frame = False
-
-    def enable_megaoptim(self, imgcity, imgcasino):
-        self.MEGAOPTIM = True
-        self.FLOORS.update({
-            0: imgcity,
-            1: imgcasino
-        })
-        self.manoffset = self.FLOOR_MAN_OFFSET[0]
-        self.scrollable_floor = self.FLOORS[0]
-        self.scrollable_floor.set_colorkey(self.UPINK)
-
-    def _check_mouse_scroll(self, screen_area, mouse_x, mouse_y):
-        # Check for map scrolling, depending on mouse position.
-        if not self._camera_updated_this_frame:
-            if mouse_x < 20:
-                dx = -SCROLL_STEP
-            elif mouse_x > (screen_area.right - 20):
-                dx = +SCROLL_STEP
-            else:
-                dx = 0
-
-            if mouse_y < 20:
-                dy = -SCROLL_STEP
-            elif mouse_y > (screen_area.bottom - 20):
-                dy = +SCROLL_STEP
-            else:
-                dy = 0
-
-            if dx or dy:
-                self._update_camera(dx, dy)
-
-    def _get_horizontal_line(self, x0, y0, line_number):
-        x = x0 + line_number // 2
-        y = y0 + (line_number + 1) // 2
-
-        _, py = self.screen_coords(x, y)
-        if py > self.visible_area.bottom:
-            return None
-
-        mylist = list()
-        while self.screen_coords(x, y)[0] < self.visible_area.right:
-            if self.isometric_map.on_the_map(x, y):
-                mylist.append((x, y))
-            x += 1
-            y -= 1
-        return mylist
-
-    def _init_visible_area_init(self, scr):
-        # The visible area describes the region of the map we need to draw
-        w, h = scr.get_size()
-        # below: args idx 0 and 1 do not matter actually
-        tw, th = self.isometric_map.tile_width, self.isometric_map.tile_height
-        self.visible_area = _hub.pygame.Rect(0, 0, w + int(0.5*tw), h + 6*th)
-
-    def _model_depth(self, model):
-        return relative_y(model.x, model.y)
-
-    def _update_camera(self, dx, dy):
-        # If the mouse and the arrow keys conflict, only one of them should win.
-        if self._camera_updated_this_frame:
-            return
-        self._focus_x, self._focus_y = self.isometric_map.clamp_pos([self._focus_x + dx, self._focus_y + dy])
-
-    def impacte_surf(self, output_surf):
-        # --- init step before drawing map objects:
-        # we record all of the objectgroup contents for display when their tile comes up
-        # Also, clamp all object positions. If this is an infinite scrolling map,
-        # objects can move off one side to the map to the other.
-        # However, in their data, we want the objects to stay within the bounds of the map.
-
-        # ++++++ old code:
-        # print( self.isometric_map.objectgroups.keys() )
-        # print(self.isometric_map.objectgroups.values())
-        # for k, v in self.isometric_map.objectgroups.items():
-        #     self.objgroup_contents[k] = collections.defaultdict(list)
-        #     for ob in v.contents:
-        #         print('ob found:', ob)
-        #         ob.x, ob.y = self.isometric_map.clamp_pos((ob.x, ob.y))
-        #         sx, sy = self.screen_coords(ob.x, ob.y, v.offsetx, v.offsety)
-        #         mx, my = self.map_x(sx, sy, return_int=False), self.map_y(sx, sy, return_int=False)
-        #         obkey = self.isometric_map.clamp_pos_int((mx, my))
-        #         self.objgroup_contents[k][obkey].append(ob)
-        #         # Also save the mofidied map pos, which will come in handy later.
-        #         self.objgroup_modified_mappos[ob] = (mx, my)
-        # print(3 / 0)
-
-        # ++++++ new code:
-        self.info_draw_mapobj.clear()
-        for layerk, objgroup in self.isometric_map.objectgroups.items():
-            offx, offy = objgroup.offsetx, objgroup.offsety
-            for map_obj in objgroup.contents:
-                # cas spe:
-                if type(map_obj) == self.pc_cls:
-                    ob = map_obj
-                    ob.x, ob.y = self.isometric_map.clamp_pos((ob.x, ob.y))  # mini-tp player!
-                    sx, sy = self.screen_coords(ob.x, ob.y, objgroup.offsetx, objgroup.offsety)
-                    mx, my = self.map_x(sx, sy, return_int=False), self.map_y(sx, sy, return_int=False)
-                    obkey = self.isometric_map.clamp_pos_int((mx, my))
-                    self.objgroup_contents[layerk] = dict()
-                    self.objgroup_contents[layerk][obkey] = [ob]
-                    self.objgroup_modified_mappos[ob] = (mx, my)
-                    continue
-                # cas général
-                scrx, scry = self.screen_coords(map_obj.x, map_obj.y, offx, offy)
-                if 0 <= scrx < self.floor_rect.w+self.isometric_map.tile_width:
-                    if 0 <= scry < self.floor_rect.h:
-                        # info_mapobj_k = self.isometric_map.clamp_pos_int((map_obj.x+offx, map_obj.y+offy))
-                        self.info_draw_mapobj[map_obj] = (scrx, scry)  # rule: 1 map_obj per location!
-                        # save the mofidied map pos, which will come in handy later.
-                        # self.objgroup_modified_mappos[map_obj] = (scrx, scry)
-
-            # STOP the loop right now! Because,
-            # actually we use only one value of the dict,
-            # since all map objects are def. in the same layer
-            break
-        # ---
-
-        x, y = self.map_x(0, 0) - 2, self.map_y(0, 0) - 1
-        x0, y0 = x, y
-        painting_tiles = True
-        line_number = 1
-
-        while painting_tiles:
-            # In order to allow smooth sub-tile movement of stuff, we have
-            # to draw everything in a particular order.
-            nuline = self._get_horizontal_line(x0, y0, line_number)
-            self.line_cache.append(nuline)
-            current_y_offset = self.isometric_map.layers[0].offsety
-            current_line = len(self.line_cache) - 1
-
-            for layer_num, layer in enumerate(self.isometric_map.layers):
-                # ------------------------------------- check this out <<<
-                # --- OPTIM blit large image for the ground level (3/3)---
-                if self.MEGAOPTIM:
-                    if layer_num == 0:
-                        continue
-
-                if current_line >= 0:
-
-                    # - Tom N.B.
-                    # this was a chunk of code that draws object. I dont think its very efficient so i replace it,
-                    # see {NEW CHUNK OBJ DRAW} that uses: self. info_draw_mapobj
-
-                    # if current_line > 1 and layer in self.objgroup_contents and self.line_cache[current_line - 1]:
-                    #     # After drawing the terrain last time, draw any objects in the previous cell.
-                    #     for x, y in self.line_cache[current_line - 1]:
-                    #         if self.cursor:
-                    #             if self.cursor.layer_name == layer.name and x == self.cursor.x and y == self.cursor.y:
-                    #                 self.cursor.render(self)
-                    #
-                    #         ox, oy = x % self.isometric_map.width, y % self.isometric_map.height
-                    #         if (ox, oy) in self.objgroup_contents[layer]:
-                    #             self.objgroup_contents[layer][(ox, oy)].sort(key=self._model_depth)
-                    #             for ob in self.objgroup_contents[layer][(ox, oy)]:
-                    #                 # The following bit of math makes sure that the clamped object positions will
-                    #                 # print at the correct screen positions. Otherwise, if the player/focus is on the
-                    #                 # other side of the map seam, this object will be printed in the wrong position.
-                    #                 mmx, mmy = self.objgroup_modified_mappos[ob]
-                    #                 fx = x + math.modf(mmx)[0]
-                    #                 fy = y + math.modf(mmy)[0]
-                    #                 sx, sy = self.screen_coords(
-                    #                     fx, fy,
-                    #                     self.isometric_map.objectgroups[layer].offsetx,
-                    #                     self.isometric_map.objectgroups[layer].offsety
-                    #                 )
-                    #                 ob(output_surf, sx, sy, self.isometric_map)
-
-                    # player draw( 1)
-                    if self._show_avatar:  # otherwise, the avatar is invisble!
-                        if current_line > 1 and layer in self.objgroup_contents and self.line_cache[current_line - 1]:
-                            for x, y in self.line_cache[current_line - 1]:
-                                ox, oy = x % self.isometric_map.width, y % self.isometric_map.height
-                                if (ox, oy) in self.objgroup_contents[layer]:
-                                    # @@@ nothing to sort bc we have only the player here!@@@
-                                    # self.objgroup_contents[layer][(ox, oy)].sort(key=self._model_depth)
-                                    for ob in self.objgroup_contents[layer][(ox, oy)]:
-                                        mmx, mmy = self.objgroup_modified_mappos[ob]
-                                        fx = x + math.modf(mmx)[0]
-                                        fy = y + math.modf(mmy)[0]
-                                        sx, sy = self.screen_coords(
-                                            fx, fy,
-                                            self.isometric_map.objectgroups[layer].offsetx,
-                                            self.isometric_map.objectgroups[layer].offsety
-                                        )
-                                        ob(output_surf, sx, sy, self.isometric_map)
-
-                    # - the rest of the drawing algorithm
-                    if self.line_cache[current_line]:
-                        for x, y in self.line_cache[current_line]:
-                            gid = layer[x, y]
-                            tile_id = gid & NOT_ALL_FLAGS
-                            if tile_id > 0:
-                                my_tile = self.isometric_map.tilesets[tile_id]
-                                # Note that x,y refer to IsometricMapObject coordinates, and so 0,0 points at the
-                                # top of the "ground" level of a tile. So, we adjust sy before sending the coords
-                                # to the printer, so it is pointing at the bottom corner of the tile instead.
-                                sx, sy = self.screen_coords(x, y)
-                                my_tile.paint_tile(
-                                    output_surf, sx, sy + layer.offsety + self.isometric_map.tile_height,
-                                                     gid & FLIPPED_HORIZONTALLY_FLAG,
-                                                     gid & FLIPPED_VERTICALLY_FLAG)
-
-                    elif self.line_cache[current_line] is None:  # and layer == self.isometric_map.layers[-1]:
-                        painting_tiles = False
-                else:
-                    break
-                if layer.offsety < current_y_offset:
-                    current_line -= 1
-                    current_y_offset = layer.offsety
-            line_number += 1
-
-        self.phase = (self.phase + 1) % 640
-        del self.line_cache[:]
-        self.objgroup_contents.clear()
-        self.objgroup_modified_mappos.clear()
-        # fin impacte_surf
-
-    def fill_wallpaper(self):
-        for x in range(-1, self.wp_grid_w):
-            self.wp_temp_rect.x = self.screen_rect.x + x * self.wp_temp_rect.w
-            for y in range(-1, self.wp_grid_h):
-                self.wp_temp_rect.y = self.screen_rect.y + y * self.wp_temp_rect.h
-                if self.animated_wallpaper:
-                    self.wp_temp_rect.y += self.phase
-
-                self.screen.blit(self.isometric_map.wallpaper, self.wp_temp_rect)
-
-    def focus(self, x, y):
-        """Move the camera to point at the requested map tile. x,y can be ints or floats."""
-        self._focus_x, self._focus_y = self.isometric_map.clamp_pos((x, y))
-
-        # self.floor_rect.x = a
-        # self.floor_rect.y = b
-
-    def map_x(self, sx, sy, return_int=True):
-        """Return the map x row for the given screen coordinates."""
-        x_off, y_off = self.screen_offset()
-
-        # We're going to use the relative coordinates of the tiles instead of the screen coordinates.
-        rx = sx - x_off
-        ry = sy - y_off
-
-        # Calculate the x position of map_x tile 0 at ry.
-        ox = float(-ry * self.half_tile_width) / float(self.half_tile_height)
-
-        # Now that we have that x origin, we can determine this screen position's x coordinate by dividing by the
-        # tile width. Fantastic.
-        if return_int:
-            # Because of the way Python handles division, we need to apply a little nudge right here.
-            if rx - ox < 0:
-                ox += self.tile_width
-            return int(math.floor((rx - ox) / self.tile_width))
-        else:
-            return (rx - ox) / self.tile_width
-
-    def map_y(self, sx, sy, return_int=True):
-        """Return the map y row for the given screen coordinates."""
-        x_off, y_off = self.screen_offset()
-
-        # We're going to use the relative coordinates of the tiles instead of the screen coordinates.
-        rx = sx - x_off
-        ry = sy - y_off
-
-        oy = float(rx * self.half_tile_height) / float(self.half_tile_width)
-
-        # Now that we have that x origin, we can determine this screen position's x coordinate by dividing by the
-        # tile width. Fantastic.
-        if return_int:
-            # Because of the way Python handles division, we need to apply a little nudge right here.
-            if ry - oy < 0:
-                oy += self.tile_height
-            return int(math.floor((ry - oy) / self.tile_height))
-        else:
-            return (ry - oy) / self.tile_height
-
-    @property
-    def mouse_tile(self):
-        if self.cursor:
-            return self.cursor.x, self.cursor.y
-        else:
-            return self._mouse_tile
-
-    def on_paint(self, ev):
-        # manage the wallpaper blit
-        if (not self.block_wallpaper) and self.isometric_map.wallpaper:
-            self.fill_wallpaper()
-        else:
-            self.screen.fill(self.SOLID_COLOR)
-
-        # -------------------------------------------------------------- OPTIM#2
-        need_to_redraw = self.force_redraw_flag
-        need_to_redraw = need_to_redraw or (self._focused_object.x != self._focused_object_x0) or \
-                         (self._focused_object.y != self._focused_object_y0)
-        if need_to_redraw:
-            self.focus(self._focused_object.x, self._focused_object.y)
-            # TODO can one find a way to optimize without the abusive flag/ that dirty branching?
-            if '__BRYTHON__' not in globals():
-                self.gfx_data_buffer.fill(self.UPINK)
-            else:
-                # a hack method, works only with pygame_emu.Surface kengi>v22-10a, thats why i use hasattr(...) here
-                if hasattr(self.gfx_data_buffer, 'wreset'):
-                    self.gfx_data_buffer.wreset()
-
-            self.impacte_surf(self.gfx_data_buffer)
-            self._focused_object_x0 = self._focused_object.x
-            self._focused_object_y0 = self._focused_object.y
-            self.force_redraw_flag = False
-        # -------------------------------------------------------------- OPTIM#2 over.
-
-        if self.MEGAOPTIM:  # floor drawing, the fast way
-            a, b = self.screen_offset()
-            self.floor_rect.topleft = self.manoffset[0] - a, self.manoffset[1] - b
-            self.screen.blit(self.scrollable_floor, (0, 0), area=self.floor_rect)
-
-        self.screen.blit(self.gfx_data_buffer, (0, 0))  # buildings & the player!
-
-        if self.cursor and self.cursor.visible:
-            # if self.cursor.layer_name == layer.name:
-            # if (x == self.cursor.x) and (y == self.cursor.y):
-            # old way:
-            # self.cursor.render(self)
-            # new way:
-            cu = self.cursor
-            sx, sy = self.screen_coords(*cu.get_pos())
-            mylayer = self.isometric_map.get_layer_by_name(cu.layer_name)
-            mydest = cu.surf.get_rect(midtop=(sx + mylayer.offsetx, sy + mylayer.offsety - 2))
-            self.screen.blit(cu.surf, mydest)
-
-        # - the new chunk of code that draws objects! {NEW CHUNK OBJ DRAW}
-        for mapobj, screen_pos in self.info_draw_mapobj.items():
-            if (not mapobj.visible) or isinstance(mapobj, self.pc_cls):
-                pass
-            else:
-                mapobj(self.screen, screen_pos[0], screen_pos[1], self.isometric_map)
-
-        # if an extra anim for the avatar, we use it on the top of everything else
-        if (not self._show_avatar) and (self.extra_anim is not None):
-            self.av_phase += 1
-            if self.av_phase >= self.av_phase_thresh:
-                self.av_phase = 0
-                if self.av_frame < self.extra_anim.card - 1:
-                    self.av_frame += 1
-                if self.av_frame > 5:
-                    self.anim_av_offset[0] += 1.75
-                    self.anim_av_offset[1] -= 0.24
-                    self.cutav_cpt += 1
-                    base = self.extra_anim[self.av_frame]
-                    kappa = self.cutav_cpt
-                    self.cutav = base.subsurface((0, kappa, base.get_width() - kappa, base.get_height() - kappa))
-            # display avatar alt anim/sprite
-            self.screen.blit(  # DIRTY but i dunno how to do better:
-                self.extra_anim[self.av_frame] if (self.cutav is None) else self.cutav,
-                (160 + int(self.anim_av_offset[0]), 118 + int(self.anim_av_offset[1]))
-            )
-
-    def on_mousemotion(self, ev):
-        mouse_x, mouse_y = core.proj_to_vscreen(ev.pos)
-
-        self.lastmousepos = (mouse_x, mouse_y)
-        self._mouse_tile = (self.map_x(mouse_x, mouse_y, False), self.map_y(mouse_x, mouse_y, False))
-
-        if self.cursor:
-            self.cursor.set_position(self.isometric_map, *self._mouse_tile)
-
-    def screen_coords(self, x, y, extra_x_offset=0, extra_y_offset=0):
-        x_off, y_off = self.screen_offset()
-        return relative_x(x, y) + x_off + extra_x_offset, relative_y(x, y) + y_off + extra_y_offset
-
-    def screen_offset(self):
-        return self.mid[0] - relative_x(self._focus_x, self._focus_y), \
-               self.mid[1] - relative_y(self._focus_x, self._focus_y)
-
-    def set_focused_object(self, fo):
-        if fo:
-            self._focused_object = fo
-            self.focus(fo.x, fo.y)
-        else:
-            self._focused_object = None
-
-    def switch_map(self, isometric_map):
-        self.force_redraw_flag = True  # obvious that we will have to redraw all!
-
-        # ---------- MEGAOPTIM
-        if self.MEGAOPTIM:
-            if isometric_map.mapname == 'city':
-                self.scrollable_floor = self.FLOORS[0]
-                self.manoffset = self.FLOOR_MAN_OFFSET[0]
-            elif isometric_map.mapname == 'casino':
-                self.scrollable_floor = self.FLOORS[1]
-                self.manoffset = self.FLOOR_MAN_OFFSET[1]
-
-        self.isometric_map = isometric_map
-        self.tile_width = isometric_map.tile_width
-        self.tile_height = isometric_map.tile_height
-
-        self.half_tile_width = isometric_map.tile_width // 2
-        self.half_tile_height = isometric_map.tile_height // 2
-        rel_set_info(
-            self.half_tile_width, self.half_tile_height
-        )
-
-        if self._focused_object:
-            fo = self._focused_object
-            self.focus(fo.x, fo.y)
-        else:
-            self._focus_x = 0
-            self._focus_y = 0
+import math
+
+from .isosm_config import NOT_ALL_FLAGS, FLIPPED_VERTICALLY_FLAG, FLIPPED_HORIZONTALLY_FLAG, SCROLL_STEP
+from ... import _hub
+from ...compo import vscreen as core
+
+
+# - aliases
+EngineEvTypes = _hub.events.EngineEvTypes
+EvListener = _hub.events.EvListener
+
+# --------------------------------------------
+# optimization
+_gl_halftile_w = _gl_halftile_h = None
+_buffer_relx = dict()
+_buffer_rely = dict()
+
+
+def relative_x(x, y):
+    """Return the relative x position of this tile, ignoring offset."""
+    try:
+        return _buffer_relx[x][y]
+    except KeyError:
+        if x not in _buffer_relx:
+            _buffer_relx[x] = dict()
+        _buffer_relx[x][y] = int(x * _gl_halftile_w - y * _gl_halftile_w)
+        return _buffer_relx[x][y]
+
+
+def relative_y(x, y):
+    """Return the relative y position of this tile, ignoring offset."""
+    try:
+        return _buffer_rely[x][y]
+    except KeyError:
+        if x not in _buffer_rely:
+            _buffer_rely[x] = dict()
+        _buffer_rely[x][y] = int(y * _gl_halftile_h + x * _gl_halftile_h)
+        return _buffer_rely[x][y]
+
+
+def rel_set_info(halftile_w, halftile_h):
+    global _gl_halftile_w, _gl_halftile_h, _buffer_relx, _buffer_rely
+    _gl_halftile_w = float(halftile_w)
+    _gl_halftile_h = float(halftile_h)
+    _buffer_relx.clear()
+    _buffer_rely.clear()
+
+
+# ----------------------------------------------
+
+
+class IsometricMapViewer(EvListener):
+    MEGAOPTIM = False
+    SOLID_COLOR = 'navyblue'
+    FLOORS = {}
+    FLOOR_MAN_OFFSET = {
+        0: (1617 + 305, 240 - 128),  # what offset one needs to apply so the floor img is aligned, map 0 (city.png)
+        1: (522 + 300, 100 - 92)
+    }
+    UPINK = (255, 0, 255)
+
+    @property
+    def show_avatar(self):
+        return self._show_avatar
+
+    @show_avatar.setter
+    def show_avatar(self, newval):
+        self._show_avatar = newval
+        self.force_redraw_flag = True
+
+    def set_av_anim_speed(self, v):
+        self.av_phase_thresh = int(100/v)
+
+    def __init__(self, isometric_map, screen, postfx=None, cursor=None,
+                 left_scroll_key=None, right_scroll_key=None, up_scroll_key=None, down_scroll_key=None):
+        super().__init__()
+
+        # RELATED to avatar {{ -- player character class --
+        self.pc_cls = int  # this needs to be set from outside, related to perf optimization
+        self._show_avatar = True
+        self.force_redraw_flag = False
+        self.av_phase_thresh = 3
+        self.av_phase = self.av_phase_thresh - 1
+        self.av_frame = 1
+        self.anim_av_offset = [2.0, -1.0]
+        self.cutav = None
+        self.cutav_cpt = 1
+
+        self.extra_anim = None
+        # done }}
+        self.animated_wallpaper = False
+        self.block_wallpaper = False
+        self.info_draw_mapobj = dict()
+
+        self.isometric_map = isometric_map
+
+        self.manoffset = (0, 0)
+        self.scrollable_floor = None
+
+        self.screen = screen
+        self.mid = (
+            self.screen.get_width() // 2, self.screen.get_height() // 2
+        )
+        # self.prevx = float('NaN')
+        # self.prevy = float('NaN')
+
+        self.floor_rect = _hub.pygame.Rect(0, 0, self.screen.get_width(), self.screen.get_height())
+        self.gfx_data_buffer = _hub.pygame.Surface(self.screen.get_size())
+        self.gfx_data_buffer.set_colorkey(self.UPINK)
+
+        if isometric_map.wallpaper:
+            self.screen_rect = self.screen.get_rect()
+            wp_width, wp_height = self.isometric_map.wallpaper.get_size()
+            self.wp_temp_rect = _hub.pygame.Rect(0, 0, wp_width, wp_height)
+            self.wp_grid_w = self.screen_rect.w // wp_width + 1
+            self.wp_grid_h = self.screen_rect.h // wp_height + 1
+
+        # The focus is defined by map coordinates, so a lot of the back and forth between screen and map coords
+        # can be cut.
+        self._focus_x = 0
+        self._focus_y = 0
+        self._focused_object_x0 = 0
+        self._focused_object_y0 = 0
+        self._focused_object = None
+
+        self.phase = 0
+
+        self.tile_width = isometric_map.tile_width
+        self.tile_height = isometric_map.tile_height
+
+        self.half_tile_width = isometric_map.tile_width // 2
+        self.half_tile_height = isometric_map.tile_height // 2
+        rel_set_info(
+            self.half_tile_width, self.half_tile_height
+        )
+        self.visible_area = None
+        self._init_visible_area_init(self.screen)
+
+        # _mouse_tile contains the actual tile the mouse is hovering over. However, in most cases what we really want
+        # is the location of the mouse cursor. Time to make a property!
+        self._mouse_tile = (-1, -1)
+        self.postfx = postfx
+        self.cursor = cursor
+        self.left_scroll_key = left_scroll_key
+        self.right_scroll_key = right_scroll_key
+        self.up_scroll_key = up_scroll_key
+        self.down_scroll_key = down_scroll_key
+        self.debug_sprite = None
+        self.lastmousepos = None
+
+        # util for the drawing of tiles
+        self.line_cache = list()
+        self.objgroup_contents = dict()
+        self.objgroup_modified_mappos = dict()
+        self._camera_updated_this_frame = False
+
+    def enable_megaoptim(self, imgcity, imgcasino):
+        self.MEGAOPTIM = True
+        self.FLOORS.update({
+            0: imgcity,
+            1: imgcasino
+        })
+        self.manoffset = self.FLOOR_MAN_OFFSET[0]
+        self.scrollable_floor = self.FLOORS[0]
+        self.scrollable_floor.set_colorkey(self.UPINK)
+
+    def _check_mouse_scroll(self, screen_area, mouse_x, mouse_y):
+        # Check for map scrolling, depending on mouse position.
+        if not self._camera_updated_this_frame:
+            if mouse_x < 20:
+                dx = -SCROLL_STEP
+            elif mouse_x > (screen_area.right - 20):
+                dx = +SCROLL_STEP
+            else:
+                dx = 0
+
+            if mouse_y < 20:
+                dy = -SCROLL_STEP
+            elif mouse_y > (screen_area.bottom - 20):
+                dy = +SCROLL_STEP
+            else:
+                dy = 0
+
+            if dx or dy:
+                self._update_camera(dx, dy)
+
+    def _get_horizontal_line(self, x0, y0, line_number):
+        x = x0 + line_number // 2
+        y = y0 + (line_number + 1) // 2
+
+        _, py = self.screen_coords(x, y)
+        if py > self.visible_area.bottom:
+            return None
+
+        mylist = list()
+        while self.screen_coords(x, y)[0] < self.visible_area.right:
+            if self.isometric_map.on_the_map(x, y):
+                mylist.append((x, y))
+            x += 1
+            y -= 1
+        return mylist
+
+    def _init_visible_area_init(self, scr):
+        # The visible area describes the region of the map we need to draw
+        w, h = scr.get_size()
+        # below: args idx 0 and 1 do not matter actually
+        tw, th = self.isometric_map.tile_width, self.isometric_map.tile_height
+        self.visible_area = _hub.pygame.Rect(0, 0, w + int(0.5*tw), h + 6*th)
+
+    def _model_depth(self, model):
+        return relative_y(model.x, model.y)
+
+    def _update_camera(self, dx, dy):
+        # If the mouse and the arrow keys conflict, only one of them should win.
+        if self._camera_updated_this_frame:
+            return
+        self._focus_x, self._focus_y = self.isometric_map.clamp_pos([self._focus_x + dx, self._focus_y + dy])
+
+    def impacte_surf(self, output_surf):
+        # --- init step before drawing map objects:
+        # we record all of the objectgroup contents for display when their tile comes up
+        # Also, clamp all object positions. If this is an infinite scrolling map,
+        # objects can move off one side to the map to the other.
+        # However, in their data, we want the objects to stay within the bounds of the map.
+
+        # ++++++ old code:
+        # print( self.isometric_map.objectgroups.keys() )
+        # print(self.isometric_map.objectgroups.values())
+        # for k, v in self.isometric_map.objectgroups.items():
+        #     self.objgroup_contents[k] = collections.defaultdict(list)
+        #     for ob in v.contents:
+        #         print('ob found:', ob)
+        #         ob.x, ob.y = self.isometric_map.clamp_pos((ob.x, ob.y))
+        #         sx, sy = self.screen_coords(ob.x, ob.y, v.offsetx, v.offsety)
+        #         mx, my = self.map_x(sx, sy, return_int=False), self.map_y(sx, sy, return_int=False)
+        #         obkey = self.isometric_map.clamp_pos_int((mx, my))
+        #         self.objgroup_contents[k][obkey].append(ob)
+        #         # Also save the mofidied map pos, which will come in handy later.
+        #         self.objgroup_modified_mappos[ob] = (mx, my)
+        # print(3 / 0)
+
+        # ++++++ new code:
+        self.info_draw_mapobj.clear()
+        for layerk, objgroup in self.isometric_map.objectgroups.items():
+            offx, offy = objgroup.offsetx, objgroup.offsety
+            for map_obj in objgroup.contents:
+                # cas spe:
+                if type(map_obj) == self.pc_cls:
+                    ob = map_obj
+                    ob.x, ob.y = self.isometric_map.clamp_pos((ob.x, ob.y))  # mini-tp player!
+                    sx, sy = self.screen_coords(ob.x, ob.y, objgroup.offsetx, objgroup.offsety)
+                    mx, my = self.map_x(sx, sy, return_int=False), self.map_y(sx, sy, return_int=False)
+                    obkey = self.isometric_map.clamp_pos_int((mx, my))
+                    self.objgroup_contents[layerk] = dict()
+                    self.objgroup_contents[layerk][obkey] = [ob]
+                    self.objgroup_modified_mappos[ob] = (mx, my)
+                    continue
+                # cas général
+                scrx, scry = self.screen_coords(map_obj.x, map_obj.y, offx, offy)
+                if 0 <= scrx < self.floor_rect.w+self.isometric_map.tile_width:
+                    if 0 <= scry < self.floor_rect.h:
+                        # info_mapobj_k = self.isometric_map.clamp_pos_int((map_obj.x+offx, map_obj.y+offy))
+                        self.info_draw_mapobj[map_obj] = (scrx, scry)  # rule: 1 map_obj per location!
+                        # save the mofidied map pos, which will come in handy later.
+                        # self.objgroup_modified_mappos[map_obj] = (scrx, scry)
+
+            # STOP the loop right now! Because,
+            # actually we use only one value of the dict,
+            # since all map objects are def. in the same layer
+            break
+        # ---
+
+        x, y = self.map_x(0, 0) - 2, self.map_y(0, 0) - 1
+        x0, y0 = x, y
+        painting_tiles = True
+        line_number = 1
+
+        while painting_tiles:
+            # In order to allow smooth sub-tile movement of stuff, we have
+            # to draw everything in a particular order.
+            nuline = self._get_horizontal_line(x0, y0, line_number)
+            self.line_cache.append(nuline)
+            current_y_offset = self.isometric_map.layers[0].offsety
+            current_line = len(self.line_cache) - 1
+
+            for layer_num, layer in enumerate(self.isometric_map.layers):
+                # ------------------------------------- check this out <<<
+                # --- OPTIM blit large image for the ground level (3/3)---
+                if self.MEGAOPTIM:
+                    if layer_num == 0:
+                        continue
+
+                if current_line >= 0:
+
+                    # - Tom N.B.
+                    # this was a chunk of code that draws object. I dont think its very efficient so i replace it,
+                    # see {NEW CHUNK OBJ DRAW} that uses: self. info_draw_mapobj
+
+                    # if current_line > 1 and layer in self.objgroup_contents and self.line_cache[current_line - 1]:
+                    #     # After drawing the terrain last time, draw any objects in the previous cell.
+                    #     for x, y in self.line_cache[current_line - 1]:
+                    #         if self.cursor:
+                    #             if self.cursor.layer_name == layer.name and x == self.cursor.x and y == self.cursor.y:
+                    #                 self.cursor.render(self)
+                    #
+                    #         ox, oy = x % self.isometric_map.width, y % self.isometric_map.height
+                    #         if (ox, oy) in self.objgroup_contents[layer]:
+                    #             self.objgroup_contents[layer][(ox, oy)].sort(key=self._model_depth)
+                    #             for ob in self.objgroup_contents[layer][(ox, oy)]:
+                    #                 # The following bit of math makes sure that the clamped object positions will
+                    #                 # print at the correct screen positions. Otherwise, if the player/focus is on the
+                    #                 # other side of the map seam, this object will be printed in the wrong position.
+                    #                 mmx, mmy = self.objgroup_modified_mappos[ob]
+                    #                 fx = x + math.modf(mmx)[0]
+                    #                 fy = y + math.modf(mmy)[0]
+                    #                 sx, sy = self.screen_coords(
+                    #                     fx, fy,
+                    #                     self.isometric_map.objectgroups[layer].offsetx,
+                    #                     self.isometric_map.objectgroups[layer].offsety
+                    #                 )
+                    #                 ob(output_surf, sx, sy, self.isometric_map)
+
+                    # player draw( 1)
+                    if self._show_avatar:  # otherwise, the avatar is invisble!
+                        if current_line > 1 and layer in self.objgroup_contents and self.line_cache[current_line - 1]:
+                            for x, y in self.line_cache[current_line - 1]:
+                                ox, oy = x % self.isometric_map.width, y % self.isometric_map.height
+                                if (ox, oy) in self.objgroup_contents[layer]:
+                                    # @@@ nothing to sort bc we have only the player here!@@@
+                                    # self.objgroup_contents[layer][(ox, oy)].sort(key=self._model_depth)
+                                    for ob in self.objgroup_contents[layer][(ox, oy)]:
+                                        mmx, mmy = self.objgroup_modified_mappos[ob]
+                                        fx = x + math.modf(mmx)[0]
+                                        fy = y + math.modf(mmy)[0]
+                                        sx, sy = self.screen_coords(
+                                            fx, fy,
+                                            self.isometric_map.objectgroups[layer].offsetx,
+                                            self.isometric_map.objectgroups[layer].offsety
+                                        )
+                                        ob(output_surf, sx, sy, self.isometric_map)
+
+                    # - the rest of the drawing algorithm
+                    if self.line_cache[current_line]:
+                        for x, y in self.line_cache[current_line]:
+                            gid = layer[x, y]
+                            tile_id = gid & NOT_ALL_FLAGS
+                            if tile_id > 0:
+                                my_tile = self.isometric_map.tilesets[tile_id]
+                                # Note that x,y refer to IsometricMapObject coordinates, and so 0,0 points at the
+                                # top of the "ground" level of a tile. So, we adjust sy before sending the coords
+                                # to the printer, so it is pointing at the bottom corner of the tile instead.
+                                sx, sy = self.screen_coords(x, y)
+                                my_tile.paint_tile(
+                                    output_surf, sx, sy + layer.offsety + self.isometric_map.tile_height,
+                                                     gid & FLIPPED_HORIZONTALLY_FLAG,
+                                                     gid & FLIPPED_VERTICALLY_FLAG)
+
+                    elif self.line_cache[current_line] is None:  # and layer == self.isometric_map.layers[-1]:
+                        painting_tiles = False
+                else:
+                    break
+                if layer.offsety < current_y_offset:
+                    current_line -= 1
+                    current_y_offset = layer.offsety
+            line_number += 1
+
+        self.phase = (self.phase + 1) % 640
+        del self.line_cache[:]
+        self.objgroup_contents.clear()
+        self.objgroup_modified_mappos.clear()
+        # fin impacte_surf
+
+    def fill_wallpaper(self):
+        for x in range(-1, self.wp_grid_w):
+            self.wp_temp_rect.x = self.screen_rect.x + x * self.wp_temp_rect.w
+            for y in range(-1, self.wp_grid_h):
+                self.wp_temp_rect.y = self.screen_rect.y + y * self.wp_temp_rect.h
+                if self.animated_wallpaper:
+                    self.wp_temp_rect.y += self.phase
+
+                self.screen.blit(self.isometric_map.wallpaper, self.wp_temp_rect)
+
+    def focus(self, x, y):
+        """Move the camera to point at the requested map tile. x,y can be ints or floats."""
+        self._focus_x, self._focus_y = self.isometric_map.clamp_pos((x, y))
+
+        # self.floor_rect.x = a
+        # self.floor_rect.y = b
+
+    def map_x(self, sx, sy, return_int=True):
+        """Return the map x row for the given screen coordinates."""
+        x_off, y_off = self.screen_offset()
+
+        # We're going to use the relative coordinates of the tiles instead of the screen coordinates.
+        rx = sx - x_off
+        ry = sy - y_off
+
+        # Calculate the x position of map_x tile 0 at ry.
+        ox = float(-ry * self.half_tile_width) / float(self.half_tile_height)
+
+        # Now that we have that x origin, we can determine this screen position's x coordinate by dividing by the
+        # tile width. Fantastic.
+        if return_int:
+            # Because of the way Python handles division, we need to apply a little nudge right here.
+            if rx - ox < 0:
+                ox += self.tile_width
+            return int(math.floor((rx - ox) / self.tile_width))
+        else:
+            return (rx - ox) / self.tile_width
+
+    def map_y(self, sx, sy, return_int=True):
+        """Return the map y row for the given screen coordinates."""
+        x_off, y_off = self.screen_offset()
+
+        # We're going to use the relative coordinates of the tiles instead of the screen coordinates.
+        rx = sx - x_off
+        ry = sy - y_off
+
+        oy = float(rx * self.half_tile_height) / float(self.half_tile_width)
+
+        # Now that we have that x origin, we can determine this screen position's x coordinate by dividing by the
+        # tile width. Fantastic.
+        if return_int:
+            # Because of the way Python handles division, we need to apply a little nudge right here.
+            if ry - oy < 0:
+                oy += self.tile_height
+            return int(math.floor((ry - oy) / self.tile_height))
+        else:
+            return (ry - oy) / self.tile_height
+
+    @property
+    def mouse_tile(self):
+        if self.cursor:
+            return self.cursor.x, self.cursor.y
+        else:
+            return self._mouse_tile
+
+    def on_paint(self, ev):
+        # manage the wallpaper blit
+        if (not self.block_wallpaper) and self.isometric_map.wallpaper:
+            self.fill_wallpaper()
+        else:
+            self.screen.fill(self.SOLID_COLOR)
+
+        # -------------------------------------------------------------- OPTIM#2
+        need_to_redraw = self.force_redraw_flag
+        need_to_redraw = need_to_redraw or (self._focused_object.x != self._focused_object_x0) or \
+                         (self._focused_object.y != self._focused_object_y0)
+        if need_to_redraw:
+            self.focus(self._focused_object.x, self._focused_object.y)
+            # TODO can one find a way to optimize without the abusive flag/ that dirty branching?
+            if '__BRYTHON__' not in globals():
+                self.gfx_data_buffer.fill(self.UPINK)
+            else:
+                # a hack method, works only with pygame_emu.Surface kengi>v22-10a, thats why i use hasattr(...) here
+                if hasattr(self.gfx_data_buffer, 'wreset'):
+                    self.gfx_data_buffer.wreset()
+
+            self.impacte_surf(self.gfx_data_buffer)
+            self._focused_object_x0 = self._focused_object.x
+            self._focused_object_y0 = self._focused_object.y
+            self.force_redraw_flag = False
+        # -------------------------------------------------------------- OPTIM#2 over.
+
+        if self.MEGAOPTIM:  # floor drawing, the fast way
+            a, b = self.screen_offset()
+            self.floor_rect.topleft = self.manoffset[0] - a, self.manoffset[1] - b
+            self.screen.blit(self.scrollable_floor, (0, 0), area=self.floor_rect)
+
+        self.screen.blit(self.gfx_data_buffer, (0, 0))  # buildings & the player!
+
+        if self.cursor and self.cursor.visible:
+            # if self.cursor.layer_name == layer.name:
+            # if (x == self.cursor.x) and (y == self.cursor.y):
+            # old way:
+            # self.cursor.render(self)
+            # new way:
+            cu = self.cursor
+            sx, sy = self.screen_coords(*cu.get_pos())
+            mylayer = self.isometric_map.get_layer_by_name(cu.layer_name)
+            mydest = cu.surf.get_rect(midtop=(sx + mylayer.offsetx, sy + mylayer.offsety - 2))
+            self.screen.blit(cu.surf, mydest)
+
+        # - the new chunk of code that draws objects! {NEW CHUNK OBJ DRAW}
+        for mapobj, screen_pos in self.info_draw_mapobj.items():
+            if (not mapobj.visible) or isinstance(mapobj, self.pc_cls):
+                pass
+            else:
+                mapobj(self.screen, screen_pos[0], screen_pos[1], self.isometric_map)
+
+        # if an extra anim for the avatar, we use it on the top of everything else
+        if (not self._show_avatar) and (self.extra_anim is not None):
+            self.av_phase += 1
+            if self.av_phase >= self.av_phase_thresh:
+                self.av_phase = 0
+                if self.av_frame < self.extra_anim.card - 1:
+                    self.av_frame += 1
+                if self.av_frame > 5:
+                    self.anim_av_offset[0] += 1.75
+                    self.anim_av_offset[1] -= 0.24
+                    self.cutav_cpt += 1
+                    base = self.extra_anim[self.av_frame]
+                    kappa = self.cutav_cpt
+                    self.cutav = base.subsurface((0, kappa, base.get_width() - kappa, base.get_height() - kappa))
+            # display avatar alt anim/sprite
+            self.screen.blit(  # DIRTY but i dunno how to do better:
+                self.extra_anim[self.av_frame] if (self.cutav is None) else self.cutav,
+                (160 + int(self.anim_av_offset[0]), 118 + int(self.anim_av_offset[1]))
+            )
+
+    def on_mousemotion(self, ev):
+        mouse_x, mouse_y = core.proj_to_vscreen(ev.pos)
+
+        self.lastmousepos = (mouse_x, mouse_y)
+        self._mouse_tile = (self.map_x(mouse_x, mouse_y, False), self.map_y(mouse_x, mouse_y, False))
+
+        if self.cursor:
+            self.cursor.set_position(self.isometric_map, *self._mouse_tile)
+
+    def screen_coords(self, x, y, extra_x_offset=0, extra_y_offset=0):
+        x_off, y_off = self.screen_offset()
+        return relative_x(x, y) + x_off + extra_x_offset, relative_y(x, y) + y_off + extra_y_offset
+
+    def screen_offset(self):
+        return self.mid[0] - relative_x(self._focus_x, self._focus_y), \
+               self.mid[1] - relative_y(self._focus_x, self._focus_y)
+
+    def set_focused_object(self, fo):
+        if fo:
+            self._focused_object = fo
+            self.focus(fo.x, fo.y)
+        else:
+            self._focused_object = None
+
+    def switch_map(self, isometric_map):
+        self.force_redraw_flag = True  # obvious that we will have to redraw all!
+
+        # ---------- MEGAOPTIM
+        if self.MEGAOPTIM:
+            if isometric_map.mapname == 'city':
+                self.scrollable_floor = self.FLOORS[0]
+                self.manoffset = self.FLOOR_MAN_OFFSET[0]
+            elif isometric_map.mapname == 'casino':
+                self.scrollable_floor = self.FLOORS[1]
+                self.manoffset = self.FLOOR_MAN_OFFSET[1]
+
+        self.isometric_map = isometric_map
+        self.tile_width = isometric_map.tile_width
+        self.tile_height = isometric_map.tile_height
+
+        self.half_tile_width = isometric_map.tile_width // 2
+        self.half_tile_height = isometric_map.tile_height // 2
+        rel_set_info(
+            self.half_tile_width, self.half_tile_height
+        )
+
+        if self._focused_object:
+            fo = self._focused_object
+            self.focus(fo.x, fo.y)
+        else:
+            self._focus_x = 0
+            self._focus_y = 0
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/extras.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/extras.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,127 +1,127 @@
-from .. import tmx
-from ...compo import vscreen as core
-from ... import _hub
-
-
-Tilesets = tmx.data.Tilesets
-
-
-class IsometricMapCursor:
-    """
-    I haven't updated this for the new map system yet... I will do that ASAP, even though the QuarterCursor is
-    the one that will be useful for Niobepolis.
-    """
-
-    def __init__(self, x, y, image, frame=0, visible=True):
-        self.x = x
-        self.y = y
-        self.image = image
-        self.frame = frame
-        self.visible = visible
-        self.pyg = _hub.pygame
-
-    def render(self, dest):  # dest: pygame.Rect
-        if self.visible:
-            self.image.render(dest, self.frame)
-
-    def set_position(self, scene, x, y, must_be_visible=True):
-        if scene.on_the_map(x, y) and (scene.get_visible(x, y) or not must_be_visible):
-            self.x, self.y = x, y
-
-    # def update(self, view, ev):
-    #     if ev.type == self.pyg.MOUSEMOTION:
-    #         self.set_position(view.isometric_map, *view._mouse_tile)
-    #     elif ev.type == self.pyg.KEYDOWN:
-    #         if ev.key == self.pyg.K_KP8:
-    #             self.set_position(view.isometric_map, self.x - 1, self.y - 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP9:
-    #             self.set_position(view.isometric_map, self.x, self.y - 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP6:
-    #             self.set_position(view.isometric_map, self.x + 1, self.y - 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP3:
-    #             self.set_position(view.isometric_map, self.x + 1, self.y)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == pygame.K_KP2:
-    #             self.set_position(view.isometric_map, self.x + 1, self.y + 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP1:
-    #             self.set_position(view.isometric_map, self.x, self.y + 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP4:
-    #             self.set_position(view.isometric_map, self.x - 1, self.y + 1)
-    #             view.focus(self.x, self.y)
-    #         elif ev.key == self.pyg.K_KP7:
-    #             self.set_position(view.isometric_map, self.x - 1, self.y)
-    #             view.focus(self.x, self.y)
-
-
-class IsometricMapQuarterCursor:
-    # A cursor that only takes up one quarter of a tile.
-    def __init__(self, x, y, surf, layer, visible=True):
-        self._doublex = int(x * 2)
-        self._doubley = int(y * 2)
-        self.surf = surf
-        self.layer_name = layer.name
-        self.visible = visible
-        self.pyg = _hub.pygame
-
-    def render(self, dest):  # dest: pygame.Rect
-        if self.visible:
-            # print(type(dest))  # mapviewer
-            dest.screen.blit(self.surf, (self.x, self.y))
-
-    def set_position(self, view, x, y):
-        self._doublex = int(x * 2)
-        self._doubley = int(y * 2)
-
-    @property
-    def x(self):
-        return self._doublex // 2
-
-    @property
-    def y(self):
-        return self._doubley // 2
-
-    def get_pos(self):
-        return float(self._doublex) / 2.0, float(self._doubley) / 2.0
-
-    def focus(self, view):
-        view.focus(*self.get_pos())
-
-    def update(self, view, ev):
-        if ev.type == self.pyg.MOUSEMOTION:
-            mouse_x, mouse_y = core.proj_to_vscreen(self.pyg.mouse.get_pos())
-            self.set_position(view, view.map_x(mouse_x, mouse_y, return_int=False),
-                              view.map_y(mouse_x, mouse_y, return_int=False))
-        elif ev.type == self.pyg.KEYDOWN:
-            if ev.key == self.pyg.K_KP8:
-                self._doublex -= 1
-                self._doubley -= 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP9:
-                self._doubley -= 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP6:
-                self._doublex += 1
-                self._doubley -= 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP3:
-                self._doublex += 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP2:
-                self._doublex += 1
-                self._doubley += 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP1:
-                self._doubley += 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP4:
-                self._doublex -= 1
-                self._doubley += 1
-                self.focus(view)
-            elif ev.key == self.pyg.K_KP7:
-                self._doublex -= 1
-                self.focus(view)
+from .. import tmx
+from ...compo import vscreen as core
+from ... import _hub
+
+
+Tilesets = tmx.data.Tilesets
+
+
+class IsometricMapCursor:
+    """
+    I haven't updated this for the new map system yet... I will do that ASAP, even though the QuarterCursor is
+    the one that will be useful for Niobepolis.
+    """
+
+    def __init__(self, x, y, image, frame=0, visible=True):
+        self.x = x
+        self.y = y
+        self.image = image
+        self.frame = frame
+        self.visible = visible
+        self.pyg = _hub.pygame
+
+    def render(self, dest):  # dest: pygame.Rect
+        if self.visible:
+            self.image.render(dest, self.frame)
+
+    def set_position(self, scene, x, y, must_be_visible=True):
+        if scene.on_the_map(x, y) and (scene.get_visible(x, y) or not must_be_visible):
+            self.x, self.y = x, y
+
+    # def update(self, view, ev):
+    #     if ev.type == self.pyg.MOUSEMOTION:
+    #         self.set_position(view.isometric_map, *view._mouse_tile)
+    #     elif ev.type == self.pyg.KEYDOWN:
+    #         if ev.key == self.pyg.K_KP8:
+    #             self.set_position(view.isometric_map, self.x - 1, self.y - 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP9:
+    #             self.set_position(view.isometric_map, self.x, self.y - 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP6:
+    #             self.set_position(view.isometric_map, self.x + 1, self.y - 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP3:
+    #             self.set_position(view.isometric_map, self.x + 1, self.y)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == pygame.K_KP2:
+    #             self.set_position(view.isometric_map, self.x + 1, self.y + 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP1:
+    #             self.set_position(view.isometric_map, self.x, self.y + 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP4:
+    #             self.set_position(view.isometric_map, self.x - 1, self.y + 1)
+    #             view.focus(self.x, self.y)
+    #         elif ev.key == self.pyg.K_KP7:
+    #             self.set_position(view.isometric_map, self.x - 1, self.y)
+    #             view.focus(self.x, self.y)
+
+
+class IsometricMapQuarterCursor:
+    # A cursor that only takes up one quarter of a tile.
+    def __init__(self, x, y, surf, layer, visible=True):
+        self._doublex = int(x * 2)
+        self._doubley = int(y * 2)
+        self.surf = surf
+        self.layer_name = layer.name
+        self.visible = visible
+        self.pyg = _hub.pygame
+
+    def render(self, dest):  # dest: pygame.Rect
+        if self.visible:
+            # print(type(dest))  # mapviewer
+            dest.screen.blit(self.surf, (self.x, self.y))
+
+    def set_position(self, view, x, y):
+        self._doublex = int(x * 2)
+        self._doubley = int(y * 2)
+
+    @property
+    def x(self):
+        return self._doublex // 2
+
+    @property
+    def y(self):
+        return self._doubley // 2
+
+    def get_pos(self):
+        return float(self._doublex) / 2.0, float(self._doubley) / 2.0
+
+    def focus(self, view):
+        view.focus(*self.get_pos())
+
+    def update(self, view, ev):
+        if ev.type == self.pyg.MOUSEMOTION:
+            mouse_x, mouse_y = core.proj_to_vscreen(self.pyg.mouse.get_pos())
+            self.set_position(view, view.map_x(mouse_x, mouse_y, return_int=False),
+                              view.map_y(mouse_x, mouse_y, return_int=False))
+        elif ev.type == self.pyg.KEYDOWN:
+            if ev.key == self.pyg.K_KP8:
+                self._doublex -= 1
+                self._doubley -= 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP9:
+                self._doubley -= 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP6:
+                self._doublex += 1
+                self._doubley -= 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP3:
+                self._doublex += 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP2:
+                self._doublex += 1
+                self._doubley += 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP1:
+                self._doubley += 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP4:
+                self._doublex -= 1
+                self._doubley += 1
+                self.focus(view)
+            elif ev.key == self.pyg.K_KP7:
+                self._doublex -= 1
+                self.focus(view)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/isometric/model.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/isometric/model.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,659 +1,659 @@
-import json
-import math
-import os
-import struct
-from base64 import b64decode
-from xml.etree import ElementTree
-from zlib import decompress
-
-from .flags import *
-from .. import tmx
-from ... import _hub
-
-
-info_type_obj = 'class'
-
-
-class IsometricTile:
-    def __init__(self, tile_id, tile_surface):
-        self.id = tile_id
-
-        self.tile_surface = tile_surface
-        self.anchor = list(tile_surface.get_size())
-        self.anchor[0] = self.anchor[0]//2  # int(0.5*self.anchor[0])
-
-        self.images = {
-            (False, False): tile_surface,
-            (True, False): _hub.pygame.transform.flip(tile_surface, True, False),
-            (False, True): _hub.pygame.transform.flip(tile_surface, False, True),
-            (True, True): _hub.pygame.transform.flip(tile_surface, True, True),
-        }
-
-        self.hflip_surface = None
-        self.vflip_surface = None
-        self.hvflip_surface = None
-
-    def paint_tile(self, dest_surface, x, y, hflip=False, vflip=False):
-        """Draw this tile on the dest_surface at the provided x,y coordinates."""
-
-        if (not hflip) and (not vflip):
-            dest_surface.blit(self.tile_surface, (x-self.anchor[0], y-self.anchor[1]))
-            return
-
-        if hflip and vflip:
-            if self.hvflip_surface is None:
-                self.hvflip_surface = _hub.pygame.transform.flip(self.tile_surface, True, True)
-                self.hvflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
-            surf = self.hvflip_surface
-
-        elif hflip:
-            if self.hflip_surface is None:
-                self.hflip_surface = _hub.pygame.transform.flip(self.tile_surface, True, False)
-                self.hflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
-            surf = self.hflip_surface
-
-        elif vflip:
-            if self.vflip_surface is None:
-                self.vflip_surface = _hub.pygame.transform.flip(self.tile_surface, False, True)
-                self.vflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
-            surf = self.vflip_surface
-
-        mydest = surf.get_rect(midbottom=(x, y))
-        dest_surface.blit(surf, mydest)
-
-    def __repr__(self):
-        return '<Tile {}>'.format(self.id)
-
-
-class IsometricTileset:
-    """
-    Based on the Tileset class from katagames_engine/_sm_shelf/tmx/data.py, but modified for the needs of isometric
-    maps. Or at least the needs of this particular isometric map.
-    """
-
-    def __init__(self, name, tile_width, tile_height, firstgid):
-        self.name = name
-        self.tile_width = tile_width
-        self.tile_height = tile_height
-        self.firstgid = firstgid
-
-        # self.hflip = False
-        # self.vflip = False
-
-        self.tiles = []
-        self.properties = {}
-
-    def get_tile(self, gid):
-        return self.tiles[gid - self.firstgid]
-
-    def _add_image(self, folders, source, num_tiles):
-        # TODO: Make this bit compatible with Kenji.
-        mysurf = _hub.pygame.image.load(os.path.join(os.sep.join(folders), source)).convert_alpha()
-        mysurf.set_colorkey((255, 0, 255))
-        myrect = _hub.pygame.Rect(0, 0, self.tile_width, self.tile_height)
-        frames_per_row = mysurf.get_width() // self.tile_width
-
-        for frame in range(num_tiles):
-            myrect.x = (frame % frames_per_row) * self.tile_width
-            myrect.y = (frame // frames_per_row) * self.tile_height
-            self.tiles.append(IsometricTile(frame + 1, mysurf.subsurface(myrect)))
-
-    @classmethod
-    def fromxml(cls, folders, tag, firstgid=None):
-        print('fromxml (isometrically)')
-        if 'source' in tag.attrib:
-            # Instead of a tileset proper, we have been handed an external tileset tag from inside a map file.
-            # Load the external tileset and continue on as if nothing had happened.
-            firstgid = int(tag.attrib['firstgid'])
-            srcc = tag.attrib['source']
-
-            # TODO: Another direct disk access here.
-            if srcc.endswith(("tsx", "xml")):
-                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
-                    print('opened ', srcc)
-                    tag = ElementTree.fromstring(f.read())
-            elif srcc.endswith(("tsj", "json")):
-                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
-                    jdict = json.load(f)
-                return cls.fromjson(folders, jdict, firstgid)
-
-        name = tag.attrib['name']
-        if firstgid is None:
-            firstgid = int(tag.attrib['firstgid'])
-        tile_width = int(tag.attrib['tilewidth'])
-        tile_height = int(tag.attrib['tileheight'])
-        num_tiles = int(tag.attrib['tilecount'])
-
-        tileset = cls(name, tile_width, tile_height, firstgid)
-
-        # TODO: The transformations must be registered before any of the tiles. Is there a better way to do this
-        # than iterating through the list twice? I know this is a minor thing but it bothers me.
-        for c in tag:  # .getchildren():
-            if c.tag == "transformations":
-                tileset.vflip = int(c.attrib.get("vflip", 0)) == 1
-                tileset.hflip = int(c.attrib.get("hflip", 0)) == 1
-                print("Flip values: v={} h={}".format(tileset.vflip, tileset.hflip))
-
-        for c in tag:  # .getchildren():
-            # TODO: The tileset can only contain an "image" tag or multiple "tile" tags; it can't combine the two.
-            # This should be enforced. For now, I'm just gonna support spritesheet tiles.
-            if c.tag == "image":
-                # create a tileset
-                arg_sheet = c.attrib['source']
-                tileset._add_image(folders, arg_sheet, num_tiles)
-
-        return tileset
-
-    @classmethod
-    def fromjson(cls, folders, jdict, firstgid=None):
-        print('fromjson (isometrically)')
-        if 'source' in jdict:
-            firstgid = int(jdict['firstgid'])
-            srcc = jdict['source']
-
-            # TODO: Another direct disk access here.
-            if srcc.endswith(("tsx", "xml")):
-                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
-                    print('opened ', srcc)
-                    tag = ElementTree.fromstring(f.read())
-                    return cls.fromxml(folders, tag, firstgid)
-            elif srcc.endswith(("tsj", "json")):
-                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
-                    jdict = json.load(f)
-
-        name = jdict['name']
-        if firstgid is None:
-            firstgid = int(jdict.get('firstgid', 1))
-        tile_width = int(jdict['tilewidth'])
-        tile_height = int(jdict['tileheight'])
-        num_tiles = int(jdict['tilecount'])
-
-        tileset = cls(name, tile_width, tile_height, firstgid)
-
-        if "transformations" in jdict:
-            c = jdict["transformations"]
-            tileset.vflip = int(c.get("vflip", 0)) == 1
-            tileset.hflip = int(c.get("hflip", 0)) == 1
-
-        # TODO: The tileset can only contain an "image" tag or multiple "tile" tags; it can't combine the two.
-        # This should be enforced. For now, I'm just gonna support spritesheet tiles.
-
-        # create a tileset
-        arg_sheet = jdict['image']
-        tileset._add_image(folders, arg_sheet, num_tiles)
-
-        return tileset
-
-
-class IsometricMapObject:
-    """
-    A thing that can be placed on the map.
-    """
-
-    def __init__(self, **kwargs):
-        self.name = ""
-        # self.type = ""
-        self.x = 0
-        self.y = 0
-        self.width = 0
-        self.height = 0
-        self.gid = 0
-        self.visible = 1
-
-        self.properties = dict(kwargs)  # copy properties, stores various custom properties
-
-        # super().__init__(**keywords)
-        for k, v in kwargs.items():
-            setattr(self, k, v)
-
-        self.drawingoffset = [0, 16]  # replaces the anchor stuff
-
-    def __call__(self, dest_surface, sx, sy, mymap):
-        """Draw this object at the requested surface coordinates on the provided surface."""
-        if self.gid:
-            tile_id = self.gid & NOT_ALL_FLAGS
-            if tile_id > 0:
-                my_tile = mymap.tilesets[tile_id]
-                my_tile.paint_tile(dest_surface, sx+self.drawingoffset[0], sy+self.drawingoffset[1], self.gid & FLIPPED_HORIZONTALLY_FLAG, self.gid & FLIPPED_VERTICALLY_FLAG)
-
-    @staticmethod
-    def _deweirdify_coordinates(tx, ty, givenlayer):
-        # It took ages to figure out the coordinate system that Tiled uses for objects on isometric maps. At first I
-        # thought the pixel coordinate origin would be the upper left corner of the map's bounding box. It isn't.
-        # In fact, it isn't a normal cartesian coordinate system at all. The pixel x,y values are the cell index
-        # multiplied by the cell height. I cannot think of any situation for which this would be a useful way to store
-        # pixel coordinates, but there you go.
-        #
-        # This function takes the Tiled pixel coordinates and changes them to tilemap cell coordinates. Feel free to
-        # delete this long rant of a comment. Or leave it as a warning to others. I am just glad to finally understand
-        # what's going on.
-
-        mx = -0.5 + (tx / float(givenlayer.tile_height))
-        my = -0.5 + (ty / float(givenlayer.tile_height))
-        return mx, my
-
-    @classmethod
-    def fromxml(cls, tag, givenlayer):
-        myob = cls()
-        myob.name = tag.attrib.get("name")
-        myob.type = tag.attrib.get(info_type_obj)
-        # Convert the x,y pixel coordinates to x,y map coordinates.
-        x = float(tag.attrib.get("x", 0))
-        y = float(tag.attrib.get("y", 0))
-        myob.x, myob.y = cls._deweirdify_coordinates(x, y, givenlayer)
-        myob.gid = int(tag.attrib.get("gid"))
-        myob.visible = int(tag.attrib.get("visible", 1))
-        for t in tag:
-            if t.tag == "properties":
-                for p in t:
-                    if p.tag == "property":
-                        myob.properties[p.attrib.get("name", "property")] = p.attrib.get("value")
-        return myob
-
-    @classmethod
-    def fromjson(cls, jdict, givenlayer):
-        name = jdict.get("name")
-        objtype = jdict.get(info_type_obj)
-        # Convert the x,y pixel coordinates to x,y map coordinates.
-        x, y = cls._deweirdify_coordinates(jdict.get("x", 0), jdict.get("y", 0), givenlayer)
-        gid = jdict.get("gid")
-        visible = jdict.get("visible")
-
-        eproperties = dict()
-        if "properties" in jdict:
-            for p in jdict["properties"]:
-                kk = p.get("name", "property")
-                vv = p.get("value")
-                eproperties[kk] = vv
-        eproperties['name'] = name
-        eproperties['type'] = objtype
-        eproperties['x'], eproperties['y'] = x, y
-        eproperties['gid'] = gid
-        eproperties['visible'] = visible
-        return cls(**eproperties)
-
-
-class IsometricLayer:
-    flag_csv = False
-
-    def __init__(self, name, visible, map, offsetx=0, offsety=0):
-        self.name = name
-        self.visible = visible
-
-        self.tile_width = map.tile_width
-        self.tile_height = map.tile_height
-
-        self.width = map.width
-        self.height = map.height
-
-        self.offsetx = offsetx
-        self.offsety = offsety
-
-        self.properties = {}
-        self.cells = list()
-
-    def __repr__(self):
-        return '<Layer "%s" at 0x%x>' % (self.name, id(self))
-
-    @classmethod
-    def emptylayer(cls, name, givenmap):
-        layer = cls(
-            name, 0, givenmap, 0, 0
-        )
-
-        layer.cells = [0, ] * givenmap.height * givenmap.width
-
-        return layer
-
-    @classmethod
-    def fromxml(cls, tag, givenmap):
-        layer = cls(
-            tag.attrib['name'], int(tag.attrib.get('visible', 1)), givenmap,
-            int(tag.attrib.get('offsetx', 0)), int(tag.attrib.get('offsety', 0))
-        )
-
-        data = tag.find('data')
-        if data is None:
-            raise ValueError('layer %s does not contain <data>' % layer.name)
-
-        data = data.text.strip()
-        data = data.encode()  # Convert to bytes
-        # Decode from base 64 and decompress via zlib
-        data = decompress(b64decode(data))
-
-        # I ran a test today and there's a slight speed advantage in leaving the cells as a list. It's not a big
-        # advantage, but it's just as easy for now to leave the data as it is.
-        #
-        # I'm changing to a list from a tuple in case destructible terrain or modifiable terrain (such as doors) are
-        # wanted in the future.
-        layer.cells = list(struct.unpack('<%di' % (len(data) / 4,), data))
-        assert len(layer.cells) == layer.width * layer.height
-
-        return layer
-
-    @classmethod
-    def fromjson(cls, jdict, givenmap):
-        layer = cls(
-            jdict['name'], jdict.get('visible', True), givenmap,
-            jdict.get('offsetx', 0), jdict.get('offsety', 0)
-        )
-
-        data = jdict.get('data')
-        if data is None:
-            raise ValueError('layer %s does not contain <data>' % layer.name)
-
-        # Remark: (june 2022)
-        # we need to support uncompressed data like CSV, for instance,
-        # for specific use cases where the zlib module cannot be used
-        # (hacking in the web ctx for example)
-
-        if not cls.flag_csv:  # default mode -> data is compressed
-            data = data.strip()
-            data = data.encode()  # Convert to bytes
-            # Decode from base 64 and decompress via zlib
-            data = decompress(b64decode(data))
-            # I ran a test today and there's a slight speed advantage in leaving the cells as a list.
-            # It's not a big advantage, but it's just as easy for now to leave the data as it is.
-            # I'm changing to a list from a tuple in case destructible terrain or modifiable terrain
-            # (such as doors) ar wanted in the future
-            layer.cells = list(struct.unpack('<%di' % (len(data) / 4,), data))
-            assert len(layer.cells) == layer.width * layer.height
-        else:  # uncompressed data
-            layer.cells = data
-
-        return layer
-
-    def __len__(self):
-        return self.height * self.width
-
-    def _pos_to_index(self, x, y):
-        # loop map feat.
-        y = y % self.height
-        x = x % self.width
-        return y * self.width + x
-
-    def __getitem__(self, key):
-        x, y = key
-        i = self._pos_to_index(x, y)
-        # no test of boundaries bc of the loop map feat.
-        # if 0 <= x < self.width and 0 <= y < self.height:
-        return self.cells[i]
-
-    def __setitem__(self, pos, value):
-        x, y = pos
-        i = self._pos_to_index(x, y)
-        # if 0 <= x < self.width and 0 <= y < self.height:
-        self.cells[i] = value
-
-
-class ObjectGroup:
-    def __init__(self, name, visible, offsetx, offsety):
-        self.name = name
-        self.visible = visible
-        self.offsetx = offsetx
-        self.offsety = offsety
-
-        self.contents = list()
-
-    @classmethod
-    def fromxml(cls, tag, givenlayer, object_classes=None):
-        mygroup = cls(
-            tag.attrib['name'], int(tag.attrib.get('visible', 1)),
-            int(tag.attrib.get('offsetx', 0)), int(tag.attrib.get('offsety', 0))
-        )
-
-        for t in tag:
-            if t.tag == "object":
-                if object_classes and t.attrib.get(info_type_obj) in object_classes:
-                    myclass = object_classes[t.attrib.get(info_type_obj)]
-                else:
-                    myclass = IsometricMapObject
-                mygroup.contents.append(myclass.fromxml(
-                    t, givenlayer
-                ))
-
-        return mygroup
-
-    @classmethod
-    def fromjson(cls, folders, jdict, givenlayer, object_classes=None):
-        mygroup = cls(
-            jdict.get('name'), jdict.get('visible', True),
-            jdict.get('offsetx', 0), jdict.get('offsety', 0)
-        )
-
-        if "objects" in jdict:
-            for t in jdict["objects"]:
-                if object_classes and t.get(info_type_obj) in object_classes:
-                    myclass = object_classes[t.get(info_type_obj)]
-                else:
-                    myclass = IsometricMapObject
-                mygroup.contents.append(myclass.fromjson(
-                    t, givenlayer
-                ))
-
-        return mygroup
-
-
-class IsometricMap:
-    # Customization:
-    # If a layer named "Move Layer" exists, the PC can only move into tiles that exist on this layer. The layer may be
-    #   invisible.
-    # If a layer named "Block Layer" exists, the PC cannot move into tiles that exist on this layer. The layer may be
-    #   invisible.
-    def __init__(self):
-        self.tile_width = 0
-        self.tile_height = 0
-        self.width = 0
-        self.height = 0
-        self.layers = list()
-        self.tilesets = tmx.data.Tilesets()
-        self.objectgroups = dict()
-
-        self.wrap_x = False
-        self.wrap_y = False
-
-        self.floor_layer = None
-        self.wall_layer = None
-
-        self.wallpaper = None
-        self.mapname = None
-
-    def seek_floor_and_wall(self):
-        for n, layer in enumerate(self.layers):
-            if layer.name == "Move Layer":
-                self.floor_layer = n
-            elif layer.name == "Block Layer":
-                self.wall_layer = n
-
-    @classmethod
-    def load_tmx(cls, folders, filename, object_classes=None):
-        # object_classes is a function that can parse a dict describing an object.
-        # If None, the only objects that can be loaded are terrain objects.
-        with open(os.path.join(os.pathsep.join(folders), filename)) as f:
-            tminfo_tree = ElementTree.fromstring(f.read())
-
-        # get most general map informations and create a surface
-        tilemap = cls()
-
-        tilemap.width = int(tminfo_tree.attrib['width'])
-        tilemap.height = int(tminfo_tree.attrib['height'])
-        tilemap.tile_width = int(tminfo_tree.attrib['tilewidth'])
-        tilemap.tile_height = int(tminfo_tree.attrib['tileheight'])
-
-        for tag in tminfo_tree.findall('tileset'):
-            tilemap.tilesets.add(
-                IsometricTileset.fromxml(folders, tag)
-                # hacks work only if no more than 1 ts
-            )
-
-        for tag in tminfo_tree:
-            if tag.tag == 'layer':
-                layer = IsometricLayer.fromxml(tag, tilemap)
-                tilemap.layers.append(layer)
-            elif tag.tag == "objectgroup":
-                if not tilemap.layers:
-                    # If the first layer on the map is an objectgroup, this is gonna be a problem. Without
-                    # a frame of reference, we won't be able to know what tile the object is in, and that is going
-                    # to be important information. So, we add an empty layer with no offsets to act as this
-                    # objectgroup's frame of reference.
-                    tilemap.layers.append(IsometricLayer.emptylayer("The Mysterious Empty Layer", tilemap))
-                tilemap.objectgroups[tilemap.layers[-1]] = ObjectGroup.fromxml(tag, tilemap.layers[-1], object_classes)
-            elif tag.tag == "properties":
-                for ptag in tag.findall("property"):
-                    if ptag.get("name") == "wrap_x":
-                        tilemap.wrap_x = ptag.get("value") == "true"
-                    elif ptag.get("name") == "wrap_y":
-                        tilemap.wrap_y = ptag.get("value") == "true"
-                    elif ptag.get("name") == "mapname":
-                        tilemap.mapname = ptag.get("mapname")
-                    elif ptag.get("name") == "wallpaper":
-                        tilemap.wallpaper = _hub.pygame.image.load(os.path.join("assets",ptag.get("value"))).convert_alpha()
-
-        return tilemap
-
-    @classmethod
-    def load_json(cls, folders, filename, object_classes=None):
-        # object_classes is a function that can parse a dict describing an object.
-        # If None, the only objects that can be loaded are terrain objects.
-
-        with open(os.path.join(os.pathsep.join(folders), filename)) as f:
-            jdict = json.load(f)
-        return cls.from_json_dict(folders, jdict, object_classes)
-
-    @classmethod
-    def from_json_dict(cls, folders, jdict, object_classes=None):
-        # get most general map informations and create a surface
-        tilemap = cls()
-
-        tilemap.width = jdict['width']
-        tilemap.height = jdict['height']
-        tilemap.tile_width = jdict['tilewidth']
-        tilemap.tile_height = jdict['tileheight']
-
-        if "properties" in jdict:
-            for tag in jdict["properties"]:
-                if tag["name"] == "wrap_x":
-                    tilemap.wrap_x = tag.get("value", False)
-                elif tag["name"] == "wrap_y":
-                    tilemap.wrap_y = tag.get("value", False)
-                elif tag["name"] == "mapname":
-                    tilemap.mapname = tag.get("value")
-                elif tag["name"] == "wallpaper":
-                    pprefix = os.pathsep.join(folders)
-                    tilemap.wallpaper = _hub.pygame.image.load(os.path.join(pprefix, tag.get("value"))).convert_alpha()
-
-        for tag in jdict['tilesets']:
-            tilemap.tilesets.add(
-                IsometricTileset.fromjson(folders, tag)
-            )
-
-        for tag in jdict["layers"]:
-            if tag["type"] == 'tilelayer':
-                layer = IsometricLayer.fromjson(tag, tilemap)
-                tilemap.layers.append(layer)
-            elif tag["type"] == "objectgroup":
-                if not tilemap.layers:
-                    # See above comment for why I'm adding an empty layer. TLDR: the objects need a reference frame.
-                    tilemap.layers.append(IsometricLayer.emptylayer("The Mysterious Empty Layer", tilemap))
-                tilemap.objectgroups[tilemap.layers[-1]] = ObjectGroup.fromjson(
-                    folders, tag, tilemap.layers[-1], object_classes
-                )
-        return tilemap
-
-    @classmethod
-    def load(cls, folders, filename, object_classes=None):
-        if filename.endswith(("tmx", "xml")):
-            mymap = cls.load_tmx(folders, filename, object_classes)
-        elif filename.endswith(("tmj", "json")):
-            mymap = cls.load_json(folders, filename, object_classes)
-        else:
-            raise NotImplementedError("No decoder for {}".format(filename))
-        mymap.seek_floor_and_wall()
-        return mymap
-
-    def on_the_map(self, x, y):
-        # Returns true if (x,y) is on the map, false otherwise
-        return (self.wrap_x or ((x >= 0) and (x < self.width))) and (self.wrap_y or ((y >= 0) and (y < self.height)))
-
-    def get_layer_by_name(self, layer_name):
-        # The Layers type in Kengi supports indexing layers by name, but it
-        # doesn't support accessing layers by
-        # negative indices. I'm not sure that it supports slicing either. Anyhow, for now, only the map cursor needs
-        # to look up layers by name so this function should be good enough for the time being.
-        for lay in self.layers:
-            if lay.name == layer_name:
-                return lay
-
-    def get_object_by_name(self, object_name):
-        # Return the first object found with the provided name.
-        for obgroup in self.objectgroups.values():
-            for ob in obgroup.contents:
-                if ob.name == object_name:
-                    return ob
-
-    def clamp_pos(self, pos):
-        # For infinite scroll maps, clamp the x and/or y values
-        nupos = list(pos)
-        if self.wrap_x:
-            f, i = math.modf(pos[0])
-            nupos[0] = int(i) % self.width + f
-        else:
-            if pos[0] < 0:
-                nupos[0] = 0
-            elif pos[0] >= self.width:
-                nupos[0] = self.width-1
-        if self.wrap_y:
-            f, i = math.modf(pos[1])
-            nupos[1] = int(i) % self.height + f
-        else:
-            if pos[1] < 0:
-                nupos[1] = 0
-            elif pos[1] >= self.height:
-                nupos[1] = self.height-1
-        return tuple(nupos)
-
-    def clamp_pos_int(self, pos):
-        def spefilter(val):
-            xinf, xmid, xsup = math.floor(val), math.floor(val) + 0.5, math.ceil(val)
-            a, b, c = abs(val - xinf), abs(val - xmid), abs(val - xsup)
-            if c < a:
-                if c < b:
-                    rez = xsup
-                else:
-                    rez = xmid
-            else:
-                if a < b:
-                    rez = xinf
-                else:
-                    rez = xmid
-            return rez
-
-        # For infinite scroll maps, clamp the x and/or y values
-        nupos = [math.floor(c) for c in pos]
-        if self.wrap_x:
-            f, i = math.modf(pos[0])
-            nupos[0] = int(i) % self.width
-        else:
-            if pos[0] < 0:
-                nupos[0] = 0
-            elif pos[0] >= self.width:
-                nupos[0] = self.width-1
-
-        if self.wrap_y:
-            f, i = math.modf(pos[1])
-            nupos[1] = int(i) % self.height
-        else:
-            if pos[1] < 0:
-                nupos[1] = 0
-            elif pos[1] >= self.height:
-                nupos[1] = self.height-1
-        return tuple(nupos)
-
-    def tile_is_blocked(self, x, y):
-        pos = self.clamp_pos_int((x,y))
-        if self.floor_layer is not None and self.layers[self.floor_layer][pos] == 0:
-            return True
-        if self.wall_layer is not None and self.layers[self.wall_layer][pos] != 0:
-            return True
-        else:
-            return False
+import json
+import math
+import os
+import struct
+from base64 import b64decode
+from xml.etree import ElementTree
+from zlib import decompress
+
+from .flags import *
+from .. import tmx
+from ... import _hub
+
+
+info_type_obj = 'class'
+
+
+class IsometricTile:
+    def __init__(self, tile_id, tile_surface):
+        self.id = tile_id
+
+        self.tile_surface = tile_surface
+        self.anchor = list(tile_surface.get_size())
+        self.anchor[0] = self.anchor[0]//2  # int(0.5*self.anchor[0])
+
+        self.images = {
+            (False, False): tile_surface,
+            (True, False): _hub.pygame.transform.flip(tile_surface, True, False),
+            (False, True): _hub.pygame.transform.flip(tile_surface, False, True),
+            (True, True): _hub.pygame.transform.flip(tile_surface, True, True),
+        }
+
+        self.hflip_surface = None
+        self.vflip_surface = None
+        self.hvflip_surface = None
+
+    def paint_tile(self, dest_surface, x, y, hflip=False, vflip=False):
+        """Draw this tile on the dest_surface at the provided x,y coordinates."""
+
+        if (not hflip) and (not vflip):
+            dest_surface.blit(self.tile_surface, (x-self.anchor[0], y-self.anchor[1]))
+            return
+
+        if hflip and vflip:
+            if self.hvflip_surface is None:
+                self.hvflip_surface = _hub.pygame.transform.flip(self.tile_surface, True, True)
+                self.hvflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
+            surf = self.hvflip_surface
+
+        elif hflip:
+            if self.hflip_surface is None:
+                self.hflip_surface = _hub.pygame.transform.flip(self.tile_surface, True, False)
+                self.hflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
+            surf = self.hflip_surface
+
+        elif vflip:
+            if self.vflip_surface is None:
+                self.vflip_surface = _hub.pygame.transform.flip(self.tile_surface, False, True)
+                self.vflip_surface.set_colorkey(self.tile_surface.get_colorkey(), self.tile_surface.get_flags())
+            surf = self.vflip_surface
+
+        mydest = surf.get_rect(midbottom=(x, y))
+        dest_surface.blit(surf, mydest)
+
+    def __repr__(self):
+        return '<Tile {}>'.format(self.id)
+
+
+class IsometricTileset:
+    """
+    Based on the Tileset class from katagames_engine/_sm_shelf/tmx/data.py, but modified for the needs of isometric
+    maps. Or at least the needs of this particular isometric map.
+    """
+
+    def __init__(self, name, tile_width, tile_height, firstgid):
+        self.name = name
+        self.tile_width = tile_width
+        self.tile_height = tile_height
+        self.firstgid = firstgid
+
+        # self.hflip = False
+        # self.vflip = False
+
+        self.tiles = []
+        self.properties = {}
+
+    def get_tile(self, gid):
+        return self.tiles[gid - self.firstgid]
+
+    def _add_image(self, folders, source, num_tiles):
+        # TODO: Make this bit compatible with Kenji.
+        mysurf = _hub.pygame.image.load(os.path.join(os.sep.join(folders), source)).convert_alpha()
+        mysurf.set_colorkey((255, 0, 255))
+        myrect = _hub.pygame.Rect(0, 0, self.tile_width, self.tile_height)
+        frames_per_row = mysurf.get_width() // self.tile_width
+
+        for frame in range(num_tiles):
+            myrect.x = (frame % frames_per_row) * self.tile_width
+            myrect.y = (frame // frames_per_row) * self.tile_height
+            self.tiles.append(IsometricTile(frame + 1, mysurf.subsurface(myrect)))
+
+    @classmethod
+    def fromxml(cls, folders, tag, firstgid=None):
+        print('fromxml (isometrically)')
+        if 'source' in tag.attrib:
+            # Instead of a tileset proper, we have been handed an external tileset tag from inside a map file.
+            # Load the external tileset and continue on as if nothing had happened.
+            firstgid = int(tag.attrib['firstgid'])
+            srcc = tag.attrib['source']
+
+            # TODO: Another direct disk access here.
+            if srcc.endswith(("tsx", "xml")):
+                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
+                    print('opened ', srcc)
+                    tag = ElementTree.fromstring(f.read())
+            elif srcc.endswith(("tsj", "json")):
+                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
+                    jdict = json.load(f)
+                return cls.fromjson(folders, jdict, firstgid)
+
+        name = tag.attrib['name']
+        if firstgid is None:
+            firstgid = int(tag.attrib['firstgid'])
+        tile_width = int(tag.attrib['tilewidth'])
+        tile_height = int(tag.attrib['tileheight'])
+        num_tiles = int(tag.attrib['tilecount'])
+
+        tileset = cls(name, tile_width, tile_height, firstgid)
+
+        # TODO: The transformations must be registered before any of the tiles. Is there a better way to do this
+        # than iterating through the list twice? I know this is a minor thing but it bothers me.
+        for c in tag:  # .getchildren():
+            if c.tag == "transformations":
+                tileset.vflip = int(c.attrib.get("vflip", 0)) == 1
+                tileset.hflip = int(c.attrib.get("hflip", 0)) == 1
+                print("Flip values: v={} h={}".format(tileset.vflip, tileset.hflip))
+
+        for c in tag:  # .getchildren():
+            # TODO: The tileset can only contain an "image" tag or multiple "tile" tags; it can't combine the two.
+            # This should be enforced. For now, I'm just gonna support spritesheet tiles.
+            if c.tag == "image":
+                # create a tileset
+                arg_sheet = c.attrib['source']
+                tileset._add_image(folders, arg_sheet, num_tiles)
+
+        return tileset
+
+    @classmethod
+    def fromjson(cls, folders, jdict, firstgid=None):
+        print('fromjson (isometrically)')
+        if 'source' in jdict:
+            firstgid = int(jdict['firstgid'])
+            srcc = jdict['source']
+
+            # TODO: Another direct disk access here.
+            if srcc.endswith(("tsx", "xml")):
+                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
+                    print('opened ', srcc)
+                    tag = ElementTree.fromstring(f.read())
+                    return cls.fromxml(folders, tag, firstgid)
+            elif srcc.endswith(("tsj", "json")):
+                with open(os.path.join(os.pathsep.join(folders), srcc)) as f:
+                    jdict = json.load(f)
+
+        name = jdict['name']
+        if firstgid is None:
+            firstgid = int(jdict.get('firstgid', 1))
+        tile_width = int(jdict['tilewidth'])
+        tile_height = int(jdict['tileheight'])
+        num_tiles = int(jdict['tilecount'])
+
+        tileset = cls(name, tile_width, tile_height, firstgid)
+
+        if "transformations" in jdict:
+            c = jdict["transformations"]
+            tileset.vflip = int(c.get("vflip", 0)) == 1
+            tileset.hflip = int(c.get("hflip", 0)) == 1
+
+        # TODO: The tileset can only contain an "image" tag or multiple "tile" tags; it can't combine the two.
+        # This should be enforced. For now, I'm just gonna support spritesheet tiles.
+
+        # create a tileset
+        arg_sheet = jdict['image']
+        tileset._add_image(folders, arg_sheet, num_tiles)
+
+        return tileset
+
+
+class IsometricMapObject:
+    """
+    A thing that can be placed on the map.
+    """
+
+    def __init__(self, **kwargs):
+        self.name = ""
+        # self.type = ""
+        self.x = 0
+        self.y = 0
+        self.width = 0
+        self.height = 0
+        self.gid = 0
+        self.visible = 1
+
+        self.properties = dict(kwargs)  # copy properties, stores various custom properties
+
+        # super().__init__(**keywords)
+        for k, v in kwargs.items():
+            setattr(self, k, v)
+
+        self.drawingoffset = [0, 16]  # replaces the anchor stuff
+
+    def __call__(self, dest_surface, sx, sy, mymap):
+        """Draw this object at the requested surface coordinates on the provided surface."""
+        if self.gid:
+            tile_id = self.gid & NOT_ALL_FLAGS
+            if tile_id > 0:
+                my_tile = mymap.tilesets[tile_id]
+                my_tile.paint_tile(dest_surface, sx+self.drawingoffset[0], sy+self.drawingoffset[1], self.gid & FLIPPED_HORIZONTALLY_FLAG, self.gid & FLIPPED_VERTICALLY_FLAG)
+
+    @staticmethod
+    def _deweirdify_coordinates(tx, ty, givenlayer):
+        # It took ages to figure out the coordinate system that Tiled uses for objects on isometric maps. At first I
+        # thought the pixel coordinate origin would be the upper left corner of the map's bounding box. It isn't.
+        # In fact, it isn't a normal cartesian coordinate system at all. The pixel x,y values are the cell index
+        # multiplied by the cell height. I cannot think of any situation for which this would be a useful way to store
+        # pixel coordinates, but there you go.
+        #
+        # This function takes the Tiled pixel coordinates and changes them to tilemap cell coordinates. Feel free to
+        # delete this long rant of a comment. Or leave it as a warning to others. I am just glad to finally understand
+        # what's going on.
+
+        mx = -0.5 + (tx / float(givenlayer.tile_height))
+        my = -0.5 + (ty / float(givenlayer.tile_height))
+        return mx, my
+
+    @classmethod
+    def fromxml(cls, tag, givenlayer):
+        myob = cls()
+        myob.name = tag.attrib.get("name")
+        myob.type = tag.attrib.get(info_type_obj)
+        # Convert the x,y pixel coordinates to x,y map coordinates.
+        x = float(tag.attrib.get("x", 0))
+        y = float(tag.attrib.get("y", 0))
+        myob.x, myob.y = cls._deweirdify_coordinates(x, y, givenlayer)
+        myob.gid = int(tag.attrib.get("gid"))
+        myob.visible = int(tag.attrib.get("visible", 1))
+        for t in tag:
+            if t.tag == "properties":
+                for p in t:
+                    if p.tag == "property":
+                        myob.properties[p.attrib.get("name", "property")] = p.attrib.get("value")
+        return myob
+
+    @classmethod
+    def fromjson(cls, jdict, givenlayer):
+        name = jdict.get("name")
+        objtype = jdict.get(info_type_obj)
+        # Convert the x,y pixel coordinates to x,y map coordinates.
+        x, y = cls._deweirdify_coordinates(jdict.get("x", 0), jdict.get("y", 0), givenlayer)
+        gid = jdict.get("gid")
+        visible = jdict.get("visible")
+
+        eproperties = dict()
+        if "properties" in jdict:
+            for p in jdict["properties"]:
+                kk = p.get("name", "property")
+                vv = p.get("value")
+                eproperties[kk] = vv
+        eproperties['name'] = name
+        eproperties['type'] = objtype
+        eproperties['x'], eproperties['y'] = x, y
+        eproperties['gid'] = gid
+        eproperties['visible'] = visible
+        return cls(**eproperties)
+
+
+class IsometricLayer:
+    flag_csv = False
+
+    def __init__(self, name, visible, map, offsetx=0, offsety=0):
+        self.name = name
+        self.visible = visible
+
+        self.tile_width = map.tile_width
+        self.tile_height = map.tile_height
+
+        self.width = map.width
+        self.height = map.height
+
+        self.offsetx = offsetx
+        self.offsety = offsety
+
+        self.properties = {}
+        self.cells = list()
+
+    def __repr__(self):
+        return '<Layer "%s" at 0x%x>' % (self.name, id(self))
+
+    @classmethod
+    def emptylayer(cls, name, givenmap):
+        layer = cls(
+            name, 0, givenmap, 0, 0
+        )
+
+        layer.cells = [0, ] * givenmap.height * givenmap.width
+
+        return layer
+
+    @classmethod
+    def fromxml(cls, tag, givenmap):
+        layer = cls(
+            tag.attrib['name'], int(tag.attrib.get('visible', 1)), givenmap,
+            int(tag.attrib.get('offsetx', 0)), int(tag.attrib.get('offsety', 0))
+        )
+
+        data = tag.find('data')
+        if data is None:
+            raise ValueError('layer %s does not contain <data>' % layer.name)
+
+        data = data.text.strip()
+        data = data.encode()  # Convert to bytes
+        # Decode from base 64 and decompress via zlib
+        data = decompress(b64decode(data))
+
+        # I ran a test today and there's a slight speed advantage in leaving the cells as a list. It's not a big
+        # advantage, but it's just as easy for now to leave the data as it is.
+        #
+        # I'm changing to a list from a tuple in case destructible terrain or modifiable terrain (such as doors) are
+        # wanted in the future.
+        layer.cells = list(struct.unpack('<%di' % (len(data) / 4,), data))
+        assert len(layer.cells) == layer.width * layer.height
+
+        return layer
+
+    @classmethod
+    def fromjson(cls, jdict, givenmap):
+        layer = cls(
+            jdict['name'], jdict.get('visible', True), givenmap,
+            jdict.get('offsetx', 0), jdict.get('offsety', 0)
+        )
+
+        data = jdict.get('data')
+        if data is None:
+            raise ValueError('layer %s does not contain <data>' % layer.name)
+
+        # Remark: (june 2022)
+        # we need to support uncompressed data like CSV, for instance,
+        # for specific use cases where the zlib module cannot be used
+        # (hacking in the web ctx for example)
+
+        if not cls.flag_csv:  # default mode -> data is compressed
+            data = data.strip()
+            data = data.encode()  # Convert to bytes
+            # Decode from base 64 and decompress via zlib
+            data = decompress(b64decode(data))
+            # I ran a test today and there's a slight speed advantage in leaving the cells as a list.
+            # It's not a big advantage, but it's just as easy for now to leave the data as it is.
+            # I'm changing to a list from a tuple in case destructible terrain or modifiable terrain
+            # (such as doors) ar wanted in the future
+            layer.cells = list(struct.unpack('<%di' % (len(data) / 4,), data))
+            assert len(layer.cells) == layer.width * layer.height
+        else:  # uncompressed data
+            layer.cells = data
+
+        return layer
+
+    def __len__(self):
+        return self.height * self.width
+
+    def _pos_to_index(self, x, y):
+        # loop map feat.
+        y = y % self.height
+        x = x % self.width
+        return y * self.width + x
+
+    def __getitem__(self, key):
+        x, y = key
+        i = self._pos_to_index(x, y)
+        # no test of boundaries bc of the loop map feat.
+        # if 0 <= x < self.width and 0 <= y < self.height:
+        return self.cells[i]
+
+    def __setitem__(self, pos, value):
+        x, y = pos
+        i = self._pos_to_index(x, y)
+        # if 0 <= x < self.width and 0 <= y < self.height:
+        self.cells[i] = value
+
+
+class ObjectGroup:
+    def __init__(self, name, visible, offsetx, offsety):
+        self.name = name
+        self.visible = visible
+        self.offsetx = offsetx
+        self.offsety = offsety
+
+        self.contents = list()
+
+    @classmethod
+    def fromxml(cls, tag, givenlayer, object_classes=None):
+        mygroup = cls(
+            tag.attrib['name'], int(tag.attrib.get('visible', 1)),
+            int(tag.attrib.get('offsetx', 0)), int(tag.attrib.get('offsety', 0))
+        )
+
+        for t in tag:
+            if t.tag == "object":
+                if object_classes and t.attrib.get(info_type_obj) in object_classes:
+                    myclass = object_classes[t.attrib.get(info_type_obj)]
+                else:
+                    myclass = IsometricMapObject
+                mygroup.contents.append(myclass.fromxml(
+                    t, givenlayer
+                ))
+
+        return mygroup
+
+    @classmethod
+    def fromjson(cls, folders, jdict, givenlayer, object_classes=None):
+        mygroup = cls(
+            jdict.get('name'), jdict.get('visible', True),
+            jdict.get('offsetx', 0), jdict.get('offsety', 0)
+        )
+
+        if "objects" in jdict:
+            for t in jdict["objects"]:
+                if object_classes and t.get(info_type_obj) in object_classes:
+                    myclass = object_classes[t.get(info_type_obj)]
+                else:
+                    myclass = IsometricMapObject
+                mygroup.contents.append(myclass.fromjson(
+                    t, givenlayer
+                ))
+
+        return mygroup
+
+
+class IsometricMap:
+    # Customization:
+    # If a layer named "Move Layer" exists, the PC can only move into tiles that exist on this layer. The layer may be
+    #   invisible.
+    # If a layer named "Block Layer" exists, the PC cannot move into tiles that exist on this layer. The layer may be
+    #   invisible.
+    def __init__(self):
+        self.tile_width = 0
+        self.tile_height = 0
+        self.width = 0
+        self.height = 0
+        self.layers = list()
+        self.tilesets = tmx.data.Tilesets()
+        self.objectgroups = dict()
+
+        self.wrap_x = False
+        self.wrap_y = False
+
+        self.floor_layer = None
+        self.wall_layer = None
+
+        self.wallpaper = None
+        self.mapname = None
+
+    def seek_floor_and_wall(self):
+        for n, layer in enumerate(self.layers):
+            if layer.name == "Move Layer":
+                self.floor_layer = n
+            elif layer.name == "Block Layer":
+                self.wall_layer = n
+
+    @classmethod
+    def load_tmx(cls, folders, filename, object_classes=None):
+        # object_classes is a function that can parse a dict describing an object.
+        # If None, the only objects that can be loaded are terrain objects.
+        with open(os.path.join(os.pathsep.join(folders), filename)) as f:
+            tminfo_tree = ElementTree.fromstring(f.read())
+
+        # get most general map informations and create a surface
+        tilemap = cls()
+
+        tilemap.width = int(tminfo_tree.attrib['width'])
+        tilemap.height = int(tminfo_tree.attrib['height'])
+        tilemap.tile_width = int(tminfo_tree.attrib['tilewidth'])
+        tilemap.tile_height = int(tminfo_tree.attrib['tileheight'])
+
+        for tag in tminfo_tree.findall('tileset'):
+            tilemap.tilesets.add(
+                IsometricTileset.fromxml(folders, tag)
+                # hacks work only if no more than 1 ts
+            )
+
+        for tag in tminfo_tree:
+            if tag.tag == 'layer':
+                layer = IsometricLayer.fromxml(tag, tilemap)
+                tilemap.layers.append(layer)
+            elif tag.tag == "objectgroup":
+                if not tilemap.layers:
+                    # If the first layer on the map is an objectgroup, this is gonna be a problem. Without
+                    # a frame of reference, we won't be able to know what tile the object is in, and that is going
+                    # to be important information. So, we add an empty layer with no offsets to act as this
+                    # objectgroup's frame of reference.
+                    tilemap.layers.append(IsometricLayer.emptylayer("The Mysterious Empty Layer", tilemap))
+                tilemap.objectgroups[tilemap.layers[-1]] = ObjectGroup.fromxml(tag, tilemap.layers[-1], object_classes)
+            elif tag.tag == "properties":
+                for ptag in tag.findall("property"):
+                    if ptag.get("name") == "wrap_x":
+                        tilemap.wrap_x = ptag.get("value") == "true"
+                    elif ptag.get("name") == "wrap_y":
+                        tilemap.wrap_y = ptag.get("value") == "true"
+                    elif ptag.get("name") == "mapname":
+                        tilemap.mapname = ptag.get("mapname")
+                    elif ptag.get("name") == "wallpaper":
+                        tilemap.wallpaper = _hub.pygame.image.load(os.path.join("assets",ptag.get("value"))).convert_alpha()
+
+        return tilemap
+
+    @classmethod
+    def load_json(cls, folders, filename, object_classes=None):
+        # object_classes is a function that can parse a dict describing an object.
+        # If None, the only objects that can be loaded are terrain objects.
+
+        with open(os.path.join(os.pathsep.join(folders), filename)) as f:
+            jdict = json.load(f)
+        return cls.from_json_dict(folders, jdict, object_classes)
+
+    @classmethod
+    def from_json_dict(cls, folders, jdict, object_classes=None):
+        # get most general map informations and create a surface
+        tilemap = cls()
+
+        tilemap.width = jdict['width']
+        tilemap.height = jdict['height']
+        tilemap.tile_width = jdict['tilewidth']
+        tilemap.tile_height = jdict['tileheight']
+
+        if "properties" in jdict:
+            for tag in jdict["properties"]:
+                if tag["name"] == "wrap_x":
+                    tilemap.wrap_x = tag.get("value", False)
+                elif tag["name"] == "wrap_y":
+                    tilemap.wrap_y = tag.get("value", False)
+                elif tag["name"] == "mapname":
+                    tilemap.mapname = tag.get("value")
+                elif tag["name"] == "wallpaper":
+                    pprefix = os.pathsep.join(folders)
+                    tilemap.wallpaper = _hub.pygame.image.load(os.path.join(pprefix, tag.get("value"))).convert_alpha()
+
+        for tag in jdict['tilesets']:
+            tilemap.tilesets.add(
+                IsometricTileset.fromjson(folders, tag)
+            )
+
+        for tag in jdict["layers"]:
+            if tag["type"] == 'tilelayer':
+                layer = IsometricLayer.fromjson(tag, tilemap)
+                tilemap.layers.append(layer)
+            elif tag["type"] == "objectgroup":
+                if not tilemap.layers:
+                    # See above comment for why I'm adding an empty layer. TLDR: the objects need a reference frame.
+                    tilemap.layers.append(IsometricLayer.emptylayer("The Mysterious Empty Layer", tilemap))
+                tilemap.objectgroups[tilemap.layers[-1]] = ObjectGroup.fromjson(
+                    folders, tag, tilemap.layers[-1], object_classes
+                )
+        return tilemap
+
+    @classmethod
+    def load(cls, folders, filename, object_classes=None):
+        if filename.endswith(("tmx", "xml")):
+            mymap = cls.load_tmx(folders, filename, object_classes)
+        elif filename.endswith(("tmj", "json")):
+            mymap = cls.load_json(folders, filename, object_classes)
+        else:
+            raise NotImplementedError("No decoder for {}".format(filename))
+        mymap.seek_floor_and_wall()
+        return mymap
+
+    def on_the_map(self, x, y):
+        # Returns true if (x,y) is on the map, false otherwise
+        return (self.wrap_x or ((x >= 0) and (x < self.width))) and (self.wrap_y or ((y >= 0) and (y < self.height)))
+
+    def get_layer_by_name(self, layer_name):
+        # The Layers type in Kengi supports indexing layers by name, but it
+        # doesn't support accessing layers by
+        # negative indices. I'm not sure that it supports slicing either. Anyhow, for now, only the map cursor needs
+        # to look up layers by name so this function should be good enough for the time being.
+        for lay in self.layers:
+            if lay.name == layer_name:
+                return lay
+
+    def get_object_by_name(self, object_name):
+        # Return the first object found with the provided name.
+        for obgroup in self.objectgroups.values():
+            for ob in obgroup.contents:
+                if ob.name == object_name:
+                    return ob
+
+    def clamp_pos(self, pos):
+        # For infinite scroll maps, clamp the x and/or y values
+        nupos = list(pos)
+        if self.wrap_x:
+            f, i = math.modf(pos[0])
+            nupos[0] = int(i) % self.width + f
+        else:
+            if pos[0] < 0:
+                nupos[0] = 0
+            elif pos[0] >= self.width:
+                nupos[0] = self.width-1
+        if self.wrap_y:
+            f, i = math.modf(pos[1])
+            nupos[1] = int(i) % self.height + f
+        else:
+            if pos[1] < 0:
+                nupos[1] = 0
+            elif pos[1] >= self.height:
+                nupos[1] = self.height-1
+        return tuple(nupos)
+
+    def clamp_pos_int(self, pos):
+        def spefilter(val):
+            xinf, xmid, xsup = math.floor(val), math.floor(val) + 0.5, math.ceil(val)
+            a, b, c = abs(val - xinf), abs(val - xmid), abs(val - xsup)
+            if c < a:
+                if c < b:
+                    rez = xsup
+                else:
+                    rez = xmid
+            else:
+                if a < b:
+                    rez = xinf
+                else:
+                    rez = xmid
+            return rez
+
+        # For infinite scroll maps, clamp the x and/or y values
+        nupos = [math.floor(c) for c in pos]
+        if self.wrap_x:
+            f, i = math.modf(pos[0])
+            nupos[0] = int(i) % self.width
+        else:
+            if pos[0] < 0:
+                nupos[0] = 0
+            elif pos[0] >= self.width:
+                nupos[0] = self.width-1
+
+        if self.wrap_y:
+            f, i = math.modf(pos[1])
+            nupos[1] = int(i) % self.height
+        else:
+            if pos[1] < 0:
+                nupos[1] = 0
+            elif pos[1] >= self.height:
+                nupos[1] = self.height-1
+        return tuple(nupos)
+
+    def tile_is_blocked(self, x, y):
+        pos = self.clamp_pos_int((x,y))
+        if self.floor_layer is not None and self.layers[self.floor_layer][pos] == 0:
+            return True
+        if self.wall_layer is not None and self.layers[self.wall_layer][pos] != 0:
+            return True
+        else:
+            return False
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/__init__.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/__init__.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,23 +1,23 @@
-"""
-(~*~ legacy code ~*~)
-AUTHOR INFO
- Joseph H. cf. https://github.com/jwvhewitt
-
-LICENSE INFO
- for the whole polarbear folder: Apache 2.0
-
-Below are chunks extracted from the Polar Bear Game Engine.
-This package contains some low-level graphics stuff needed to
-create an isometric RPG style rules in Python. The idea is to
-isolate the graphics handling from the code as much as possible,
-so that if PyGame is replaced the interface shouldn't change
-too much. Also, so that creating a new rules should be as simple
-as importing this package.
-Word wrapper taken from the PyGame wiki plus the list-printer
-from Anne Archibald's GearHead Prime demo.
-"""
-
-from . import image
-from . import widgets
-from .general import default_border, render_text, wait_event, TIMEREVENT, INFO_GREEN
-from .image import draw_text
+"""
+(~*~ legacy code ~*~)
+AUTHOR INFO
+ Joseph H. cf. https://github.com/jwvhewitt
+
+LICENSE INFO
+ for the whole polarbear folder: Apache 2.0
+
+Below are chunks extracted from the Polar Bear Game Engine.
+This package contains some low-level graphics stuff needed to
+create an isometric RPG style rules in Python. The idea is to
+isolate the graphics handling from the code as much as possible,
+so that if PyGame is replaced the interface shouldn't change
+too much. Also, so that creating a new rules should be as simple
+as importing this package.
+Word wrapper taken from the PyGame wiki plus the list-printer
+from Anne Archibald's GearHead Prime demo.
+"""
+
+from . import image
+from . import widgets
+from .general import default_border, render_text, wait_event, TIMEREVENT, INFO_GREEN
+from .image import draw_text
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/frects.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/frects.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,37 +1,37 @@
-from ... import _hub
-from ...compo import vscreen as core
-
-
-ANCHOR_UPPERLEFT = (0, 0)
-ANCHOR_UPPERRIGHT = (2, 0)
-ANCHOR_CENTER = (1, 1)
-ANCHOR_LOWERLEFT = (0, 2)
-ANCHOR_LOWERRIGHT = (2, 2)
-ANCHOR_TOP = (1, 0)
-ANCHOR_LEFT = (0, 1)
-ANCHOR_RIGHT = (2, 1)
-
-pygame = _hub.pygame
-
-
-class Frect(object):
-    """Floating rect- changes position depending on the screen dimensions."""
-
-    def __init__(self, dx, dy, w, h, anchor=ANCHOR_CENTER, parent=None):
-        self.dx = dx
-        self.dy = dy
-        self.w = w
-        self.h = h
-        self.anchor = anchor
-        self.parent = parent
-
-    def get_rect(self):
-        if self.parent:
-            prect = self.parent.get_rect()
-            x0 = prect.left + (prect.w // 2) * self.anchor[0]
-            y0 = prect.top + (prect.h // 2) * self.anchor[1]
-        else:
-            sw, sh = core.get_screen().get_size()
-            x0 = (sw // 2) * self.anchor[0]
-            y0 = (sh // 2) * self.anchor[1]
-        return pygame.Rect(self.dx + x0, self.dy + y0, self.w, self.h)
+from ... import _hub
+from ...compo import vscreen as core
+
+
+ANCHOR_UPPERLEFT = (0, 0)
+ANCHOR_UPPERRIGHT = (2, 0)
+ANCHOR_CENTER = (1, 1)
+ANCHOR_LOWERLEFT = (0, 2)
+ANCHOR_LOWERRIGHT = (2, 2)
+ANCHOR_TOP = (1, 0)
+ANCHOR_LEFT = (0, 1)
+ANCHOR_RIGHT = (2, 1)
+
+pygame = _hub.pygame
+
+
+class Frect(object):
+    """Floating rect- changes position depending on the screen dimensions."""
+
+    def __init__(self, dx, dy, w, h, anchor=ANCHOR_CENTER, parent=None):
+        self.dx = dx
+        self.dy = dy
+        self.w = w
+        self.h = h
+        self.anchor = anchor
+        self.parent = parent
+
+    def get_rect(self):
+        if self.parent:
+            prect = self.parent.get_rect()
+            x0 = prect.left + (prect.w // 2) * self.anchor[0]
+            y0 = prect.top + (prect.h // 2) * self.anchor[1]
+        else:
+            sw, sh = core.get_screen().get_size()
+            x0 = (sw // 2) * self.anchor[0]
+            y0 = (sh // 2) * self.anchor[1]
+        return pygame.Rect(self.dx + x0, self.dy + y0, self.w, self.h)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/polarbear/widgets.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/polarbear/widgets.py`

 * *Ordering differences only*

 * *Files 13% similar despite different names*

```diff
@@ -1,706 +1,706 @@
-from . import frects
-from . import image
-from ... import _hub
-pygame = _hub.pygame
-
-from .general import my_state, TEXT_COLOR, Border, default_border, wrap_with_records
-from .image import wrap_multi_line, draw_text
-
-# respond_event: Receives an event.
-#   If the widget has a method corresponding to the event,
-#   that method will be called.
-
-# Note that the widget needs to be added to my_state.widgets to be used!
-# Or, as the child of another widget. Removing it from that list
-# removes it.
-
-ACTIVE_FLASH = [(0, 0, 0), ] * 5 + [(230, 230, 0), ] * 20
-
-widget_border_off = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge1.png",
-                           tex_name="sys_widbor_back.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=2)
-widget_border_on = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge2.png",
-                          tex_name="sys_widbor_back.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=2)
-popup_menu_border = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge2.png",
-                           tex_name="sys_defbackground.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=8,
-                           transparent=False)
-
-
-class Widget(frects.Frect):
-    def __init__(self, dx, dy, w, h, data=None, on_click=None, tooltip=None, children=(), active=True,
-                 show_when_inactive=False, on_right_click=None, **kwargs):
-        # on_click takes widget, event as parameters.
-        # on_right_click takes widget, event as parameters.
-        super().__init__(dx, dy, w, h, **kwargs)
-        self.data = data
-        self.active = active
-        self.tooltip = tooltip
-        self.on_click = on_click
-        self.on_right_click = on_right_click
-        self.children = list(children)
-        self.show_when_inactive = show_when_inactive
-
-    def respond_event(self, ev):
-        if self.active:
-            for c in self.children:
-                c.respond_event(ev)
-            if self.get_rect().collidepoint(my_state.mouse_pos):
-                if self.active and (ev.type == pygame.MOUSEBUTTONUP) and (
-                        ev.button == 1) and not my_state.widget_clicked:
-                    if not my_state.widget_clicked:
-                        my_state.active_widget = self
-                    if self.on_click:
-                        self.on_click(self, ev)
-                    my_state.widget_clicked = True
-                elif self.active and (ev.type == pygame.MOUSEBUTTONUP) and (
-                        ev.button == 3) and self.on_right_click and not my_state.widget_clicked:
-                    if not my_state.widget_clicked:
-                        my_state.active_widget = self
-                    self.on_right_click(self, ev)
-                    my_state.widget_clicked = True
-            elif my_state.active_widget is self:
-                if self.on_click and (ev.type == pygame.KEYDOWN) and (ev.key in my_state.get_keys_for("click_widget")):
-                    self.on_click(self, ev)
-                    my_state.widget_clicked = True
-            self._builtin_responder(ev)
-
-    def _builtin_responder(self, ev):
-        pass
-
-    def super_render(self):
-        # This renders the widget and children, setting tooltip and whatnot.
-        if self.active or self.show_when_inactive:
-            self.render(self._should_flash())
-            if self.tooltip and self.get_rect().collidepoint(my_state.mouse_pos):
-                my_state.widget_tooltip = self.tooltip
-            for c in self.children:
-                c.super_render()
-
-    def _should_flash(self):
-        if self.parent and hasattr(self.parent, "kb_flash_override"):
-            return self.parent.kb_flash_override(self)
-        elif hasattr(self, "kbhandler") and self.kbhandler and hasattr(self.kbhandler, "kb_flash_override"):
-            return self.kbhandler.kb_flash_override(self)
-        else:
-            return (self is my_state.active_widget) and my_state.active_widget_hilight
-
-    def _default_flash(self):
-        pygame.draw.rect(my_state.screen, ACTIVE_FLASH[my_state.anim_phase % len(ACTIVE_FLASH)], self.get_rect(), 1)
-
-    def render(self, flash=False):
-        if flash:
-            self._default_flash()
-
-    def is_kb_selectable(self):
-        if self.parent and hasattr(self.parent, "kb_select_override"):
-            return self.parent.kb_select_override(self)
-        elif hasattr(self, "kbhandler") and self.kbhandler and hasattr(self.kbhandler, "kb_select_override"):
-            return self.kbhandler.kb_select_override(self)
-        else:
-            return self.on_click
-
-
-class ButtonWidget(Widget):
-    def __init__(self, dx, dy, w, h, sprite=None, frame=0, on_frame=0, off_frame=0, **kwargs):
-        super(ButtonWidget, self).__init__(dx, dy, w, h, **kwargs)
-        self.sprite = sprite
-        self.frame = frame
-        self.on_frame = on_frame
-        self.off_frame = off_frame
-
-    def render(self, flash=False):
-        if self.sprite:
-            self.sprite.render(self.get_rect(), self.frame)
-        if flash:
-            self._default_flash()
-
-
-class LabelWidget(Widget):
-    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, draw_border=False,
-                 border=widget_border_off, text_fun=None, **kwargs):
-        # text_fun is a function that takes this widget as a parameter. It returns the text to display.
-        super(LabelWidget, self).__init__(dx, dy, w, h, **kwargs)
-        self.text = text
-        self.color = color or TEXT_COLOR
-        self.font = font or my_state.small_font
-        if h == 0:
-            self.h = len(wrap_multi_line(text, self.font, self.w)) * self.font.get_linesize()
-        self.justify = justify
-        self.draw_border = draw_border
-        self.border = border
-        self.text_fun = text_fun
-
-    def render(self, flash=False):
-        if self.draw_border:
-            self.border.render(self.get_rect())
-        if self.text_fun:
-            self.text = self.text_fun(self)
-        draw_text(self.font, self.text, self.get_rect(), self.color, self.justify)
-        if flash:
-            self._default_flash()
-
-
-class TextEntryWidget(Widget):
-    ALLOWABLE_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890()-=_+,.?"'
-
-    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, on_change=None, **kwargs):
-        # on_change is a callable that takes (widget,ev) whenever the contents of the text changes.
-        super(TextEntryWidget, self).__init__(dx, dy, w, h, **kwargs)
-        if not text:
-            text = ''
-        self.char_list = list(text)
-        self.color = color or TEXT_COLOR
-        self.font = font or my_state.big_font
-        self.justify = justify
-        self.input_cursor = image.Image("sys_textcursor.png", 8, 16)
-        self.on_change = on_change
-
-    def render(self, flash=False):
-        mydest = self.get_rect()
-        if self is my_state.active_widget:
-            widget_border_on.render(mydest.inflate(-4, -4))
-        else:
-            widget_border_off.render(mydest.inflate(-4, -4))
-        myimage = self.font.render(self.text, True, self.color)
-        my_state.screen.set_clip(mydest)
-        textdest = myimage.get_rect(center=mydest.center)
-        my_state.screen.blit(myimage, textdest)
-        my_state.screen.set_clip(None)
-        if flash or (my_state.active_widget is self):
-            self.input_cursor.render(textdest.topright, (my_state.anim_phase // 3) % 4)
-
-    def _builtin_responder(self, ev):
-        if my_state.active_widget is self:
-            if ev.type == pygame.KEYDOWN:
-                if (ev.key == pygame.K_BACKSPACE) and (len(self.char_list) > 0):
-                    del self.char_list[-1]
-                    if self.on_change:
-                        self.on_change(self, ev)
-                elif (ev.unicode in self.ALLOWABLE_CHARACTERS) and (len(ev.unicode) > 0):
-                    self.char_list.append(ev.unicode)
-                    if self.on_change:
-                        self.on_change(self, ev)
-
-    def is_kb_selectable(self):
-        return True
-
-    def _get_text(self):
-        return "".join(self.char_list)
-
-    def _set_text(self, text):
-        self.char_list = list(text)
-        if self.on_change:
-            self.on_change(self, None)
-
-    text = property(_get_text, _set_text)
-
-    def quietly_set_text(self, text):
-        # Set the text without calling on_change.
-        self.char_list = list(text)
-
-
-class RadioButtonWidget(Widget):
-    def __init__(self, dx, dy, w, h, sprite=None, buttons=(), spacing=2, **kwargs):
-        # buttons is a list of dicts possibly containing: on_frame, off_frame, on_click, on_right_click, tooltip
-        super().__init__(dx, dy, w, h, **kwargs)
-        self.sprite = sprite
-        self.buttons = list()
-        self.spacing = spacing
-        ddx = 0
-        for b in buttons:
-            self.buttons.append(ButtonWidget(
-                ddx, 0, sprite.frame_width, sprite.frame_height, sprite,
-                frame=b.get("off_frame", 1), on_frame=b.get("on_frame", 0),
-                off_frame=b.get("off_frame", 1), tooltip=b.get("tooltip", None),
-                on_click=self.click_radio, data=b.get("on_click", None),
-                on_right_click=b.get("on_right_click", None),
-                parent=self, anchor=frects.ANCHOR_UPPERLEFT
-            ))
-            ddx += sprite.frame_width + self.spacing
-        self.buttons[0].frame = self.buttons[0].on_frame
-        self.active_button = self.buttons[0]
-        self.children += self.buttons
-
-    def activate_button(self, button):
-        self.active_button.frame = self.active_button.off_frame
-        self.active_button = button
-        button.frame = button.on_frame
-
-    def get_button(self, data_sought):
-        for b in self.buttons:
-            if b.data == data_sought:
-                return b
-
-    def click_radio(self, button, ev):
-        self.activate_button(button)
-        if button.data:
-            button.data(button, ev)
-
-
-class ColumnWidget(Widget):
-    def __init__(self, dx, dy, w, h, draw_border=False, border=default_border, padding=5, center_interior=False,
-                 **kwargs):
-        super(ColumnWidget, self).__init__(dx, dy, w, h, **kwargs)
-        self.draw_border = draw_border
-        self.border = border
-        self._interior_widgets = list()
-        self._header_widget = None
-        self.padding = padding
-        self.center_interior = center_interior
-
-    def add_interior(self, other_w):
-        self.children.append(other_w)
-        self._interior_widgets.append(other_w)
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        self._position_contents()
-
-    def set_header(self, other_w):
-        self.children.append(other_w)
-        self._header_widget = other_w
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        self._position_contents()
-
-    def clear(self):
-        del self._interior_widgets[:]
-        del self.children[:]
-        self._header_widget = None
-
-    def _position_contents(self):
-        dy = 0
-        if self._header_widget:
-            self._header_widget.dx = -(self._header_widget.w // 2)
-            self._header_widget.dy = -(self._header_widget.h // 2)
-            self._header_widget.anchor = frects.ANCHOR_TOP
-            dy += self._header_widget.h // 2 + self.padding
-        for widg in self._interior_widgets:
-            if self.center_interior:
-                widg.dx = (self.w - widg.w) // 2
-            else:
-                widg.dx = 0
-            widg.dy = dy
-            widg.anchor = frects.ANCHOR_UPPERLEFT
-            dy += widg.h + self.padding
-        self.h = dy
-
-    def render(self, flash=False):
-        if self.draw_border:
-            self.border.render(self.get_rect())
-        if flash:
-            self._default_flash()
-
-
-class ScrollColumnWidget(Widget):
-    def __init__(self, dx, dy, w, h, up_button, down_button, draw_border=False, border=default_border, padding=5,
-                 autoclick=False, focus_locked=False, **kwargs):
-        super(ScrollColumnWidget, self).__init__(dx, dy, w, h, **kwargs)
-        self.draw_border = draw_border
-        self.border = border
-        self._interior_widgets = list()
-        self.padding = padding
-        self.top_widget = 0
-        self.up_button = up_button
-        self.up_button.on_click = self.scroll_up
-        self.up_button.kbhandler = self
-        self.down_button = down_button
-        self.down_button.on_click = self.scroll_down
-        self.down_button.frame = self.down_button.off_frame
-        self.down_button.kbhandler = self
-        self.autoclick = autoclick
-        self.focus_locked = focus_locked
-        self._active_widget = -1
-        self.active_widget = 0
-
-    def _set_active_widget(self, widindex):
-        if widindex >= 0 and widindex < len(self._interior_widgets) and widindex != self._active_widget:
-            self._active_widget = widindex
-            wid = self._interior_widgets[widindex]
-            if not wid.active:
-                self.scroll_to_index(widindex)
-            if self.autoclick and wid.on_click:
-                wid.on_click(wid, None)
-
-    def _get_active_widget(self):
-        return self._active_widget
-
-    active_widget = property(_get_active_widget, _set_active_widget)
-
-    def kb_select_override(self, child):
-        return not (child in self._interior_widgets or child is self.up_button or child is self.down_button)
-
-    def kb_flash_override(self, child):
-        return ((my_state.active_widget is self) or self.focus_locked) and (child in self._interior_widgets) and (
-                self._interior_widgets.index(child) == self.active_widget
-        )
-
-    def is_kb_selectable(self):
-        return True
-
-    def decorate_click(self, other_on_click):
-        def nuclick(wid, ev):
-            if wid in self._interior_widgets and self.active_widget != self._interior_widgets.index(wid):
-                self.active_widget = self._interior_widgets.index(wid)
-            other_on_click(wid, ev)
-
-        return nuclick
-
-    def add_interior(self, other_w):
-        self.children.append(other_w)
-        self._interior_widgets.append(other_w)
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        other_w.dx = 0
-        other_w.anchor = frects.ANCHOR_UPPERLEFT
-        self._position_contents()
-        if other_w.on_click:
-            other_w.on_click = self.decorate_click(other_w.on_click)
-
-    def clear(self):
-        for w in list(self._interior_widgets):
-            self._interior_widgets.remove(w)
-            self.children.remove(w)
-
-    def _position_contents(self):
-        # Disable all interior widgets, except those currently visible.
-        for w in self._interior_widgets:
-            w.active = False
-        dy = 0
-        n = self.top_widget
-        if n >= len(self._interior_widgets):
-            n = 0
-        while (dy < self.h) and (n < len(self._interior_widgets)):
-            widg = self._interior_widgets[n]
-            widg.dy = dy
-            if (dy == 0) or (dy + widg.h + self.padding <= self.h):
-                widg.active = True
-            dy += widg.h + self.padding
-            n += 1
-        # Activate or deactivate the up/down buttons.
-        if self.top_widget > 0:
-            self.up_button.frame = self.up_button.on_frame
-        else:
-            self.up_button.frame = self.up_button.off_frame
-        if self._interior_widgets and not self._interior_widgets[-1].active:
-            self.down_button.frame = self.down_button.on_frame
-        else:
-            self.down_button.frame = self.down_button.off_frame
-
-        if self.active_widget < self.top_widget:
-            self.active_widget = self.top_widget
-        elif self.active_widget >= (n - 1):
-            self.active_widget = max(n - 2, 0)
-
-    def scroll_up(self, *args):
-        if self.top_widget > 0:
-            self.top_widget -= 1
-            self._position_contents()
-
-    def scroll_down(self, *args):
-        if self._interior_widgets and not self._interior_widgets[-1].active:
-            self.top_widget += 1
-            self._position_contents()
-
-    def scroll_to_index(self, index):
-        '''Programmatic access to ensure a particular list item is shown'''
-        if index < len(self._interior_widgets) and not self._interior_widgets[index].active:
-            self.top_widget = index
-            self._position_contents()
-            self.active_widget = index
-
-    def sort(self, key=None):
-        self._interior_widgets.sort(key=key)
-        self._position_contents()
-
-    def _builtin_responder(self, ev):
-        if (ev.type == pygame.MOUSEBUTTONDOWN) and self.get_rect().collidepoint(my_state.mouse_pos):
-            if (ev.button == 4):
-                self.scroll_up()
-            elif (ev.button == 5):
-                self.scroll_down()
-        elif ((my_state.active_widget is self) or self.focus_locked) and (ev.type == pygame.KEYDOWN):
-            if ev.key in my_state.get_keys_for("click_widget"):
-                if self.active_widget < len(self._interior_widgets):
-                    mybutton = self._interior_widgets[self.active_widget]
-                    mybutton.on_click(mybutton, ev)
-                    my_state.widget_clicked = True
-            elif ev.key in my_state.get_keys_for("up") and self.active_widget > 0:
-                self.active_widget -= 1
-            elif ev.key in my_state.get_keys_for("down") and self.active_widget < (len(self._interior_widgets) - 1):
-                self.active_widget += 1
-
-    def render(self, flash=False):
-        if self.draw_border:
-            self.border.render(self.get_rect())
-        if flash:
-            self._default_flash()
-
-
-class RowWidget(Widget):
-    def __init__(self, dx, dy, w, h, draw_border=False, border=default_border, padding=5, **kwargs):
-        super().__init__(dx, dy, w, h, **kwargs)
-        self.draw_border = draw_border
-        self.border = border
-        self._left_widgets = list()
-        self._center_widgets = list()
-        self._right_widgets = list()
-        self.padding = padding
-
-    def add_left(self, other_w):
-        self.children.append(other_w)
-        self._left_widgets.append(other_w)
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        self._position_contents()
-
-    def add_center(self, other_w):
-        self.children.append(other_w)
-        self._center_widgets.append(other_w)
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        self._position_contents()
-
-    def add_right(self, other_w):
-        self.children.append(other_w)
-        self._right_widgets.append(other_w)
-        # Set the position of other_w inside this widget.
-        other_w.parent = self
-        self._position_contents()
-
-    def _position_contents(self):
-        dx = 0
-        self.h = max(w.h for w in self._right_widgets + self._center_widgets + self._left_widgets)
-        for widg in self._left_widgets:
-            widg.dx = dx
-            widg.dy = -widg.h // 2
-            widg.anchor = frects.ANCHOR_LEFT
-            dx += widg.w + self.padding
-
-        if self._center_widgets:
-            dx = -(sum(w.w for w in self._center_widgets) + (len(self._center_widgets) - 1) * self.padding) // 2
-            for widg in self._center_widgets:
-                widg.dx = dx
-                widg.dy = -widg.h // 2
-                widg.anchor = frects.ANCHOR_CENTER
-                dx += widg.w + self.padding
-
-        if self._right_widgets:
-            dx = -sum(w.w for w in self._right_widgets) - (len(self._right_widgets) - 1) * self.padding
-            for widg in self._right_widgets:
-                widg.dx = dx
-                widg.dy = -widg.h // 2
-                widg.anchor = frects.ANCHOR_RIGHT
-                dx += widg.w + self.padding
-
-    def render(self, flash=False):
-        if self.draw_border:
-            self.border.render(self.get_rect())
-        if flash:
-            self._default_flash()
-
-
-class DropdownWidget(Widget):
-    MENU_HEIGHT = 150
-
-    def __init__(self, dx, dy, w, h, color=None, font=None, justify=-1, on_select=None, **kwargs):
-        # on_select is a callable that takes the menu query result as its argument
-        super(DropdownWidget, self).__init__(dx, dy, w, h, **kwargs)
-        self.color = color or TEXT_COLOR
-        self.font = font or my_state.small_font
-        self.on_select = on_select
-        self.on_click = self.open_menu
-        self.menu = rpgmenu.Menu(dx, dy, w, self.MENU_HEIGHT, border=popup_menu_border, font=font,
-                                 anchor=frects.ANCHOR_UPPERLEFT)
-
-    def render(self, flash=False):
-        mydest = self.get_rect()
-        if self is my_state.active_widget:
-            widget_border_on.render(mydest.inflate(-4, -4))
-        else:
-            widget_border_off.render(mydest.inflate(-4, -4))
-        myimage = self.font.render(str(self.menu.get_current_item()), True, self.color)
-        my_state.screen.set_clip(mydest)
-        textdest = myimage.get_rect(center=mydest.center)
-        my_state.screen.blit(myimage, textdest)
-        my_state.screen.set_clip(None)
-        if flash:
-            self._default_flash()
-
-    def add_item(self, msg, value, desc=None):
-        self.menu.add_item(msg, value, desc)
-
-    def open_menu(self, also_self_probably, ev):
-        mydest = self.get_rect()
-        mydest.h = self.menu.h
-        mydest.w = self.menu.w
-        mydest.clamp_ip(my_state.screen.get_rect())
-        self.menu.dx, self.menu.dy = mydest.x, mydest.y
-        result = self.menu.query()
-        if self.on_select:
-            self.on_select(result)
-
-    @property
-    def value(self):
-        return self.menu.get_current_value()
-
-
-class TextEditorWidget(Widget):
-    # This widget is going to be different from the text entry widget above in that it's meant to be a full
-    # functioned text editor. What have I gotten myself into?
-    ALLOWABLE_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890()-=_+,.?"\''
-
-    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, on_change=None, **kwargs):
-        # on_change is a callable that takes (widget,ev) whenever the contents of the text changes.
-        super().__init__(dx, dy, w, h, **kwargs)
-        if not text:
-            text = ''
-        self.char_list = list(text)
-        self.color = color or TEXT_COLOR
-        self.font = font or my_state.big_font
-        self.justify = justify
-        self.cursor_image = image.Image("sys_editcursor.png", 8, 16)
-
-        up_arrow = ButtonWidget(w - 32, -8, 32, 16, sprite=image.Image("sys_updownbuttons_small.png", 32, 16),
-                                on_frame=0, off_frame=1, parent=self)
-        down_arrow = ButtonWidget(w - 32, h + 8, 32, 16, sprite=image.Image("sys_updownbuttons_small.png", 32, 16),
-                                  on_frame=2, off_frame=3, parent=self)
-
-        self.children.append(up_arrow)
-        self.children.append(down_arrow)
-
-        self.on_change = on_change
-        # The current index of the cursor and carat:
-        self.cursor_i = 0
-        self.carat_i = None
-        self.top_line = 0
-        self.num_lines = (self.h - 12) // self.font.get_linesize()
-
-    def get_line_pos(self, index, lengths):
-        # Given the buffer index and lengths of each screen line (in characters), return the screen line
-        # and the screen index of this position.
-        line = 0
-        for l in lengths:
-            if index < l:
-                break
-            else:
-                index -= l
-                line += 1
-        return line, index
-
-    def get_buffer_index(self, dx, dy, lines):
-        pass
-
-    def render(self, flash=False):
-        mydest = self.get_rect()
-        if flash or (self is my_state.active_widget):
-            widget_border_on.render(mydest.inflate(-4, -4))
-        else:
-            widget_border_off.render(mydest.inflate(-4, -4))
-
-        lines, lengths = wrap_with_records(self.text, self.font, self.w - 12)
-
-        cursor_line, cursor_pos = self.get_line_pos(self.cursor_i, lengths)
-
-        if self.top_line + self.num_lines - 1 > len(lines):
-            self.top_line = max(0, len(lines) - self.num_lines)
-
-        textdest = mydest.inflate(-12, -12)
-        my_state.screen.set_clip(textdest)
-
-        current_line = self.top_line
-        # print(cursor_countdown, cursor_line, cursor_pos)
-        for l in lines[self.top_line:self.top_line + self.num_lines]:
-            img = self.font.render(l, True, self.color)
-            my_state.screen.blit(img, textdest)
-            if self is my_state.active_widget and current_line == cursor_line:
-                cdest = textdest.copy()
-                cdest.x += self.font.size(l[:cursor_pos])[0] - 4
-                self.cursor_image.render(cdest.topleft, (my_state.anim_phase // 5) % 4)
-            current_line += 1
-            textdest.y += self.font.get_linesize()
-
-        my_state.screen.set_clip(None)
-
-    def _insert(self, new_text):
-        for c in list(new_text):
-            self.char_list.insert(self.cursor_i, new_text)
-            self.cursor_i += 1
-
-    def _builtin_responder(self, ev):
-        if my_state.active_widget is self:
-            if ev.type == pygame.KEYDOWN:
-                if (ev.key == pygame.K_BACKSPACE) and (len(self.char_list) > 0):
-                    if self.cursor_i > 0:
-                        del self.char_list[self.cursor_i - 1]
-                        self.cursor_i -= 1
-                        if self.on_change:
-                            self.on_change(self, ev)
-                elif (ev.key == pygame.K_DELETE) and (len(self.char_list) > 0):
-                    if self.cursor_i < len(self.char_list):
-                        del self.char_list[self.cursor_i]
-                        if self.on_change:
-                            self.on_change(self, ev)
-                elif ev.key == pygame.K_LEFT:
-                    if self.cursor_i > 0:
-                        self.cursor_i -= 1
-                elif ev.key == pygame.K_RIGHT:
-                    if self.cursor_i < len(self.char_list):
-                        self.cursor_i += 1
-                elif (ev.unicode in self.ALLOWABLE_CHARACTERS) and (len(ev.unicode) > 0):
-                    self._insert(ev.unicode)
-                    if self.on_change:
-                        self.on_change(self, ev)
-
-    def is_kb_selectable(self):
-        return True
-
-    def _get_text(self):
-        return "".join(self.char_list)
-
-    def _set_text(self, text):
-        self.char_list = list(text)
-        if self.on_change:
-            self.on_change(self, None)
-
-    text = property(_get_text, _set_text)
-
-
-# Widgets for columns
-
-class ColTextEntryWidget(RowWidget):
-    def __init__(self, width, prompt="Enter Text", text='***', color=None, font=None, justify=-1, on_change=None,
-                 **kwargs):
-        mylabel = LabelWidget(0, 0, width * 2 // 5 - 10, 0, prompt, font=font)
-        super().__init__(0, 0, width, mylabel.h + 8, **kwargs)
-        self.add_left(mylabel)
-        self.my_text_widget = TextEntryWidget(0, 0, width * 3 // 5, mylabel.h + 8, text, color, font, justify,
-                                              on_change=on_change, )
-        self.add_right(self.my_text_widget)
-
-    def _get_text(self):
-        return self.my_text_widget.text
-
-    def _set_text(self, text):
-        self.my_text_widget.text = text
-
-    text = property(_get_text, _set_text)
-
-    def quietly_set_text(self, text):
-        # Set the text without calling on_change.
-        self.my_text_widget.quietly_set_text(text)
-
-
-class ColDropdownWidget(RowWidget):
-    def __init__(self, width, prompt="Choose Option", font=None, justify=-1, on_select=None, **kwargs):
-        mylabel = LabelWidget(0, 0, width * 2 // 5 - 10, 0, prompt, font=font)
-        super().__init__(0, 0, width, mylabel.h + 8, **kwargs)
-        self.add_left(mylabel)
-        self.my_menu_widget = DropdownWidget(0, 0, width * 3 // 5, mylabel.h + 8, font=font, justify=justify,
-                                             on_select=on_select)
-        self.add_right(self.my_menu_widget)
-
-    def add_item(self, msg, value, desc=None):
-        self.my_menu_widget.add_item(msg, value, desc)
-
-    @property
-    def value(self):
-        return self.my_menu_widget.value
+from . import frects
+from . import image
+from ... import _hub
+pygame = _hub.pygame
+
+from .general import my_state, TEXT_COLOR, Border, default_border, wrap_with_records
+from .image import wrap_multi_line, draw_text
+
+# respond_event: Receives an event.
+#   If the widget has a method corresponding to the event,
+#   that method will be called.
+
+# Note that the widget needs to be added to my_state.widgets to be used!
+# Or, as the child of another widget. Removing it from that list
+# removes it.
+
+ACTIVE_FLASH = [(0, 0, 0), ] * 5 + [(230, 230, 0), ] * 20
+
+widget_border_off = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge1.png",
+                           tex_name="sys_widbor_back.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=2)
+widget_border_on = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge2.png",
+                          tex_name="sys_widbor_back.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=2)
+popup_menu_border = Border(border_width=8, tex_width=16, border_name="sys_widbor_edge2.png",
+                           tex_name="sys_defbackground.png", tl=0, tr=3, bl=4, br=5, t=1, b=1, l=2, r=2, padding=8,
+                           transparent=False)
+
+
+class Widget(frects.Frect):
+    def __init__(self, dx, dy, w, h, data=None, on_click=None, tooltip=None, children=(), active=True,
+                 show_when_inactive=False, on_right_click=None, **kwargs):
+        # on_click takes widget, event as parameters.
+        # on_right_click takes widget, event as parameters.
+        super().__init__(dx, dy, w, h, **kwargs)
+        self.data = data
+        self.active = active
+        self.tooltip = tooltip
+        self.on_click = on_click
+        self.on_right_click = on_right_click
+        self.children = list(children)
+        self.show_when_inactive = show_when_inactive
+
+    def respond_event(self, ev):
+        if self.active:
+            for c in self.children:
+                c.respond_event(ev)
+            if self.get_rect().collidepoint(my_state.mouse_pos):
+                if self.active and (ev.type == pygame.MOUSEBUTTONUP) and (
+                        ev.button == 1) and not my_state.widget_clicked:
+                    if not my_state.widget_clicked:
+                        my_state.active_widget = self
+                    if self.on_click:
+                        self.on_click(self, ev)
+                    my_state.widget_clicked = True
+                elif self.active and (ev.type == pygame.MOUSEBUTTONUP) and (
+                        ev.button == 3) and self.on_right_click and not my_state.widget_clicked:
+                    if not my_state.widget_clicked:
+                        my_state.active_widget = self
+                    self.on_right_click(self, ev)
+                    my_state.widget_clicked = True
+            elif my_state.active_widget is self:
+                if self.on_click and (ev.type == pygame.KEYDOWN) and (ev.key in my_state.get_keys_for("click_widget")):
+                    self.on_click(self, ev)
+                    my_state.widget_clicked = True
+            self._builtin_responder(ev)
+
+    def _builtin_responder(self, ev):
+        pass
+
+    def super_render(self):
+        # This renders the widget and children, setting tooltip and whatnot.
+        if self.active or self.show_when_inactive:
+            self.render(self._should_flash())
+            if self.tooltip and self.get_rect().collidepoint(my_state.mouse_pos):
+                my_state.widget_tooltip = self.tooltip
+            for c in self.children:
+                c.super_render()
+
+    def _should_flash(self):
+        if self.parent and hasattr(self.parent, "kb_flash_override"):
+            return self.parent.kb_flash_override(self)
+        elif hasattr(self, "kbhandler") and self.kbhandler and hasattr(self.kbhandler, "kb_flash_override"):
+            return self.kbhandler.kb_flash_override(self)
+        else:
+            return (self is my_state.active_widget) and my_state.active_widget_hilight
+
+    def _default_flash(self):
+        pygame.draw.rect(my_state.screen, ACTIVE_FLASH[my_state.anim_phase % len(ACTIVE_FLASH)], self.get_rect(), 1)
+
+    def render(self, flash=False):
+        if flash:
+            self._default_flash()
+
+    def is_kb_selectable(self):
+        if self.parent and hasattr(self.parent, "kb_select_override"):
+            return self.parent.kb_select_override(self)
+        elif hasattr(self, "kbhandler") and self.kbhandler and hasattr(self.kbhandler, "kb_select_override"):
+            return self.kbhandler.kb_select_override(self)
+        else:
+            return self.on_click
+
+
+class ButtonWidget(Widget):
+    def __init__(self, dx, dy, w, h, sprite=None, frame=0, on_frame=0, off_frame=0, **kwargs):
+        super(ButtonWidget, self).__init__(dx, dy, w, h, **kwargs)
+        self.sprite = sprite
+        self.frame = frame
+        self.on_frame = on_frame
+        self.off_frame = off_frame
+
+    def render(self, flash=False):
+        if self.sprite:
+            self.sprite.render(self.get_rect(), self.frame)
+        if flash:
+            self._default_flash()
+
+
+class LabelWidget(Widget):
+    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, draw_border=False,
+                 border=widget_border_off, text_fun=None, **kwargs):
+        # text_fun is a function that takes this widget as a parameter. It returns the text to display.
+        super(LabelWidget, self).__init__(dx, dy, w, h, **kwargs)
+        self.text = text
+        self.color = color or TEXT_COLOR
+        self.font = font or my_state.small_font
+        if h == 0:
+            self.h = len(wrap_multi_line(text, self.font, self.w)) * self.font.get_linesize()
+        self.justify = justify
+        self.draw_border = draw_border
+        self.border = border
+        self.text_fun = text_fun
+
+    def render(self, flash=False):
+        if self.draw_border:
+            self.border.render(self.get_rect())
+        if self.text_fun:
+            self.text = self.text_fun(self)
+        draw_text(self.font, self.text, self.get_rect(), self.color, self.justify)
+        if flash:
+            self._default_flash()
+
+
+class TextEntryWidget(Widget):
+    ALLOWABLE_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890()-=_+,.?"'
+
+    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, on_change=None, **kwargs):
+        # on_change is a callable that takes (widget,ev) whenever the contents of the text changes.
+        super(TextEntryWidget, self).__init__(dx, dy, w, h, **kwargs)
+        if not text:
+            text = ''
+        self.char_list = list(text)
+        self.color = color or TEXT_COLOR
+        self.font = font or my_state.big_font
+        self.justify = justify
+        self.input_cursor = image.Image("sys_textcursor.png", 8, 16)
+        self.on_change = on_change
+
+    def render(self, flash=False):
+        mydest = self.get_rect()
+        if self is my_state.active_widget:
+            widget_border_on.render(mydest.inflate(-4, -4))
+        else:
+            widget_border_off.render(mydest.inflate(-4, -4))
+        myimage = self.font.render(self.text, True, self.color)
+        my_state.screen.set_clip(mydest)
+        textdest = myimage.get_rect(center=mydest.center)
+        my_state.screen.blit(myimage, textdest)
+        my_state.screen.set_clip(None)
+        if flash or (my_state.active_widget is self):
+            self.input_cursor.render(textdest.topright, (my_state.anim_phase // 3) % 4)
+
+    def _builtin_responder(self, ev):
+        if my_state.active_widget is self:
+            if ev.type == pygame.KEYDOWN:
+                if (ev.key == pygame.K_BACKSPACE) and (len(self.char_list) > 0):
+                    del self.char_list[-1]
+                    if self.on_change:
+                        self.on_change(self, ev)
+                elif (ev.unicode in self.ALLOWABLE_CHARACTERS) and (len(ev.unicode) > 0):
+                    self.char_list.append(ev.unicode)
+                    if self.on_change:
+                        self.on_change(self, ev)
+
+    def is_kb_selectable(self):
+        return True
+
+    def _get_text(self):
+        return "".join(self.char_list)
+
+    def _set_text(self, text):
+        self.char_list = list(text)
+        if self.on_change:
+            self.on_change(self, None)
+
+    text = property(_get_text, _set_text)
+
+    def quietly_set_text(self, text):
+        # Set the text without calling on_change.
+        self.char_list = list(text)
+
+
+class RadioButtonWidget(Widget):
+    def __init__(self, dx, dy, w, h, sprite=None, buttons=(), spacing=2, **kwargs):
+        # buttons is a list of dicts possibly containing: on_frame, off_frame, on_click, on_right_click, tooltip
+        super().__init__(dx, dy, w, h, **kwargs)
+        self.sprite = sprite
+        self.buttons = list()
+        self.spacing = spacing
+        ddx = 0
+        for b in buttons:
+            self.buttons.append(ButtonWidget(
+                ddx, 0, sprite.frame_width, sprite.frame_height, sprite,
+                frame=b.get("off_frame", 1), on_frame=b.get("on_frame", 0),
+                off_frame=b.get("off_frame", 1), tooltip=b.get("tooltip", None),
+                on_click=self.click_radio, data=b.get("on_click", None),
+                on_right_click=b.get("on_right_click", None),
+                parent=self, anchor=frects.ANCHOR_UPPERLEFT
+            ))
+            ddx += sprite.frame_width + self.spacing
+        self.buttons[0].frame = self.buttons[0].on_frame
+        self.active_button = self.buttons[0]
+        self.children += self.buttons
+
+    def activate_button(self, button):
+        self.active_button.frame = self.active_button.off_frame
+        self.active_button = button
+        button.frame = button.on_frame
+
+    def get_button(self, data_sought):
+        for b in self.buttons:
+            if b.data == data_sought:
+                return b
+
+    def click_radio(self, button, ev):
+        self.activate_button(button)
+        if button.data:
+            button.data(button, ev)
+
+
+class ColumnWidget(Widget):
+    def __init__(self, dx, dy, w, h, draw_border=False, border=default_border, padding=5, center_interior=False,
+                 **kwargs):
+        super(ColumnWidget, self).__init__(dx, dy, w, h, **kwargs)
+        self.draw_border = draw_border
+        self.border = border
+        self._interior_widgets = list()
+        self._header_widget = None
+        self.padding = padding
+        self.center_interior = center_interior
+
+    def add_interior(self, other_w):
+        self.children.append(other_w)
+        self._interior_widgets.append(other_w)
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        self._position_contents()
+
+    def set_header(self, other_w):
+        self.children.append(other_w)
+        self._header_widget = other_w
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        self._position_contents()
+
+    def clear(self):
+        del self._interior_widgets[:]
+        del self.children[:]
+        self._header_widget = None
+
+    def _position_contents(self):
+        dy = 0
+        if self._header_widget:
+            self._header_widget.dx = -(self._header_widget.w // 2)
+            self._header_widget.dy = -(self._header_widget.h // 2)
+            self._header_widget.anchor = frects.ANCHOR_TOP
+            dy += self._header_widget.h // 2 + self.padding
+        for widg in self._interior_widgets:
+            if self.center_interior:
+                widg.dx = (self.w - widg.w) // 2
+            else:
+                widg.dx = 0
+            widg.dy = dy
+            widg.anchor = frects.ANCHOR_UPPERLEFT
+            dy += widg.h + self.padding
+        self.h = dy
+
+    def render(self, flash=False):
+        if self.draw_border:
+            self.border.render(self.get_rect())
+        if flash:
+            self._default_flash()
+
+
+class ScrollColumnWidget(Widget):
+    def __init__(self, dx, dy, w, h, up_button, down_button, draw_border=False, border=default_border, padding=5,
+                 autoclick=False, focus_locked=False, **kwargs):
+        super(ScrollColumnWidget, self).__init__(dx, dy, w, h, **kwargs)
+        self.draw_border = draw_border
+        self.border = border
+        self._interior_widgets = list()
+        self.padding = padding
+        self.top_widget = 0
+        self.up_button = up_button
+        self.up_button.on_click = self.scroll_up
+        self.up_button.kbhandler = self
+        self.down_button = down_button
+        self.down_button.on_click = self.scroll_down
+        self.down_button.frame = self.down_button.off_frame
+        self.down_button.kbhandler = self
+        self.autoclick = autoclick
+        self.focus_locked = focus_locked
+        self._active_widget = -1
+        self.active_widget = 0
+
+    def _set_active_widget(self, widindex):
+        if widindex >= 0 and widindex < len(self._interior_widgets) and widindex != self._active_widget:
+            self._active_widget = widindex
+            wid = self._interior_widgets[widindex]
+            if not wid.active:
+                self.scroll_to_index(widindex)
+            if self.autoclick and wid.on_click:
+                wid.on_click(wid, None)
+
+    def _get_active_widget(self):
+        return self._active_widget
+
+    active_widget = property(_get_active_widget, _set_active_widget)
+
+    def kb_select_override(self, child):
+        return not (child in self._interior_widgets or child is self.up_button or child is self.down_button)
+
+    def kb_flash_override(self, child):
+        return ((my_state.active_widget is self) or self.focus_locked) and (child in self._interior_widgets) and (
+                self._interior_widgets.index(child) == self.active_widget
+        )
+
+    def is_kb_selectable(self):
+        return True
+
+    def decorate_click(self, other_on_click):
+        def nuclick(wid, ev):
+            if wid in self._interior_widgets and self.active_widget != self._interior_widgets.index(wid):
+                self.active_widget = self._interior_widgets.index(wid)
+            other_on_click(wid, ev)
+
+        return nuclick
+
+    def add_interior(self, other_w):
+        self.children.append(other_w)
+        self._interior_widgets.append(other_w)
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        other_w.dx = 0
+        other_w.anchor = frects.ANCHOR_UPPERLEFT
+        self._position_contents()
+        if other_w.on_click:
+            other_w.on_click = self.decorate_click(other_w.on_click)
+
+    def clear(self):
+        for w in list(self._interior_widgets):
+            self._interior_widgets.remove(w)
+            self.children.remove(w)
+
+    def _position_contents(self):
+        # Disable all interior widgets, except those currently visible.
+        for w in self._interior_widgets:
+            w.active = False
+        dy = 0
+        n = self.top_widget
+        if n >= len(self._interior_widgets):
+            n = 0
+        while (dy < self.h) and (n < len(self._interior_widgets)):
+            widg = self._interior_widgets[n]
+            widg.dy = dy
+            if (dy == 0) or (dy + widg.h + self.padding <= self.h):
+                widg.active = True
+            dy += widg.h + self.padding
+            n += 1
+        # Activate or deactivate the up/down buttons.
+        if self.top_widget > 0:
+            self.up_button.frame = self.up_button.on_frame
+        else:
+            self.up_button.frame = self.up_button.off_frame
+        if self._interior_widgets and not self._interior_widgets[-1].active:
+            self.down_button.frame = self.down_button.on_frame
+        else:
+            self.down_button.frame = self.down_button.off_frame
+
+        if self.active_widget < self.top_widget:
+            self.active_widget = self.top_widget
+        elif self.active_widget >= (n - 1):
+            self.active_widget = max(n - 2, 0)
+
+    def scroll_up(self, *args):
+        if self.top_widget > 0:
+            self.top_widget -= 1
+            self._position_contents()
+
+    def scroll_down(self, *args):
+        if self._interior_widgets and not self._interior_widgets[-1].active:
+            self.top_widget += 1
+            self._position_contents()
+
+    def scroll_to_index(self, index):
+        '''Programmatic access to ensure a particular list item is shown'''
+        if index < len(self._interior_widgets) and not self._interior_widgets[index].active:
+            self.top_widget = index
+            self._position_contents()
+            self.active_widget = index
+
+    def sort(self, key=None):
+        self._interior_widgets.sort(key=key)
+        self._position_contents()
+
+    def _builtin_responder(self, ev):
+        if (ev.type == pygame.MOUSEBUTTONDOWN) and self.get_rect().collidepoint(my_state.mouse_pos):
+            if (ev.button == 4):
+                self.scroll_up()
+            elif (ev.button == 5):
+                self.scroll_down()
+        elif ((my_state.active_widget is self) or self.focus_locked) and (ev.type == pygame.KEYDOWN):
+            if ev.key in my_state.get_keys_for("click_widget"):
+                if self.active_widget < len(self._interior_widgets):
+                    mybutton = self._interior_widgets[self.active_widget]
+                    mybutton.on_click(mybutton, ev)
+                    my_state.widget_clicked = True
+            elif ev.key in my_state.get_keys_for("up") and self.active_widget > 0:
+                self.active_widget -= 1
+            elif ev.key in my_state.get_keys_for("down") and self.active_widget < (len(self._interior_widgets) - 1):
+                self.active_widget += 1
+
+    def render(self, flash=False):
+        if self.draw_border:
+            self.border.render(self.get_rect())
+        if flash:
+            self._default_flash()
+
+
+class RowWidget(Widget):
+    def __init__(self, dx, dy, w, h, draw_border=False, border=default_border, padding=5, **kwargs):
+        super().__init__(dx, dy, w, h, **kwargs)
+        self.draw_border = draw_border
+        self.border = border
+        self._left_widgets = list()
+        self._center_widgets = list()
+        self._right_widgets = list()
+        self.padding = padding
+
+    def add_left(self, other_w):
+        self.children.append(other_w)
+        self._left_widgets.append(other_w)
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        self._position_contents()
+
+    def add_center(self, other_w):
+        self.children.append(other_w)
+        self._center_widgets.append(other_w)
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        self._position_contents()
+
+    def add_right(self, other_w):
+        self.children.append(other_w)
+        self._right_widgets.append(other_w)
+        # Set the position of other_w inside this widget.
+        other_w.parent = self
+        self._position_contents()
+
+    def _position_contents(self):
+        dx = 0
+        self.h = max(w.h for w in self._right_widgets + self._center_widgets + self._left_widgets)
+        for widg in self._left_widgets:
+            widg.dx = dx
+            widg.dy = -widg.h // 2
+            widg.anchor = frects.ANCHOR_LEFT
+            dx += widg.w + self.padding
+
+        if self._center_widgets:
+            dx = -(sum(w.w for w in self._center_widgets) + (len(self._center_widgets) - 1) * self.padding) // 2
+            for widg in self._center_widgets:
+                widg.dx = dx
+                widg.dy = -widg.h // 2
+                widg.anchor = frects.ANCHOR_CENTER
+                dx += widg.w + self.padding
+
+        if self._right_widgets:
+            dx = -sum(w.w for w in self._right_widgets) - (len(self._right_widgets) - 1) * self.padding
+            for widg in self._right_widgets:
+                widg.dx = dx
+                widg.dy = -widg.h // 2
+                widg.anchor = frects.ANCHOR_RIGHT
+                dx += widg.w + self.padding
+
+    def render(self, flash=False):
+        if self.draw_border:
+            self.border.render(self.get_rect())
+        if flash:
+            self._default_flash()
+
+
+class DropdownWidget(Widget):
+    MENU_HEIGHT = 150
+
+    def __init__(self, dx, dy, w, h, color=None, font=None, justify=-1, on_select=None, **kwargs):
+        # on_select is a callable that takes the menu query result as its argument
+        super(DropdownWidget, self).__init__(dx, dy, w, h, **kwargs)
+        self.color = color or TEXT_COLOR
+        self.font = font or my_state.small_font
+        self.on_select = on_select
+        self.on_click = self.open_menu
+        self.menu = rpgmenu.Menu(dx, dy, w, self.MENU_HEIGHT, border=popup_menu_border, font=font,
+                                 anchor=frects.ANCHOR_UPPERLEFT)
+
+    def render(self, flash=False):
+        mydest = self.get_rect()
+        if self is my_state.active_widget:
+            widget_border_on.render(mydest.inflate(-4, -4))
+        else:
+            widget_border_off.render(mydest.inflate(-4, -4))
+        myimage = self.font.render(str(self.menu.get_current_item()), True, self.color)
+        my_state.screen.set_clip(mydest)
+        textdest = myimage.get_rect(center=mydest.center)
+        my_state.screen.blit(myimage, textdest)
+        my_state.screen.set_clip(None)
+        if flash:
+            self._default_flash()
+
+    def add_item(self, msg, value, desc=None):
+        self.menu.add_item(msg, value, desc)
+
+    def open_menu(self, also_self_probably, ev):
+        mydest = self.get_rect()
+        mydest.h = self.menu.h
+        mydest.w = self.menu.w
+        mydest.clamp_ip(my_state.screen.get_rect())
+        self.menu.dx, self.menu.dy = mydest.x, mydest.y
+        result = self.menu.query()
+        if self.on_select:
+            self.on_select(result)
+
+    @property
+    def value(self):
+        return self.menu.get_current_value()
+
+
+class TextEditorWidget(Widget):
+    # This widget is going to be different from the text entry widget above in that it's meant to be a full
+    # functioned text editor. What have I gotten myself into?
+    ALLOWABLE_CHARACTERS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ 1234567890()-=_+,.?"\''
+
+    def __init__(self, dx, dy, w, h, text='***', color=None, font=None, justify=-1, on_change=None, **kwargs):
+        # on_change is a callable that takes (widget,ev) whenever the contents of the text changes.
+        super().__init__(dx, dy, w, h, **kwargs)
+        if not text:
+            text = ''
+        self.char_list = list(text)
+        self.color = color or TEXT_COLOR
+        self.font = font or my_state.big_font
+        self.justify = justify
+        self.cursor_image = image.Image("sys_editcursor.png", 8, 16)
+
+        up_arrow = ButtonWidget(w - 32, -8, 32, 16, sprite=image.Image("sys_updownbuttons_small.png", 32, 16),
+                                on_frame=0, off_frame=1, parent=self)
+        down_arrow = ButtonWidget(w - 32, h + 8, 32, 16, sprite=image.Image("sys_updownbuttons_small.png", 32, 16),
+                                  on_frame=2, off_frame=3, parent=self)
+
+        self.children.append(up_arrow)
+        self.children.append(down_arrow)
+
+        self.on_change = on_change
+        # The current index of the cursor and carat:
+        self.cursor_i = 0
+        self.carat_i = None
+        self.top_line = 0
+        self.num_lines = (self.h - 12) // self.font.get_linesize()
+
+    def get_line_pos(self, index, lengths):
+        # Given the buffer index and lengths of each screen line (in characters), return the screen line
+        # and the screen index of this position.
+        line = 0
+        for l in lengths:
+            if index < l:
+                break
+            else:
+                index -= l
+                line += 1
+        return line, index
+
+    def get_buffer_index(self, dx, dy, lines):
+        pass
+
+    def render(self, flash=False):
+        mydest = self.get_rect()
+        if flash or (self is my_state.active_widget):
+            widget_border_on.render(mydest.inflate(-4, -4))
+        else:
+            widget_border_off.render(mydest.inflate(-4, -4))
+
+        lines, lengths = wrap_with_records(self.text, self.font, self.w - 12)
+
+        cursor_line, cursor_pos = self.get_line_pos(self.cursor_i, lengths)
+
+        if self.top_line + self.num_lines - 1 > len(lines):
+            self.top_line = max(0, len(lines) - self.num_lines)
+
+        textdest = mydest.inflate(-12, -12)
+        my_state.screen.set_clip(textdest)
+
+        current_line = self.top_line
+        # print(cursor_countdown, cursor_line, cursor_pos)
+        for l in lines[self.top_line:self.top_line + self.num_lines]:
+            img = self.font.render(l, True, self.color)
+            my_state.screen.blit(img, textdest)
+            if self is my_state.active_widget and current_line == cursor_line:
+                cdest = textdest.copy()
+                cdest.x += self.font.size(l[:cursor_pos])[0] - 4
+                self.cursor_image.render(cdest.topleft, (my_state.anim_phase // 5) % 4)
+            current_line += 1
+            textdest.y += self.font.get_linesize()
+
+        my_state.screen.set_clip(None)
+
+    def _insert(self, new_text):
+        for c in list(new_text):
+            self.char_list.insert(self.cursor_i, new_text)
+            self.cursor_i += 1
+
+    def _builtin_responder(self, ev):
+        if my_state.active_widget is self:
+            if ev.type == pygame.KEYDOWN:
+                if (ev.key == pygame.K_BACKSPACE) and (len(self.char_list) > 0):
+                    if self.cursor_i > 0:
+                        del self.char_list[self.cursor_i - 1]
+                        self.cursor_i -= 1
+                        if self.on_change:
+                            self.on_change(self, ev)
+                elif (ev.key == pygame.K_DELETE) and (len(self.char_list) > 0):
+                    if self.cursor_i < len(self.char_list):
+                        del self.char_list[self.cursor_i]
+                        if self.on_change:
+                            self.on_change(self, ev)
+                elif ev.key == pygame.K_LEFT:
+                    if self.cursor_i > 0:
+                        self.cursor_i -= 1
+                elif ev.key == pygame.K_RIGHT:
+                    if self.cursor_i < len(self.char_list):
+                        self.cursor_i += 1
+                elif (ev.unicode in self.ALLOWABLE_CHARACTERS) and (len(ev.unicode) > 0):
+                    self._insert(ev.unicode)
+                    if self.on_change:
+                        self.on_change(self, ev)
+
+    def is_kb_selectable(self):
+        return True
+
+    def _get_text(self):
+        return "".join(self.char_list)
+
+    def _set_text(self, text):
+        self.char_list = list(text)
+        if self.on_change:
+            self.on_change(self, None)
+
+    text = property(_get_text, _set_text)
+
+
+# Widgets for columns
+
+class ColTextEntryWidget(RowWidget):
+    def __init__(self, width, prompt="Enter Text", text='***', color=None, font=None, justify=-1, on_change=None,
+                 **kwargs):
+        mylabel = LabelWidget(0, 0, width * 2 // 5 - 10, 0, prompt, font=font)
+        super().__init__(0, 0, width, mylabel.h + 8, **kwargs)
+        self.add_left(mylabel)
+        self.my_text_widget = TextEntryWidget(0, 0, width * 3 // 5, mylabel.h + 8, text, color, font, justify,
+                                              on_change=on_change, )
+        self.add_right(self.my_text_widget)
+
+    def _get_text(self):
+        return self.my_text_widget.text
+
+    def _set_text(self, text):
+        self.my_text_widget.text = text
+
+    text = property(_get_text, _set_text)
+
+    def quietly_set_text(self, text):
+        # Set the text without calling on_change.
+        self.my_text_widget.quietly_set_text(text)
+
+
+class ColDropdownWidget(RowWidget):
+    def __init__(self, width, prompt="Choose Option", font=None, justify=-1, on_select=None, **kwargs):
+        mylabel = LabelWidget(0, 0, width * 2 // 5 - 10, 0, prompt, font=font)
+        super().__init__(0, 0, width, mylabel.h + 8, **kwargs)
+        self.add_left(mylabel)
+        self.my_menu_widget = DropdownWidget(0, 0, width * 3 // 5, mylabel.h + 8, font=font, justify=justify,
+                                             on_select=on_select)
+        self.add_right(self.my_menu_widget)
+
+    def add_item(self, msg, value, desc=None):
+        self.my_menu_widget.add_item(msg, value, desc)
+
+    @property
+    def value(self):
+        return self.my_menu_widget.value
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/rogue.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/rogue.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,548 +1,548 @@
-import random
-import math
-from .. import struct
-
-
-# ----------------------------
-#  random map generation tool
-# ----------------------------
-SYM_UP, SYM_DOWN, SYM_LEFT, SYM_RIGHT = range(4)
-
-DIRS = [
-    SYM_UP,
-    SYM_DOWN,
-    SYM_LEFT,
-    SYM_RIGHT]
-
-COORD_OFFSET = {
-    SYM_UP: [0, -1],
-    SYM_DOWN: [0, +1],
-    SYM_LEFT: [-1, 0],
-    SYM_RIGHT: [+1, 0]}
-
-WINDING_FACTOR = 0.4
-SEUIL_CASES = 44
-
-
-def dist_manhattan(c1, c2):
-    return abs(c2[0] - c1[0]) + abs(c2[1] - c1[1])
-
-
-def cell_in_range(cell, size):
-    if cell[0] < 0 or cell[0] >= size[0]:
-        return False
-    if cell[1] < 0 or cell[1] >= size[1]:
-        return False
-    return True
-
-
-def cell_voisinnes(c, size):
-    i, j = c
-    res = list()
-    for d in DIRS:
-        voisin_direct = (i + COORD_OFFSET[d][0], j + COORD_OFFSET[d][1])
-        if cell_in_range(voisin_direct, size):
-            res.append(voisin_direct)
-    return res
-
-
-class RandomMaze:
-    """
-    le but de cette classe est de générer un labyrinthe aléatoire :
-    représenté via une matrice 2d à valeurs abritraires (soit None soit Nombre entier)
-    représentant salles et couloirs
-
-    Elle permet de récupérer une matrice (objet type IntegerMatrix) constante et adéquate
-    pour le but recherché (disposer dun labyrinthe différent à chaque fois)
-    via la méthode RandomMaze.getMatrix
-    """
-    def __init__(self, w, h, min_room_size, max_room_size, density_factor=140):
-        self.int_matrix = struct.IntegerMatrix((w, h))
-        self.int_matrix.set_all(None)  # super important! Otherwise the algorithm wont work
-
-        self.room_possib_size = list()
-
-        for i in range(min_room_size, max_room_size + 1):
-            if i % 2 == 0:  # choix dune taille impaire nécessairement
-                continue
-            self.room_possib_size.append(i)
-
-        # --- pr stocker meta données
-        self.curr_region = 0
-        self.li_rooms = list()
-
-        # --- procédure de constr dun labyrinthe randomize
-
-        # (1) creation non overlaping rooms
-        self.nb_rooms = 0
-        self.all_room_codes = set()
-        for i in range(density_factor):
-            self.__add_room()
-
-        # (2) growing tree algo
-        for i in range(1, w - 1, 2):
-            for j in range(1, h - 1, 2):
-                pos = (i, j)
-                if self.int_matrix.get_val(*pos) is None:
-                    self.__growMaze(pos)
-
-        # (3) connexion de regions (creuse les jonctions)
-        self.candidats_connexion = list()
-        self.li_connecteurs = list()
-        dim = self.int_matrix.get_size()
-        for i in range(dim[0]):
-            for j in range(dim[1]):
-                if self.__canBeConnector((i, j)):
-                    self.candidats_connexion.append((i, j))
-
-        self.regions_to_blobs = dict()
-        while self.canMerge():
-            self.stepMerge()
-
-        # (4) suppr. cul-de-sac
-        self.tested_pos = set()
-        self.recUncarve((1, 1))
-
-    def pick_walkable_cell(self):
-        # helps choosing a valid initial position for the avatar
-        floor = self.int_matrix
-        w, h = floor.get_size()
-        chosen_pos = [
-            random.randint(0, w-1),
-            random.randint(0, h-1)
-        ]
-        while floor.get_val(*chosen_pos) is None:  # i.e. a wall
-            # try again
-            chosen_pos[0] = random.randint(0, w-1)
-            chosen_pos[1] = random.randint(0, h-1)
-        return chosen_pos
-    
-    def isRoomRegion(self, pos):
-        val = self.int_matrix.get_val(*pos)
-        return val in self.all_room_codes
-
-    def recUncarve(self, pos):
-        if pos in self.tested_pos:
-            return
-        self.tested_pos.add(pos)
-
-        m_size = self.int_matrix.get_size()
-        voisins = cell_voisinnes(pos, m_size)
-        nb_cell_carved_v = 0  # sera un nb entre 1 et 4
-        for v in voisins:
-            if self.int_matrix.get_val(*v) is not None:
-                nb_cell_carved_v += 1
-
-        if nb_cell_carved_v == 1:
-            self.int_matrix.set_val(pos[0], pos[1], None)
-            for v in voisins:
-                if v in self.tested_pos:
-                    self.tested_pos.remove(v)
-
-        for v in voisins:
-            if self.int_matrix.get_val(*v) is not None:
-                self.recUncarve(v)
-
-    def __detRegionsProches(self, c):
-        # -- traitement basique : lister les codes distincts des régions voisines
-        m_size = self.int_matrix.get_size()
-        voisins = cell_voisinnes(c, m_size)
-        ens_tmp = set()
-        for v in voisins:
-            tmp_val = self.int_matrix.get_val(*v)
-            if tmp_val is not None:
-                ens_tmp.add(tmp_val)
-        return list(ens_tmp)
-
-    def __canBeConnector(self, pos):
-        # un connecteur : est avant tt un mur, il doit letre
-        tmp_val = self.int_matrix.get_val(*pos)
-        if tmp_val is not None:
-            return False
-
-        # un connecteur : est proche de 2 régions distinctes
-        codes_reg_prox = self.__detRegionsProches(pos)
-        return len(codes_reg_prox) >= 2
-
-    def __isCloseToRegion(self, pos, code):
-        codes_reg_prox = self.__detRegionsProches(pos)
-        return code in codes_reg_prox
-
-    def canMerge(self):
-        return len(self.candidats_connexion) > 0
-
-    def stepMerge(self):
-        COEFF_REDONDANCE = 0.3
-
-        connect_valid = random.choice(self.candidats_connexion)
-        tmp = self.__detRegionsProches(connect_valid)
-
-        if tmp[0] in self.all_room_codes:  # on privilegie un connecteur = region de couloir
-            args = [tmp[1], tmp[0]]
-        else:
-            args = tmp
-
-        self.__mergeRegions(connect_valid, args[0], args[1])
-
-        # --- On garde que les connecteurs utiles et pas trop près dun connecteur validé
-        liste_filtree = list()
-
-        for c in self.candidats_connexion:
-            # -- élimination des connecteurs trop proches du nouveau connect_valid
-            if dist_manhattan(c, connect_valid) <= 1:
-                continue
-
-            # -- utile pr merger?
-            merging_utility = False
-            cod_rp = self.__detRegionsProches(c)
-            if (cod_rp[0] not in self.regions_to_blobs) or (cod_rp[1] not in self.regions_to_blobs):
-                merging_utility = True
-            elif self.regions_to_blobs[cod_rp[0]] != self.regions_to_blobs[cod_rp[1]]:
-                merging_utility = True
-
-            if merging_utility:
-                liste_filtree.append(c)
-                continue
-            # -- conservation "chanceuse" de candidats inutiles
-            if random.random() < COEFF_REDONDANCE:
-                liste_filtree.append(c)
-
-        self.candidats_connexion = liste_filtree
-
-    def __findCloseWalls(self, i, j):
-        murs_voisins = list()
-        for d in DIRS:
-            tmp = (i + COORD_OFFSET[d][0], j + COORD_OFFSET[d][1])
-            if self.int_matrix.get_val(*tmp) is None:
-                murs_voisins.append(tmp)
-        return murs_voisins
-
-    def __mergeRegions(self, current_cell, cod_region_a, cod_region_b):
-        self.int_matrix.set_val(current_cell[0], current_cell[1], cod_region_a)
-
-        self.candidats_connexion.remove(current_cell)
-        self.li_connecteurs.append(current_cell)
-
-        candidats_blob = list()
-        if cod_region_a in self.regions_to_blobs:
-            candidats_blob.append(self.regions_to_blobs[cod_region_a])
-        if cod_region_b in self.regions_to_blobs:
-            candidats_blob.append(self.regions_to_blobs[cod_region_b])
-
-        if len(candidats_blob) == 0:
-            # nouveau blob
-            tmp_blob_codes = list(self.regions_to_blobs.values())
-            if len(tmp_blob_codes) == 0:
-                blob_corresp = 1
-            else:
-                blob_corresp = max(tmp_blob_codes) + 1
-        else:
-            # blob existant, on garde le num le plus petit
-            blob_corresp = min(candidats_blob)
-
-        self.regions_to_blobs[cod_region_a] = blob_corresp
-        self.regions_to_blobs[cod_region_b] = blob_corresp
-
-    def getMatrix(self):
-        return self.int_matrix
-
-    def __startRegion(self):
-        self.curr_region += 1
-
-    def getRegion(self):
-        return self.curr_region
-
-    def __add_room(self):
-        taille_room = random.choice(self.room_possib_size)
-        w, h = self.int_matrix.get_size()
-
-        bsupw = w - taille_room
-        bsuph = h - taille_room
-
-        intervalle_x = [2 * x + 1 for x in range(0, bsupw // 2)]
-        intervalle_y = [2 * y + 1 for y in range(0, bsuph // 2)]
-        intervalle_x.pop()
-        intervalle_y.pop()
-
-        pos_salle = (
-            random.choice(intervalle_x),
-            random.choice(intervalle_y)
-        )
-
-        # salle empiete sur qq chose ?
-        for i in range(pos_salle[0] - 1, pos_salle[0] + taille_room + 2):
-            for j in range(pos_salle[1] - 1, pos_salle[1] + taille_room + 2):
-                if self.int_matrix.get_val(i, j) is not None:
-                    return
-
-        # --- création room
-        self.__startRegion()
-        code = self.getRegion()
-        self.li_rooms.append((pos_salle, taille_room, code))
-
-        for i in range(pos_salle[0], pos_salle[0] + taille_room):
-            for j in range(pos_salle[1], pos_salle[1] + taille_room):
-                self.int_matrix.set_val(i, j, code)
-        self.nb_rooms += 1
-        self.all_room_codes.add(code)
-
-    def __carve(self, pos):
-        self.int_matrix.set_val(pos[0], pos[1], self.getRegion())
-
-    def __canCarve(self, from_pos, direction):
-        base_offset = COORD_OFFSET[direction]
-        # on dépasse de la matr?
-        offset = map(lambda x: x * 3, base_offset)
-        offset = tuple(offset)
-        dest = (from_pos[0] + offset[0], from_pos[1] + offset[1])
-
-        m_size = self.int_matrix.get_size()
-        if not cell_in_range(dest, m_size):
-            return False
-
-        # on tente de carve de deja carvé?
-        offset = map(lambda x: x * 2, base_offset)
-        offset = tuple(offset)
-        dest = (from_pos[0] + offset[0], from_pos[1] + offset[1])
-        return self.int_matrix.get_val(*dest) is None
-
-    def __growMaze(self, pos):
-        last_dir = None
-        self.__startRegion()
-        self.__carve(pos)
-        total_cases_couloir = 1
-        self.li_cells_to_explore = [pos]
-
-        while len(self.li_cells_to_explore) > 0:
-
-            index_last = len(self.li_cells_to_explore)
-            cell = self.li_cells_to_explore[index_last - 1]
-
-            unmade_possib = list()
-
-            for d in DIRS:
-                if self.__canCarve(cell, d):
-                    unmade_possib.append(d)
-
-            if len(unmade_possib) > 0:
-                if last_dir is None:
-                    direction = random.choice(unmade_possib)
-                else:
-                    if (last_dir not in unmade_possib) or (random.random() < WINDING_FACTOR):
-                        direction = random.choice(unmade_possib)
-                    else:
-                        direction = last_dir
-
-                base_offset = COORD_OFFSET[direction]
-                self.__carve((cell[0] + base_offset[0], cell[1] + base_offset[1]))
-                cell_creusee = (cell[0] + 2 * base_offset[0], cell[1] + 2 * base_offset[1])
-                self.__carve(cell_creusee)
-                total_cases_couloir += 2
-                if total_cases_couloir <= SEUIL_CASES:
-                    self.li_cells_to_explore.append(cell_creusee)
-                    last_dir = direction
-            else:
-                del self.li_cells_to_explore[index_last - 1]
-                last_dir = None  # this path ended
-
-
-# ----------------------------
-#   BELOW is an extension by Travis Moy'
-#
-# *MIT License*
-# Copyright (c) 2017 Travis Moy'
-
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-
-# Holds the three angles for each cell. Near is closest to the horizontal/vertical line, and far is furthest.
-# Also used for obstructions; for the purposes of obstructions, the center variable is ignored.
-class CellAngles(object):
-    def __init__(self, near, center, far):
-        self.near = near
-        self.center = center
-        self.far = far
-
-    def __repr__(self):
-        return "(near={0} center={1} far={2})".format(self.near, self.center, self.far)
-
-
-class FOVCalc(object):
-
-    # Changing the radius-fudge changes how smooth the edges of the vision bubble are.
-    #
-    # RADIUS_FUDGE should always be a value between 0 and 1.
-    RADIUS_FUDGE = 1.0 / 3.0
-
-    # If this is False, some cells will unexpectedly be visible.
-    #
-    # For example, let's say you you have obstructions blocking (0.0 - 0.25) and (.33 - 1.0).
-    # A far off cell with (near=0.25, center=0.3125, far=0.375) will have both its near and center unblocked.
-    #
-    # On certain restrictiveness settings this will mean that it will be visible, but the blocks in front of it will
-    # not, which is unexpected and probably not desired.
-    #
-    # Setting it to True, however, makes the algorithm more restrictive.
-    NOT_VISIBLE_BLOCKS_VISION = True
-
-    # Determines how restrictive the algorithm is.
-    #
-    # 0 - if you have a line to the near, center, or far, it will return as visible
-    # 1 - if you have a line to the center and at least one other corner it will return as visible
-    # 2 - if you have a line to all the near, center, and far, it will return as visible
-    #
-    # If any other value is given, it will treat it as a 2.
-    RESTRICTIVENESS = 1
-
-    # If VISIBLE_ON_EQUAL is False, an obstruction will obstruct its endpoints. If True, it will not.
-    #
-    # For example, if there is an obstruction (0.0 - 0.25) and a square at (0.25 - 0.5), the square's near angle will
-    # be unobstructed in True, and obstructed on False.
-    #
-    # Setting this to False will make the algorithm more restrictive.
-    VISIBLE_ON_EQUAL = True
-
-    # Parameter func_transparent is a function with the sig: boolean func(x, y)
-    # It should return True if the cell is transparent, and False otherwise.
-    #
-    # Returns a set with all (x, y) tuples visible from the centerpoint.
-    def calc_visible_cells_from(self, x_center, y_center, radius, func_transparent):
-        cells = self._visible_cells_in_quadrant_from(x_center, y_center, 1, 1, radius, func_transparent)
-        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, 1, -1, radius, func_transparent))
-        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, -1, -1, radius, func_transparent))
-        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, -1, 1, radius, func_transparent))
-        cells.add((x_center, y_center))
-        return cells
-
-    # Parameters quad_x, quad_y should only be 1 or -1. The combination of the two determines the quadrant.
-    # Returns a set of (x, y) tuples.
-    def _visible_cells_in_quadrant_from(self, x_center, y_center, quad_x, quad_y, radius, func_transparent):
-        cells = self._visible_cells_in_octant_from(x_center, y_center, quad_x, quad_y, radius, func_transparent, True)
-        cells.update(self._visible_cells_in_octant_from(x_center, y_center, quad_x, quad_y, radius, func_transparent,
-                                                        False))
-        return cells
-
-    # Returns a set of (x, y) typles.
-    # Utilizes the NOT_VISIBLE_BLOCKS_VISION variable.
-    def _visible_cells_in_octant_from(self, x_center, y_center, quad_x, quad_y, radius, func_transparent, is_vertical):
-        iteration = 1
-        visible_cells = set()
-        obstructions = list()
-
-        # End conditions:
-        #   iteration > radius
-        #   Full obstruction coverage (indicated by one object in the obstruction list covering the full angle from 0
-        #      to 1)
-        while iteration <= radius and not (len(obstructions) == 1 and
-                                           obstructions[0].near == 0.0 and obstructions[0].far == 1.0):
-            num_cells_in_row = iteration + 1
-            angle_allocation = 1.0 / float(num_cells_in_row)
-
-            # Start at the center (vertical or horizontal line) and step outwards
-            for step in range(iteration + 1):
-                cell = self._cell_at(x_center, y_center, quad_x, quad_y, step, iteration, is_vertical)
-
-                if self._cell_in_radius(x_center, y_center, cell, radius):
-                    cell_angles = CellAngles(near=(float(step) * angle_allocation),
-                                             center=(float(step + .5) * angle_allocation),
-                                             far=(float(step + 1) * angle_allocation))
-
-                    if self._cell_is_visible(cell_angles, obstructions):
-                        visible_cells.add(cell)
-                        if not func_transparent(cell[0], cell[1]):
-                            obstructions = self._add_obstruction(obstructions, cell_angles)
-                    elif self.NOT_VISIBLE_BLOCKS_VISION:
-                        obstructions = self._add_obstruction(obstructions, cell_angles)
-
-            iteration += 1
-
-        return visible_cells
-
-    # Returns a (x, y) tuple.
-    def _cell_at(self, x_center, y_center, quad_x, quad_y, step, iteration, is_vertical):
-        if is_vertical:
-            cell = (x_center + step * quad_x, y_center + iteration * quad_y)
-        else:
-            cell = (x_center + iteration * quad_x, y_center + step * quad_y)
-        return cell
-
-    # Returns True/False.
-    def _cell_in_radius(self, x_center, y_center, cell, radius):
-        cell_distance = math.sqrt((x_center - cell[0]) * (x_center - cell[0]) +
-                                  (y_center - cell[1]) * (y_center - cell[1]))
-        return cell_distance <= float(radius) + self.RADIUS_FUDGE
-
-    # Returns True/False.
-    # Utilizes the VISIBLE_ON_EQUAL and RESTRICTIVENESS variables.
-    def _cell_is_visible(self, cell_angles, obstructions):
-        near_visible = True
-        center_visible = True
-        far_visible = True
-
-        for obstruction in obstructions:
-            if self.VISIBLE_ON_EQUAL:
-                if obstruction.near < cell_angles.near < obstruction.far:
-                    near_visible = False
-                if obstruction.near < cell_angles.center < obstruction.far:
-                    center_visible = False
-                if obstruction.near < cell_angles.far < obstruction.far:
-                    far_visible = False
-            else:
-                if obstruction.near <= cell_angles.near <= obstruction.far:
-                    near_visible = False
-                if obstruction.near <= cell_angles.center <= obstruction.far:
-                    center_visible = False
-                if obstruction.near <= cell_angles.far <= obstruction.far:
-                    far_visible = False
-
-        if self.RESTRICTIVENESS == 0:
-            return center_visible or near_visible or far_visible
-        elif self.RESTRICTIVENESS == 1:
-            return (center_visible and near_visible) or (center_visible and far_visible)
-        else:
-            return center_visible and near_visible and far_visible
-
-    # Generates a new list by combining all old obstructions with the new one (removing them if they are combined) and
-    # adding the resulting obstruction to the list.
-    #
-    # Returns the generated list.
-    def _add_obstruction(self, obstructions, new_obstruction):
-        new_object = CellAngles(new_obstruction.near, new_obstruction.center, new_obstruction.far)
-        new_list = [o for o in obstructions if not self._combine_obstructions(o, new_object)]
-        new_list.append(new_object)
-        return new_list
-
-    # Returns True if you combine, False otherwise
-    def _combine_obstructions(self, old, new):
-        # Pseudo-sort; if their near values are equal, they overlap
-        if old.near < new.near:
-            low = old
-            high = new
-        elif new.near < old.near:
-            low = new
-            high = old
-        else:
-            new.far = max(old.far, new.far)
-            return True
-
-        # If they overlap, combine and return True
-        if low.far >= high.near:
-            new.near = min(low.near, high.near)
-            new.far = max(low.far, high.far)
-            return True
-        return False
+import random
+import math
+from .. import struct
+
+
+# ----------------------------
+#  random map generation tool
+# ----------------------------
+SYM_UP, SYM_DOWN, SYM_LEFT, SYM_RIGHT = range(4)
+
+DIRS = [
+    SYM_UP,
+    SYM_DOWN,
+    SYM_LEFT,
+    SYM_RIGHT]
+
+COORD_OFFSET = {
+    SYM_UP: [0, -1],
+    SYM_DOWN: [0, +1],
+    SYM_LEFT: [-1, 0],
+    SYM_RIGHT: [+1, 0]}
+
+WINDING_FACTOR = 0.4
+SEUIL_CASES = 44
+
+
+def dist_manhattan(c1, c2):
+    return abs(c2[0] - c1[0]) + abs(c2[1] - c1[1])
+
+
+def cell_in_range(cell, size):
+    if cell[0] < 0 or cell[0] >= size[0]:
+        return False
+    if cell[1] < 0 or cell[1] >= size[1]:
+        return False
+    return True
+
+
+def cell_voisinnes(c, size):
+    i, j = c
+    res = list()
+    for d in DIRS:
+        voisin_direct = (i + COORD_OFFSET[d][0], j + COORD_OFFSET[d][1])
+        if cell_in_range(voisin_direct, size):
+            res.append(voisin_direct)
+    return res
+
+
+class RandomMaze:
+    """
+    le but de cette classe est de générer un labyrinthe aléatoire :
+    représenté via une matrice 2d à valeurs abritraires (soit None soit Nombre entier)
+    représentant salles et couloirs
+
+    Elle permet de récupérer une matrice (objet type IntegerMatrix) constante et adéquate
+    pour le but recherché (disposer dun labyrinthe différent à chaque fois)
+    via la méthode RandomMaze.getMatrix
+    """
+    def __init__(self, w, h, min_room_size, max_room_size, density_factor=140):
+        self.int_matrix = struct.IntegerMatrix((w, h))
+        self.int_matrix.set_all(None)  # super important! Otherwise the algorithm wont work
+
+        self.room_possib_size = list()
+
+        for i in range(min_room_size, max_room_size + 1):
+            if i % 2 == 0:  # choix dune taille impaire nécessairement
+                continue
+            self.room_possib_size.append(i)
+
+        # --- pr stocker meta données
+        self.curr_region = 0
+        self.li_rooms = list()
+
+        # --- procédure de constr dun labyrinthe randomize
+
+        # (1) creation non overlaping rooms
+        self.nb_rooms = 0
+        self.all_room_codes = set()
+        for i in range(density_factor):
+            self.__add_room()
+
+        # (2) growing tree algo
+        for i in range(1, w - 1, 2):
+            for j in range(1, h - 1, 2):
+                pos = (i, j)
+                if self.int_matrix.get_val(*pos) is None:
+                    self.__growMaze(pos)
+
+        # (3) connexion de regions (creuse les jonctions)
+        self.candidats_connexion = list()
+        self.li_connecteurs = list()
+        dim = self.int_matrix.get_size()
+        for i in range(dim[0]):
+            for j in range(dim[1]):
+                if self.__canBeConnector((i, j)):
+                    self.candidats_connexion.append((i, j))
+
+        self.regions_to_blobs = dict()
+        while self.canMerge():
+            self.stepMerge()
+
+        # (4) suppr. cul-de-sac
+        self.tested_pos = set()
+        self.recUncarve((1, 1))
+
+    def pick_walkable_cell(self):
+        # helps choosing a valid initial position for the avatar
+        floor = self.int_matrix
+        w, h = floor.get_size()
+        chosen_pos = [
+            random.randint(0, w-1),
+            random.randint(0, h-1)
+        ]
+        while floor.get_val(*chosen_pos) is None:  # i.e. a wall
+            # try again
+            chosen_pos[0] = random.randint(0, w-1)
+            chosen_pos[1] = random.randint(0, h-1)
+        return chosen_pos
+    
+    def isRoomRegion(self, pos):
+        val = self.int_matrix.get_val(*pos)
+        return val in self.all_room_codes
+
+    def recUncarve(self, pos):
+        if pos in self.tested_pos:
+            return
+        self.tested_pos.add(pos)
+
+        m_size = self.int_matrix.get_size()
+        voisins = cell_voisinnes(pos, m_size)
+        nb_cell_carved_v = 0  # sera un nb entre 1 et 4
+        for v in voisins:
+            if self.int_matrix.get_val(*v) is not None:
+                nb_cell_carved_v += 1
+
+        if nb_cell_carved_v == 1:
+            self.int_matrix.set_val(pos[0], pos[1], None)
+            for v in voisins:
+                if v in self.tested_pos:
+                    self.tested_pos.remove(v)
+
+        for v in voisins:
+            if self.int_matrix.get_val(*v) is not None:
+                self.recUncarve(v)
+
+    def __detRegionsProches(self, c):
+        # -- traitement basique : lister les codes distincts des régions voisines
+        m_size = self.int_matrix.get_size()
+        voisins = cell_voisinnes(c, m_size)
+        ens_tmp = set()
+        for v in voisins:
+            tmp_val = self.int_matrix.get_val(*v)
+            if tmp_val is not None:
+                ens_tmp.add(tmp_val)
+        return list(ens_tmp)
+
+    def __canBeConnector(self, pos):
+        # un connecteur : est avant tt un mur, il doit letre
+        tmp_val = self.int_matrix.get_val(*pos)
+        if tmp_val is not None:
+            return False
+
+        # un connecteur : est proche de 2 régions distinctes
+        codes_reg_prox = self.__detRegionsProches(pos)
+        return len(codes_reg_prox) >= 2
+
+    def __isCloseToRegion(self, pos, code):
+        codes_reg_prox = self.__detRegionsProches(pos)
+        return code in codes_reg_prox
+
+    def canMerge(self):
+        return len(self.candidats_connexion) > 0
+
+    def stepMerge(self):
+        COEFF_REDONDANCE = 0.3
+
+        connect_valid = random.choice(self.candidats_connexion)
+        tmp = self.__detRegionsProches(connect_valid)
+
+        if tmp[0] in self.all_room_codes:  # on privilegie un connecteur = region de couloir
+            args = [tmp[1], tmp[0]]
+        else:
+            args = tmp
+
+        self.__mergeRegions(connect_valid, args[0], args[1])
+
+        # --- On garde que les connecteurs utiles et pas trop près dun connecteur validé
+        liste_filtree = list()
+
+        for c in self.candidats_connexion:
+            # -- élimination des connecteurs trop proches du nouveau connect_valid
+            if dist_manhattan(c, connect_valid) <= 1:
+                continue
+
+            # -- utile pr merger?
+            merging_utility = False
+            cod_rp = self.__detRegionsProches(c)
+            if (cod_rp[0] not in self.regions_to_blobs) or (cod_rp[1] not in self.regions_to_blobs):
+                merging_utility = True
+            elif self.regions_to_blobs[cod_rp[0]] != self.regions_to_blobs[cod_rp[1]]:
+                merging_utility = True
+
+            if merging_utility:
+                liste_filtree.append(c)
+                continue
+            # -- conservation "chanceuse" de candidats inutiles
+            if random.random() < COEFF_REDONDANCE:
+                liste_filtree.append(c)
+
+        self.candidats_connexion = liste_filtree
+
+    def __findCloseWalls(self, i, j):
+        murs_voisins = list()
+        for d in DIRS:
+            tmp = (i + COORD_OFFSET[d][0], j + COORD_OFFSET[d][1])
+            if self.int_matrix.get_val(*tmp) is None:
+                murs_voisins.append(tmp)
+        return murs_voisins
+
+    def __mergeRegions(self, current_cell, cod_region_a, cod_region_b):
+        self.int_matrix.set_val(current_cell[0], current_cell[1], cod_region_a)
+
+        self.candidats_connexion.remove(current_cell)
+        self.li_connecteurs.append(current_cell)
+
+        candidats_blob = list()
+        if cod_region_a in self.regions_to_blobs:
+            candidats_blob.append(self.regions_to_blobs[cod_region_a])
+        if cod_region_b in self.regions_to_blobs:
+            candidats_blob.append(self.regions_to_blobs[cod_region_b])
+
+        if len(candidats_blob) == 0:
+            # nouveau blob
+            tmp_blob_codes = list(self.regions_to_blobs.values())
+            if len(tmp_blob_codes) == 0:
+                blob_corresp = 1
+            else:
+                blob_corresp = max(tmp_blob_codes) + 1
+        else:
+            # blob existant, on garde le num le plus petit
+            blob_corresp = min(candidats_blob)
+
+        self.regions_to_blobs[cod_region_a] = blob_corresp
+        self.regions_to_blobs[cod_region_b] = blob_corresp
+
+    def getMatrix(self):
+        return self.int_matrix
+
+    def __startRegion(self):
+        self.curr_region += 1
+
+    def getRegion(self):
+        return self.curr_region
+
+    def __add_room(self):
+        taille_room = random.choice(self.room_possib_size)
+        w, h = self.int_matrix.get_size()
+
+        bsupw = w - taille_room
+        bsuph = h - taille_room
+
+        intervalle_x = [2 * x + 1 for x in range(0, bsupw // 2)]
+        intervalle_y = [2 * y + 1 for y in range(0, bsuph // 2)]
+        intervalle_x.pop()
+        intervalle_y.pop()
+
+        pos_salle = (
+            random.choice(intervalle_x),
+            random.choice(intervalle_y)
+        )
+
+        # salle empiete sur qq chose ?
+        for i in range(pos_salle[0] - 1, pos_salle[0] + taille_room + 2):
+            for j in range(pos_salle[1] - 1, pos_salle[1] + taille_room + 2):
+                if self.int_matrix.get_val(i, j) is not None:
+                    return
+
+        # --- création room
+        self.__startRegion()
+        code = self.getRegion()
+        self.li_rooms.append((pos_salle, taille_room, code))
+
+        for i in range(pos_salle[0], pos_salle[0] + taille_room):
+            for j in range(pos_salle[1], pos_salle[1] + taille_room):
+                self.int_matrix.set_val(i, j, code)
+        self.nb_rooms += 1
+        self.all_room_codes.add(code)
+
+    def __carve(self, pos):
+        self.int_matrix.set_val(pos[0], pos[1], self.getRegion())
+
+    def __canCarve(self, from_pos, direction):
+        base_offset = COORD_OFFSET[direction]
+        # on dépasse de la matr?
+        offset = map(lambda x: x * 3, base_offset)
+        offset = tuple(offset)
+        dest = (from_pos[0] + offset[0], from_pos[1] + offset[1])
+
+        m_size = self.int_matrix.get_size()
+        if not cell_in_range(dest, m_size):
+            return False
+
+        # on tente de carve de deja carvé?
+        offset = map(lambda x: x * 2, base_offset)
+        offset = tuple(offset)
+        dest = (from_pos[0] + offset[0], from_pos[1] + offset[1])
+        return self.int_matrix.get_val(*dest) is None
+
+    def __growMaze(self, pos):
+        last_dir = None
+        self.__startRegion()
+        self.__carve(pos)
+        total_cases_couloir = 1
+        self.li_cells_to_explore = [pos]
+
+        while len(self.li_cells_to_explore) > 0:
+
+            index_last = len(self.li_cells_to_explore)
+            cell = self.li_cells_to_explore[index_last - 1]
+
+            unmade_possib = list()
+
+            for d in DIRS:
+                if self.__canCarve(cell, d):
+                    unmade_possib.append(d)
+
+            if len(unmade_possib) > 0:
+                if last_dir is None:
+                    direction = random.choice(unmade_possib)
+                else:
+                    if (last_dir not in unmade_possib) or (random.random() < WINDING_FACTOR):
+                        direction = random.choice(unmade_possib)
+                    else:
+                        direction = last_dir
+
+                base_offset = COORD_OFFSET[direction]
+                self.__carve((cell[0] + base_offset[0], cell[1] + base_offset[1]))
+                cell_creusee = (cell[0] + 2 * base_offset[0], cell[1] + 2 * base_offset[1])
+                self.__carve(cell_creusee)
+                total_cases_couloir += 2
+                if total_cases_couloir <= SEUIL_CASES:
+                    self.li_cells_to_explore.append(cell_creusee)
+                    last_dir = direction
+            else:
+                del self.li_cells_to_explore[index_last - 1]
+                last_dir = None  # this path ended
+
+
+# ----------------------------
+#   BELOW is an extension by Travis Moy'
+#
+# *MIT License*
+# Copyright (c) 2017 Travis Moy'
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice shall be included in all
+# copies or substantial portions of the Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+# Holds the three angles for each cell. Near is closest to the horizontal/vertical line, and far is furthest.
+# Also used for obstructions; for the purposes of obstructions, the center variable is ignored.
+class CellAngles(object):
+    def __init__(self, near, center, far):
+        self.near = near
+        self.center = center
+        self.far = far
+
+    def __repr__(self):
+        return "(near={0} center={1} far={2})".format(self.near, self.center, self.far)
+
+
+class FOVCalc(object):
+
+    # Changing the radius-fudge changes how smooth the edges of the vision bubble are.
+    #
+    # RADIUS_FUDGE should always be a value between 0 and 1.
+    RADIUS_FUDGE = 1.0 / 3.0
+
+    # If this is False, some cells will unexpectedly be visible.
+    #
+    # For example, let's say you you have obstructions blocking (0.0 - 0.25) and (.33 - 1.0).
+    # A far off cell with (near=0.25, center=0.3125, far=0.375) will have both its near and center unblocked.
+    #
+    # On certain restrictiveness settings this will mean that it will be visible, but the blocks in front of it will
+    # not, which is unexpected and probably not desired.
+    #
+    # Setting it to True, however, makes the algorithm more restrictive.
+    NOT_VISIBLE_BLOCKS_VISION = True
+
+    # Determines how restrictive the algorithm is.
+    #
+    # 0 - if you have a line to the near, center, or far, it will return as visible
+    # 1 - if you have a line to the center and at least one other corner it will return as visible
+    # 2 - if you have a line to all the near, center, and far, it will return as visible
+    #
+    # If any other value is given, it will treat it as a 2.
+    RESTRICTIVENESS = 1
+
+    # If VISIBLE_ON_EQUAL is False, an obstruction will obstruct its endpoints. If True, it will not.
+    #
+    # For example, if there is an obstruction (0.0 - 0.25) and a square at (0.25 - 0.5), the square's near angle will
+    # be unobstructed in True, and obstructed on False.
+    #
+    # Setting this to False will make the algorithm more restrictive.
+    VISIBLE_ON_EQUAL = True
+
+    # Parameter func_transparent is a function with the sig: boolean func(x, y)
+    # It should return True if the cell is transparent, and False otherwise.
+    #
+    # Returns a set with all (x, y) tuples visible from the centerpoint.
+    def calc_visible_cells_from(self, x_center, y_center, radius, func_transparent):
+        cells = self._visible_cells_in_quadrant_from(x_center, y_center, 1, 1, radius, func_transparent)
+        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, 1, -1, radius, func_transparent))
+        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, -1, -1, radius, func_transparent))
+        cells.update(self._visible_cells_in_quadrant_from(x_center, y_center, -1, 1, radius, func_transparent))
+        cells.add((x_center, y_center))
+        return cells
+
+    # Parameters quad_x, quad_y should only be 1 or -1. The combination of the two determines the quadrant.
+    # Returns a set of (x, y) tuples.
+    def _visible_cells_in_quadrant_from(self, x_center, y_center, quad_x, quad_y, radius, func_transparent):
+        cells = self._visible_cells_in_octant_from(x_center, y_center, quad_x, quad_y, radius, func_transparent, True)
+        cells.update(self._visible_cells_in_octant_from(x_center, y_center, quad_x, quad_y, radius, func_transparent,
+                                                        False))
+        return cells
+
+    # Returns a set of (x, y) typles.
+    # Utilizes the NOT_VISIBLE_BLOCKS_VISION variable.
+    def _visible_cells_in_octant_from(self, x_center, y_center, quad_x, quad_y, radius, func_transparent, is_vertical):
+        iteration = 1
+        visible_cells = set()
+        obstructions = list()
+
+        # End conditions:
+        #   iteration > radius
+        #   Full obstruction coverage (indicated by one object in the obstruction list covering the full angle from 0
+        #      to 1)
+        while iteration <= radius and not (len(obstructions) == 1 and
+                                           obstructions[0].near == 0.0 and obstructions[0].far == 1.0):
+            num_cells_in_row = iteration + 1
+            angle_allocation = 1.0 / float(num_cells_in_row)
+
+            # Start at the center (vertical or horizontal line) and step outwards
+            for step in range(iteration + 1):
+                cell = self._cell_at(x_center, y_center, quad_x, quad_y, step, iteration, is_vertical)
+
+                if self._cell_in_radius(x_center, y_center, cell, radius):
+                    cell_angles = CellAngles(near=(float(step) * angle_allocation),
+                                             center=(float(step + .5) * angle_allocation),
+                                             far=(float(step + 1) * angle_allocation))
+
+                    if self._cell_is_visible(cell_angles, obstructions):
+                        visible_cells.add(cell)
+                        if not func_transparent(cell[0], cell[1]):
+                            obstructions = self._add_obstruction(obstructions, cell_angles)
+                    elif self.NOT_VISIBLE_BLOCKS_VISION:
+                        obstructions = self._add_obstruction(obstructions, cell_angles)
+
+            iteration += 1
+
+        return visible_cells
+
+    # Returns a (x, y) tuple.
+    def _cell_at(self, x_center, y_center, quad_x, quad_y, step, iteration, is_vertical):
+        if is_vertical:
+            cell = (x_center + step * quad_x, y_center + iteration * quad_y)
+        else:
+            cell = (x_center + iteration * quad_x, y_center + step * quad_y)
+        return cell
+
+    # Returns True/False.
+    def _cell_in_radius(self, x_center, y_center, cell, radius):
+        cell_distance = math.sqrt((x_center - cell[0]) * (x_center - cell[0]) +
+                                  (y_center - cell[1]) * (y_center - cell[1]))
+        return cell_distance <= float(radius) + self.RADIUS_FUDGE
+
+    # Returns True/False.
+    # Utilizes the VISIBLE_ON_EQUAL and RESTRICTIVENESS variables.
+    def _cell_is_visible(self, cell_angles, obstructions):
+        near_visible = True
+        center_visible = True
+        far_visible = True
+
+        for obstruction in obstructions:
+            if self.VISIBLE_ON_EQUAL:
+                if obstruction.near < cell_angles.near < obstruction.far:
+                    near_visible = False
+                if obstruction.near < cell_angles.center < obstruction.far:
+                    center_visible = False
+                if obstruction.near < cell_angles.far < obstruction.far:
+                    far_visible = False
+            else:
+                if obstruction.near <= cell_angles.near <= obstruction.far:
+                    near_visible = False
+                if obstruction.near <= cell_angles.center <= obstruction.far:
+                    center_visible = False
+                if obstruction.near <= cell_angles.far <= obstruction.far:
+                    far_visible = False
+
+        if self.RESTRICTIVENESS == 0:
+            return center_visible or near_visible or far_visible
+        elif self.RESTRICTIVENESS == 1:
+            return (center_visible and near_visible) or (center_visible and far_visible)
+        else:
+            return center_visible and near_visible and far_visible
+
+    # Generates a new list by combining all old obstructions with the new one (removing them if they are combined) and
+    # adding the resulting obstruction to the list.
+    #
+    # Returns the generated list.
+    def _add_obstruction(self, obstructions, new_obstruction):
+        new_object = CellAngles(new_obstruction.near, new_obstruction.center, new_obstruction.far)
+        new_list = [o for o in obstructions if not self._combine_obstructions(o, new_object)]
+        new_list.append(new_object)
+        return new_list
+
+    # Returns True if you combine, False otherwise
+    def _combine_obstructions(self, old, new):
+        # Pseudo-sort; if their near values are equal, they overlap
+        if old.near < new.near:
+            low = old
+            high = new
+        elif new.near < old.near:
+            low = new
+            high = old
+        else:
+            new.far = max(old.far, new.far)
+            return True
+
+        # If they overlap, combine and return True
+        if low.far >= high.near:
+            new.near = min(low.near, high.near)
+            new.far = max(low.far, high.far)
+            return True
+        return False
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tabletop.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tabletop.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,522 +1,522 @@
-import operator
-import random
-from abc import ABCMeta, abstractmethod
-
-
-class StandardCard:
-    OMEGA_SYM = ('2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A')
-    OMEGA_SUIT = ('c', 'd', 'h', 's')
-
-    def __init__(self, code):
-        if (not isinstance(code, str)) or len(code) != 2:
-            raise ValueError('please pass a StdCard code to the constructor! Err1')
-        sym, suit = code
-        if suit not in self.OMEGA_SUIT:
-            raise ValueError('StdCard code isnt valid! Err2(suit)')
-        if sym not in self.OMEGA_SYM:
-            raise ValueError('StdCard code isnt valid! Err3(sym)')
-        self._code = code
-
-    @classmethod
-    def all_card_codes(cls):
-        res = list()
-        for sym in cls.OMEGA_SYM:
-            for suit in cls.OMEGA_SUIT:
-                res.append(sym + suit)
-        return res
-
-    @classmethod
-    def at_random(cls, excluded_set=None):
-        if excluded_set is None:
-            excluded_set = set()
-        if len(excluded_set) >= 52:
-            raise ValueError('draw_card Err: excluded_set is too broad!')
-        omega_code0 = set(cls.all_card_codes())
-        omega_code = tuple(omega_code0 - excluded_set)
-        return cls(random.choice(omega_code))
-
-    @property
-    def code(self):
-        return self._code
-
-    @property
-    def rank(self):
-        return self._code[0]
-
-    @property
-    def rank_text(self):
-        x = self._code[0]
-
-        if x == 'J':
-            return 'Jack'
-        elif x == 'Q':
-            return 'Queen'
-        elif x == 'K':
-            return 'King'
-        elif x == 'A':
-            return 'Ace'
-        return {
-            '2': 'Deuce',
-            '3': 'Trey',
-            '4': 'Four',
-            '5': 'Five',
-            '6': 'Six',
-            '7': 'Seven',
-            '8': 'Eight',
-            '9': 'Nine',
-            'T': 'Ten'
-        }[x]
-
-    @property
-    def numeric(self):
-        x = self._code[0]
-        f = {
-            '2': 2,
-            '3': 3,
-            '4': 4,
-            '5': 5,
-            '6': 6,
-            '7': 7,
-            '8': 8,
-            '9': 9,
-            'T': 10,
-            'J': 11,
-            'Q': 12,
-            'K': 13,
-            'A': 14
-        }
-        return f[x]
-
-    @property
-    def suit(self):
-        return self._code[1]
-
-    @property
-    def suit_text(self):
-        return {
-            'c': 'Clubs',
-            'd': 'Diamonds',
-            'h': 'Hearts',
-            's': 'Spades'
-        }[self._code[1]]
-
-    def __str__(self):
-        return self.rank_text + ' of ' + self.suit_text
-
-
-class BaseHandOfCards(metaclass=ABCMeta):
-    def __init__(self):
-        self.content = []
-
-    @property
-    def value(self):
-        return self.compute_value()
-
-    @abstractmethod
-    def compute_value(self):
-        raise NotImplementedError
-
-
-class PokerHand(BaseHandOfCards):
-    """
-    A list of 5 cards + its score
-
-    ranked from highest to lowest we have:
-    < 1> Royal flush: A, K, Q, J, 10, all the same suit
-    < 2> Straight flush: Five cards in a sequence, all in the same suit
-    < 3> Four of a kind: All four cards of the same rank
-    < 4> Full house: Three of a kind with a pair
-    < 5> Flush: Any five cards of the same suit, but not in a sequence
-    < 6> Straight: Five cards in a sequence, but not of the same suit
-    < 7> Three of a kind: Three cards of the same rank
-    < 8> Two pair: Two different pairs
-    < 9> One Pair: Two cards of the same rank
-    <10> High card: When you haven't made any of the hands above
-    """
-
-    def __init__(self, hand):
-        super().__init__()
-        assert len(hand) == 5
-        self.content = hand  # list of cards
-
-    def __str__(self):
-        out = ""
-        for card in self.content:
-            out += str(card) + ", "
-        return out
-
-    def __getitem__(self, index):
-        return self.content[index]
-
-    def __len__(self):
-        return len(self.content)
-
-    def get_highest_num(self):
-        h = 0
-        for card_obj in self.content:
-            if card_obj.numeric > h:
-                h = card_obj.numeric
-        print(h)
-        return h
-
-    def is_royal(self):
-        # the IMPOSSIBLE luck ;)
-        a = self.is_flush()
-        b = self.is_straight()
-        c = self.get_highest_num() == 14
-        print(a, b, c)
-        return a and b and c   # last test= test if ace
-
-    def has_pair1(self):
-        return str(self.value)[0] == '2'
-
-    def has_pair2(self):
-        return str(self.value)[0] == '3'
-
-    def is_trips(self):
-        return str(self.value)[0] == '4'
-
-    def is_four_oak(self):
-        return str(self.value)[0] == '8'
-
-    def is_straight(self):
-        """
-        a hand is a straight if, when sorted, the current card's rank + 1 is the same as the next card
-        """
-        values = list()
-        for card in self.content:
-            values.append(int(PokerHand.adhoc_mapping(card.rank)))
-        values.sort()
-
-        for n in range(0, 4):
-            if values[n] + 1 != values[n+1]:
-                return False
-        return True
-
-    def is_full(self):
-        return str(self.value)[0] == '7'
-
-    def is_flush(self):
-        """a hand is a flush if all the cards are of the same suit
-        """
-        for suit in StandardCard.OMEGA_SUIT:
-            # - debug by tom
-            # print(f'test [{suit}]')
-            # print(f'  [{self.hand[0].suit}]')
-            # print(f'  [{self.hand[1].suit}]')
-            # print(f'  [{self.hand[2].suit}]')
-            # print(f'  [{self.hand[3].suit}]')
-            # print(f'  [{self.hand[4].suit}]')
-            if all((
-                suit == self.content[0].suit,
-                suit == self.content[1].suit,
-                suit == self.content[2].suit,
-                suit == self.content[3].suit,
-                suit == self.content[4].suit
-            )):
-                return True
-        return False
-
-    @staticmethod
-    def adhoc_mapping(xx):
-        tmp = {
-            'T': 10,
-            'J': 11,
-            'Q': 12,
-            'K': 13,
-            'A': 14
-        }
-        if xx in tmp:
-            rez = str(tmp[xx])
-        else:
-            rez = xx.zfill(2)
-        return rez
-
-    @property
-    def description(self):
-        """
-        returns an accurate poker term to describe the current poker hand
-        """
-        score = self.value
-        if str(score)[0] == '1':
-            return "High Card"
-        elif str(score)[0] == '2':
-            return "One Pair"
-        elif str(score)[0] == '3':
-            return "Two Pair"
-        elif str(score)[0] == '4':
-            return "Three of a Kind"
-        elif str(score)[0] == '5':
-            return "Straight"
-        elif str(score)[0] == '6':
-            return "Flush"
-        elif str(score)[0] == '7':
-            return "Full House"
-        elif str(score)[0] == '8':
-            return "Four of a Kind"
-        elif str(score)[0] == '9':
-            return "Straight Flush"
-
-    # redef
-    def compute_value(self):
-        """
-        The first digits represents the type of hand and the rest represent the cards in the hands
-        returns an integer that represents a score given to the hand.
-        """
-        card_count = dict()  # the count of each card rank (we ignore the suit for now)
-        for card_sym in StandardCard.OMEGA_SYM:
-            nsym = self.adhoc_mapping(card_sym)
-            card_count[nsym] = 0
-
-        for card in self.content:
-            nsym = self.adhoc_mapping(card.code[0])
-            card_count[nsym] += 1
-
-        # count number of unique cards
-        unique_count = 0
-        for rankCount in card_count.values():
-            if rankCount > 0:
-                unique_count += 1
-
-        straight = self.is_straight()
-        flush = self.is_flush()
-        points = 0
-
-        if straight and flush:
-            points = max(points, 9)  # straight flush
-        elif flush and not straight:
-            points = max(points, 6)  # flush
-        elif not flush and straight:
-            points = max(points, 5)  # straight
-
-        elif unique_count == 2:
-            if max(card_count.values()) == 4:
-                points = 8  # four of a kind (2 uniques and 4 are the same)
-            elif max(card_count.values()) == 3:
-                points = 7  # full house (2 unique and 3 are the same)
-
-        elif unique_count == 3:
-            if max(card_count.values()) == 3:
-                points = 4  # three of a kind (3 unique and 3 are the same)
-            elif max(card_count.values()) == 2:
-                points = 3  # two pair (3 uniques and 2 are the same)
-
-        elif unique_count == 4:
-            if max(card_count.values()) == 2:
-                points = 2  # one pair (4 uniques and 2 are the same)
-
-        elif unique_count == 5:
-            points = 1  # high card
-
-        # print out the values of the cards in order from greatest to least with 2 digits for each card
-        # in order to generate a point value
-
-        sorted_card_count = sorted(list(card_count.items()), key=operator.itemgetter(1, 0), reverse=True)
-        for keyval in sorted_card_count:
-            if keyval[1] != 0:
-                points = int(str(points) + str(keyval[1] * PokerHand.adhoc_mapping(keyval[0])))
-        return points
-
-
-# ----------------
-#  util function that finds the best possible 5-hand poker hand amongst 7 cards
-# ----------------
-def find_best_ph(possib_cards: list):
-    """
-    returns an instance of PokerHand
-    """
-    assert len(possib_cards) == 7
-    # There are 21 possible 5 card combinations in a deck of 7
-    # for texas hold'em this is a static problem so we can define every possibility below and use the list
-    # to build the algorithm
-    perms = """\
-01234,01235,01236,01245,01246,01256,01345,\
-01346,01356,01456,02345,02346,02356,02456,\
-03456,12345,12346,12356,12456,13456,23456\
-""".split(',')
-    best_ph_sofar = None
-    best_ph_score = None
-
-    for sigma in perms:
-        tmpe = list(sigma)
-        indices = list(map(int, tmpe))  # content CONVERTED to ints
-
-        chosen_cards = list()
-        for i in indices:
-            chosen_cards.append(possib_cards[i])
-        ph = PokerHand(chosen_cards)
-        if (best_ph_sofar is None) or (best_ph_score < ph.value):
-            best_ph_sofar = ph
-            best_ph_score = ph.value
-    return best_ph_sofar
-
-
-class BlackjackHand(BaseHandOfCards):
-    def __init__(self):
-        super().__init__()
-
-    # redefinition
-    def compute_value(self):
-        """ Checks the value of the cards in the player's or dealer's hand. """
-        total_value = 0
-
-        for card in self.content:
-            value = card[1:]
-
-            # Jacks, kings and queens are all worth 10, and ace is worth 11
-            if value == 'j' or value == 'q' or value == 'k':
-                value = 10
-            elif value == 'a':
-                value = 11
-            else:
-                value = int(value)
-
-            total_value += value
-
-        if total_value > 21:
-            for card in self.content:
-                # If the player would bust and he has an ace in his hand, the ace's value is diminished by 10
-                # In situations where there are multiple aces in the hand, this checks to see if the total value
-                # would still be over 21 if the second ace wasn't changed to a value of one.
-                # if it's under 21, there's no need
-                # to change the value of the second ace, so the loop breaks.
-                if card[1] == 'a':
-                    total_value -= 10
-                if total_value <= 21:
-                    break
-        return total_value
-
-
-class CardDeck:
-    """
-    By default this should create a deck which contains all 52 cards and returns it
-    BUT this should be the most GENERIC class,
-
-    > For example what if I need to model 78-card Tarot Deck,
-    if a class for TarotCard is known, this should be easy, etc.
-
-    > Or for example what if I design a new game where 3 jokers are used?
-    """
-
-    def __init__(self):
-        # by default we create a full deck, it contains every single standard card
-        self.content = list()
-        self.reset()
-
-        # if contenu_init is None:
-        #     contenu = ['sj', 'sq', 'sk', 'sa']  # spades
-        #     contenu.extend(['hj', 'hq', 'hk', 'ha'])  # hearts
-        #     contenu.extend(['cj', 'cq', 'ck', 'ca'])  # clubs
-        #     contenu.extend(['dj', 'dq', 'dk', 'da'])  # diamonds
-        #     values = range(2, 11)
-        #     for x in values:
-        #         spades = "s" + str(x)
-        #         hearts = "h" + str(x)
-        #         clubs = "c" + str(x)
-        #         diamonds = "d" + str(x)
-        #         contenu.append(spades)
-        #         contenu.append(hearts)
-        #         contenu.append(clubs)
-        #         contenu.append(diamonds)
-        #     self.contenu = contenu
-        # else:
-        #     self.contenu = contenu_init
-
-    def reset(self):
-        del self.content[:]
-        for c in StandardCard.all_card_codes():
-            self.content.append(StandardCard(c))
-        random.shuffle(self.content)
-
-    def deal(self, n=1):
-        k = self.size
-        if n > k:
-            raise ValueError(f'cannot deal {n} cards! Only {k} are available in deck')
-        res = list()
-        while n > 0:
-            res.append(self.content.pop(0))
-            n -= 1
-        return res
-
-    def __getitem__(self, item):
-        return self.content[item]
-
-    @property
-    def size(self):
-        return len(self.content)
-
-    # anciennement def returnFromDead(self, deadDeck):
-    def recois(self, autre_deck):
-        """ Appends the cards from the deadDeck to the deck that is in play. This is called when the main deck
-        has been emptied. """
-        # équivaut à défausser deadDeck dans le paquet courant
-
-        for card in autre_deck.contenu:
-            self.contenu.append(card)
-        self.shuffle()
-
-        return self.__class__([])
-
-
-    def get_info_card(self, ind):
-        return self.contenu[ind]
-
-    def deck_deal(self, dead_deck):
-        """
-        Shuffles the deck, takes the top 4 cards off the deck,
-        appends them to the player's and dealer's hands, and
-        returns the player's and dealer's hands.
-        """
-        self.shuffle()
-
-        li_dealer_hand, li_player_hand = [], []
-        cards_to_deal = 4
-        deck = self.contenu
-        while cards_to_deal > 0:
-            if len(deck) == 0:
-                dead_deck = self.recois(dead_deck)
-
-            # deal the first card to the player, second to dealer, 3rd to player, 4th to dealer, based on divisibility
-            # (it starts at 4, so it's even first)
-            if cards_to_deal % 2 == 0:
-                li_player_hand.append(deck[0])
-            else:
-                li_dealer_hand.append(deck[0])
-
-            del deck[0]
-            cards_to_deal -= 1
-        cls = self.__class__
-        return dead_deck, cls(li_player_hand), cls(li_dealer_hand)
-
-    def hit(self, dealt_deck, hand):
-        """ Checks to see if the deck is gone, in which case it takes the cards from
-        the dead deck (cards that have been played and discarded)
-        and shuffles them in. Then if the player is hitting, it gives
-        a card to the player, or if the dealer is hitting, gives one to the dealer."""
-
-        # if the deck is empty, shuffle in the dead deck
-        deck = self.contenu
-        if len(deck) == 0:
-            dealt_deck = self.recois(dealt_deck)
-
-        hand.contenu.append(deck[0])
-        del deck[0]
-        return dealt_deck, hand
-
-
-if __name__ == '__main__':
-    d = CardDeck()
-    print(d.size)
-    print(d)
-
-    print(d[0])
-    print(d[1])
-    print(d[2])
-    print('deal 3 cards')
-    tmp = d.deal(3)
-    print('   ', tmp[0])
-    print('   ', tmp[1])
-    print('   ', tmp[2])
-    print(tmp)
-    print(d[0])
-    print(d[13])
+import operator
+import random
+from abc import ABCMeta, abstractmethod
+
+
+class StandardCard:
+    OMEGA_SYM = ('2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A')
+    OMEGA_SUIT = ('c', 'd', 'h', 's')
+
+    def __init__(self, code):
+        if (not isinstance(code, str)) or len(code) != 2:
+            raise ValueError('please pass a StdCard code to the constructor! Err1')
+        sym, suit = code
+        if suit not in self.OMEGA_SUIT:
+            raise ValueError('StdCard code isnt valid! Err2(suit)')
+        if sym not in self.OMEGA_SYM:
+            raise ValueError('StdCard code isnt valid! Err3(sym)')
+        self._code = code
+
+    @classmethod
+    def all_card_codes(cls):
+        res = list()
+        for sym in cls.OMEGA_SYM:
+            for suit in cls.OMEGA_SUIT:
+                res.append(sym + suit)
+        return res
+
+    @classmethod
+    def at_random(cls, excluded_set=None):
+        if excluded_set is None:
+            excluded_set = set()
+        if len(excluded_set) >= 52:
+            raise ValueError('draw_card Err: excluded_set is too broad!')
+        omega_code0 = set(cls.all_card_codes())
+        omega_code = tuple(omega_code0 - excluded_set)
+        return cls(random.choice(omega_code))
+
+    @property
+    def code(self):
+        return self._code
+
+    @property
+    def rank(self):
+        return self._code[0]
+
+    @property
+    def rank_text(self):
+        x = self._code[0]
+
+        if x == 'J':
+            return 'Jack'
+        elif x == 'Q':
+            return 'Queen'
+        elif x == 'K':
+            return 'King'
+        elif x == 'A':
+            return 'Ace'
+        return {
+            '2': 'Deuce',
+            '3': 'Trey',
+            '4': 'Four',
+            '5': 'Five',
+            '6': 'Six',
+            '7': 'Seven',
+            '8': 'Eight',
+            '9': 'Nine',
+            'T': 'Ten'
+        }[x]
+
+    @property
+    def numeric(self):
+        x = self._code[0]
+        f = {
+            '2': 2,
+            '3': 3,
+            '4': 4,
+            '5': 5,
+            '6': 6,
+            '7': 7,
+            '8': 8,
+            '9': 9,
+            'T': 10,
+            'J': 11,
+            'Q': 12,
+            'K': 13,
+            'A': 14
+        }
+        return f[x]
+
+    @property
+    def suit(self):
+        return self._code[1]
+
+    @property
+    def suit_text(self):
+        return {
+            'c': 'Clubs',
+            'd': 'Diamonds',
+            'h': 'Hearts',
+            's': 'Spades'
+        }[self._code[1]]
+
+    def __str__(self):
+        return self.rank_text + ' of ' + self.suit_text
+
+
+class BaseHandOfCards(metaclass=ABCMeta):
+    def __init__(self):
+        self.content = []
+
+    @property
+    def value(self):
+        return self.compute_value()
+
+    @abstractmethod
+    def compute_value(self):
+        raise NotImplementedError
+
+
+class PokerHand(BaseHandOfCards):
+    """
+    A list of 5 cards + its score
+
+    ranked from highest to lowest we have:
+    < 1> Royal flush: A, K, Q, J, 10, all the same suit
+    < 2> Straight flush: Five cards in a sequence, all in the same suit
+    < 3> Four of a kind: All four cards of the same rank
+    < 4> Full house: Three of a kind with a pair
+    < 5> Flush: Any five cards of the same suit, but not in a sequence
+    < 6> Straight: Five cards in a sequence, but not of the same suit
+    < 7> Three of a kind: Three cards of the same rank
+    < 8> Two pair: Two different pairs
+    < 9> One Pair: Two cards of the same rank
+    <10> High card: When you haven't made any of the hands above
+    """
+
+    def __init__(self, hand):
+        super().__init__()
+        assert len(hand) == 5
+        self.content = hand  # list of cards
+
+    def __str__(self):
+        out = ""
+        for card in self.content:
+            out += str(card) + ", "
+        return out
+
+    def __getitem__(self, index):
+        return self.content[index]
+
+    def __len__(self):
+        return len(self.content)
+
+    def get_highest_num(self):
+        h = 0
+        for card_obj in self.content:
+            if card_obj.numeric > h:
+                h = card_obj.numeric
+        print(h)
+        return h
+
+    def is_royal(self):
+        # the IMPOSSIBLE luck ;)
+        a = self.is_flush()
+        b = self.is_straight()
+        c = self.get_highest_num() == 14
+        print(a, b, c)
+        return a and b and c   # last test= test if ace
+
+    def has_pair1(self):
+        return str(self.value)[0] == '2'
+
+    def has_pair2(self):
+        return str(self.value)[0] == '3'
+
+    def is_trips(self):
+        return str(self.value)[0] == '4'
+
+    def is_four_oak(self):
+        return str(self.value)[0] == '8'
+
+    def is_straight(self):
+        """
+        a hand is a straight if, when sorted, the current card's rank + 1 is the same as the next card
+        """
+        values = list()
+        for card in self.content:
+            values.append(int(PokerHand.adhoc_mapping(card.rank)))
+        values.sort()
+
+        for n in range(0, 4):
+            if values[n] + 1 != values[n+1]:
+                return False
+        return True
+
+    def is_full(self):
+        return str(self.value)[0] == '7'
+
+    def is_flush(self):
+        """a hand is a flush if all the cards are of the same suit
+        """
+        for suit in StandardCard.OMEGA_SUIT:
+            # - debug by tom
+            # print(f'test [{suit}]')
+            # print(f'  [{self.hand[0].suit}]')
+            # print(f'  [{self.hand[1].suit}]')
+            # print(f'  [{self.hand[2].suit}]')
+            # print(f'  [{self.hand[3].suit}]')
+            # print(f'  [{self.hand[4].suit}]')
+            if all((
+                suit == self.content[0].suit,
+                suit == self.content[1].suit,
+                suit == self.content[2].suit,
+                suit == self.content[3].suit,
+                suit == self.content[4].suit
+            )):
+                return True
+        return False
+
+    @staticmethod
+    def adhoc_mapping(xx):
+        tmp = {
+            'T': 10,
+            'J': 11,
+            'Q': 12,
+            'K': 13,
+            'A': 14
+        }
+        if xx in tmp:
+            rez = str(tmp[xx])
+        else:
+            rez = xx.zfill(2)
+        return rez
+
+    @property
+    def description(self):
+        """
+        returns an accurate poker term to describe the current poker hand
+        """
+        score = self.value
+        if str(score)[0] == '1':
+            return "High Card"
+        elif str(score)[0] == '2':
+            return "One Pair"
+        elif str(score)[0] == '3':
+            return "Two Pair"
+        elif str(score)[0] == '4':
+            return "Three of a Kind"
+        elif str(score)[0] == '5':
+            return "Straight"
+        elif str(score)[0] == '6':
+            return "Flush"
+        elif str(score)[0] == '7':
+            return "Full House"
+        elif str(score)[0] == '8':
+            return "Four of a Kind"
+        elif str(score)[0] == '9':
+            return "Straight Flush"
+
+    # redef
+    def compute_value(self):
+        """
+        The first digits represents the type of hand and the rest represent the cards in the hands
+        returns an integer that represents a score given to the hand.
+        """
+        card_count = dict()  # the count of each card rank (we ignore the suit for now)
+        for card_sym in StandardCard.OMEGA_SYM:
+            nsym = self.adhoc_mapping(card_sym)
+            card_count[nsym] = 0
+
+        for card in self.content:
+            nsym = self.adhoc_mapping(card.code[0])
+            card_count[nsym] += 1
+
+        # count number of unique cards
+        unique_count = 0
+        for rankCount in card_count.values():
+            if rankCount > 0:
+                unique_count += 1
+
+        straight = self.is_straight()
+        flush = self.is_flush()
+        points = 0
+
+        if straight and flush:
+            points = max(points, 9)  # straight flush
+        elif flush and not straight:
+            points = max(points, 6)  # flush
+        elif not flush and straight:
+            points = max(points, 5)  # straight
+
+        elif unique_count == 2:
+            if max(card_count.values()) == 4:
+                points = 8  # four of a kind (2 uniques and 4 are the same)
+            elif max(card_count.values()) == 3:
+                points = 7  # full house (2 unique and 3 are the same)
+
+        elif unique_count == 3:
+            if max(card_count.values()) == 3:
+                points = 4  # three of a kind (3 unique and 3 are the same)
+            elif max(card_count.values()) == 2:
+                points = 3  # two pair (3 uniques and 2 are the same)
+
+        elif unique_count == 4:
+            if max(card_count.values()) == 2:
+                points = 2  # one pair (4 uniques and 2 are the same)
+
+        elif unique_count == 5:
+            points = 1  # high card
+
+        # print out the values of the cards in order from greatest to least with 2 digits for each card
+        # in order to generate a point value
+
+        sorted_card_count = sorted(list(card_count.items()), key=operator.itemgetter(1, 0), reverse=True)
+        for keyval in sorted_card_count:
+            if keyval[1] != 0:
+                points = int(str(points) + str(keyval[1] * PokerHand.adhoc_mapping(keyval[0])))
+        return points
+
+
+# ----------------
+#  util function that finds the best possible 5-hand poker hand amongst 7 cards
+# ----------------
+def find_best_ph(possib_cards: list):
+    """
+    returns an instance of PokerHand
+    """
+    assert len(possib_cards) == 7
+    # There are 21 possible 5 card combinations in a deck of 7
+    # for texas hold'em this is a static problem so we can define every possibility below and use the list
+    # to build the algorithm
+    perms = """\
+01234,01235,01236,01245,01246,01256,01345,\
+01346,01356,01456,02345,02346,02356,02456,\
+03456,12345,12346,12356,12456,13456,23456\
+""".split(',')
+    best_ph_sofar = None
+    best_ph_score = None
+
+    for sigma in perms:
+        tmpe = list(sigma)
+        indices = list(map(int, tmpe))  # content CONVERTED to ints
+
+        chosen_cards = list()
+        for i in indices:
+            chosen_cards.append(possib_cards[i])
+        ph = PokerHand(chosen_cards)
+        if (best_ph_sofar is None) or (best_ph_score < ph.value):
+            best_ph_sofar = ph
+            best_ph_score = ph.value
+    return best_ph_sofar
+
+
+class BlackjackHand(BaseHandOfCards):
+    def __init__(self):
+        super().__init__()
+
+    # redefinition
+    def compute_value(self):
+        """ Checks the value of the cards in the player's or dealer's hand. """
+        total_value = 0
+
+        for card in self.content:
+            value = card[1:]
+
+            # Jacks, kings and queens are all worth 10, and ace is worth 11
+            if value == 'j' or value == 'q' or value == 'k':
+                value = 10
+            elif value == 'a':
+                value = 11
+            else:
+                value = int(value)
+
+            total_value += value
+
+        if total_value > 21:
+            for card in self.content:
+                # If the player would bust and he has an ace in his hand, the ace's value is diminished by 10
+                # In situations where there are multiple aces in the hand, this checks to see if the total value
+                # would still be over 21 if the second ace wasn't changed to a value of one.
+                # if it's under 21, there's no need
+                # to change the value of the second ace, so the loop breaks.
+                if card[1] == 'a':
+                    total_value -= 10
+                if total_value <= 21:
+                    break
+        return total_value
+
+
+class CardDeck:
+    """
+    By default this should create a deck which contains all 52 cards and returns it
+    BUT this should be the most GENERIC class,
+
+    > For example what if I need to model 78-card Tarot Deck,
+    if a class for TarotCard is known, this should be easy, etc.
+
+    > Or for example what if I design a new game where 3 jokers are used?
+    """
+
+    def __init__(self):
+        # by default we create a full deck, it contains every single standard card
+        self.content = list()
+        self.reset()
+
+        # if contenu_init is None:
+        #     contenu = ['sj', 'sq', 'sk', 'sa']  # spades
+        #     contenu.extend(['hj', 'hq', 'hk', 'ha'])  # hearts
+        #     contenu.extend(['cj', 'cq', 'ck', 'ca'])  # clubs
+        #     contenu.extend(['dj', 'dq', 'dk', 'da'])  # diamonds
+        #     values = range(2, 11)
+        #     for x in values:
+        #         spades = "s" + str(x)
+        #         hearts = "h" + str(x)
+        #         clubs = "c" + str(x)
+        #         diamonds = "d" + str(x)
+        #         contenu.append(spades)
+        #         contenu.append(hearts)
+        #         contenu.append(clubs)
+        #         contenu.append(diamonds)
+        #     self.contenu = contenu
+        # else:
+        #     self.contenu = contenu_init
+
+    def reset(self):
+        del self.content[:]
+        for c in StandardCard.all_card_codes():
+            self.content.append(StandardCard(c))
+        random.shuffle(self.content)
+
+    def deal(self, n=1):
+        k = self.size
+        if n > k:
+            raise ValueError(f'cannot deal {n} cards! Only {k} are available in deck')
+        res = list()
+        while n > 0:
+            res.append(self.content.pop(0))
+            n -= 1
+        return res
+
+    def __getitem__(self, item):
+        return self.content[item]
+
+    @property
+    def size(self):
+        return len(self.content)
+
+    # anciennement def returnFromDead(self, deadDeck):
+    def recois(self, autre_deck):
+        """ Appends the cards from the deadDeck to the deck that is in play. This is called when the main deck
+        has been emptied. """
+        # équivaut à défausser deadDeck dans le paquet courant
+
+        for card in autre_deck.contenu:
+            self.contenu.append(card)
+        self.shuffle()
+
+        return self.__class__([])
+
+
+    def get_info_card(self, ind):
+        return self.contenu[ind]
+
+    def deck_deal(self, dead_deck):
+        """
+        Shuffles the deck, takes the top 4 cards off the deck,
+        appends them to the player's and dealer's hands, and
+        returns the player's and dealer's hands.
+        """
+        self.shuffle()
+
+        li_dealer_hand, li_player_hand = [], []
+        cards_to_deal = 4
+        deck = self.contenu
+        while cards_to_deal > 0:
+            if len(deck) == 0:
+                dead_deck = self.recois(dead_deck)
+
+            # deal the first card to the player, second to dealer, 3rd to player, 4th to dealer, based on divisibility
+            # (it starts at 4, so it's even first)
+            if cards_to_deal % 2 == 0:
+                li_player_hand.append(deck[0])
+            else:
+                li_dealer_hand.append(deck[0])
+
+            del deck[0]
+            cards_to_deal -= 1
+        cls = self.__class__
+        return dead_deck, cls(li_player_hand), cls(li_dealer_hand)
+
+    def hit(self, dealt_deck, hand):
+        """ Checks to see if the deck is gone, in which case it takes the cards from
+        the dead deck (cards that have been played and discarded)
+        and shuffles them in. Then if the player is hitting, it gives
+        a card to the player, or if the dealer is hitting, gives one to the dealer."""
+
+        # if the deck is empty, shuffle in the dead deck
+        deck = self.contenu
+        if len(deck) == 0:
+            dealt_deck = self.recois(dealt_deck)
+
+        hand.contenu.append(deck[0])
+        del deck[0]
+        return dealt_deck, hand
+
+
+if __name__ == '__main__':
+    d = CardDeck()
+    print(d.size)
+    print(d)
+
+    print(d[0])
+    print(d[1])
+    print(d[2])
+    print('deal 3 cards')
+    tmp = d.deal(3)
+    print('   ', tmp[0])
+    print('   ', tmp[1])
+    print('   ', tmp[2])
+    print(tmp)
+    print(d[0])
+    print(d[13])
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/data.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/data.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,761 +1,761 @@
-from ... import _hub
-
-# TODO model refactoring: use matrices as building blocks,
-# it will save some effort (Cell, CellLayer etc.)
-
-# decompress ; b64decode ; struct... Sont tous 3
-# employés dans Layer.fromxml
-# TODO check if its katasdk -compatible?
-from zlib import decompress
-from base64 import b64decode
-import struct
-
-# ElemenTree est employé en 2 endroits: dans Tileset.fromxml & Tilemap.load
-# this works in local ctx:
-# from xml.etree import ElementTree
-from xml.etree import ElementTree
-
-
-def load_tmx(filename):
-    return TileMap.load(filename)
-
-
-class Cell:
-    """
-    Layers are made of Cells (or empty space).
-    Cells have some basic properties:
-
-    x, y - the cell's index in the layer
-    px, py - the cell's pixel position
-    left, right, top, bottom - the cell's pixel boundaries
-
-    Additionally the cell may have other properties which are accessed using
-    standard dictionary methods:
-
-    cell['property name']
-
-    You may assign a new value for a property to or even delete an existing
-    property from the cell - this will not affect the Tile or any other Cells
-    using the Cell's Tile.
-    """
-
-    def __init__(self, x, y, px, py, tile):
-        self.x, self.y = x, y
-        self.px, self.py = px, py
-        self.tile = tile
-        self.topleft = (px, py)
-        self.left = px
-        self.right = px + tile.tile_width
-        self.top = py
-        self.bottom = py + tile.tile_height
-        self.center = (px + tile.tile_width // 2, py + tile.tile_height // 2)
-        self._added_properties = {}
-        self._deleted_properties = set()
-
-    def __repr__(self):
-        return '<Cell %s,%s %d>' % (self.px, self.py, self.tile.gid)
-
-    def __contains__(self, key):
-        if key in self._deleted_properties:
-            return False
-        return key in self._added_properties or key in self.tile.properties
-
-    def __getitem__(self, key):
-        if key in self._deleted_properties:
-            raise KeyError(key)
-        if key in self._added_properties:
-            return self._added_properties[key]
-        if key in self.tile.properties:
-            return self.tile.properties[key]
-        raise KeyError(key)
-
-    def __setitem__(self, key, value):
-        self._added_properties[key] = value
-
-    def __delitem__(self, key):
-        self._deleted_properties.add(key)
-
-    def intersects(self, other):
-        """
-        Determine whether this Cell intersects with the other rect (which has
-        .x, .y, .width and .height attributes.)
-        """
-        if self.px + self.tile.tile_width < other.x:
-            return False
-        if other.x + other.width - 1 < self.px:
-            return False
-        if self.py + self.tile.tile_height < other.y:
-            return False
-        if other.y + other.height - 1 < self.py:
-            return False
-        return True
-
-
-class LayerIterator(object):
-    """
-    Iterates over all the cells in a layer in column,row order.
-    """
-
-    def __init__(self, layer):
-        self.layer = layer
-        self.i, self.j = 0, 0
-
-    def __next__(self):
-        if self.i == self.layer.width - 1:
-            self.j += 1
-            self.i = 0
-        if self.j == self.layer.height - 1:
-            raise StopIteration()
-        value = self.layer[self.i, self.j]
-        self.i += 1
-        return value
-
-
-# TODO faut sortir draw
-class ObjectTmx:
-    """An object in a TMX object layer.
-    name: The name of the object. An arbitrary string.
-    type: The type of the object. An arbitrary string.
-    x: The x coordinate of the object in pixels.
-    y: The y coordinate of the object in pixels.
-    width: The width of the object in pixels (defaults to 0).
-    height: The height of the object in pixels (defaults to 0).
-    gid: An reference to a tile (optional).
-    visible: Whether the object is shown (1) or hidden (0). Defaults to 1.
-    """
-
-    def __init__(self, type, x, y, width=0, height=0, name=None,
-                 gid=None, tile=None, visible=1):
-        self.type = type
-        self.px = x
-        self.left = x
-        if tile:
-            y -= tile.tile_height
-            width = tile.tile_width
-            height = tile.tile_height
-        self.py = y
-        self.top = y
-        self.width = width
-        self.right = x + width
-        self.height = height
-        self.bottom = y + height
-        self.name = name
-        self.gid = gid
-        self.tile = tile
-        self.visible = visible
-        self.properties = {}
-
-        self._added_properties = {}
-        self._deleted_properties = set()
-        self.pyg = _hub.pygame
-
-    def __repr__(self):
-        if self.tile:
-            return '<Object %s,%s %s,%s tile=%d>' % (self.px, self.py, self.width, self.height, self.gid)
-        else:
-            return '<Object %s,%s %s,%s>' % (self.px, self.py, self.width, self.height)
-
-    def __contains__(self, key):
-        if key in self._deleted_properties:
-            return False
-        if key in self._added_properties:
-            return True
-        if key in self.properties:
-            return True
-        return self.tile and key in self.tile.properties
-
-    def __getitem__(self, key):
-        if key in self._deleted_properties:
-            raise KeyError(key)
-        if key in self._added_properties:
-            return self._added_properties[key]
-        if key in self.properties:
-            return self.properties[key]
-        if self.tile and key in self.tile.properties:
-            return self.tile.properties[key]
-        raise KeyError(key)
-
-    def __setitem__(self, key, value):
-        self._added_properties[key] = value
-
-    def __delitem__(self, key):
-        self._deleted_properties.add(key)
-
-    def draw(self, surface, view_x, view_y):
-        if self.visible:
-            x, y = (self.px - view_x, self.py - view_y)
-            if self.tile:
-                surface.blit(self.tile.surface, (x, y))
-            else:
-                r = self.pyg.Rect((x, y), (self.width, self.height))
-                self.pyg.draw.rect(surface, (255, 100, 100), r, 2)
-
-    @classmethod
-    def fromxml(cls, tag, map):
-        if 'gid' in tag.attrib:
-            gid = int(tag.attrib['gid'])
-            tile = map.tilesets[gid]
-            w = tile.tile_width
-            h = tile.tile_height
-        else:
-            gid = None
-            tile = None
-            w = round(float(tag.attrib['width']))
-            h = round(float(tag.attrib['height']))
-
-        x_attr, y_attr = round(float(tag.attrib['x'])), round(float(tag.attrib['y']))
-        o = cls(
-            tag.attrib.get('type', 'rect'),
-            x_attr, y_attr, w, h, tag.attrib.get('name'), gid, tile,
-            int(tag.attrib.get('visible', 1))
-        )
-
-        props = tag.find('properties')
-        if props is None:
-            return o
-
-        for c in props.findall('property'):
-            # store additional properties.
-            name = c.attrib['name']
-            value = c.attrib['value']
-
-            # TODO hax
-            if value.isdigit():
-                value = int(value)
-            o.properties[name] = value
-        return o
-
-    def intersects(self, x1, y1, x2, y2):
-        return not any((x2 < self.px, y2 < self.py, x1 > self.px + self.width, y1 > self.py + self.height))
-
-
-# TODO la aussi, deux methodes de dessin a evacuer!
-class ObjectLayer:
-    """
-    A layer composed of basic primitive shapes.
-    Actually encompasses a TMX <objectgroup> but even the TMX documentation
-    refers to them as object layers, so I will.
-
-    ObjectLayers have some basic properties:
-
-        position - ignored (cannot be edited in the current Tiled editor)
-        name - the name of the object group.
-        color - the color used to display the objects in this group.
-        opacity - the opacity of the layer as a value from 0 to 1.
-        visible - whether the layer is shown (1) or hidden (0).
-        objects - the objects in this Layer (Object instances)
-    """
-
-    def __init__(self, name, color, objects, opacity=1,
-                 visible=1, position=(0, 0)):
-        self.name = name
-        self.color = color
-        self.objects = objects
-        self.opacity = opacity
-        self.visible = visible
-        self.position = position
-        self.properties = {}
-
-    def __repr__(self):
-        return '<ObjectLayer "%s" at 0x%x>' % (self.name, id(self))
-
-    @classmethod
-    def fromxml(cls, tag, map):
-        layer = cls(tag.attrib['name'], tag.attrib.get('color'), [],
-                    float(tag.attrib.get('opacity', 1)),
-                    int(tag.attrib.get('visible', 1)))
-        for object in tag.findall('object'):
-            layer.objects.append(ObjectTmx.fromxml(object, map))
-        for c in tag.findall('property'):
-            # store additional properties.
-            name = c.attrib['name']
-            value = c.attrib['value']
-
-            # TODO hax
-            if value.isdigit():
-                value = int(value)
-            layer.properties[name] = value
-        return layer
-
-    def update(self, dt, *args):
-        pass
-
-    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
-        self.view_x, self.view_y = x, y
-        self.view_w, self.view_h = w, h
-        x -= viewport_ox
-        y -= viewport_oy
-        self.position = (x, y)
-
-    def draw(self, surface):
-        """
-        Draw this layer, limited to the current viewport, to the Surface.
-        """
-        if not self.visible:
-            return
-        ox, oy = self.position
-        w, h = self.view_w, self.view_h
-        for myobj in self.objects:
-            myobj.draw(surface, self.view_x, self.view_y)
-
-    def find(self, *properties):
-        """
-        Find all cells with the given properties set.
-        """
-        r = []
-        for propname in properties:
-            for myobj in self.objects:
-                if myobj and propname in myobj or propname in self.properties:
-                    r.append(myobj)
-        return r
-
-    def match(self, **properties):
-        """
-        Find all objects with the given properties set to the given values.
-        """
-        r = []
-        for propname in properties:
-            for myobj in self.objects:
-                if propname in myobj:
-                    val = myobj[propname]
-                elif propname in self.properties:
-                    val = self.properties[propname]
-                else:
-                    continue
-                if properties[propname] == val:
-                    r.append(myobj)
-        return r
-
-    def collide(self, rect, propname):
-        """
-        Find all objects the rect is touching that have the indicated
-        property name set.
-        """
-        r = []
-        for myobj in self.get_in_region(rect.left, rect.top, rect.right, rect.bottom):
-            if propname in myobj or propname in self.properties:
-                r.append(myobj)
-        return r
-
-    def get_in_region(self, x1, y1, x2, y2):
-        """
-        Return objects that are within the map-space
-        pixel bounds specified by the bottom-left (x1, y1) and top-right
-        (x2, y2) corners.
-
-        Return a list of Object instances.
-        """
-        return [obj for obj in self.objects if obj.intersects(x1, y1, x2, y2)]
-
-    def get_at(self, x, y):
-        """
-        Return the first object found at the nominated (x, y) coordinate.
-        Return an Object instance or None.
-        """
-        for myobj in self.objects:
-            if myobj.contains(x, y):
-                return myobj
-
-
-# TODO y a deux methodes a evacuer c'est set_view(...) et draw(...)
-class Layer:
-    """
-    A 2d grid of Cells.
-
-    Layers have some basic properties:
-
-        width, height - the dimensions of the Layer in cells
-        tile_width, tile_height - the dimensions of each cell
-        px_width, px_height - the dimensions of the Layer in pixels
-        tilesets - the tilesets used in this Layer (a Tilesets instance)
-        properties - any properties set for this Layer
-        cells - a dict of all the Cell instances for this Layer, keyed off
-                (x, y) index.
-
-    Additionally you may look up a cell using direct item access:
-
-       layer[x, y] is layer.cells[x, y]
-
-    Note that empty cells will be set to None instead of a Cell instance.
-    """
-
-    def __init__(self, name, visible, map):
-        self.name = name
-        self.visible = visible
-        self.position = (0, 0)
-        # TODO get from TMX?
-        self.px_width = map.px_width
-        self.px_height = map.px_height
-        self.tile_width = map.tile_width
-        self.tile_height = map.tile_height
-        self.width = map.width
-        self.height = map.height
-        self.tilesets = map.tilesets
-        self.group = _hub.pygame.sprite.Group()
-        self.properties = {}
-        self.cells = {}
-
-    def __repr__(self):
-        return '<Layer "%s" at 0x%x>' % (self.name, id(self))
-
-    def __getitem__(self, pos):
-        return self.cells.get(pos)
-
-    def __setitem__(self, pos, tile):
-        x, y = pos
-        px = x * self.tile_width
-        py = y * self.tile_width
-        self.cells[pos] = Cell(x, y, px, py, tile)
-
-    def __iter__(self):
-        return LayerIterator(self)
-
-    @classmethod
-    def fromxml(cls, tag, givenmap):
-        layer = cls(tag.attrib['name'], int(tag.attrib.get('visible', 1)), givenmap)
-
-        data = tag.find('data')
-        if data is None:
-            raise ValueError('layer %s does not contain <data>' % layer.name)
-
-        data = data.text.strip()
-        data = data.encode()  # Convert to bytes
-        # Decode from base 64 and decompress via zlib
-        data = decompress(b64decode(data))
-        data = struct.unpack('<%di' % (len(data) / 4,), data)
-        assert len(data) == layer.width * layer.height
-        for idx, gid in enumerate(data):
-            if gid >= 1:  # otherwise its not set
-                tile = givenmap.tilesets[gid]
-                x = idx % layer.width
-                y = idx // layer.width
-                layer.cells[x, y] = Cell(x, y, x * givenmap.tile_width, y * givenmap.tile_height, tile)
-
-        return layer
-
-    def update(self, dt, *args):
-        pass
-
-    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
-        self.view_x, self.view_y = x, y
-        self.view_w, self.view_h = w, h
-        x -= viewport_ox
-        y -= viewport_oy
-        self.position = (x, y)
-
-    def draw(self, surface):
-        """
-        Draw this layer, limited to the current viewport, to the Surface.
-        """
-        ox, oy = self.position
-        w, h = self.view_w, self.view_h
-        for x in range(ox, ox + w + self.tile_width, self.tile_width):
-            i = x // self.tile_width
-            for y in range(oy, oy + h + self.tile_height, self.tile_height):
-                j = y // self.tile_height
-                if (i, j) not in self.cells:
-                    continue
-                cell = self.cells[i, j]
-                surface.blit(cell.tile.surface, (cell.px - ox, cell.py - oy))
-
-    def find(self, *properties):
-        """
-        Find all cells with the given properties set.
-        """
-        r = []
-        for propname in properties:
-            for cell in list(self.cells.values()):
-                if cell and propname in cell:
-                    r.append(cell)
-        return r
-
-    def match(self, **properties):
-        """
-        Find all cells with the given properties set to the given values.
-        """
-        r = []
-        for propname in properties:
-            for cell in list(self.cells.values()):
-                if propname not in cell:
-                    continue
-                if properties[propname] == cell[propname]:
-                    r.append(cell)
-        return r
-
-    def collide(self, rect, propname):
-        """
-        Find all cells the rect is touching that have the indicated property
-        name set.
-        """
-        r = []
-        for cell in self.get_in_region(rect.left, rect.top, rect.right,
-                                       rect.bottom):
-            if not cell.intersects(rect):
-                continue
-            if propname in cell:
-                r.append(cell)
-        return r
-
-    def get_in_region(self, x1, y1, x2, y2):
-        """
-        Return cells (in [column][row]) that are within the map-space
-        pixel bounds specified by the bottom-left (x1, y1) and top-right
-        (x2, y2) corners.
-        Return a list of Cell instances.
-        """
-        i1 = max(0, x1 // self.tile_width)
-        j1 = max(0, y1 // self.tile_height)
-        i2 = min(self.width, x2 // self.tile_width + 1)
-        j2 = min(self.height, y2 // self.tile_height + 1)
-        return [self.cells[i, j]
-                for i in range(int(i1), int(i2))
-                for j in range(int(j1), int(j2))
-                if (i, j) in self.cells]
-
-    def get_at(self, x, y):
-        """
-        Return the cell at the nominated (x, y) coordinate.
-        Return a Cell instance or None.
-        """
-        i = x // self.tile_width
-        j = y // self.tile_height
-        return self.cells.get((i, j))
-
-    def neighbors(self, index):
-        """
-        Return the indexes of the valid (ie. within the map) cardinal (ie.
-        North, South, East, West) neighbors of the nominated cell index.
-        Returns a list of 2-tuple indexes.
-        """
-        i, j = index
-        n = []
-        if i < self.width - 1:
-            n.append((i + 1, j))
-        if i > 0:
-            n.append((i - 1, j))
-        if j < self.height - 1:
-            n.append((i, j + 1))
-        if j > 0:
-            n.append((i, j - 1))
-        return n
-
-
-class Tile:
-
-    def __init__(self, gid, surface, tileset):
-        self.gid = gid
-        self.surface = surface
-        self.tile_width = tileset.tile_width
-        self.tile_height = tileset.tile_height
-        self.properties = {}
-
-    @classmethod
-    def fromSurface(cls, surface):
-        """
-        Create a new Tile object straight from a pygame Surface.
-        Its tile_width and tile_height will be set using the Surface dimensions.
-        Its gid will be 0.
-        """
-        class ts:
-            tile_width, tile_height = surface.get_size()
-
-        return cls(0, surface, ts)
-
-    def loadxml(self, tag):
-        props = tag.find('properties')
-        if props is None:
-            return
-        for c in props.findall('property'):
-            # store additional properties.
-            name = c.attrib['name']
-            value = c.attrib['value']
-
-            # TODO hax
-            if value.isdigit():
-                value = int(value)
-            self.properties[name] = value
-
-    def __repr__(self):
-        return '<Tile %d>' % self.gid
-
-
-class Tileset:
-    """
-    (mm si l'on charge des img pygame ca reste du modele car on fetch les donnees depuis
-    une telle instance...)
-    """
-
-    def __init__(self, name, tile_width, tile_height, firstgid):
-        self.name = name
-        self.tile_width = tile_width
-        self.tile_height = tile_height
-        self.firstgid = firstgid
-        self.tiles = []
-        self.properties = {}
-
-    def add_image(self, file):
-        image = _hub.pygame.image.load(file).convert_alpha()
-        if not image:
-            print("Error creating new Tileset: file %s not found" % file)
-            raise FileNotFoundError
-
-        ident = self.firstgid
-        tile_w, tile_h = self.tile_width, self.tile_height
-        for line in range(image.get_height() // tile_h):
-            for column in range(image.get_width() // tile_w):
-                pos = _hub.pygame.Rect(column * tile_w, line * tile_h, tile_w, tile_h)
-                self.tiles.append(Tile(ident, image.subsurface(pos), self))
-                ident += 1
-
-    def get_tile(self, gid):
-        return self.tiles[gid - self.firstgid]
-
-    @classmethod
-    def fromxml(cls, tag, firstgid=None, hacksource=None, hacktileset=None):
-        print('fromxml ')
-        if 'source' in tag.attrib:
-            firstgid = int(tag.attrib['firstgid'])
-            if hacksource:
-                srcc = hacksource
-            else:
-                srcc = tag.attrib['source']
-
-            with open(srcc) as f:
-                print('opened ', srcc)
-                tileset = ElementTree.fromstring(f.read())
-
-            return cls.fromxml(tileset, firstgid, hacktileset=hacktileset)
-
-        name = tag.attrib['name']
-        if firstgid is None:
-            firstgid = int(tag.attrib['firstgid'])
-        tile_width = int(tag.attrib['tilewidth'])
-        tile_height = int(tag.attrib['tileheight'])
-
-        tileset = cls(name, tile_width, tile_height, firstgid)
-
-        for c in tag:  # .getchildren():
-            if c.tag == "image":
-                # create a tileset
-                arg_sheet = c.attrib['source'] if (hacktileset is None) else hacktileset
-                tileset.add_image(arg_sheet)
-            elif c.tag == 'tile':
-                gid = tileset.firstgid + int(c.attrib['id'])
-                tileset.get_tile(gid).loadxml(c)
-        return tileset
-
-
-class Tilesets(dict):
-    def add(self, tileset):
-        for idx, tile in enumerate(tileset.tiles):
-            idx += tileset.firstgid
-            self[idx] = tile
-
-
-class Layers(list):
-    def __init__(self):
-        self.by_name = {}
-
-    def add_named(self, layer, name):
-        self.append(layer)
-        self.by_name[name] = layer
-
-    def __getitem__(self, item):
-        if isinstance(item, int):
-            return self[item]
-        return self.by_name[item]
-
-
-class TileMap:
-    """
-    A TileMap is a collection of Layers which contain gridded maps or sprites
-    TileMaps are loaded from TMX files which sets the .layers and .tilesets properties
-
-    After loading, additional SpriteLayers may be added.
-
-    A TileMap's rendering is restricted by a viewport which is defined by the
-    size passed in at construction time and the focus set by set_focus() or
-    force_focus().
-
-    TileMaps have a number of properties:
-
-        width, height - the dimensions of the tilemap in cells
-
-        tile_width, tile_height - the dimensions of the cells in the map
-        px_width, px_height - the dimensions of the tilemap in pixels
-        properties - any properties set on the tilemap in the TMX file
-        layers - all layers of this tilemap as a Layers instance
-        tilesets - all tilesets of this tilemap as a Tilesets instance
-
-    """
-
-    def __init__(self):
-        self.px_width = 0
-        self.px_height = 0
-        self.tile_width = 0
-        self.tile_height = 0
-        self.width = 0
-        self.height = 0
-        self.properties = {}
-        self.layers = Layers()
-        self.tilesets = Tilesets()
-
-    @property
-    def pix_width(self):
-        return self.px_width
-
-    @property
-    def pix_height(self):
-        return self.px_height
-
-    def update(self, dt, *args):
-        for layer in self.layers:
-            layer.update(dt, *args)
-
-    @classmethod
-    def load(cls, filename, hack_tsxfile=None, hack_ts=None):
-        with open(filename) as f:
-            tminfo_tree = ElementTree.fromstring(f.read())
-
-        # get most general map informations and create a surface
-        tilemap = TileMap()
-
-        tilemap.width = int(tminfo_tree.attrib['width'])
-        tilemap.height = int(tminfo_tree.attrib['height'])
-        tilemap.tile_width = int(tminfo_tree.attrib['tilewidth'])
-        tilemap.tile_height = int(tminfo_tree.attrib['tileheight'])
-        tilemap.px_width = tilemap.width * tilemap.tile_width
-        tilemap.px_height = tilemap.height * tilemap.tile_height
-
-        for tag in tminfo_tree.findall('tileset'):
-            tilemap.tilesets.add(
-                Tileset.fromxml(tag, hacksource=hack_tsxfile, hacktileset=hack_ts)  # hacks work only if no more than 1 ts
-            )
-            print('tilesets added')
-
-        for tag in tminfo_tree.findall('layer'):
-            layer = Layer.fromxml(tag, tilemap)
-            tilemap.layers.add_named(layer, layer.name)
-
-        for tag in tminfo_tree.findall('objectgroup'):
-            layer = ObjectLayer.fromxml(tag, tilemap)
-            tilemap.layers.add_named(layer, layer.name)
-
-        # We wanna persist info about the (optional) Image layer found in .tmx
-        # TODO add to kengi a class that modelize ImageLayer?
-        tagraw_ilayer_li = tminfo_tree.findall('imagelayer')
-        if len(tagraw_ilayer_li) == 1:
-            tagraw_ilayer = tagraw_ilayer_li.pop()
-            subnode = tagraw_ilayer.find('image')
-            tilemap.background = {  # persist info in tilemap_obj.background
-                'img_path': subnode.attrib['source'],
-                'offsetx': round(float(tagraw_ilayer.attrib['offsetx'])),
-                'offsety': round(float(tagraw_ilayer.attrib['offsety'])),
-                'repeatx': int(tagraw_ilayer.attrib['repeatx'])  # 0 or 1
-            }
-        elif len(tagraw_ilayer_li) > 1:
-            raise NotImplementedError
-        else:
-            tilemap.background = None
-
-        return tilemap
+from ... import _hub
+
+# TODO model refactoring: use matrices as building blocks,
+# it will save some effort (Cell, CellLayer etc.)
+
+# decompress ; b64decode ; struct... Sont tous 3
+# employés dans Layer.fromxml
+# TODO check if its katasdk -compatible?
+from zlib import decompress
+from base64 import b64decode
+import struct
+
+# ElemenTree est employé en 2 endroits: dans Tileset.fromxml & Tilemap.load
+# this works in local ctx:
+# from xml.etree import ElementTree
+from xml.etree import ElementTree
+
+
+def load_tmx(filename):
+    return TileMap.load(filename)
+
+
+class Cell:
+    """
+    Layers are made of Cells (or empty space).
+    Cells have some basic properties:
+
+    x, y - the cell's index in the layer
+    px, py - the cell's pixel position
+    left, right, top, bottom - the cell's pixel boundaries
+
+    Additionally the cell may have other properties which are accessed using
+    standard dictionary methods:
+
+    cell['property name']
+
+    You may assign a new value for a property to or even delete an existing
+    property from the cell - this will not affect the Tile or any other Cells
+    using the Cell's Tile.
+    """
+
+    def __init__(self, x, y, px, py, tile):
+        self.x, self.y = x, y
+        self.px, self.py = px, py
+        self.tile = tile
+        self.topleft = (px, py)
+        self.left = px
+        self.right = px + tile.tile_width
+        self.top = py
+        self.bottom = py + tile.tile_height
+        self.center = (px + tile.tile_width // 2, py + tile.tile_height // 2)
+        self._added_properties = {}
+        self._deleted_properties = set()
+
+    def __repr__(self):
+        return '<Cell %s,%s %d>' % (self.px, self.py, self.tile.gid)
+
+    def __contains__(self, key):
+        if key in self._deleted_properties:
+            return False
+        return key in self._added_properties or key in self.tile.properties
+
+    def __getitem__(self, key):
+        if key in self._deleted_properties:
+            raise KeyError(key)
+        if key in self._added_properties:
+            return self._added_properties[key]
+        if key in self.tile.properties:
+            return self.tile.properties[key]
+        raise KeyError(key)
+
+    def __setitem__(self, key, value):
+        self._added_properties[key] = value
+
+    def __delitem__(self, key):
+        self._deleted_properties.add(key)
+
+    def intersects(self, other):
+        """
+        Determine whether this Cell intersects with the other rect (which has
+        .x, .y, .width and .height attributes.)
+        """
+        if self.px + self.tile.tile_width < other.x:
+            return False
+        if other.x + other.width - 1 < self.px:
+            return False
+        if self.py + self.tile.tile_height < other.y:
+            return False
+        if other.y + other.height - 1 < self.py:
+            return False
+        return True
+
+
+class LayerIterator(object):
+    """
+    Iterates over all the cells in a layer in column,row order.
+    """
+
+    def __init__(self, layer):
+        self.layer = layer
+        self.i, self.j = 0, 0
+
+    def __next__(self):
+        if self.i == self.layer.width - 1:
+            self.j += 1
+            self.i = 0
+        if self.j == self.layer.height - 1:
+            raise StopIteration()
+        value = self.layer[self.i, self.j]
+        self.i += 1
+        return value
+
+
+# TODO faut sortir draw
+class ObjectTmx:
+    """An object in a TMX object layer.
+    name: The name of the object. An arbitrary string.
+    type: The type of the object. An arbitrary string.
+    x: The x coordinate of the object in pixels.
+    y: The y coordinate of the object in pixels.
+    width: The width of the object in pixels (defaults to 0).
+    height: The height of the object in pixels (defaults to 0).
+    gid: An reference to a tile (optional).
+    visible: Whether the object is shown (1) or hidden (0). Defaults to 1.
+    """
+
+    def __init__(self, type, x, y, width=0, height=0, name=None,
+                 gid=None, tile=None, visible=1):
+        self.type = type
+        self.px = x
+        self.left = x
+        if tile:
+            y -= tile.tile_height
+            width = tile.tile_width
+            height = tile.tile_height
+        self.py = y
+        self.top = y
+        self.width = width
+        self.right = x + width
+        self.height = height
+        self.bottom = y + height
+        self.name = name
+        self.gid = gid
+        self.tile = tile
+        self.visible = visible
+        self.properties = {}
+
+        self._added_properties = {}
+        self._deleted_properties = set()
+        self.pyg = _hub.pygame
+
+    def __repr__(self):
+        if self.tile:
+            return '<Object %s,%s %s,%s tile=%d>' % (self.px, self.py, self.width, self.height, self.gid)
+        else:
+            return '<Object %s,%s %s,%s>' % (self.px, self.py, self.width, self.height)
+
+    def __contains__(self, key):
+        if key in self._deleted_properties:
+            return False
+        if key in self._added_properties:
+            return True
+        if key in self.properties:
+            return True
+        return self.tile and key in self.tile.properties
+
+    def __getitem__(self, key):
+        if key in self._deleted_properties:
+            raise KeyError(key)
+        if key in self._added_properties:
+            return self._added_properties[key]
+        if key in self.properties:
+            return self.properties[key]
+        if self.tile and key in self.tile.properties:
+            return self.tile.properties[key]
+        raise KeyError(key)
+
+    def __setitem__(self, key, value):
+        self._added_properties[key] = value
+
+    def __delitem__(self, key):
+        self._deleted_properties.add(key)
+
+    def draw(self, surface, view_x, view_y):
+        if self.visible:
+            x, y = (self.px - view_x, self.py - view_y)
+            if self.tile:
+                surface.blit(self.tile.surface, (x, y))
+            else:
+                r = self.pyg.Rect((x, y), (self.width, self.height))
+                self.pyg.draw.rect(surface, (255, 100, 100), r, 2)
+
+    @classmethod
+    def fromxml(cls, tag, map):
+        if 'gid' in tag.attrib:
+            gid = int(tag.attrib['gid'])
+            tile = map.tilesets[gid]
+            w = tile.tile_width
+            h = tile.tile_height
+        else:
+            gid = None
+            tile = None
+            w = round(float(tag.attrib['width']))
+            h = round(float(tag.attrib['height']))
+
+        x_attr, y_attr = round(float(tag.attrib['x'])), round(float(tag.attrib['y']))
+        o = cls(
+            tag.attrib.get('type', 'rect'),
+            x_attr, y_attr, w, h, tag.attrib.get('name'), gid, tile,
+            int(tag.attrib.get('visible', 1))
+        )
+
+        props = tag.find('properties')
+        if props is None:
+            return o
+
+        for c in props.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            o.properties[name] = value
+        return o
+
+    def intersects(self, x1, y1, x2, y2):
+        return not any((x2 < self.px, y2 < self.py, x1 > self.px + self.width, y1 > self.py + self.height))
+
+
+# TODO la aussi, deux methodes de dessin a evacuer!
+class ObjectLayer:
+    """
+    A layer composed of basic primitive shapes.
+    Actually encompasses a TMX <objectgroup> but even the TMX documentation
+    refers to them as object layers, so I will.
+
+    ObjectLayers have some basic properties:
+
+        position - ignored (cannot be edited in the current Tiled editor)
+        name - the name of the object group.
+        color - the color used to display the objects in this group.
+        opacity - the opacity of the layer as a value from 0 to 1.
+        visible - whether the layer is shown (1) or hidden (0).
+        objects - the objects in this Layer (Object instances)
+    """
+
+    def __init__(self, name, color, objects, opacity=1,
+                 visible=1, position=(0, 0)):
+        self.name = name
+        self.color = color
+        self.objects = objects
+        self.opacity = opacity
+        self.visible = visible
+        self.position = position
+        self.properties = {}
+
+    def __repr__(self):
+        return '<ObjectLayer "%s" at 0x%x>' % (self.name, id(self))
+
+    @classmethod
+    def fromxml(cls, tag, map):
+        layer = cls(tag.attrib['name'], tag.attrib.get('color'), [],
+                    float(tag.attrib.get('opacity', 1)),
+                    int(tag.attrib.get('visible', 1)))
+        for object in tag.findall('object'):
+            layer.objects.append(ObjectTmx.fromxml(object, map))
+        for c in tag.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            layer.properties[name] = value
+        return layer
+
+    def update(self, dt, *args):
+        pass
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.position = (x, y)
+
+    def draw(self, surface):
+        """
+        Draw this layer, limited to the current viewport, to the Surface.
+        """
+        if not self.visible:
+            return
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+        for myobj in self.objects:
+            myobj.draw(surface, self.view_x, self.view_y)
+
+    def find(self, *properties):
+        """
+        Find all cells with the given properties set.
+        """
+        r = []
+        for propname in properties:
+            for myobj in self.objects:
+                if myobj and propname in myobj or propname in self.properties:
+                    r.append(myobj)
+        return r
+
+    def match(self, **properties):
+        """
+        Find all objects with the given properties set to the given values.
+        """
+        r = []
+        for propname in properties:
+            for myobj in self.objects:
+                if propname in myobj:
+                    val = myobj[propname]
+                elif propname in self.properties:
+                    val = self.properties[propname]
+                else:
+                    continue
+                if properties[propname] == val:
+                    r.append(myobj)
+        return r
+
+    def collide(self, rect, propname):
+        """
+        Find all objects the rect is touching that have the indicated
+        property name set.
+        """
+        r = []
+        for myobj in self.get_in_region(rect.left, rect.top, rect.right, rect.bottom):
+            if propname in myobj or propname in self.properties:
+                r.append(myobj)
+        return r
+
+    def get_in_region(self, x1, y1, x2, y2):
+        """
+        Return objects that are within the map-space
+        pixel bounds specified by the bottom-left (x1, y1) and top-right
+        (x2, y2) corners.
+
+        Return a list of Object instances.
+        """
+        return [obj for obj in self.objects if obj.intersects(x1, y1, x2, y2)]
+
+    def get_at(self, x, y):
+        """
+        Return the first object found at the nominated (x, y) coordinate.
+        Return an Object instance or None.
+        """
+        for myobj in self.objects:
+            if myobj.contains(x, y):
+                return myobj
+
+
+# TODO y a deux methodes a evacuer c'est set_view(...) et draw(...)
+class Layer:
+    """
+    A 2d grid of Cells.
+
+    Layers have some basic properties:
+
+        width, height - the dimensions of the Layer in cells
+        tile_width, tile_height - the dimensions of each cell
+        px_width, px_height - the dimensions of the Layer in pixels
+        tilesets - the tilesets used in this Layer (a Tilesets instance)
+        properties - any properties set for this Layer
+        cells - a dict of all the Cell instances for this Layer, keyed off
+                (x, y) index.
+
+    Additionally you may look up a cell using direct item access:
+
+       layer[x, y] is layer.cells[x, y]
+
+    Note that empty cells will be set to None instead of a Cell instance.
+    """
+
+    def __init__(self, name, visible, map):
+        self.name = name
+        self.visible = visible
+        self.position = (0, 0)
+        # TODO get from TMX?
+        self.px_width = map.px_width
+        self.px_height = map.px_height
+        self.tile_width = map.tile_width
+        self.tile_height = map.tile_height
+        self.width = map.width
+        self.height = map.height
+        self.tilesets = map.tilesets
+        self.group = _hub.pygame.sprite.Group()
+        self.properties = {}
+        self.cells = {}
+
+    def __repr__(self):
+        return '<Layer "%s" at 0x%x>' % (self.name, id(self))
+
+    def __getitem__(self, pos):
+        return self.cells.get(pos)
+
+    def __setitem__(self, pos, tile):
+        x, y = pos
+        px = x * self.tile_width
+        py = y * self.tile_width
+        self.cells[pos] = Cell(x, y, px, py, tile)
+
+    def __iter__(self):
+        return LayerIterator(self)
+
+    @classmethod
+    def fromxml(cls, tag, givenmap):
+        layer = cls(tag.attrib['name'], int(tag.attrib.get('visible', 1)), givenmap)
+
+        data = tag.find('data')
+        if data is None:
+            raise ValueError('layer %s does not contain <data>' % layer.name)
+
+        data = data.text.strip()
+        data = data.encode()  # Convert to bytes
+        # Decode from base 64 and decompress via zlib
+        data = decompress(b64decode(data))
+        data = struct.unpack('<%di' % (len(data) / 4,), data)
+        assert len(data) == layer.width * layer.height
+        for idx, gid in enumerate(data):
+            if gid >= 1:  # otherwise its not set
+                tile = givenmap.tilesets[gid]
+                x = idx % layer.width
+                y = idx // layer.width
+                layer.cells[x, y] = Cell(x, y, x * givenmap.tile_width, y * givenmap.tile_height, tile)
+
+        return layer
+
+    def update(self, dt, *args):
+        pass
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.position = (x, y)
+
+    def draw(self, surface):
+        """
+        Draw this layer, limited to the current viewport, to the Surface.
+        """
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+        for x in range(ox, ox + w + self.tile_width, self.tile_width):
+            i = x // self.tile_width
+            for y in range(oy, oy + h + self.tile_height, self.tile_height):
+                j = y // self.tile_height
+                if (i, j) not in self.cells:
+                    continue
+                cell = self.cells[i, j]
+                surface.blit(cell.tile.surface, (cell.px - ox, cell.py - oy))
+
+    def find(self, *properties):
+        """
+        Find all cells with the given properties set.
+        """
+        r = []
+        for propname in properties:
+            for cell in list(self.cells.values()):
+                if cell and propname in cell:
+                    r.append(cell)
+        return r
+
+    def match(self, **properties):
+        """
+        Find all cells with the given properties set to the given values.
+        """
+        r = []
+        for propname in properties:
+            for cell in list(self.cells.values()):
+                if propname not in cell:
+                    continue
+                if properties[propname] == cell[propname]:
+                    r.append(cell)
+        return r
+
+    def collide(self, rect, propname):
+        """
+        Find all cells the rect is touching that have the indicated property
+        name set.
+        """
+        r = []
+        for cell in self.get_in_region(rect.left, rect.top, rect.right,
+                                       rect.bottom):
+            if not cell.intersects(rect):
+                continue
+            if propname in cell:
+                r.append(cell)
+        return r
+
+    def get_in_region(self, x1, y1, x2, y2):
+        """
+        Return cells (in [column][row]) that are within the map-space
+        pixel bounds specified by the bottom-left (x1, y1) and top-right
+        (x2, y2) corners.
+        Return a list of Cell instances.
+        """
+        i1 = max(0, x1 // self.tile_width)
+        j1 = max(0, y1 // self.tile_height)
+        i2 = min(self.width, x2 // self.tile_width + 1)
+        j2 = min(self.height, y2 // self.tile_height + 1)
+        return [self.cells[i, j]
+                for i in range(int(i1), int(i2))
+                for j in range(int(j1), int(j2))
+                if (i, j) in self.cells]
+
+    def get_at(self, x, y):
+        """
+        Return the cell at the nominated (x, y) coordinate.
+        Return a Cell instance or None.
+        """
+        i = x // self.tile_width
+        j = y // self.tile_height
+        return self.cells.get((i, j))
+
+    def neighbors(self, index):
+        """
+        Return the indexes of the valid (ie. within the map) cardinal (ie.
+        North, South, East, West) neighbors of the nominated cell index.
+        Returns a list of 2-tuple indexes.
+        """
+        i, j = index
+        n = []
+        if i < self.width - 1:
+            n.append((i + 1, j))
+        if i > 0:
+            n.append((i - 1, j))
+        if j < self.height - 1:
+            n.append((i, j + 1))
+        if j > 0:
+            n.append((i, j - 1))
+        return n
+
+
+class Tile:
+
+    def __init__(self, gid, surface, tileset):
+        self.gid = gid
+        self.surface = surface
+        self.tile_width = tileset.tile_width
+        self.tile_height = tileset.tile_height
+        self.properties = {}
+
+    @classmethod
+    def fromSurface(cls, surface):
+        """
+        Create a new Tile object straight from a pygame Surface.
+        Its tile_width and tile_height will be set using the Surface dimensions.
+        Its gid will be 0.
+        """
+        class ts:
+            tile_width, tile_height = surface.get_size()
+
+        return cls(0, surface, ts)
+
+    def loadxml(self, tag):
+        props = tag.find('properties')
+        if props is None:
+            return
+        for c in props.findall('property'):
+            # store additional properties.
+            name = c.attrib['name']
+            value = c.attrib['value']
+
+            # TODO hax
+            if value.isdigit():
+                value = int(value)
+            self.properties[name] = value
+
+    def __repr__(self):
+        return '<Tile %d>' % self.gid
+
+
+class Tileset:
+    """
+    (mm si l'on charge des img pygame ca reste du modele car on fetch les donnees depuis
+    une telle instance...)
+    """
+
+    def __init__(self, name, tile_width, tile_height, firstgid):
+        self.name = name
+        self.tile_width = tile_width
+        self.tile_height = tile_height
+        self.firstgid = firstgid
+        self.tiles = []
+        self.properties = {}
+
+    def add_image(self, file):
+        image = _hub.pygame.image.load(file).convert_alpha()
+        if not image:
+            print("Error creating new Tileset: file %s not found" % file)
+            raise FileNotFoundError
+
+        ident = self.firstgid
+        tile_w, tile_h = self.tile_width, self.tile_height
+        for line in range(image.get_height() // tile_h):
+            for column in range(image.get_width() // tile_w):
+                pos = _hub.pygame.Rect(column * tile_w, line * tile_h, tile_w, tile_h)
+                self.tiles.append(Tile(ident, image.subsurface(pos), self))
+                ident += 1
+
+    def get_tile(self, gid):
+        return self.tiles[gid - self.firstgid]
+
+    @classmethod
+    def fromxml(cls, tag, firstgid=None, hacksource=None, hacktileset=None):
+        print('fromxml ')
+        if 'source' in tag.attrib:
+            firstgid = int(tag.attrib['firstgid'])
+            if hacksource:
+                srcc = hacksource
+            else:
+                srcc = tag.attrib['source']
+
+            with open(srcc) as f:
+                print('opened ', srcc)
+                tileset = ElementTree.fromstring(f.read())
+
+            return cls.fromxml(tileset, firstgid, hacktileset=hacktileset)
+
+        name = tag.attrib['name']
+        if firstgid is None:
+            firstgid = int(tag.attrib['firstgid'])
+        tile_width = int(tag.attrib['tilewidth'])
+        tile_height = int(tag.attrib['tileheight'])
+
+        tileset = cls(name, tile_width, tile_height, firstgid)
+
+        for c in tag:  # .getchildren():
+            if c.tag == "image":
+                # create a tileset
+                arg_sheet = c.attrib['source'] if (hacktileset is None) else hacktileset
+                tileset.add_image(arg_sheet)
+            elif c.tag == 'tile':
+                gid = tileset.firstgid + int(c.attrib['id'])
+                tileset.get_tile(gid).loadxml(c)
+        return tileset
+
+
+class Tilesets(dict):
+    def add(self, tileset):
+        for idx, tile in enumerate(tileset.tiles):
+            idx += tileset.firstgid
+            self[idx] = tile
+
+
+class Layers(list):
+    def __init__(self):
+        self.by_name = {}
+
+    def add_named(self, layer, name):
+        self.append(layer)
+        self.by_name[name] = layer
+
+    def __getitem__(self, item):
+        if isinstance(item, int):
+            return self[item]
+        return self.by_name[item]
+
+
+class TileMap:
+    """
+    A TileMap is a collection of Layers which contain gridded maps or sprites
+    TileMaps are loaded from TMX files which sets the .layers and .tilesets properties
+
+    After loading, additional SpriteLayers may be added.
+
+    A TileMap's rendering is restricted by a viewport which is defined by the
+    size passed in at construction time and the focus set by set_focus() or
+    force_focus().
+
+    TileMaps have a number of properties:
+
+        width, height - the dimensions of the tilemap in cells
+
+        tile_width, tile_height - the dimensions of the cells in the map
+        px_width, px_height - the dimensions of the tilemap in pixels
+        properties - any properties set on the tilemap in the TMX file
+        layers - all layers of this tilemap as a Layers instance
+        tilesets - all tilesets of this tilemap as a Tilesets instance
+
+    """
+
+    def __init__(self):
+        self.px_width = 0
+        self.px_height = 0
+        self.tile_width = 0
+        self.tile_height = 0
+        self.width = 0
+        self.height = 0
+        self.properties = {}
+        self.layers = Layers()
+        self.tilesets = Tilesets()
+
+    @property
+    def pix_width(self):
+        return self.px_width
+
+    @property
+    def pix_height(self):
+        return self.px_height
+
+    def update(self, dt, *args):
+        for layer in self.layers:
+            layer.update(dt, *args)
+
+    @classmethod
+    def load(cls, filename, hack_tsxfile=None, hack_ts=None):
+        with open(filename) as f:
+            tminfo_tree = ElementTree.fromstring(f.read())
+
+        # get most general map informations and create a surface
+        tilemap = TileMap()
+
+        tilemap.width = int(tminfo_tree.attrib['width'])
+        tilemap.height = int(tminfo_tree.attrib['height'])
+        tilemap.tile_width = int(tminfo_tree.attrib['tilewidth'])
+        tilemap.tile_height = int(tminfo_tree.attrib['tileheight'])
+        tilemap.px_width = tilemap.width * tilemap.tile_width
+        tilemap.px_height = tilemap.height * tilemap.tile_height
+
+        for tag in tminfo_tree.findall('tileset'):
+            tilemap.tilesets.add(
+                Tileset.fromxml(tag, hacksource=hack_tsxfile, hacktileset=hack_ts)  # hacks work only if no more than 1 ts
+            )
+            print('tilesets added')
+
+        for tag in tminfo_tree.findall('layer'):
+            layer = Layer.fromxml(tag, tilemap)
+            tilemap.layers.add_named(layer, layer.name)
+
+        for tag in tminfo_tree.findall('objectgroup'):
+            layer = ObjectLayer.fromxml(tag, tilemap)
+            tilemap.layers.add_named(layer, layer.name)
+
+        # We wanna persist info about the (optional) Image layer found in .tmx
+        # TODO add to kengi a class that modelize ImageLayer?
+        tagraw_ilayer_li = tminfo_tree.findall('imagelayer')
+        if len(tagraw_ilayer_li) == 1:
+            tagraw_ilayer = tagraw_ilayer_li.pop()
+            subnode = tagraw_ilayer.find('image')
+            tilemap.background = {  # persist info in tilemap_obj.background
+                'img_path': subnode.attrib['source'],
+                'offsetx': round(float(tagraw_ilayer.attrib['offsetx'])),
+                'offsety': round(float(tagraw_ilayer.attrib['offsety'])),
+                'repeatx': int(tagraw_ilayer.attrib['repeatx'])  # 0 or 1
+            }
+        elif len(tagraw_ilayer_li) > 1:
+            raise NotImplementedError
+        else:
+            tilemap.background = None
+
+        return tilemap
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/misc.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/misc.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,188 +1,188 @@
-
-"""
-TODO support .json, uncompressed files
-"""
-from ... import _hub as inj
-pygame = inj.pygame
-
-
-class SpriteLayer(pygame.sprite.AbstractGroup):
-    def __init__(self):
-        super(SpriteLayer, self).__init__()
-        self.visible = True
-
-    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
-        self.view_x, self.view_y = x, y
-        self.view_w, self.view_h = w, h
-        x -= viewport_ox
-        y -= viewport_oy
-        self.dx = viewport_ox
-        self.dy = viewport_oy
-        self.position = (x, y)
-
-    def draw(self, screen):
-        ox, oy = self.position
-        w, h = self.view_w, self.view_h
-
-        for sprite in self.sprites():
-            sx, sy = sprite.rect.topleft
-            # Only the sprite's defined width and height will be drawn
-            area = pygame.Rect((0, 0),
-                               (sprite.rect.width,
-                                sprite.rect.height))
-            screen.blit(sprite.image, (sx - ox, sy - oy), area)
-
-
-class Viewport(pygame.Rect):
-    """
-    viewport: based upont pygame.Rect (pygame obj. for storing rectangular coordinates)
-
-    can draw tilemaps, constrained by viewport origin and dimensions
-
-    attributes:
-    fx, fy - viewport focus point
-    view_w, view_h - viewport size
-    view_x, view_y - viewport offset (origin)
-    """
-    _old_focus = None
-
-    def __init__(self,  tilemap_ref, origin, size, **kwargs):
-        super().__init__(origin, size)
-        self._tm = tilemap_ref  # Tilemap instance
-
-        self.fx, self.fy = 0, 0  # viewport focus point
-        self.view_w, self.view_h = size  # viewport size
-        self.view_x, self.view_y = origin  # viewport offset
-
-        # rn the followin line is very important as it is responible for
-        # init. Layer draw process (forcing .set_view(...) call)
-        # and to set offset properly!
-        self.force_focus(*origin)
-        # debug: print('force_focus: ', origin[0], origin[1])
-
-        # this is like a temp storage
-        self.childs_ox, self.childs_oy = None, None
-
-        # wtf? how is this useful
-        self.restricted_fx, self.restricted_fy = None, None
-
-        for ckey, val in kwargs.items():
-            setattr(self, ckey, val)
-
-    def set_focus(self, fx, fy, force=False):
-        """
-        Determine the viewport based on a desired focus pixel in the
-        Layer space (fx, fy) and honoring any bounding restrictions of
-        child layers.
-
-        The focus will always be shifted to ensure no child layers display
-        out-of-bounds data, as defined by their dimensions px_width and px_height.
-        """
-        # -debug
-        # print('set_focus CALL. Args= ', fx, fy)
-
-        # The result is that all chilren will have their viewport set, defining
-        # which of their pixels should be visible.
-        fx, fy = int(fx), int(fy)
-        self.fx, self.fy = fx, fy
-
-        a = (fx, fy)
-
-        # check for NOOP (same arg passed in)
-        if not force and self._old_focus == a:
-            # noop
-            return
-        self._old_focus = a
-
-        # get our viewport information, scaled as appropriate
-        w = int(self.view_w)
-        h = int(self.view_h)
-        w2, h2 = w // 2, h // 2
-
-        totwidth, totheight = self._tm.pix_width, self._tm.pix_height
-        if totwidth <= w:
-            # this branch for centered view and no view jump when
-            # crossing the center; both when world width <= view width
-            restricted_fx = totwidth / 2
-        else:
-            if (fx - w2) < 0:
-                restricted_fx = w2  # hit minimum X extent
-            elif (fx + w2) > totwidth:
-                restricted_fx = totwidth - w2  # hit maximum X extent
-            else:
-                restricted_fx = fx
-
-        if self._tm.pix_height <= h:
-            # this branch for centered view and no view jump when
-            # crossing the center; both when world height <= view height
-            restricted_fy = totheight / 2
-        else:
-            if (fy - h2) < 0:
-                restricted_fy = h2  # hit minimum Y extent
-            elif (fy + h2) > totheight:
-                restricted_fy = totheight - h2  # hit maximum Y extent
-            else:
-                restricted_fy = fy
-
-        # ... and this is our focus point, center of screen
-        self.restricted_fx = int(restricted_fx)
-        self.restricted_fy = int(restricted_fy)
-
-        # determine child view bounds to match that focus point
-        x, y = int(restricted_fx - w2), int(restricted_fy - h2)
-        self._match_focus_pt(x, y, w, h)
-
-    def force_focus(self, fx, fy):
-        """
-        Force the manager to focus on a point,
-        regardless of any managed layer visible boundaries.
-        """
-
-        # This calculation takes into account the scaling of this Layer (and
-        # therefore also its children).
-        # The result is that all chilren will have their viewport set, defining
-        # which of their pixels should be visible.
-        self.fx, self.fy = list(map(int, (fx, fy)))
-
-        # self.fx, self.fy = fx, fy
-
-        # get our view size
-        w = int(self.view_w)
-        h = int(self.view_h)
-        w2, h2 = w // 2, h // 2
-
-        # bottom-left corner of the viewport
-        x, y = fx - w2, fy - h2
-        self._match_focus_pt(x, y, w, h)
-
-    def _match_focus_pt(self, x, y, dimw, dimh):
-        self.x = x  # self.x is a super(), that is Rect-defined attribute
-        self.y = y  # self.y is a super(), that is Rect-defined attribute
-
-        # change offsets, n update all layers view
-        self.childs_ox = x - self.view_x
-        self.childs_oy = y - self.view_y
-        for layer in self._tm.layers:
-            layer.set_view(x, y, dimw, dimh, self.view_x, self.view_y)
-
-    def draw(self, screen):
-        for layer in self._tm.layers:
-            if layer.visible:
-                layer.draw(screen)
-
-    # - utils
-    def pixel_from_screen(self, x, y):
-        # look up the Layer-space pixel matching the screen-space pixel.
-        vx, vy = self.childs_ox, self.childs_oy
-        return int(vx + x), int(vy + y)
-
-    def pixel_to_screen(self, x, y):
-        # look up the screen-space pixel matching the Layer-space pixel
-        screen_x = x - self.childs_ox
-        screen_y = y - self.childs_oy
-        return int(screen_x), int(screen_y)
-
-    def index_at(self, x, y):
-        # return the map index at the (screen-space) pixel position.
-        sx, sy = self.pixel_from_screen(x, y)
-        return int(sx // self._tm.tile_width), int(sy // self._tm.tile_height)
+
+"""
+TODO support .json, uncompressed files
+"""
+from ... import _hub as inj
+pygame = inj.pygame
+
+
+class SpriteLayer(pygame.sprite.AbstractGroup):
+    def __init__(self):
+        super(SpriteLayer, self).__init__()
+        self.visible = True
+
+    def set_view(self, x, y, w, h, viewport_ox=0, viewport_oy=0):
+        self.view_x, self.view_y = x, y
+        self.view_w, self.view_h = w, h
+        x -= viewport_ox
+        y -= viewport_oy
+        self.dx = viewport_ox
+        self.dy = viewport_oy
+        self.position = (x, y)
+
+    def draw(self, screen):
+        ox, oy = self.position
+        w, h = self.view_w, self.view_h
+
+        for sprite in self.sprites():
+            sx, sy = sprite.rect.topleft
+            # Only the sprite's defined width and height will be drawn
+            area = pygame.Rect((0, 0),
+                               (sprite.rect.width,
+                                sprite.rect.height))
+            screen.blit(sprite.image, (sx - ox, sy - oy), area)
+
+
+class Viewport(pygame.Rect):
+    """
+    viewport: based upont pygame.Rect (pygame obj. for storing rectangular coordinates)
+
+    can draw tilemaps, constrained by viewport origin and dimensions
+
+    attributes:
+    fx, fy - viewport focus point
+    view_w, view_h - viewport size
+    view_x, view_y - viewport offset (origin)
+    """
+    _old_focus = None
+
+    def __init__(self,  tilemap_ref, origin, size, **kwargs):
+        super().__init__(origin, size)
+        self._tm = tilemap_ref  # Tilemap instance
+
+        self.fx, self.fy = 0, 0  # viewport focus point
+        self.view_w, self.view_h = size  # viewport size
+        self.view_x, self.view_y = origin  # viewport offset
+
+        # rn the followin line is very important as it is responible for
+        # init. Layer draw process (forcing .set_view(...) call)
+        # and to set offset properly!
+        self.force_focus(*origin)
+        # debug: print('force_focus: ', origin[0], origin[1])
+
+        # this is like a temp storage
+        self.childs_ox, self.childs_oy = None, None
+
+        # wtf? how is this useful
+        self.restricted_fx, self.restricted_fy = None, None
+
+        for ckey, val in kwargs.items():
+            setattr(self, ckey, val)
+
+    def set_focus(self, fx, fy, force=False):
+        """
+        Determine the viewport based on a desired focus pixel in the
+        Layer space (fx, fy) and honoring any bounding restrictions of
+        child layers.
+
+        The focus will always be shifted to ensure no child layers display
+        out-of-bounds data, as defined by their dimensions px_width and px_height.
+        """
+        # -debug
+        # print('set_focus CALL. Args= ', fx, fy)
+
+        # The result is that all chilren will have their viewport set, defining
+        # which of their pixels should be visible.
+        fx, fy = int(fx), int(fy)
+        self.fx, self.fy = fx, fy
+
+        a = (fx, fy)
+
+        # check for NOOP (same arg passed in)
+        if not force and self._old_focus == a:
+            # noop
+            return
+        self._old_focus = a
+
+        # get our viewport information, scaled as appropriate
+        w = int(self.view_w)
+        h = int(self.view_h)
+        w2, h2 = w // 2, h // 2
+
+        totwidth, totheight = self._tm.pix_width, self._tm.pix_height
+        if totwidth <= w:
+            # this branch for centered view and no view jump when
+            # crossing the center; both when world width <= view width
+            restricted_fx = totwidth / 2
+        else:
+            if (fx - w2) < 0:
+                restricted_fx = w2  # hit minimum X extent
+            elif (fx + w2) > totwidth:
+                restricted_fx = totwidth - w2  # hit maximum X extent
+            else:
+                restricted_fx = fx
+
+        if self._tm.pix_height <= h:
+            # this branch for centered view and no view jump when
+            # crossing the center; both when world height <= view height
+            restricted_fy = totheight / 2
+        else:
+            if (fy - h2) < 0:
+                restricted_fy = h2  # hit minimum Y extent
+            elif (fy + h2) > totheight:
+                restricted_fy = totheight - h2  # hit maximum Y extent
+            else:
+                restricted_fy = fy
+
+        # ... and this is our focus point, center of screen
+        self.restricted_fx = int(restricted_fx)
+        self.restricted_fy = int(restricted_fy)
+
+        # determine child view bounds to match that focus point
+        x, y = int(restricted_fx - w2), int(restricted_fy - h2)
+        self._match_focus_pt(x, y, w, h)
+
+    def force_focus(self, fx, fy):
+        """
+        Force the manager to focus on a point,
+        regardless of any managed layer visible boundaries.
+        """
+
+        # This calculation takes into account the scaling of this Layer (and
+        # therefore also its children).
+        # The result is that all chilren will have their viewport set, defining
+        # which of their pixels should be visible.
+        self.fx, self.fy = list(map(int, (fx, fy)))
+
+        # self.fx, self.fy = fx, fy
+
+        # get our view size
+        w = int(self.view_w)
+        h = int(self.view_h)
+        w2, h2 = w // 2, h // 2
+
+        # bottom-left corner of the viewport
+        x, y = fx - w2, fy - h2
+        self._match_focus_pt(x, y, w, h)
+
+    def _match_focus_pt(self, x, y, dimw, dimh):
+        self.x = x  # self.x is a super(), that is Rect-defined attribute
+        self.y = y  # self.y is a super(), that is Rect-defined attribute
+
+        # change offsets, n update all layers view
+        self.childs_ox = x - self.view_x
+        self.childs_oy = y - self.view_y
+        for layer in self._tm.layers:
+            layer.set_view(x, y, dimw, dimh, self.view_x, self.view_y)
+
+    def draw(self, screen):
+        for layer in self._tm.layers:
+            if layer.visible:
+                layer.draw(screen)
+
+    # - utils
+    def pixel_from_screen(self, x, y):
+        # look up the Layer-space pixel matching the screen-space pixel.
+        vx, vy = self.childs_ox, self.childs_oy
+        return int(vx + x), int(vy + y)
+
+    def pixel_to_screen(self, x, y):
+        # look up the screen-space pixel matching the Layer-space pixel
+        screen_x = x - self.childs_ox
+        screen_y = y - self.childs_oy
+        return int(screen_x), int(screen_y)
+
+    def index_at(self, x, y):
+        # return the map index at the (screen-space) pixel position.
+        sx, sy = self.pixel_from_screen(x, y)
+        return int(sx // self._tm.tile_width), int(sy // self._tm.tile_height)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/__init__.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/__init__.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,22 +1,22 @@
-"""Parse Tiled Maps and Tilesets
-
-See: https://www.mapeditor.org/
-
-This library is for parsing JSON formatted Tiled Map Editormaps and tilesets to be
-    used as maps and levels for 2D top-down (orthogonal, hexogonal, or isometric)
-    or side-scrolling games in a strictly typed fashion.
-
-PyTiled Parser is not tied to any particular graphics library or game engine.
-"""
-
-# pylint: disable=too-few-public-methods
-
-from .common_types import Color, OrderedPair, Size
-from .exception import UnknownFormat
-from .layer import Chunk, ImageLayer, Layer, LayerGroup, ObjectLayer, TileLayer
-from .parser import parse_map, parse_world
-from .properties import Properties, Property
-from .tiled_map import TiledMap
-from .tileset import Frame, Grid, Tile, Tileset, Transformations
-from .version import __version__
-from .world import World, WorldMap
+"""Parse Tiled Maps and Tilesets
+
+See: https://www.mapeditor.org/
+
+This library is for parsing JSON formatted Tiled Map Editormaps and tilesets to be
+    used as maps and levels for 2D top-down (orthogonal, hexogonal, or isometric)
+    or side-scrolling games in a strictly typed fashion.
+
+PyTiled Parser is not tied to any particular graphics library or game engine.
+"""
+
+# pylint: disable=too-few-public-methods
+
+from .common_types import Color, OrderedPair, Size
+from .exception import UnknownFormat
+from .layer import Chunk, ImageLayer, Layer, LayerGroup, ObjectLayer, TileLayer
+from .parser import parse_map, parse_world
+from .properties import Properties, Property
+from .tiled_map import TiledMap
+from .tileset import Frame, Grid, Tile, Tileset, Transformations
+from .version import __version__
+from .world import World, WorldMap
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/common_types.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/common_types.py`

 * *Ordering differences only*

 * *Files 22% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-"""Module containing types that are common to other modules."""
-
-# pylint: disable=too-few-public-methods
-
-from typing import NamedTuple
-
-
-class Color(NamedTuple):
-    """Represents an RGBA color value as a four value Tuple.
-
-    Attributes:
-        red: Red value, between 0 and 255.
-        green: Green value, between 0 and 255.
-        blue: Blue value, between 0 and 255.
-        alpha: Alpha value, between 0 and 255.
-    """
-
-    red: int
-    green: int
-    blue: int
-    alpha: int
-
-
-class Size(NamedTuple):
-    """Represents a two dimensional size as a two value Tuple.
-
-    Attributes:
-        width: The width of the object. Can be in either pixels or number of tiles.
-        height: The height of the object. Can be in either pixels or number of tiles.
-    """
-
-    width: float
-    height: float
-
-
-class OrderedPair(NamedTuple):
-    """Represents a two dimensional position as a two value Tuple.
-
-    Attributes:
-        x: X coordinate. Can be in either pixels or number of tiles.
-        y: Y coordinate. Can be in either pixels or number of tiles.
-    """
-
-    x: float
-    y: float
+"""Module containing types that are common to other modules."""
+
+# pylint: disable=too-few-public-methods
+
+from typing import NamedTuple
+
+
+class Color(NamedTuple):
+    """Represents an RGBA color value as a four value Tuple.
+
+    Attributes:
+        red: Red value, between 0 and 255.
+        green: Green value, between 0 and 255.
+        blue: Blue value, between 0 and 255.
+        alpha: Alpha value, between 0 and 255.
+    """
+
+    red: int
+    green: int
+    blue: int
+    alpha: int
+
+
+class Size(NamedTuple):
+    """Represents a two dimensional size as a two value Tuple.
+
+    Attributes:
+        width: The width of the object. Can be in either pixels or number of tiles.
+        height: The height of the object. Can be in either pixels or number of tiles.
+    """
+
+    width: float
+    height: float
+
+
+class OrderedPair(NamedTuple):
+    """Represents a two dimensional position as a two value Tuple.
+
+    Attributes:
+        x: X coordinate. Can be in either pixels or number of tiles.
+        y: Y coordinate. Can be in either pixels or number of tiles.
+    """
+
+    x: float
+    y: float
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/layer.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/layer.py`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,180 +1,180 @@
-"""This module provides classes for all layer types
-
-There is the base Layer class, which TileLayer, ObjectLayer, ImageLayer,
-and LayerGroup all derive from. The base Layer class is never directly used,
-and serves only as an abstract base for common elements between all types.
-
-For more information about Layers, see [Tiled's Manual](https://doc.mapeditor.org/en/stable/manual/layers/)
-"""
-
-# pylint: disable=too-few-public-methods
-
-from pathlib import Path
-from typing import List, Optional, Union
-
-# import attr
-from .common_types import Color, OrderedPair, Size
-from .properties import Properties
-from .tiled_object import TiledObject
-
-
-class Layer:
-    """Base class that all layer types inherit from. Includes common attributes between
-    the various types of layers. This class will never be returned directly by the parser.
-    It will always return one of the full layer types.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#layer>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
-
-    Attributes:
-        name: The name of the layer object.
-        opacity: Decimal value between 0 and 1 to determine opacity. 1 is completely
-            opaque, 0 is completely transparent. Defaults to 1.
-        visible: If the layer is visible in the Tiled Editor. Defaults to True
-        coordinates: Where layer content starts in tiles. Only used by infinite maps.
-            Defaults to (0, 0).
-        parallax_factor: Used to determine parallaxing speed of a layer. Defaults to (1, 1).
-        offset: Rendering offset of the layer object in pixels. Defaults to (0, 0).
-        id: Unique ID of the layer. Each layer that is added to a map gets a unique id.
-            Even if a layer is deleted, no layer ever gets the same ID.
-        size: Ordered pair of size of map in tiles.
-        properties: Properties for the layer.
-        tint_color: Tint color that is multiplied with any graphics in this layer.
-        class_: The Tiled class of this Layer.
-        repeat_x: Repeat drawing on the X Axis(Currently only applies to image layers)
-        repeat_y: Repeat drawing on the Y Axis(Currently only applies to image layers)
-    """
-    def __init__(self, name='', opacity=1, visible=True, repeat_x=False, repeat_y=False, coordinates=[0,0], id=0, parallax_factor=[1,1], size=[0,0]):
-        self.name = name
-        self.opacity = opacity
-        self.visible = visible
-
-        # These technically only apply to image layers as of now, however Tiled has indicated
-        # that is only at this time, and there's no reason they couldn't apply to other
-        # types of layers in the future. For this reason they are stored in the common class.
-        self.repeat_x=repeat_x
-        self.repeat_y = repeat_y
-
-        self.coordinates = coordinates
-        # TODO finish
-        self.parallax_factor=parallax_factor
-        # offset: OrderedPair = OrderedPair(0, 0)
-        self.id = id
-        # class_: Optional[str] = None
-        self.size = size
-        # properties: Optional[Properties] = None
-        # tint_color: Optional[Color] = None
-
-
-TileLayerGrid = List[List[int]]
-
-
-class Chunk:
-    """Chunk object for infinite maps. Stores `data` like you would have in a normal
-    TileLayer but only for the area specified by `coordinates` and `size`.
-
-    `Infinite Maps Docs <https://doc.mapeditor.org/en/stable/manual/using-infinite-maps/>`_
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#chunk>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#chunk>`_
-
-    Attributes:
-        coordinates: Location of chunk in tiles.
-        size: The size of the chunk in tiles.
-        data: The global tile IDs in the chunk. A row-first two dimensional array.
-    """
-
-    coordinates: OrderedPair
-    size: Size
-    data: List[List[int]]
-
-
-# The tile data for one layer.
-#
-# Either a 2 dimensional array of integers representing the global tile IDs
-#     for a TileLayerGrid, or a list of chunks for an infinite map layer.
-LayerData = Union[TileLayerGrid, List[Chunk]]
-
-
-class TileLayer(Layer):
-    """The base type of layer which stores tile data for an area of a map.
-
-    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#tile-layers>`_
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#layer>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tile-layer-example>`_
-
-    Attributes:
-        chunks: List of chunks (only populated for infinite maps)
-        data: A two dimensional array of integers representing the global
-        tile IDs for the layer (only populaed for non-infinite maps)
-    """
-
-    chunks: Optional[List[Chunk]] = None
-    data: Optional[List[List[int]]] = None
-
-
-class ObjectLayer(Layer):
-    """A Layer type which stores a list of Tiled Objects
-
-    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#object-layers>`_
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#objectgroup>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#object-layer-example>`_
-
-    Attributes:
-        tiled_objects: List of tiled_objects in the layer.
-        draworder: Whether the objects are drawn according to the order of the object
-            elements in the object group element ('manual'), or sorted by their
-            y-coordinate ('topdown'). Defaults to 'topdown'. See:
-            https://doc.mapeditor.org/en/stable/manual/objects/#changing-stacking-order
-            for more info.
-    """
-    def __init__(self,tiled_objects=None,draw_order='topdown', **kwargs):
-        self.tiled_objects=list()
-        if tiled_objects:
-            self.tiled_objects=tiled_objects
-        self.draw_order= draw_order
-        super().__init__(**kwargs)
-
-
-class ImageLayer(Layer):
-    """A layer type which stores a single image
-
-    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#image-layers>`_
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#imagelayer>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
-
-    Attributes:
-        image: The image used by this layer.
-        transparent_color: Color that is to be made transparent on this layer.
-    """
-
-    image: Path
-    transparent_color: Optional[Color] = None
-
-
-class LayerGroup(Layer):
-    """A layer that contains layers (potentially including other LayerGroups, nested infinitely).
-
-    In Tiled, offset and opacity recursively affect child layers, however that is not enforced during
-    parsing by pytiled_parser, and is up to the implementation how to handle recursive effects of
-    LayerGroups
-
-    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#group-layers>`_
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#group>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
-
-    Attributes:
-        layers: list of layers contained in the group.
-    """
-
-    layers: Optional[List[Layer]]
+"""This module provides classes for all layer types
+
+There is the base Layer class, which TileLayer, ObjectLayer, ImageLayer,
+and LayerGroup all derive from. The base Layer class is never directly used,
+and serves only as an abstract base for common elements between all types.
+
+For more information about Layers, see [Tiled's Manual](https://doc.mapeditor.org/en/stable/manual/layers/)
+"""
+
+# pylint: disable=too-few-public-methods
+
+from pathlib import Path
+from typing import List, Optional, Union
+
+# import attr
+from .common_types import Color, OrderedPair, Size
+from .properties import Properties
+from .tiled_object import TiledObject
+
+
+class Layer:
+    """Base class that all layer types inherit from. Includes common attributes between
+    the various types of layers. This class will never be returned directly by the parser.
+    It will always return one of the full layer types.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#layer>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
+
+    Attributes:
+        name: The name of the layer object.
+        opacity: Decimal value between 0 and 1 to determine opacity. 1 is completely
+            opaque, 0 is completely transparent. Defaults to 1.
+        visible: If the layer is visible in the Tiled Editor. Defaults to True
+        coordinates: Where layer content starts in tiles. Only used by infinite maps.
+            Defaults to (0, 0).
+        parallax_factor: Used to determine parallaxing speed of a layer. Defaults to (1, 1).
+        offset: Rendering offset of the layer object in pixels. Defaults to (0, 0).
+        id: Unique ID of the layer. Each layer that is added to a map gets a unique id.
+            Even if a layer is deleted, no layer ever gets the same ID.
+        size: Ordered pair of size of map in tiles.
+        properties: Properties for the layer.
+        tint_color: Tint color that is multiplied with any graphics in this layer.
+        class_: The Tiled class of this Layer.
+        repeat_x: Repeat drawing on the X Axis(Currently only applies to image layers)
+        repeat_y: Repeat drawing on the Y Axis(Currently only applies to image layers)
+    """
+    def __init__(self, name='', opacity=1, visible=True, repeat_x=False, repeat_y=False, coordinates=[0,0], id=0, parallax_factor=[1,1], size=[0,0]):
+        self.name = name
+        self.opacity = opacity
+        self.visible = visible
+
+        # These technically only apply to image layers as of now, however Tiled has indicated
+        # that is only at this time, and there's no reason they couldn't apply to other
+        # types of layers in the future. For this reason they are stored in the common class.
+        self.repeat_x=repeat_x
+        self.repeat_y = repeat_y
+
+        self.coordinates = coordinates
+        # TODO finish
+        self.parallax_factor=parallax_factor
+        # offset: OrderedPair = OrderedPair(0, 0)
+        self.id = id
+        # class_: Optional[str] = None
+        self.size = size
+        # properties: Optional[Properties] = None
+        # tint_color: Optional[Color] = None
+
+
+TileLayerGrid = List[List[int]]
+
+
+class Chunk:
+    """Chunk object for infinite maps. Stores `data` like you would have in a normal
+    TileLayer but only for the area specified by `coordinates` and `size`.
+
+    `Infinite Maps Docs <https://doc.mapeditor.org/en/stable/manual/using-infinite-maps/>`_
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#chunk>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#chunk>`_
+
+    Attributes:
+        coordinates: Location of chunk in tiles.
+        size: The size of the chunk in tiles.
+        data: The global tile IDs in the chunk. A row-first two dimensional array.
+    """
+
+    coordinates: OrderedPair
+    size: Size
+    data: List[List[int]]
+
+
+# The tile data for one layer.
+#
+# Either a 2 dimensional array of integers representing the global tile IDs
+#     for a TileLayerGrid, or a list of chunks for an infinite map layer.
+LayerData = Union[TileLayerGrid, List[Chunk]]
+
+
+class TileLayer(Layer):
+    """The base type of layer which stores tile data for an area of a map.
+
+    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#tile-layers>`_
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#layer>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tile-layer-example>`_
+
+    Attributes:
+        chunks: List of chunks (only populated for infinite maps)
+        data: A two dimensional array of integers representing the global
+        tile IDs for the layer (only populaed for non-infinite maps)
+    """
+
+    chunks: Optional[List[Chunk]] = None
+    data: Optional[List[List[int]]] = None
+
+
+class ObjectLayer(Layer):
+    """A Layer type which stores a list of Tiled Objects
+
+    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#object-layers>`_
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#objectgroup>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#object-layer-example>`_
+
+    Attributes:
+        tiled_objects: List of tiled_objects in the layer.
+        draworder: Whether the objects are drawn according to the order of the object
+            elements in the object group element ('manual'), or sorted by their
+            y-coordinate ('topdown'). Defaults to 'topdown'. See:
+            https://doc.mapeditor.org/en/stable/manual/objects/#changing-stacking-order
+            for more info.
+    """
+    def __init__(self,tiled_objects=None,draw_order='topdown', **kwargs):
+        self.tiled_objects=list()
+        if tiled_objects:
+            self.tiled_objects=tiled_objects
+        self.draw_order= draw_order
+        super().__init__(**kwargs)
+
+
+class ImageLayer(Layer):
+    """A layer type which stores a single image
+
+    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#image-layers>`_
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#imagelayer>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
+
+    Attributes:
+        image: The image used by this layer.
+        transparent_color: Color that is to be made transparent on this layer.
+    """
+
+    image: Path
+    transparent_color: Optional[Color] = None
+
+
+class LayerGroup(Layer):
+    """A layer that contains layers (potentially including other LayerGroups, nested infinitely).
+
+    In Tiled, offset and opacity recursively affect child layers, however that is not enforced during
+    parsing by pytiled_parser, and is up to the implementation how to handle recursive effects of
+    LayerGroups
+
+    `Tiled Docs <https://doc.mapeditor.org/en/stable/manual/layers/#group-layers>`_
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#group>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#layer>`_
+
+    Attributes:
+        layers: list of layers contained in the group.
+    """
+
+    layers: Optional[List[Layer]]
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parser.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parser.py`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,45 +1,45 @@
-from pathlib import Path
-
-from . import UnknownFormat
-from .parsers.json.tiled_map import parse as json_map_parse
-from .parsers.tmx.tiled_map import parse as tmx_map_parse
-from .tiled_map import TiledMap
-from .util import check_format
-from .world import World
-from .world import parse_world as _parse_world
-
-
-def parse_map(file: Path) -> TiledMap:
-    """Parse the raw Tiled map into a pytiled_parser type
-
-    Args:
-        file: Path to the map file
-
-    Returns:
-        TiledMap: A parsed and typed TiledMap
-    """
-    parser = check_format(file)
-
-    # The type ignores are because mypy for some reason thinks those functions return Any
-    if parser == "tmx":
-        return tmx_map_parse(file)  # type: ignore
-    else:
-        try:
-            return json_map_parse(file)  # type: ignore
-        except ValueError:
-            raise UnknownFormat(
-                "Unknown Map Format, please use either the TMX or JSON format. "
-                "This message could also mean your map file is invalid or corrupted."
-            )
-
-
-def parse_world(file: Path) -> World:
-    """Parse the raw world file into a pytiled_parser type
-
-    Args:
-        file: Path to the world file
-
-    Returns:
-        World: A parsed and typed World
-    """
-    return _parse_world(file)
+from pathlib import Path
+
+from . import UnknownFormat
+from .parsers.json.tiled_map import parse as json_map_parse
+from .parsers.tmx.tiled_map import parse as tmx_map_parse
+from .tiled_map import TiledMap
+from .util import check_format
+from .world import World
+from .world import parse_world as _parse_world
+
+
+def parse_map(file: Path) -> TiledMap:
+    """Parse the raw Tiled map into a pytiled_parser type
+
+    Args:
+        file: Path to the map file
+
+    Returns:
+        TiledMap: A parsed and typed TiledMap
+    """
+    parser = check_format(file)
+
+    # The type ignores are because mypy for some reason thinks those functions return Any
+    if parser == "tmx":
+        return tmx_map_parse(file)  # type: ignore
+    else:
+        try:
+            return json_map_parse(file)  # type: ignore
+        except ValueError:
+            raise UnknownFormat(
+                "Unknown Map Format, please use either the TMX or JSON format. "
+                "This message could also mean your map file is invalid or corrupted."
+            )
+
+
+def parse_world(file: Path) -> World:
+    """Parse the raw world file into a pytiled_parser type
+
+    Args:
+        file: Path to the world file
+
+    Returns:
+        World: A parsed and typed World
+    """
+    return _parse_world(file)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/properties.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/properties.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-"""Property parsing for the JSON Map Format
-"""
-
-from pathlib import Path
-from typing import List, Union, cast
-# from typing_extensions import TypedDict
-from ...properties import Properties, Property
-from ...util import parse_color
-
-
-# RawValue = Union[float, str, bool]
-
-RawValue = float
-
-# class RawProperty(TypedDict):
-#     """The keys and their values that appear in a Tiled JSON Property Object.
-#
-#     Tiled Docs: https://doc.mapeditor.org/en/stable/reference/json-map-format/#property
-#     """
-#     name: str
-#     type: str
-#     value: RawValue
-
-
-def parse(raw_properties):  #: List[RawProperty]) -> Properties:
-    """Parse a list of `RawProperty` objects into `Properties`.
-
-    Args:
-        raw_properties: The list of `RawProperty` objects to parse.
-
-    Returns:
-        Properties: The parsed `Property` objects.
-    """
-
-    final: Properties = {}
-    value: Property
-
-    for raw_property in raw_properties:
-        if raw_property["type"] == "file":
-            value = Path(cast(str, raw_property["value"]))
-        elif raw_property["type"] == "color":
-            value = parse_color(cast(str, raw_property["value"]))
-        else:
-            value = raw_property["value"]
-        final[raw_property["name"]] = value
-
-    return final
+"""Property parsing for the JSON Map Format
+"""
+
+from pathlib import Path
+from typing import List, Union, cast
+# from typing_extensions import TypedDict
+from ...properties import Properties, Property
+from ...util import parse_color
+
+
+# RawValue = Union[float, str, bool]
+
+RawValue = float
+
+# class RawProperty(TypedDict):
+#     """The keys and their values that appear in a Tiled JSON Property Object.
+#
+#     Tiled Docs: https://doc.mapeditor.org/en/stable/reference/json-map-format/#property
+#     """
+#     name: str
+#     type: str
+#     value: RawValue
+
+
+def parse(raw_properties):  #: List[RawProperty]) -> Properties:
+    """Parse a list of `RawProperty` objects into `Properties`.
+
+    Args:
+        raw_properties: The list of `RawProperty` objects to parse.
+
+    Returns:
+        Properties: The parsed `Property` objects.
+    """
+
+    final: Properties = {}
+    value: Property
+
+    for raw_property in raw_properties:
+        if raw_property["type"] == "file":
+            value = Path(cast(str, raw_property["value"]))
+        elif raw_property["type"] == "color":
+            value = parse_color(cast(str, raw_property["value"]))
+        else:
+            value = raw_property["value"]
+        final[raw_property["name"]] = value
+
+    return final
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_object.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_object.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,368 +1,368 @@
-"""Object parsing for the JSON Map Format.
-"""
-from pathlib import Path
-from typing import Any, Callable, Dict, List, Optional
-
-# from typing_extensions import TypedDict
-
-from ...common_types import OrderedPair, Size
-# from pytiled_parser.parsers.json.properties import RawProperty
-from ...parsers.json.properties import parse as parse_properties
-from ...tiled_object import (
-    Ellipse,
-    Point,
-    Polygon,
-    Polyline,
-    Rectangle,
-    Text,
-    Tile,
-    TiledObject,
-)
-from ...util import load_object_template, parse_color
-
-RawText = {
-    "text": '',
-    "color": '',
-    "fontfamily": '',
-    "pixelsize": 0.0,  # this is `font_size` in Text
-    "bold": False,
-    "italic": False,
-    "strikeout": False,
-    "underline": False,
-    "kerning": False,
-    "halign": '',
-    "valign": '',
-    "wrap": False,
-}
-
-# RawText = TypedDict(
-#     "RawText",
-#     {
-#         "text": str,
-#         "color": str,
-#         "fontfamily": str,
-#         "pixelsize": float,  # this is `font_size` in Text
-#         "bold": bool,
-#         "italic": bool,
-#         "strikeout": bool,
-#         "underline": bool,
-#         "kerning": bool,
-#         "halign": str,
-#         "valign": str,
-#         "wrap": bool,
-#     },
-# )
-# RawText.__doc__ = """
-#     The keys and their types that appear in a Tiled JSON Text Object.
-#
-#     Tiled Doc: https://doc.mapeditor.org/en/stable/reference/json-map-format/#text-example
-# """
-
-
-# RawObject = TypedDict(
-#     "RawObject",
-#     {
-#         "id": int,
-#         "gid": int,
-#         "template": str,
-#         "x": float,
-#         "y": float,
-#         "width": float,
-#         "height": float,
-#         "rotation": float,
-#         "visible": bool,
-#         "name": str,
-#         "class": str,
-#         "type": str,
-#         "properties": List[RawProperty],
-#         "ellipse": bool,
-#         "point": bool,
-#         "polygon": List[Dict[str, float]],
-#         "polyline": List[Dict[str, float]],
-#         "text": RawText,
-#     },
-# )
-RawObject = {
-    "id": 0,
-    "gid": 0,
-    "template": '',
-    "x": 0.0,
-    "y": 0.0,
-    "width": 0.0,
-    "height":0.0,
-    "rotation": 0.0,
-    "visible": False,
-    "name": '',
-    "class": '',
-    "type": '',
-    "properties": list(), # List[RawProperty],
-    "ellipse": False,
-    "point": False,
-    "polygon": list(),
-    "polyline": list(),
-    "text": '',
-}
-
-# RawObject.__doc__ = """
-#     The keys and their types that appear in a Tiled JSON Object.
-#
-#     Tiled Doc: https://doc.mapeditor.org/en/stable/reference/json-map-format/#object
-# """
-
-
-def _parse_common(raw_object: RawObject) -> TiledObject:
-    """Create an Object containing all the attributes common to all types of objects.
-
-    Args:
-        raw_object: Raw object to get common attributes from
-
-    Returns:
-        Object: The attributes in common of all types of objects
-    """
-
-    common = TiledObject(
-        id=raw_object["id"],
-        coordinates=OrderedPair(raw_object["x"], raw_object["y"]),
-        visible=raw_object["visible"],
-        size=Size(raw_object["width"], raw_object["height"]),
-        rotation=raw_object["rotation"],
-        name=raw_object["name"],
-    )
-
-    if raw_object.get("type") is not None:
-        common.class_ = raw_object["type"]
-
-    if raw_object.get("class") is not None:
-        common.class_ = raw_object["class"]
-
-    if raw_object.get("properties") is not None:
-        common.properties = parse_properties(raw_object["properties"])
-
-    return common
-
-
-def _parse_ellipse(raw_object: RawObject) -> Ellipse:
-    """Parse the raw object into an Ellipse.
-
-    Args:
-        raw_object: Raw object to be parsed to an Ellipse
-
-    Returns:
-        Ellipse: The Ellipse object created from the raw object
-    """
-    return Ellipse(**_parse_common(raw_object).__dict__)
-
-
-def _parse_rectangle(raw_object: RawObject) -> Rectangle:
-    """Parse the raw object into a Rectangle.
-
-    Args:
-        raw_object: Raw object to be parsed to a Rectangle
-
-    Returns:
-        Rectangle: The Rectangle object created from the raw object
-    """
-    return Rectangle(**_parse_common(raw_object).__dict__)
-
-
-def _parse_point(raw_object: RawObject) -> Point:
-    """Parse the raw object into a Point.
-
-    Args:
-        raw_object: Raw object to be parsed to a Point
-
-    Returns:
-        Point: The Point object created from the raw object
-    """
-    return Point(**_parse_common(raw_object).__dict__)
-
-
-def _parse_polygon(raw_object: RawObject) -> Polygon:
-    """Parse the raw object into a Polygon.
-
-    Args:
-        raw_object: Raw object to be parsed to a Polygon
-
-    Returns:
-        Polygon: The Polygon object created from the raw object
-    """
-    polygon = []
-    for point in raw_object["polygon"]:
-        polygon.append(OrderedPair(point["x"], point["y"]))
-
-    return Polygon(points=polygon, **_parse_common(raw_object).__dict__)
-
-
-def _parse_polyline(raw_object: RawObject) -> Polyline:
-    """Parse the raw object into a Polyline.
-
-    Args:
-        raw_object: Raw object to be parsed to a Polyline
-
-    Returns:
-        Polyline: The Polyline object created from the raw object
-    """
-    polyline = []
-    for point in raw_object["polyline"]:
-        polyline.append(OrderedPair(point["x"], point["y"]))
-
-    return Polyline(points=polyline, **_parse_common(raw_object).__dict__)
-
-
-def _parse_tile(
-    raw_object: RawObject,
-    new_tileset: Optional[Dict[str, Any]] = None,
-    new_tileset_path: Optional[Path] = None,
-) -> Tile:
-    """Parse the raw object into a Tile.
-
-    Args:
-        raw_object: Raw object to be parsed to a Tile
-
-    Returns:
-        Tile: The Tile object created from the raw object
-    """
-    gid = raw_object["gid"]
-
-    return Tile(
-        gid=gid,
-        new_tileset=new_tileset,
-        new_tileset_path=new_tileset_path,
-        **_parse_common(raw_object).__dict__
-    )
-
-
-def _parse_text(raw_object: RawObject) -> Text:
-    """Parse the raw object into Text.
-
-    Args:
-        raw_object: Raw object to be parsed to a Text
-
-    Returns:
-        Text: The Text object created from the raw object
-    """
-    # required attributes
-    raw_text: RawText = raw_object["text"]
-    text = raw_text["text"]
-
-    # create base Text object
-    text_object = Text(text=text, **_parse_common(raw_object).__dict__)
-
-    # optional attributes
-    if raw_text.get("color") is not None:
-        text_object.color = parse_color(raw_text["color"])
-
-    if raw_text.get("fontfamily") is not None:
-        text_object.font_family = raw_text["fontfamily"]
-
-    if raw_text.get("pixelsize") is not None:
-        text_object.font_size = raw_text["pixelsize"]
-
-    if raw_text.get("bold") is not None:
-        text_object.bold = raw_text["bold"]
-
-    if raw_text.get("italic") is not None:
-        text_object.italic = raw_text["italic"]
-
-    if raw_text.get("kerning") is not None:
-        text_object.kerning = raw_text["kerning"]
-
-    if raw_text.get("strikeout") is not None:
-        text_object.strike_out = raw_text["strikeout"]
-
-    if raw_text.get("underline") is not None:
-        text_object.underline = raw_text["underline"]
-
-    if raw_text.get("halign") is not None:
-        text_object.horizontal_align = raw_text["halign"]
-
-    if raw_text.get("valign") is not None:
-        text_object.vertical_align = raw_text["valign"]
-
-    if raw_text.get("wrap") is not None:
-        text_object.wrap = raw_text["wrap"]
-
-    return text_object
-
-
-def _get_parser(raw_object: RawObject) -> Callable[[RawObject], TiledObject]:
-    """Get the parser function for a given raw object.
-
-    Only used internally by the JSON parser.
-
-    Args:
-        raw_object: Raw object that is analyzed to determine the parser function.
-
-    Returns:
-        Callable[[RawObject], Object]: The parser function.
-    """
-    if raw_object.get("ellipse"):
-        return _parse_ellipse
-
-    if raw_object.get("point"):
-        return _parse_point
-
-    # This is excluded from tests because the coverage is broken. I promise
-    # there are tests for Tile objects, but for some reason the coverage
-    # isn't picking up this if statement(though it does pickup the _parse_tile)
-    # function so who knows
-    if raw_object.get("gid"):  # pragma: no cover
-        # Only tile objects have the `gid` key
-        return _parse_tile
-
-    if raw_object.get("polygon"):
-        return _parse_polygon
-
-    if raw_object.get("polyline"):
-        return _parse_polyline
-
-    if raw_object.get("text"):
-        return _parse_text
-
-    # If it's none of the above, rectangle is the only one left.
-    # Rectangle is the only object which has no special properties to signify that.
-    return _parse_rectangle
-
-
-def parse(
-    raw_object: RawObject,
-    parent_dir: Optional[Path] = None,
-) -> TiledObject:
-    """Parse the raw object into a pytiled_parser version
-
-    Args:
-        raw_object: Raw object that is to be cast.
-        parent_dir: The parent directory that the map file is in.
-
-    Returns:
-        Object: A parsed Object.
-
-    Raises:
-        RuntimeError: When a parameter that is conditionally required was not sent.
-    """
-    new_tileset = None
-    new_tileset_path = None
-
-    if raw_object.get("template"):
-        if not parent_dir:
-            raise RuntimeError(
-                "A parent directory must be specified when using object templates."
-            )
-        template_path = Path(parent_dir / raw_object["template"])
-        template, new_tileset, new_tileset_path = load_object_template(template_path)
-
-        if isinstance(template, dict):
-            loaded_template = template["object"]
-            for key in loaded_template:
-                if key != "id":
-                    raw_object[key] = loaded_template[key]  # type: ignore
-        else:
-            raise NotImplementedError(
-                "Loading TMX object templates inside a JSON map is currently not supported, "
-                "but will be in a future release."
-            )
-
-    if raw_object.get("gid"):
-        return _parse_tile(raw_object, new_tileset, new_tileset_path)
-
-    return _get_parser(raw_object)(raw_object)
+"""Object parsing for the JSON Map Format.
+"""
+from pathlib import Path
+from typing import Any, Callable, Dict, List, Optional
+
+# from typing_extensions import TypedDict
+
+from ...common_types import OrderedPair, Size
+# from pytiled_parser.parsers.json.properties import RawProperty
+from ...parsers.json.properties import parse as parse_properties
+from ...tiled_object import (
+    Ellipse,
+    Point,
+    Polygon,
+    Polyline,
+    Rectangle,
+    Text,
+    Tile,
+    TiledObject,
+)
+from ...util import load_object_template, parse_color
+
+RawText = {
+    "text": '',
+    "color": '',
+    "fontfamily": '',
+    "pixelsize": 0.0,  # this is `font_size` in Text
+    "bold": False,
+    "italic": False,
+    "strikeout": False,
+    "underline": False,
+    "kerning": False,
+    "halign": '',
+    "valign": '',
+    "wrap": False,
+}
+
+# RawText = TypedDict(
+#     "RawText",
+#     {
+#         "text": str,
+#         "color": str,
+#         "fontfamily": str,
+#         "pixelsize": float,  # this is `font_size` in Text
+#         "bold": bool,
+#         "italic": bool,
+#         "strikeout": bool,
+#         "underline": bool,
+#         "kerning": bool,
+#         "halign": str,
+#         "valign": str,
+#         "wrap": bool,
+#     },
+# )
+# RawText.__doc__ = """
+#     The keys and their types that appear in a Tiled JSON Text Object.
+#
+#     Tiled Doc: https://doc.mapeditor.org/en/stable/reference/json-map-format/#text-example
+# """
+
+
+# RawObject = TypedDict(
+#     "RawObject",
+#     {
+#         "id": int,
+#         "gid": int,
+#         "template": str,
+#         "x": float,
+#         "y": float,
+#         "width": float,
+#         "height": float,
+#         "rotation": float,
+#         "visible": bool,
+#         "name": str,
+#         "class": str,
+#         "type": str,
+#         "properties": List[RawProperty],
+#         "ellipse": bool,
+#         "point": bool,
+#         "polygon": List[Dict[str, float]],
+#         "polyline": List[Dict[str, float]],
+#         "text": RawText,
+#     },
+# )
+RawObject = {
+    "id": 0,
+    "gid": 0,
+    "template": '',
+    "x": 0.0,
+    "y": 0.0,
+    "width": 0.0,
+    "height":0.0,
+    "rotation": 0.0,
+    "visible": False,
+    "name": '',
+    "class": '',
+    "type": '',
+    "properties": list(), # List[RawProperty],
+    "ellipse": False,
+    "point": False,
+    "polygon": list(),
+    "polyline": list(),
+    "text": '',
+}
+
+# RawObject.__doc__ = """
+#     The keys and their types that appear in a Tiled JSON Object.
+#
+#     Tiled Doc: https://doc.mapeditor.org/en/stable/reference/json-map-format/#object
+# """
+
+
+def _parse_common(raw_object: RawObject) -> TiledObject:
+    """Create an Object containing all the attributes common to all types of objects.
+
+    Args:
+        raw_object: Raw object to get common attributes from
+
+    Returns:
+        Object: The attributes in common of all types of objects
+    """
+
+    common = TiledObject(
+        id=raw_object["id"],
+        coordinates=OrderedPair(raw_object["x"], raw_object["y"]),
+        visible=raw_object["visible"],
+        size=Size(raw_object["width"], raw_object["height"]),
+        rotation=raw_object["rotation"],
+        name=raw_object["name"],
+    )
+
+    if raw_object.get("type") is not None:
+        common.class_ = raw_object["type"]
+
+    if raw_object.get("class") is not None:
+        common.class_ = raw_object["class"]
+
+    if raw_object.get("properties") is not None:
+        common.properties = parse_properties(raw_object["properties"])
+
+    return common
+
+
+def _parse_ellipse(raw_object: RawObject) -> Ellipse:
+    """Parse the raw object into an Ellipse.
+
+    Args:
+        raw_object: Raw object to be parsed to an Ellipse
+
+    Returns:
+        Ellipse: The Ellipse object created from the raw object
+    """
+    return Ellipse(**_parse_common(raw_object).__dict__)
+
+
+def _parse_rectangle(raw_object: RawObject) -> Rectangle:
+    """Parse the raw object into a Rectangle.
+
+    Args:
+        raw_object: Raw object to be parsed to a Rectangle
+
+    Returns:
+        Rectangle: The Rectangle object created from the raw object
+    """
+    return Rectangle(**_parse_common(raw_object).__dict__)
+
+
+def _parse_point(raw_object: RawObject) -> Point:
+    """Parse the raw object into a Point.
+
+    Args:
+        raw_object: Raw object to be parsed to a Point
+
+    Returns:
+        Point: The Point object created from the raw object
+    """
+    return Point(**_parse_common(raw_object).__dict__)
+
+
+def _parse_polygon(raw_object: RawObject) -> Polygon:
+    """Parse the raw object into a Polygon.
+
+    Args:
+        raw_object: Raw object to be parsed to a Polygon
+
+    Returns:
+        Polygon: The Polygon object created from the raw object
+    """
+    polygon = []
+    for point in raw_object["polygon"]:
+        polygon.append(OrderedPair(point["x"], point["y"]))
+
+    return Polygon(points=polygon, **_parse_common(raw_object).__dict__)
+
+
+def _parse_polyline(raw_object: RawObject) -> Polyline:
+    """Parse the raw object into a Polyline.
+
+    Args:
+        raw_object: Raw object to be parsed to a Polyline
+
+    Returns:
+        Polyline: The Polyline object created from the raw object
+    """
+    polyline = []
+    for point in raw_object["polyline"]:
+        polyline.append(OrderedPair(point["x"], point["y"]))
+
+    return Polyline(points=polyline, **_parse_common(raw_object).__dict__)
+
+
+def _parse_tile(
+    raw_object: RawObject,
+    new_tileset: Optional[Dict[str, Any]] = None,
+    new_tileset_path: Optional[Path] = None,
+) -> Tile:
+    """Parse the raw object into a Tile.
+
+    Args:
+        raw_object: Raw object to be parsed to a Tile
+
+    Returns:
+        Tile: The Tile object created from the raw object
+    """
+    gid = raw_object["gid"]
+
+    return Tile(
+        gid=gid,
+        new_tileset=new_tileset,
+        new_tileset_path=new_tileset_path,
+        **_parse_common(raw_object).__dict__
+    )
+
+
+def _parse_text(raw_object: RawObject) -> Text:
+    """Parse the raw object into Text.
+
+    Args:
+        raw_object: Raw object to be parsed to a Text
+
+    Returns:
+        Text: The Text object created from the raw object
+    """
+    # required attributes
+    raw_text: RawText = raw_object["text"]
+    text = raw_text["text"]
+
+    # create base Text object
+    text_object = Text(text=text, **_parse_common(raw_object).__dict__)
+
+    # optional attributes
+    if raw_text.get("color") is not None:
+        text_object.color = parse_color(raw_text["color"])
+
+    if raw_text.get("fontfamily") is not None:
+        text_object.font_family = raw_text["fontfamily"]
+
+    if raw_text.get("pixelsize") is not None:
+        text_object.font_size = raw_text["pixelsize"]
+
+    if raw_text.get("bold") is not None:
+        text_object.bold = raw_text["bold"]
+
+    if raw_text.get("italic") is not None:
+        text_object.italic = raw_text["italic"]
+
+    if raw_text.get("kerning") is not None:
+        text_object.kerning = raw_text["kerning"]
+
+    if raw_text.get("strikeout") is not None:
+        text_object.strike_out = raw_text["strikeout"]
+
+    if raw_text.get("underline") is not None:
+        text_object.underline = raw_text["underline"]
+
+    if raw_text.get("halign") is not None:
+        text_object.horizontal_align = raw_text["halign"]
+
+    if raw_text.get("valign") is not None:
+        text_object.vertical_align = raw_text["valign"]
+
+    if raw_text.get("wrap") is not None:
+        text_object.wrap = raw_text["wrap"]
+
+    return text_object
+
+
+def _get_parser(raw_object: RawObject) -> Callable[[RawObject], TiledObject]:
+    """Get the parser function for a given raw object.
+
+    Only used internally by the JSON parser.
+
+    Args:
+        raw_object: Raw object that is analyzed to determine the parser function.
+
+    Returns:
+        Callable[[RawObject], Object]: The parser function.
+    """
+    if raw_object.get("ellipse"):
+        return _parse_ellipse
+
+    if raw_object.get("point"):
+        return _parse_point
+
+    # This is excluded from tests because the coverage is broken. I promise
+    # there are tests for Tile objects, but for some reason the coverage
+    # isn't picking up this if statement(though it does pickup the _parse_tile)
+    # function so who knows
+    if raw_object.get("gid"):  # pragma: no cover
+        # Only tile objects have the `gid` key
+        return _parse_tile
+
+    if raw_object.get("polygon"):
+        return _parse_polygon
+
+    if raw_object.get("polyline"):
+        return _parse_polyline
+
+    if raw_object.get("text"):
+        return _parse_text
+
+    # If it's none of the above, rectangle is the only one left.
+    # Rectangle is the only object which has no special properties to signify that.
+    return _parse_rectangle
+
+
+def parse(
+    raw_object: RawObject,
+    parent_dir: Optional[Path] = None,
+) -> TiledObject:
+    """Parse the raw object into a pytiled_parser version
+
+    Args:
+        raw_object: Raw object that is to be cast.
+        parent_dir: The parent directory that the map file is in.
+
+    Returns:
+        Object: A parsed Object.
+
+    Raises:
+        RuntimeError: When a parameter that is conditionally required was not sent.
+    """
+    new_tileset = None
+    new_tileset_path = None
+
+    if raw_object.get("template"):
+        if not parent_dir:
+            raise RuntimeError(
+                "A parent directory must be specified when using object templates."
+            )
+        template_path = Path(parent_dir / raw_object["template"])
+        template, new_tileset, new_tileset_path = load_object_template(template_path)
+
+        if isinstance(template, dict):
+            loaded_template = template["object"]
+            for key in loaded_template:
+                if key != "id":
+                    raw_object[key] = loaded_template[key]  # type: ignore
+        else:
+            raise NotImplementedError(
+                "Loading TMX object templates inside a JSON map is currently not supported, "
+                "but will be in a future release."
+            )
+
+    if raw_object.get("gid"):
+        return _parse_tile(raw_object, new_tileset, new_tileset_path)
+
+    return _get_parser(raw_object)(raw_object)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tileset.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tileset.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,329 +1,329 @@
-from pathlib import Path
-from typing import List, Optional, Union
-# from typing_extensions import TypedDict
-from ...common_types import OrderedPair
-# from pytiled_parser.parsers.json.layer import RawLayer
-from ...parsers.json.layer import parse as parse_layer
-# from pytiled_parser.parsers.json.properties import RawProperty
-from ...parsers.json.properties import parse as parse_properties
-# from pytiled_parser.parsers.json.wang_set import RawWangSet
-# from pytiled_parser.parsers.json.wang_set import parse as parse_wangset
-from ...tileset import Frame, Grid, Tile, Tileset, Transformations
-from ...util import parse_color
-
-
-# RawFrame = TypedDict("RawFrame", {"duration": int, "tileid": int})
-# RawFrame.__doc__ = """
-#     The keys and their types that appear in a Frame JSON Object.
-# """
-
-
-# RawTileOffset = TypedDict("RawTileOffset", {"x": int, "y": int})
-# RawTileOffset.__doc__ = """
-#     The keys and their types that appear in a TileOffset JSON Object.
-# """
-
-
-# RawTransformations = TypedDict(
-#     "RawTransformations",
-#     {"hflip": bool, "vflip": bool, "rotate": bool, "preferuntransformed": bool},
-# )
-# RawTransformations.__doc__ = """
-#     The keys and their types that appear in a Transformations JSON Object.
-# """
-
-
-# RawTile = TypedDict(
-#     "RawTile",
-#     {
-#         "animation": List[RawFrame],
-#         "class": str,
-#         "id": int,
-#         "image": str,
-#         "imageheight": int,
-#         "imagewidth": int,
-#         "opacity": float,
-#         "type": str,
-#         "properties": List[RawProperty],
-#         "objectgroup": RawLayer,
-#         "x": int,
-#         "y": int,
-#         "width": int,
-#         "height": int,
-#     },
-# )
-# RawTile.__doc__ = """
-#     The keys and their types that appear in a Tile JSON Object.
-# """
-
-
-# RawGrid = TypedDict("RawGrid", {"height": int, "width": int, "orientation": str})
-# RawGrid.__doc__ = """
-#     The keys and their types that appear in a Grid JSON Object.
-# """
-
-
-# RawTileSet = TypedDict(
-#     "RawTileSet",
-#     {
-#         "backgroundcolor": str,
-#         "class": str,
-#         "columns": int,
-#         "firstgid": int,
-#         "grid": RawGrid,
-#         "image": str,
-#         "imageheight": int,
-#         "imagewidth": int,
-#         "margin": int,
-#         "name": str,
-#         "properties": List[RawProperty],
-#         "fillmode": str,
-#         "objectalignment": str,
-#         "source": str,
-#         "spacing": int,
-#         "tilecount": int,
-#         "tiledversion": str,
-#         "tileheight": int,
-#         "tileoffset": RawTileOffset,
-#         "tilerendersize": str,
-#         "tiles": List[RawTile],
-#         "tilewidth": int,
-#         "transparentcolor": str,
-#         "transformations": RawTransformations,
-#         "version": Union[str, float],
-#         "wangsets": List[RawWangSet],
-#     },
-# )
-# RawTileSet.__doc__ = """
-#     The keys and their types that appear in a TileSet JSON Object.
-# """
-
-
-def _parse_frame(raw_frame):  #: RawFrame) -> Frame:
-    """Parse the raw_frame to a Frame.
-
-    Args:
-        raw_frame: RawFrame to be parsed to a Frame
-
-    Returns:
-        Frame: The Frame created from the raw_frame
-    """
-
-    return Frame(duration=raw_frame["duration"], tile_id=raw_frame["tileid"])
-
-
-def _parse_tile_offset(raw_tile_offset):  # : RawTileOffset) -> OrderedPair:
-    """Parse the raw_tile_offset to an OrderedPair.
-
-    Args:
-        raw_tile_offset: RawTileOffset to be parsed to an OrderedPair
-
-    Returns:
-        OrderedPair: The OrderedPair created from the raw_tile_offset
-    """
-
-    return OrderedPair(raw_tile_offset["x"], raw_tile_offset["y"])
-
-
-def _parse_transformations(raw_transformations):  #: RawTransformations) -> Transformations:
-    """Parse the raw_transformations to a Transformations object.
-
-    Args:
-        raw_transformations: RawTransformations to be parsed to a Transformations
-
-    Returns:
-        Transformations: The Transformations created from the raw_transformations
-    """
-
-    return Transformations(
-        hflip=raw_transformations["hflip"],
-        vflip=raw_transformations["vflip"],
-        rotate=raw_transformations["rotate"],
-        prefer_untransformed=raw_transformations["preferuntransformed"],
-    )
-
-
-def _parse_grid(raw_grid) -> Grid:  #raw_grid : RawGrid
-    """Parse the raw_grid to a Grid object.
-
-    Args:
-        raw_grid: RawGrid to be parsed to a Grid
-
-    Returns:
-        Grid: The Grid created from the raw_grid
-    """
-
-    return Grid(
-        orientation=raw_grid["orientation"],
-        width=raw_grid["width"],
-        height=raw_grid["height"],
-    )
-
-
-def _parse_tile(raw_tile, external_path: Optional[Path] = None) -> Tile:  #raw_tile: RawTile
-    """Parse the raw_tile to a Tile object.
-
-    Args:
-        raw_tile: RawTile to be parsed to a Tile
-
-    Returns:
-        Tile: The Tile created from the raw_tile
-    """
-
-    id_ = raw_tile["id"]
-    tile = Tile(id=id_)
-
-    if raw_tile.get("animation") is not None:
-        tile.animation = []
-        for frame in raw_tile["animation"]:
-            tile.animation.append(_parse_frame(frame))
-
-    if raw_tile.get("objectgroup") is not None:
-        tile.objects = parse_layer(raw_tile["objectgroup"])
-
-    if raw_tile.get("properties") is not None:
-        tile.properties = parse_properties(raw_tile["properties"])
-
-    if raw_tile.get("image") is not None:
-        if external_path:
-            tile.image = Path(external_path / raw_tile["image"]).absolute().resolve()
-        else:
-            tile.image = Path(raw_tile["image"])
-
-    # These are ignored from coverage because there does not exist a scenario where
-    # image is set, but these aren't, so the branches will never fully be hit.
-    # However, leaving these checks in place is nice to prevent fatal errors on
-    # a manually edited map that has an "incorrect" but not "unusable" structure
-    #
-    # We also set the width and height attributes here as the values for these in
-    # Tiled defaults to the same value as imagewidth and imageheight if no custom value
-    # is set. We then later load in the custom value if it exists.
-    if raw_tile.get("imagewidth") is not None:  # pragma: no cover
-        tile.image_width = raw_tile["imagewidth"]
-        tile.width = tile.image_width
-
-    if raw_tile.get("imageheight") is not None:  # pragma: no cover
-        tile.image_height = raw_tile["imageheight"]
-        tile.height = tile.image_height
-
-    if raw_tile.get("type") is not None:
-        tile.class_ = raw_tile["type"]
-
-    if raw_tile.get("class") is not None:
-        tile.class_ = raw_tile["class"]
-
-    if raw_tile.get("x") is not None:
-        tile.x = raw_tile["x"]
-
-    if raw_tile.get("y") is not None:
-        tile.y = raw_tile["y"]
-
-    if raw_tile.get("width") is not None:
-        tile.width = raw_tile["width"]
-
-    if raw_tile.get("height") is not None:
-        tile.height = raw_tile["height"]
-
-    return tile
-
-
-def parse(
-    raw_tileset, # : RawTileSet,
-    firstgid: int,
-    external_path: Optional[Path] = None,
-) -> Tileset:
-    """Parse the raw tileset into a pytiled_parser type
-
-    Args:
-        raw_tileset: Raw Tileset to be parsed.
-        firstgid: GID corresponding the first tile in the set.
-        external_path: The path to the tileset if it is not an embedded one.
-
-    Returns:
-        TileSet: a properly typed TileSet.
-    """
-
-    tileset = Tileset(
-        name=raw_tileset["name"],
-        tile_count=raw_tileset["tilecount"],
-        tile_width=raw_tileset["tilewidth"],
-        tile_height=raw_tileset["tileheight"],
-        columns=raw_tileset["columns"],
-        spacing=raw_tileset["spacing"],
-        margin=raw_tileset["margin"],
-        firstgid=firstgid,
-    )
-
-    if raw_tileset.get("version") is not None:
-        # This is here to support old versions of Tiled Maps. It's a pain
-        # to keep old versions in the test data and not update them with the
-        # rest so I'm excluding this from coverage. In reality it's probably
-        # not needed. Tiled hasn't been using floats for the version for a long time
-        if isinstance(raw_tileset["version"], float):  # pragma: no cover
-            tileset.version = str(raw_tileset["version"])
-        else:
-            tileset.version = raw_tileset["version"]
-
-    if raw_tileset.get("tiledversion") is not None:
-        tileset.tiled_version = raw_tileset["tiledversion"]
-
-    if raw_tileset.get("image") is not None:
-        if external_path:
-            tileset.image = (
-                Path(external_path / raw_tileset["image"]).absolute().resolve()
-            )
-        else:
-            tileset.image = Path(raw_tileset["image"])
-
-    # See above note about imagewidth and imageheight on parse_tile function
-    # for an explanation on why these are ignored
-    if raw_tileset.get("imagewidth") is not None:  # pragma: no cover
-        tileset.image_width = raw_tileset["imagewidth"]
-
-    if raw_tileset.get("imageheight") is not None:  # pragma: no cover
-        tileset.image_height = raw_tileset["imageheight"]
-
-    if raw_tileset.get("objectalignment") is not None:
-        tileset.alignment = raw_tileset["objectalignment"]
-
-    if raw_tileset.get("backgroundcolor") is not None:
-        tileset.background_color = parse_color(raw_tileset["backgroundcolor"])
-
-    if raw_tileset.get("tileoffset") is not None:
-        tileset.tile_offset = _parse_tile_offset(raw_tileset["tileoffset"])
-
-    if raw_tileset.get("transparentcolor") is not None:
-        tileset.transparent_color = parse_color(raw_tileset["transparentcolor"])
-
-    if raw_tileset.get("grid") is not None:
-        tileset.grid = _parse_grid(raw_tileset["grid"])
-
-    if raw_tileset.get("properties") is not None:
-        tileset.properties = parse_properties(raw_tileset["properties"])
-
-    if raw_tileset.get("tiles") is not None:
-        tiles = {}
-        for raw_tile in raw_tileset["tiles"]:
-            tiles[raw_tile["id"]] = _parse_tile(raw_tile, external_path=external_path)
-        tileset.tiles = tiles
-
-    if raw_tileset.get("wangsets") is not None:
-        print('*** WARN: wangsets not supported by this PARSER ***')
-        wangsets = []
-        # for raw_wangset in raw_tileset["wangsets"]:
-        #     wangsets.append(parse_wangset(raw_wangset))
-        tileset.wang_sets = wangsets
-
-    if raw_tileset.get("transformations") is not None:
-        tileset.transformations = _parse_transformations(raw_tileset["transformations"])
-
-    if raw_tileset.get("class") is not None:
-        tileset.class_ = raw_tileset["class"]
-
-    if raw_tileset.get("tilerendersize") is not None:
-        tileset.tile_render_size = raw_tileset["tilerendersize"]
-
-    if raw_tileset.get("fillmode") is not None:
-        tileset.fill_mode = raw_tileset["fillmode"]
-
-    return tileset
+from pathlib import Path
+from typing import List, Optional, Union
+# from typing_extensions import TypedDict
+from ...common_types import OrderedPair
+# from pytiled_parser.parsers.json.layer import RawLayer
+from ...parsers.json.layer import parse as parse_layer
+# from pytiled_parser.parsers.json.properties import RawProperty
+from ...parsers.json.properties import parse as parse_properties
+# from pytiled_parser.parsers.json.wang_set import RawWangSet
+# from pytiled_parser.parsers.json.wang_set import parse as parse_wangset
+from ...tileset import Frame, Grid, Tile, Tileset, Transformations
+from ...util import parse_color
+
+
+# RawFrame = TypedDict("RawFrame", {"duration": int, "tileid": int})
+# RawFrame.__doc__ = """
+#     The keys and their types that appear in a Frame JSON Object.
+# """
+
+
+# RawTileOffset = TypedDict("RawTileOffset", {"x": int, "y": int})
+# RawTileOffset.__doc__ = """
+#     The keys and their types that appear in a TileOffset JSON Object.
+# """
+
+
+# RawTransformations = TypedDict(
+#     "RawTransformations",
+#     {"hflip": bool, "vflip": bool, "rotate": bool, "preferuntransformed": bool},
+# )
+# RawTransformations.__doc__ = """
+#     The keys and their types that appear in a Transformations JSON Object.
+# """
+
+
+# RawTile = TypedDict(
+#     "RawTile",
+#     {
+#         "animation": List[RawFrame],
+#         "class": str,
+#         "id": int,
+#         "image": str,
+#         "imageheight": int,
+#         "imagewidth": int,
+#         "opacity": float,
+#         "type": str,
+#         "properties": List[RawProperty],
+#         "objectgroup": RawLayer,
+#         "x": int,
+#         "y": int,
+#         "width": int,
+#         "height": int,
+#     },
+# )
+# RawTile.__doc__ = """
+#     The keys and their types that appear in a Tile JSON Object.
+# """
+
+
+# RawGrid = TypedDict("RawGrid", {"height": int, "width": int, "orientation": str})
+# RawGrid.__doc__ = """
+#     The keys and their types that appear in a Grid JSON Object.
+# """
+
+
+# RawTileSet = TypedDict(
+#     "RawTileSet",
+#     {
+#         "backgroundcolor": str,
+#         "class": str,
+#         "columns": int,
+#         "firstgid": int,
+#         "grid": RawGrid,
+#         "image": str,
+#         "imageheight": int,
+#         "imagewidth": int,
+#         "margin": int,
+#         "name": str,
+#         "properties": List[RawProperty],
+#         "fillmode": str,
+#         "objectalignment": str,
+#         "source": str,
+#         "spacing": int,
+#         "tilecount": int,
+#         "tiledversion": str,
+#         "tileheight": int,
+#         "tileoffset": RawTileOffset,
+#         "tilerendersize": str,
+#         "tiles": List[RawTile],
+#         "tilewidth": int,
+#         "transparentcolor": str,
+#         "transformations": RawTransformations,
+#         "version": Union[str, float],
+#         "wangsets": List[RawWangSet],
+#     },
+# )
+# RawTileSet.__doc__ = """
+#     The keys and their types that appear in a TileSet JSON Object.
+# """
+
+
+def _parse_frame(raw_frame):  #: RawFrame) -> Frame:
+    """Parse the raw_frame to a Frame.
+
+    Args:
+        raw_frame: RawFrame to be parsed to a Frame
+
+    Returns:
+        Frame: The Frame created from the raw_frame
+    """
+
+    return Frame(duration=raw_frame["duration"], tile_id=raw_frame["tileid"])
+
+
+def _parse_tile_offset(raw_tile_offset):  # : RawTileOffset) -> OrderedPair:
+    """Parse the raw_tile_offset to an OrderedPair.
+
+    Args:
+        raw_tile_offset: RawTileOffset to be parsed to an OrderedPair
+
+    Returns:
+        OrderedPair: The OrderedPair created from the raw_tile_offset
+    """
+
+    return OrderedPair(raw_tile_offset["x"], raw_tile_offset["y"])
+
+
+def _parse_transformations(raw_transformations):  #: RawTransformations) -> Transformations:
+    """Parse the raw_transformations to a Transformations object.
+
+    Args:
+        raw_transformations: RawTransformations to be parsed to a Transformations
+
+    Returns:
+        Transformations: The Transformations created from the raw_transformations
+    """
+
+    return Transformations(
+        hflip=raw_transformations["hflip"],
+        vflip=raw_transformations["vflip"],
+        rotate=raw_transformations["rotate"],
+        prefer_untransformed=raw_transformations["preferuntransformed"],
+    )
+
+
+def _parse_grid(raw_grid) -> Grid:  #raw_grid : RawGrid
+    """Parse the raw_grid to a Grid object.
+
+    Args:
+        raw_grid: RawGrid to be parsed to a Grid
+
+    Returns:
+        Grid: The Grid created from the raw_grid
+    """
+
+    return Grid(
+        orientation=raw_grid["orientation"],
+        width=raw_grid["width"],
+        height=raw_grid["height"],
+    )
+
+
+def _parse_tile(raw_tile, external_path: Optional[Path] = None) -> Tile:  #raw_tile: RawTile
+    """Parse the raw_tile to a Tile object.
+
+    Args:
+        raw_tile: RawTile to be parsed to a Tile
+
+    Returns:
+        Tile: The Tile created from the raw_tile
+    """
+
+    id_ = raw_tile["id"]
+    tile = Tile(id=id_)
+
+    if raw_tile.get("animation") is not None:
+        tile.animation = []
+        for frame in raw_tile["animation"]:
+            tile.animation.append(_parse_frame(frame))
+
+    if raw_tile.get("objectgroup") is not None:
+        tile.objects = parse_layer(raw_tile["objectgroup"])
+
+    if raw_tile.get("properties") is not None:
+        tile.properties = parse_properties(raw_tile["properties"])
+
+    if raw_tile.get("image") is not None:
+        if external_path:
+            tile.image = Path(external_path / raw_tile["image"]).absolute().resolve()
+        else:
+            tile.image = Path(raw_tile["image"])
+
+    # These are ignored from coverage because there does not exist a scenario where
+    # image is set, but these aren't, so the branches will never fully be hit.
+    # However, leaving these checks in place is nice to prevent fatal errors on
+    # a manually edited map that has an "incorrect" but not "unusable" structure
+    #
+    # We also set the width and height attributes here as the values for these in
+    # Tiled defaults to the same value as imagewidth and imageheight if no custom value
+    # is set. We then later load in the custom value if it exists.
+    if raw_tile.get("imagewidth") is not None:  # pragma: no cover
+        tile.image_width = raw_tile["imagewidth"]
+        tile.width = tile.image_width
+
+    if raw_tile.get("imageheight") is not None:  # pragma: no cover
+        tile.image_height = raw_tile["imageheight"]
+        tile.height = tile.image_height
+
+    if raw_tile.get("type") is not None:
+        tile.class_ = raw_tile["type"]
+
+    if raw_tile.get("class") is not None:
+        tile.class_ = raw_tile["class"]
+
+    if raw_tile.get("x") is not None:
+        tile.x = raw_tile["x"]
+
+    if raw_tile.get("y") is not None:
+        tile.y = raw_tile["y"]
+
+    if raw_tile.get("width") is not None:
+        tile.width = raw_tile["width"]
+
+    if raw_tile.get("height") is not None:
+        tile.height = raw_tile["height"]
+
+    return tile
+
+
+def parse(
+    raw_tileset, # : RawTileSet,
+    firstgid: int,
+    external_path: Optional[Path] = None,
+) -> Tileset:
+    """Parse the raw tileset into a pytiled_parser type
+
+    Args:
+        raw_tileset: Raw Tileset to be parsed.
+        firstgid: GID corresponding the first tile in the set.
+        external_path: The path to the tileset if it is not an embedded one.
+
+    Returns:
+        TileSet: a properly typed TileSet.
+    """
+
+    tileset = Tileset(
+        name=raw_tileset["name"],
+        tile_count=raw_tileset["tilecount"],
+        tile_width=raw_tileset["tilewidth"],
+        tile_height=raw_tileset["tileheight"],
+        columns=raw_tileset["columns"],
+        spacing=raw_tileset["spacing"],
+        margin=raw_tileset["margin"],
+        firstgid=firstgid,
+    )
+
+    if raw_tileset.get("version") is not None:
+        # This is here to support old versions of Tiled Maps. It's a pain
+        # to keep old versions in the test data and not update them with the
+        # rest so I'm excluding this from coverage. In reality it's probably
+        # not needed. Tiled hasn't been using floats for the version for a long time
+        if isinstance(raw_tileset["version"], float):  # pragma: no cover
+            tileset.version = str(raw_tileset["version"])
+        else:
+            tileset.version = raw_tileset["version"]
+
+    if raw_tileset.get("tiledversion") is not None:
+        tileset.tiled_version = raw_tileset["tiledversion"]
+
+    if raw_tileset.get("image") is not None:
+        if external_path:
+            tileset.image = (
+                Path(external_path / raw_tileset["image"]).absolute().resolve()
+            )
+        else:
+            tileset.image = Path(raw_tileset["image"])
+
+    # See above note about imagewidth and imageheight on parse_tile function
+    # for an explanation on why these are ignored
+    if raw_tileset.get("imagewidth") is not None:  # pragma: no cover
+        tileset.image_width = raw_tileset["imagewidth"]
+
+    if raw_tileset.get("imageheight") is not None:  # pragma: no cover
+        tileset.image_height = raw_tileset["imageheight"]
+
+    if raw_tileset.get("objectalignment") is not None:
+        tileset.alignment = raw_tileset["objectalignment"]
+
+    if raw_tileset.get("backgroundcolor") is not None:
+        tileset.background_color = parse_color(raw_tileset["backgroundcolor"])
+
+    if raw_tileset.get("tileoffset") is not None:
+        tileset.tile_offset = _parse_tile_offset(raw_tileset["tileoffset"])
+
+    if raw_tileset.get("transparentcolor") is not None:
+        tileset.transparent_color = parse_color(raw_tileset["transparentcolor"])
+
+    if raw_tileset.get("grid") is not None:
+        tileset.grid = _parse_grid(raw_tileset["grid"])
+
+    if raw_tileset.get("properties") is not None:
+        tileset.properties = parse_properties(raw_tileset["properties"])
+
+    if raw_tileset.get("tiles") is not None:
+        tiles = {}
+        for raw_tile in raw_tileset["tiles"]:
+            tiles[raw_tile["id"]] = _parse_tile(raw_tile, external_path=external_path)
+        tileset.tiles = tiles
+
+    if raw_tileset.get("wangsets") is not None:
+        print('*** WARN: wangsets not supported by this PARSER ***')
+        wangsets = []
+        # for raw_wangset in raw_tileset["wangsets"]:
+        #     wangsets.append(parse_wangset(raw_wangset))
+        tileset.wang_sets = wangsets
+
+    if raw_tileset.get("transformations") is not None:
+        tileset.transformations = _parse_transformations(raw_tileset["transformations"])
+
+    if raw_tileset.get("class") is not None:
+        tileset.class_ = raw_tileset["class"]
+
+    if raw_tileset.get("tilerendersize") is not None:
+        tileset.tile_render_size = raw_tileset["tilerendersize"]
+
+    if raw_tileset.get("fillmode") is not None:
+        tileset.fill_mode = raw_tileset["fillmode"]
+
+    return tileset
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/wang_set.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/wang_set.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,120 +1,120 @@
-from typing import List
-
-# from typing_extensions import TypedDict
-
-# from pytiled_parser.parsers.json.properties import RawProperty
-from pytiled_parser.parsers.json.properties import parse as parse_properties
-from pytiled_parser.util import parse_color
-from pytiled_parser.wang_set import WangColor, WangSet, WangTile
-
-RawWangTile = TypedDict(
-    "RawWangTile",
-    {
-        "tileid": int,
-        # Tiled stores these IDs as a list represented like so:
-        # [top, top_right, right, bottom_right, bottom, bottom_left, left, top_left]
-        "wangid": List[int],
-    },
-)
-RawWangTile.__doc__ = """
-    The keys and their types that appear in a Wang Tile JSON Object.
-"""
-
-
-RawWangColor = TypedDict(
-    "RawWangColor",
-    {
-        "color": str,
-        "class": str,
-        "name": str,
-        "probability": float,
-        "tile": int,
-        "properties": List[RawProperty],
-    },
-)
-RawWangColor.__doc__ = """
-    The keys and their types that appear in a Wang Color JSON Object.
-"""
-
-
-RawWangSet = TypedDict(
-    "RawWangSet",
-    {
-        "colors": List[RawWangColor],
-        "class": str,
-        "name": str,
-        "properties": List[RawProperty],
-        "tile": int,
-        "type": str,
-        "wangtiles": List[RawWangTile],
-    },
-)
-RawWangSet.__doc__ = """
-    The keys and their types that appear in a Wang Set JSON Object.
-"""
-
-
-def _parse_wang_tile(raw_wang_tile: RawWangTile) -> WangTile:
-    """Parse the raw wang tile into a pytiled_parser type
-
-    Args:
-        raw_wang_tile: RawWangTile to be parsed.
-
-    Returns:
-        WangTile: A properly typed WangTile.
-    """
-    return WangTile(tile_id=raw_wang_tile["tileid"], wang_id=raw_wang_tile["wangid"])
-
-
-def _parse_wang_color(raw_wang_color: RawWangColor) -> WangColor:
-    """Parse the raw wang color into a pytiled_parser type
-
-    Args:
-        raw_wang_color: RawWangColor to be parsed.
-
-    Returns:
-        WangColor: A properly typed WangColor.
-    """
-    wang_color = WangColor(
-        name=raw_wang_color["name"],
-        color=parse_color(raw_wang_color["color"]),
-        tile=raw_wang_color["tile"],
-        probability=raw_wang_color["probability"],
-    )
-
-    if raw_wang_color.get("properties") is not None:
-        wang_color.properties = parse_properties(raw_wang_color["properties"])
-
-    return wang_color
-
-
-def parse(raw_wangset: RawWangSet) -> WangSet:
-    """Parse the raw wangset into a pytiled_parser type
-
-    Args:
-        raw_wangset: Raw Wangset to be parsed.
-
-    Returns:
-        WangSet: A properly typed WangSet.
-    """
-
-    colors = []
-    for raw_wang_color in raw_wangset["colors"]:
-        colors.append(_parse_wang_color(raw_wang_color))
-
-    tiles = {}
-    for raw_wang_tile in raw_wangset["wangtiles"]:
-        tiles[raw_wang_tile["tileid"]] = _parse_wang_tile(raw_wang_tile)
-
-    wangset = WangSet(
-        name=raw_wangset["name"],
-        tile=raw_wangset["tile"],
-        wang_type=raw_wangset["type"],
-        wang_colors=colors,
-        wang_tiles=tiles,
-    )
-
-    if raw_wangset.get("properties") is not None:
-        wangset.properties = parse_properties(raw_wangset["properties"])
-
-    return wangset
+from typing import List
+
+# from typing_extensions import TypedDict
+
+# from pytiled_parser.parsers.json.properties import RawProperty
+from pytiled_parser.parsers.json.properties import parse as parse_properties
+from pytiled_parser.util import parse_color
+from pytiled_parser.wang_set import WangColor, WangSet, WangTile
+
+RawWangTile = TypedDict(
+    "RawWangTile",
+    {
+        "tileid": int,
+        # Tiled stores these IDs as a list represented like so:
+        # [top, top_right, right, bottom_right, bottom, bottom_left, left, top_left]
+        "wangid": List[int],
+    },
+)
+RawWangTile.__doc__ = """
+    The keys and their types that appear in a Wang Tile JSON Object.
+"""
+
+
+RawWangColor = TypedDict(
+    "RawWangColor",
+    {
+        "color": str,
+        "class": str,
+        "name": str,
+        "probability": float,
+        "tile": int,
+        "properties": List[RawProperty],
+    },
+)
+RawWangColor.__doc__ = """
+    The keys and their types that appear in a Wang Color JSON Object.
+"""
+
+
+RawWangSet = TypedDict(
+    "RawWangSet",
+    {
+        "colors": List[RawWangColor],
+        "class": str,
+        "name": str,
+        "properties": List[RawProperty],
+        "tile": int,
+        "type": str,
+        "wangtiles": List[RawWangTile],
+    },
+)
+RawWangSet.__doc__ = """
+    The keys and their types that appear in a Wang Set JSON Object.
+"""
+
+
+def _parse_wang_tile(raw_wang_tile: RawWangTile) -> WangTile:
+    """Parse the raw wang tile into a pytiled_parser type
+
+    Args:
+        raw_wang_tile: RawWangTile to be parsed.
+
+    Returns:
+        WangTile: A properly typed WangTile.
+    """
+    return WangTile(tile_id=raw_wang_tile["tileid"], wang_id=raw_wang_tile["wangid"])
+
+
+def _parse_wang_color(raw_wang_color: RawWangColor) -> WangColor:
+    """Parse the raw wang color into a pytiled_parser type
+
+    Args:
+        raw_wang_color: RawWangColor to be parsed.
+
+    Returns:
+        WangColor: A properly typed WangColor.
+    """
+    wang_color = WangColor(
+        name=raw_wang_color["name"],
+        color=parse_color(raw_wang_color["color"]),
+        tile=raw_wang_color["tile"],
+        probability=raw_wang_color["probability"],
+    )
+
+    if raw_wang_color.get("properties") is not None:
+        wang_color.properties = parse_properties(raw_wang_color["properties"])
+
+    return wang_color
+
+
+def parse(raw_wangset: RawWangSet) -> WangSet:
+    """Parse the raw wangset into a pytiled_parser type
+
+    Args:
+        raw_wangset: Raw Wangset to be parsed.
+
+    Returns:
+        WangSet: A properly typed WangSet.
+    """
+
+    colors = []
+    for raw_wang_color in raw_wangset["colors"]:
+        colors.append(_parse_wang_color(raw_wang_color))
+
+    tiles = {}
+    for raw_wang_tile in raw_wangset["wangtiles"]:
+        tiles[raw_wang_tile["tileid"]] = _parse_wang_tile(raw_wang_tile)
+
+    wangset = WangSet(
+        name=raw_wangset["name"],
+        tile=raw_wangset["tile"],
+        wang_type=raw_wangset["type"],
+        wang_colors=colors,
+        wang_tiles=tiles,
+    )
+
+    if raw_wangset.get("properties") is not None:
+        wangset.properties = parse_properties(raw_wangset["properties"])
+
+    return wangset
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_map.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/json/tiled_map.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,158 +1,235 @@
-import json
-import xml.etree.ElementTree as etree
-from pathlib import Path
-from ...common_types import OrderedPair, Size
-from ...exception import UnknownFormat
-from ...parsers.json.tileset import parse as parse_json_tileset
-from ...parsers.tmx.layer import parse as parse_layer
-from ...parsers.tmx.properties import parse as parse_properties
-from ...parsers.tmx.tileset import parse as parse_tmx_tileset
-from ...tiled_map import TiledMap, TilesetDict
-from ...util import check_format, parse_color
-
-
-def parse(file: Path) -> TiledMap:
-    """Parse the raw Tiled map into a pytiled_parser type.
-
-    Args:
-        file: Path to the map file.
-
-    Returns:
-        TiledMap: A parsed TiledMap.
-    """
-    with open(file) as map_file:
-        raw_map = etree.parse(map_file).getroot()
-
-    parent_dir = file.parent
-
-    raw_tilesets = raw_map.findall("./tileset")
-    tilesets: TilesetDict = {}
-
-    for raw_tileset in raw_tilesets:
-        if raw_tileset.attrib.get("source") is not None:
-            # Is an external Tileset
-            tileset_path = Path(parent_dir / raw_tileset.attrib["source"])
-            parser = check_format(tileset_path)
-            with open(tileset_path) as tileset_file:
-                if parser == "tmx":
-                    raw_tileset_external = etree.parse(tileset_file).getroot()
-                    tilesets[int(raw_tileset.attrib["firstgid"])] = parse_tmx_tileset(
-                        raw_tileset_external,
-                        int(raw_tileset.attrib["firstgid"]),
-                        external_path=tileset_path.parent,
-                    )
-                elif parser == "json":
-                    tilesets[int(raw_tileset.attrib["firstgid"])] = parse_json_tileset(
-                        json.load(tileset_file),
-                        int(raw_tileset.attrib["firstgid"]),
-                        external_path=tileset_path.parent,
-                    )
-                else:
-                    raise UnknownFormat(
-                        "Unkown Tileset format, please use either the TSX or JSON format."
-                    )
-
-        else:
-            # Is an embedded Tileset
-            tilesets[int(raw_tileset.attrib["firstgid"])] = parse_tmx_tileset(
-                raw_tileset, int(raw_tileset.attrib["firstgid"])
-            )
-
-    layers = []
-    for element in raw_map.iter():
-        if element.tag in ["layer", "objectgroup", "imagelayer", "group"]:
-            layers.append(parse_layer(element, parent_dir))
-
-    map_ = TiledMap(
-        map_file=file,
-        infinite=bool(int(raw_map.attrib["infinite"])),
-        layers=layers,
-        map_size=Size(int(raw_map.attrib["width"]), int(raw_map.attrib["height"])),
-        next_layer_id=int(raw_map.attrib["nextlayerid"]),
-        next_object_id=int(raw_map.attrib["nextobjectid"]),
-        orientation=raw_map.attrib["orientation"],
-        render_order=raw_map.attrib["renderorder"],
-        tiled_version=raw_map.attrib["tiledversion"],
-        tile_size=Size(
-            int(raw_map.attrib["tilewidth"]), int(raw_map.attrib["tileheight"])
-        ),
-        tilesets=tilesets,
-        version=raw_map.attrib["version"],
-    )
-
-    layers = [layer for layer in map_.layers if hasattr(layer, "tiled_objects")]
-
-    for my_layer in layers:
-        # Mypy extremely hates what is going on in this whole block
-        # For some reason an ignore on this first for loop is causing it
-        # to just not care about any of the problems in here.
-        # However, under normal circumstances, mypy hates just about every
-        # line of this block.
-        #
-        # This is because we are doing some run-time modification of the attributes
-        # on the tiled_object class and making assumptions about things based on that.
-        # This is done to achieve a system where we can load-in tilesets which were
-        # defined in a Tiled Object Template. This is tough because we need to know what
-        # tilesets have been loaded in already, and use them if they have been, but then
-        # be able to dynamically add-in tilesets after having parsed the rest of the map.
-
-        for tiled_object in my_layer.tiled_objects:  # type: ignore
-            if hasattr(tiled_object, "new_tileset"):
-                if tiled_object.new_tileset is not None:
-                    already_loaded = None
-                    for val in map_.tilesets.values():
-                        if val.name == tiled_object.new_tileset.attrib["name"]:
-                            already_loaded = val
-                            break
-
-                    if not already_loaded:
-                        print("here")
-                        highest_firstgid = max(map_.tilesets.keys())
-                        last_tileset_count = map_.tilesets[highest_firstgid].tile_count
-                        new_firstgid = highest_firstgid + last_tileset_count
-                        map_.tilesets[new_firstgid] = parse_tmx_tileset(
-                            tiled_object.new_tileset,
-                            new_firstgid,
-                            tiled_object.new_tileset_path,
-                        )
-                        tiled_object.gid = tiled_object.gid + (new_firstgid - 1)
-
-                    else:
-                        tiled_object.gid = tiled_object.gid + (
-                            already_loaded.firstgid - 1
-                        )
-
-                    tiled_object.new_tileset = None
-                    tiled_object.new_tileset_path = None
-
-    if raw_map.attrib.get("backgroundcolor") is not None:
-        map_.background_color = parse_color(raw_map.attrib["backgroundcolor"])
-
-    if raw_map.attrib.get("hexsidelength") is not None:
-        map_.hex_side_length = int(raw_map.attrib["hexsidelength"])
-
-    properties_element = raw_map.find("./properties")
-    if properties_element:
-        map_.properties = parse_properties(properties_element)
-
-    if raw_map.attrib.get("staggeraxis") is not None:
-        map_.stagger_axis = raw_map.attrib["staggeraxis"]
-
-    if raw_map.attrib.get("staggerindex") is not None:
-        map_.stagger_index = raw_map.attrib["staggerindex"]
-
-    if raw_map.attrib.get("class") is not None:
-        map_.class_ = raw_map.attrib["class"]
-
-    _parallax_origin_x = 0.0
-    _parallax_origin_y = 0.0
-
-    if raw_map.attrib.get("parallaxoriginx") is not None:
-        _parallax_origin_x = float(raw_map.attrib["parallaxoriginx"])
-
-    if raw_map.get("parallaxoriginy") is not None:
-        _parallax_origin_y = float(raw_map.attrib["parallaxoriginy"])
-
-    map_.parallax_origin = OrderedPair(_parallax_origin_x, _parallax_origin_y)
-
-    return map_
+import json
+import xml.etree.ElementTree as etree
+from pathlib import Path
+from typing import List, Union, cast
+# from typing_extensions import TypedDict
+from ...common_types import OrderedPair, Size
+from ...exception import UnknownFormat
+# from pytiled_parser.parsers.json.layer import RawLayer
+from .layer import parse as parse_layer
+# from pytiled_parser.parsers.json.properties import RawProperty
+from .properties import parse as parse_properties
+# from pytiled_parser.parsers.json.tileset import RawTileSet
+from .tileset import parse as parse_json_tileset
+from ...parsers.tmx.tileset import parse as parse_tmx_tileset
+from ...tiled_map import TiledMap, TilesetDict
+from ...util import check_format, parse_color
+
+# RawTilesetMapping = TypedDict("RawTilesetMapping", {"firstgid": int, "source": str})
+RawTilesetMapping = {
+    'firstgid': 0,
+    'source': ''
+}
+
+RawTiledMap = {
+    "backgroundcolor": '',
+    "compressionlevel": 0,
+    "height": 0,
+    "hexsidelength": 0,
+    "infinite": False,
+    "layers": list(),
+    "nextlayerid": 0,
+    "nextobjectid": 0,
+    "orientation": '',
+    "properties": list(),
+    "renderorder": '',
+    "staggeraxis": '',
+    "staggerindex": '',
+    "tiledversion": '',
+    "tileheight": 0,
+    "tilesets": list(),
+    "tilewidth": 0,
+    "class": '',
+    "type": '',
+    "version": '',
+    "width": 0,
+    "parallaxoriginx": 0.0,
+    "parallaxoriginy": 0.0,
+}
+
+# RawTiledMap = TypedDict(
+#     "RawTiledMap",
+#     {
+#         "backgroundcolor": str,
+#         "compressionlevel": int,
+#         "height": int,
+#         "hexsidelength": int,
+#         "infinite": bool,
+#         "layers": List[RawLayer],
+#         "nextlayerid": int,
+#         "nextobjectid": int,
+#         "orientation": str,
+#         "properties": List[RawProperty],
+#         "renderorder": str,
+#         "staggeraxis": str,
+#         "staggerindex": str,
+#         "tiledversion": str,
+#         "tileheight": int,
+#         "tilesets": List[RawTilesetMapping],
+#         "tilewidth": int,
+#         "class": str,
+#         "type": str,
+#         "version": Union[str, float],
+#         "width": int,
+#         "parallaxoriginx": float,
+#         "parallaxoriginy": float,
+#     },
+# )
+# RawTiledMap.__doc__ = """
+#     The keys and their types that appear in a Tiled JSON Map Object.
+#
+#     Tiled Docs: https://doc.mapeditor.org/en/stable/reference/json-map-format/#map
+# """
+
+
+def parse(file: Path) -> TiledMap:
+    """Parse the raw Tiled map into a pytiled_parser type.
+
+    Args:
+        file: Path to the map file.
+
+    Returns:
+        TiledMap: A parsed TiledMap.
+    """
+    with open(file) as map_file:
+        raw_tiled_map = json.load(map_file)
+
+    #before ktg
+    #parent_dir = file.parent
+    # ktg: we assume tileset is ALWAYS embedded!
+    parent_dir='.'
+
+    #before ktg:
+    # raw_tilesets: List[Union[RawTileSet, RawTilesetMapping]] = raw_tiled_map["tilesets"]
+    raw_tilesets = raw_tiled_map['tilesets']
+    #before ktg
+    # tilesets: TilesetDict = {}
+    tilesets = {}
+
+    for raw_tileset in raw_tilesets:
+        if raw_tileset.get("source") is not None:
+            # Is an external Tileset
+            tileset_path = Path(parent_dir / raw_tileset["source"])
+            parser = check_format(tileset_path)
+            with open(tileset_path) as raw_tileset_file:
+                if parser == "tmx":
+                    raw_tileset_external = etree.parse(raw_tileset_file).getroot()
+                    tilesets[raw_tileset["firstgid"]] = parse_tmx_tileset(
+                        raw_tileset_external,
+                        raw_tileset["firstgid"],
+                        external_path=tileset_path.parent,
+                    )
+                else:
+                    try:
+                        tilesets[raw_tileset["firstgid"]] = parse_json_tileset(
+                            json.load(raw_tileset_file),
+                            raw_tileset["firstgid"],
+                            external_path=tileset_path.parent,
+                        )
+                    except ValueError:
+                        raise UnknownFormat(
+                            "Unknown Tileset Format, please use either the TSX or JSON format. "
+                            "This message could also mean your tileset file is invalid or corrupted."
+                        )
+        else:
+            # Is an embedded Tileset
+            # raw_tileset = cast(RawTileSet, raw_tileset)
+            tilesets[raw_tileset["firstgid"]] = parse_json_tileset(
+                raw_tileset, raw_tileset["firstgid"]
+            )
+
+    if isinstance(raw_tiled_map["version"], float):  # pragma: no cover
+        version = str(raw_tiled_map["version"])
+    else:
+        version = raw_tiled_map["version"]
+
+    # `map` is a built-in function
+    map_ = TiledMap(
+        map_file=file,
+        infinite=raw_tiled_map["infinite"],
+        layers=[parse_layer(layer_, parent_dir) for layer_ in raw_tiled_map["layers"]],
+        map_size=Size(raw_tiled_map["width"], raw_tiled_map["height"]),
+        next_layer_id=raw_tiled_map["nextlayerid"],
+        next_object_id=raw_tiled_map["nextobjectid"],
+        orientation=raw_tiled_map["orientation"],
+        render_order=raw_tiled_map["renderorder"],
+        tiled_version=raw_tiled_map["tiledversion"],
+        tile_size=Size(raw_tiled_map["tilewidth"], raw_tiled_map["tileheight"]),
+        tilesets=tilesets,
+        version=version,
+    )
+
+    layers = [layer for layer in map_.layers if hasattr(layer, "tiled_objects")]
+
+    for my_layer in layers:
+        # Mypy extremely hates what is going on in this whole block
+        # For some reason an ignore on this first for loop is causing it
+        # to just not care about any of the problems in here.
+        # However, under normal circumstances, mypy hates just about every
+        # line of this block.
+        #
+        # This is because we are doing some run-time modification of the attributes
+        # on the tiled_object class and making assumptions about things based on that.
+        # This is done to achieve a system where we can load-in tilesets which were
+        # defined in a Tiled Object Template. This is tough because we need to know what
+        # tilesets have been loaded in already, and use them if they have been, but then
+        # be able to dynamically add-in tilesets after having parsed the rest of the map.
+
+        for tiled_object in my_layer.tiled_objects:  # type: ignore
+            if hasattr(tiled_object, "new_tileset"):
+                if tiled_object.new_tileset is not None:
+                    already_loaded = None
+                    for val in map_.tilesets.values():
+                        if val.name == tiled_object.new_tileset["name"]:
+                            already_loaded = val
+                            break
+
+                    if not already_loaded:
+                        highest_firstgid = max(map_.tilesets.keys())
+                        last_tileset_count = map_.tilesets[highest_firstgid].tile_count
+                        new_firstgid = highest_firstgid + last_tileset_count
+                        map_.tilesets[new_firstgid] = parse_json_tileset(
+                            tiled_object.new_tileset,
+                            new_firstgid,
+                            tiled_object.new_tileset_path,
+                        )
+                        tiled_object.gid = tiled_object.gid + (new_firstgid - 1)
+
+                    else:
+                        tiled_object.gid = tiled_object.gid + (
+                            already_loaded.firstgid - 1
+                        )
+
+                    tiled_object.new_tileset = None
+                    tiled_object.new_tileset_path = None
+
+    if raw_tiled_map.get("class") is not None:
+        map_.class_ = raw_tiled_map["class"]
+
+    if raw_tiled_map.get("backgroundcolor") is not None:
+        map_.background_color = parse_color(raw_tiled_map["backgroundcolor"])
+
+    if raw_tiled_map.get("hexsidelength") is not None:
+        map_.hex_side_length = raw_tiled_map["hexsidelength"]
+
+    if raw_tiled_map.get("properties") is not None:
+        map_.properties = parse_properties(raw_tiled_map["properties"])
+
+    if raw_tiled_map.get("staggeraxis") is not None:
+        map_.stagger_axis = raw_tiled_map["staggeraxis"]
+
+    if raw_tiled_map.get("staggerindex") is not None:
+        map_.stagger_index = raw_tiled_map["staggerindex"]
+
+    _parallax_origin_x = 0
+    _parallax_origin_y = 0
+
+    if raw_tiled_map.get("parallaxoriginx") is not None:
+        _parallax_origin_x = raw_tiled_map["parallaxoriginx"]
+
+    if raw_tiled_map.get("parallaxoriginy") is not None:
+        _parallax_origin_y = raw_tiled_map["parallaxoriginy"]
+
+    map_.parallax_origin = OrderedPair(_parallax_origin_x, _parallax_origin_y)
+
+    return map_
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_object.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tiled_object.py`

 * *Ordering differences only*

 * *Files 9% similar despite different names*

```diff
@@ -1,294 +1,294 @@
-import xml.etree.ElementTree as etree
-from pathlib import Path
-from typing import Callable, Optional
-from ...common_types import OrderedPair, Size
-from ...parsers.tmx.properties import parse as parse_properties
-from ...tiled_object import (
-    Ellipse,
-    Point,
-    Polygon,
-    Polyline,
-    Rectangle,
-    Text,
-    Tile,
-    TiledObject,
-)
-from ...util import load_object_template, parse_color
-
-
-def _parse_common(raw_object: etree.Element) -> TiledObject:
-    """Create an Object containing all the attributes common to all types of objects.
-
-    Args:
-        raw_object: XML Element to get common attributes from
-
-    Returns:
-        Object: The attributes in common of all types of objects
-    """
-
-    common = TiledObject(
-        id=int(raw_object.attrib["id"]),
-        coordinates=OrderedPair(
-            float(raw_object.attrib["x"]), float(raw_object.attrib["y"])
-        ),
-    )
-
-    if raw_object.attrib.get("width") is not None:
-        common.size = Size(
-            float(raw_object.attrib["width"]), float(raw_object.attrib["height"])
-        )
-
-    if raw_object.attrib.get("visible") is not None:
-        common.visible = bool(int(raw_object.attrib["visible"]))
-
-    if raw_object.attrib.get("rotation") is not None:
-        common.rotation = float(raw_object.attrib["rotation"])
-
-    if raw_object.attrib.get("name") is not None:
-        common.name = raw_object.attrib["name"]
-
-    if raw_object.attrib.get("type") is not None:
-        common.class_ = raw_object.attrib["type"]
-
-    if raw_object.attrib.get("class") is not None:
-        common.class_ = raw_object.attrib["class"]
-
-    properties_element = raw_object.find("./properties")
-    if properties_element:
-        common.properties = parse_properties(properties_element)
-
-    return common
-
-
-def _parse_ellipse(raw_object: etree.Element) -> Ellipse:
-    """Parse the raw object into an Ellipse.
-
-    Args:
-        raw_object: XML Element to be parsed to an Ellipse
-
-    Returns:
-        Ellipse: The Ellipse object created from the raw object
-    """
-    return Ellipse(**_parse_common(raw_object).__dict__)
-
-
-def _parse_rectangle(raw_object: etree.Element) -> Rectangle:
-    """Parse the raw object into a Rectangle.
-
-    Args:
-        raw_object: XML Element to be parsed to a Rectangle
-
-    Returns:
-        Rectangle: The Rectangle object created from the raw object
-    """
-    return Rectangle(**_parse_common(raw_object).__dict__)
-
-
-def _parse_point(raw_object: etree.Element) -> Point:
-    """Parse the raw object into a Point.
-
-    Args:
-        raw_object: XML Element to be parsed to a Point
-
-    Returns:
-        Point: The Point object created from the raw object
-    """
-    return Point(**_parse_common(raw_object).__dict__)
-
-
-def _parse_polygon(raw_object: etree.Element) -> Polygon:
-    """Parse the raw object into a Polygon.
-
-    Args:
-        raw_object: XML Element to be parsed to a Polygon
-
-    Returns:
-        Polygon: The Polygon object created from the raw object
-    """
-    polygon = []
-    polygon_element = raw_object.find("./polygon")
-    if polygon_element is not None:
-        for raw_point in polygon_element.attrib["points"].split(" "):
-            point = raw_point.split(",")
-            polygon.append(OrderedPair(float(point[0]), float(point[1])))
-
-    return Polygon(points=polygon, **_parse_common(raw_object).__dict__)
-
-
-def _parse_polyline(raw_object: etree.Element) -> Polyline:
-    """Parse the raw object into a Polyline.
-
-    Args:
-        raw_object: Raw object to be parsed to a Polyline
-
-    Returns:
-        Polyline: The Polyline object created from the raw object
-    """
-    polyline = []
-    polyline_element = raw_object.find("./polyline")
-    if polyline_element is not None:
-        for raw_point in polyline_element.attrib["points"].split(" "):
-            point = raw_point.split(",")
-            polyline.append(OrderedPair(float(point[0]), float(point[1])))
-
-    return Polyline(points=polyline, **_parse_common(raw_object).__dict__)
-
-
-def _parse_tile(
-    raw_object: etree.Element,
-    new_tileset: Optional[etree.Element] = None,
-    new_tileset_path: Optional[Path] = None,
-) -> Tile:
-    """Parse the raw object into a Tile.
-
-    Args:
-        raw_object: XML Element to be parsed to a Tile
-
-    Returns:
-        Tile: The Tile object created from the raw object
-    """
-    return Tile(
-        gid=int(raw_object.attrib["gid"]),
-        new_tileset=new_tileset,
-        new_tileset_path=new_tileset_path,
-        **_parse_common(raw_object).__dict__
-    )
-
-
-def _parse_text(raw_object: etree.Element) -> Text:
-    """Parse the raw object into Text.
-
-    Args:
-        raw_object: XML Element to be parsed to a Text
-
-    Returns:
-        Text: The Text object created from the raw object
-    """
-    # required attributes
-    text_element = raw_object.find("./text")
-
-    if text_element is not None:
-        text = text_element.text
-
-        if not text:
-            text = ""
-        # create base Text object
-        text_object = Text(text=text, **_parse_common(raw_object).__dict__)
-
-        # optional attributes
-
-        if text_element.attrib.get("color") is not None:
-            text_object.color = parse_color(text_element.attrib["color"])
-
-        if text_element.attrib.get("fontfamily") is not None:
-            text_object.font_family = text_element.attrib["fontfamily"]
-
-        if text_element.attrib.get("pixelsize") is not None:
-            text_object.font_size = float(text_element.attrib["pixelsize"])
-
-        if text_element.attrib.get("bold") is not None:
-            text_object.bold = bool(int(text_element.attrib["bold"]))
-
-        if text_element.attrib.get("italic") is not None:
-            text_object.italic = bool(int(text_element.attrib["italic"]))
-
-        if text_element.attrib.get("kerning") is not None:
-            text_object.kerning = bool(int(text_element.attrib["kerning"]))
-
-        if text_element.attrib.get("strikeout") is not None:
-            text_object.strike_out = bool(int(text_element.attrib["strikeout"]))
-
-        if text_element.attrib.get("underline") is not None:
-            text_object.underline = bool(int(text_element.attrib["underline"]))
-
-        if text_element.attrib.get("halign") is not None:
-            text_object.horizontal_align = text_element.attrib["halign"]
-
-        if text_element.attrib.get("valign") is not None:
-            text_object.vertical_align = text_element.attrib["valign"]
-
-        if text_element.attrib.get("wrap") is not None:
-            text_object.wrap = bool(int(text_element.attrib["wrap"]))
-
-    return text_object
-
-
-def _get_parser(raw_object: etree.Element) -> Callable[[etree.Element], TiledObject]:
-    """Get the parser function for a given raw object.
-
-    Only used internally by the TMX parser.
-
-    Args:
-        raw_object: XML Element that is analyzed to determine the parser function.
-
-    Returns:
-        Callable[[Element], Object]: The parser function.
-    """
-    if raw_object.find("./ellipse") is not None:
-        return _parse_ellipse
-
-    if raw_object.find("./point") is not None:
-        return _parse_point
-
-    if raw_object.find("./polygon") is not None:
-        return _parse_polygon
-
-    if raw_object.find("./polyline") is not None:
-        return _parse_polyline
-
-    if raw_object.find("./text") is not None:
-        return _parse_text
-
-    # If it's none of the above, rectangle is the only one left.
-    # Rectangle is the only object which has no properties to signify that.
-    return _parse_rectangle
-
-
-def parse(raw_object: etree.Element, parent_dir: Optional[Path] = None) -> TiledObject:
-    """Parse the raw object into a pytiled_parser version
-
-    Args:
-        raw_object: XML Element that is to be parsed.
-        parent_dir: The parent directory that the map file is in.
-
-    Returns:
-        TiledObject: A parsed Object.
-
-    Raises:
-        RuntimeError: When a parameter that is conditionally required was not sent.
-    """
-    new_tileset = None
-    new_tileset_path = None
-
-    if raw_object.attrib.get("template"):
-        if not parent_dir:
-            raise RuntimeError(
-                "A parent directory must be specified when using object templates."
-            )
-        template_path = Path(parent_dir / raw_object.attrib["template"])
-        template, new_tileset, new_tileset_path = load_object_template(template_path)
-
-        if isinstance(template, etree.Element):
-            new_object = template.find("./object")
-            if new_object is not None:
-                if raw_object.attrib.get("id") is not None:
-                    new_object.attrib["id"] = raw_object.attrib["id"]
-
-                if raw_object.attrib.get("x") is not None:
-                    new_object.attrib["x"] = raw_object.attrib["x"]
-
-                if raw_object.attrib.get("y") is not None:
-                    new_object.attrib["y"] = raw_object.attrib["y"]
-
-                raw_object = new_object
-        elif isinstance(template, dict):
-            # load the JSON object into the XML object
-            raise NotImplementedError(
-                "Loading JSON object templates inside a TMX map is currently not supported, "
-                "but will be in a future release."
-            )
-
-    if raw_object.attrib.get("gid"):
-        return _parse_tile(raw_object, new_tileset, new_tileset_path)
-
-    return _get_parser(raw_object)(raw_object)
+import xml.etree.ElementTree as etree
+from pathlib import Path
+from typing import Callable, Optional
+from ...common_types import OrderedPair, Size
+from ...parsers.tmx.properties import parse as parse_properties
+from ...tiled_object import (
+    Ellipse,
+    Point,
+    Polygon,
+    Polyline,
+    Rectangle,
+    Text,
+    Tile,
+    TiledObject,
+)
+from ...util import load_object_template, parse_color
+
+
+def _parse_common(raw_object: etree.Element) -> TiledObject:
+    """Create an Object containing all the attributes common to all types of objects.
+
+    Args:
+        raw_object: XML Element to get common attributes from
+
+    Returns:
+        Object: The attributes in common of all types of objects
+    """
+
+    common = TiledObject(
+        id=int(raw_object.attrib["id"]),
+        coordinates=OrderedPair(
+            float(raw_object.attrib["x"]), float(raw_object.attrib["y"])
+        ),
+    )
+
+    if raw_object.attrib.get("width") is not None:
+        common.size = Size(
+            float(raw_object.attrib["width"]), float(raw_object.attrib["height"])
+        )
+
+    if raw_object.attrib.get("visible") is not None:
+        common.visible = bool(int(raw_object.attrib["visible"]))
+
+    if raw_object.attrib.get("rotation") is not None:
+        common.rotation = float(raw_object.attrib["rotation"])
+
+    if raw_object.attrib.get("name") is not None:
+        common.name = raw_object.attrib["name"]
+
+    if raw_object.attrib.get("type") is not None:
+        common.class_ = raw_object.attrib["type"]
+
+    if raw_object.attrib.get("class") is not None:
+        common.class_ = raw_object.attrib["class"]
+
+    properties_element = raw_object.find("./properties")
+    if properties_element:
+        common.properties = parse_properties(properties_element)
+
+    return common
+
+
+def _parse_ellipse(raw_object: etree.Element) -> Ellipse:
+    """Parse the raw object into an Ellipse.
+
+    Args:
+        raw_object: XML Element to be parsed to an Ellipse
+
+    Returns:
+        Ellipse: The Ellipse object created from the raw object
+    """
+    return Ellipse(**_parse_common(raw_object).__dict__)
+
+
+def _parse_rectangle(raw_object: etree.Element) -> Rectangle:
+    """Parse the raw object into a Rectangle.
+
+    Args:
+        raw_object: XML Element to be parsed to a Rectangle
+
+    Returns:
+        Rectangle: The Rectangle object created from the raw object
+    """
+    return Rectangle(**_parse_common(raw_object).__dict__)
+
+
+def _parse_point(raw_object: etree.Element) -> Point:
+    """Parse the raw object into a Point.
+
+    Args:
+        raw_object: XML Element to be parsed to a Point
+
+    Returns:
+        Point: The Point object created from the raw object
+    """
+    return Point(**_parse_common(raw_object).__dict__)
+
+
+def _parse_polygon(raw_object: etree.Element) -> Polygon:
+    """Parse the raw object into a Polygon.
+
+    Args:
+        raw_object: XML Element to be parsed to a Polygon
+
+    Returns:
+        Polygon: The Polygon object created from the raw object
+    """
+    polygon = []
+    polygon_element = raw_object.find("./polygon")
+    if polygon_element is not None:
+        for raw_point in polygon_element.attrib["points"].split(" "):
+            point = raw_point.split(",")
+            polygon.append(OrderedPair(float(point[0]), float(point[1])))
+
+    return Polygon(points=polygon, **_parse_common(raw_object).__dict__)
+
+
+def _parse_polyline(raw_object: etree.Element) -> Polyline:
+    """Parse the raw object into a Polyline.
+
+    Args:
+        raw_object: Raw object to be parsed to a Polyline
+
+    Returns:
+        Polyline: The Polyline object created from the raw object
+    """
+    polyline = []
+    polyline_element = raw_object.find("./polyline")
+    if polyline_element is not None:
+        for raw_point in polyline_element.attrib["points"].split(" "):
+            point = raw_point.split(",")
+            polyline.append(OrderedPair(float(point[0]), float(point[1])))
+
+    return Polyline(points=polyline, **_parse_common(raw_object).__dict__)
+
+
+def _parse_tile(
+    raw_object: etree.Element,
+    new_tileset: Optional[etree.Element] = None,
+    new_tileset_path: Optional[Path] = None,
+) -> Tile:
+    """Parse the raw object into a Tile.
+
+    Args:
+        raw_object: XML Element to be parsed to a Tile
+
+    Returns:
+        Tile: The Tile object created from the raw object
+    """
+    return Tile(
+        gid=int(raw_object.attrib["gid"]),
+        new_tileset=new_tileset,
+        new_tileset_path=new_tileset_path,
+        **_parse_common(raw_object).__dict__
+    )
+
+
+def _parse_text(raw_object: etree.Element) -> Text:
+    """Parse the raw object into Text.
+
+    Args:
+        raw_object: XML Element to be parsed to a Text
+
+    Returns:
+        Text: The Text object created from the raw object
+    """
+    # required attributes
+    text_element = raw_object.find("./text")
+
+    if text_element is not None:
+        text = text_element.text
+
+        if not text:
+            text = ""
+        # create base Text object
+        text_object = Text(text=text, **_parse_common(raw_object).__dict__)
+
+        # optional attributes
+
+        if text_element.attrib.get("color") is not None:
+            text_object.color = parse_color(text_element.attrib["color"])
+
+        if text_element.attrib.get("fontfamily") is not None:
+            text_object.font_family = text_element.attrib["fontfamily"]
+
+        if text_element.attrib.get("pixelsize") is not None:
+            text_object.font_size = float(text_element.attrib["pixelsize"])
+
+        if text_element.attrib.get("bold") is not None:
+            text_object.bold = bool(int(text_element.attrib["bold"]))
+
+        if text_element.attrib.get("italic") is not None:
+            text_object.italic = bool(int(text_element.attrib["italic"]))
+
+        if text_element.attrib.get("kerning") is not None:
+            text_object.kerning = bool(int(text_element.attrib["kerning"]))
+
+        if text_element.attrib.get("strikeout") is not None:
+            text_object.strike_out = bool(int(text_element.attrib["strikeout"]))
+
+        if text_element.attrib.get("underline") is not None:
+            text_object.underline = bool(int(text_element.attrib["underline"]))
+
+        if text_element.attrib.get("halign") is not None:
+            text_object.horizontal_align = text_element.attrib["halign"]
+
+        if text_element.attrib.get("valign") is not None:
+            text_object.vertical_align = text_element.attrib["valign"]
+
+        if text_element.attrib.get("wrap") is not None:
+            text_object.wrap = bool(int(text_element.attrib["wrap"]))
+
+    return text_object
+
+
+def _get_parser(raw_object: etree.Element) -> Callable[[etree.Element], TiledObject]:
+    """Get the parser function for a given raw object.
+
+    Only used internally by the TMX parser.
+
+    Args:
+        raw_object: XML Element that is analyzed to determine the parser function.
+
+    Returns:
+        Callable[[Element], Object]: The parser function.
+    """
+    if raw_object.find("./ellipse") is not None:
+        return _parse_ellipse
+
+    if raw_object.find("./point") is not None:
+        return _parse_point
+
+    if raw_object.find("./polygon") is not None:
+        return _parse_polygon
+
+    if raw_object.find("./polyline") is not None:
+        return _parse_polyline
+
+    if raw_object.find("./text") is not None:
+        return _parse_text
+
+    # If it's none of the above, rectangle is the only one left.
+    # Rectangle is the only object which has no properties to signify that.
+    return _parse_rectangle
+
+
+def parse(raw_object: etree.Element, parent_dir: Optional[Path] = None) -> TiledObject:
+    """Parse the raw object into a pytiled_parser version
+
+    Args:
+        raw_object: XML Element that is to be parsed.
+        parent_dir: The parent directory that the map file is in.
+
+    Returns:
+        TiledObject: A parsed Object.
+
+    Raises:
+        RuntimeError: When a parameter that is conditionally required was not sent.
+    """
+    new_tileset = None
+    new_tileset_path = None
+
+    if raw_object.attrib.get("template"):
+        if not parent_dir:
+            raise RuntimeError(
+                "A parent directory must be specified when using object templates."
+            )
+        template_path = Path(parent_dir / raw_object.attrib["template"])
+        template, new_tileset, new_tileset_path = load_object_template(template_path)
+
+        if isinstance(template, etree.Element):
+            new_object = template.find("./object")
+            if new_object is not None:
+                if raw_object.attrib.get("id") is not None:
+                    new_object.attrib["id"] = raw_object.attrib["id"]
+
+                if raw_object.attrib.get("x") is not None:
+                    new_object.attrib["x"] = raw_object.attrib["x"]
+
+                if raw_object.attrib.get("y") is not None:
+                    new_object.attrib["y"] = raw_object.attrib["y"]
+
+                raw_object = new_object
+        elif isinstance(template, dict):
+            # load the JSON object into the XML object
+            raise NotImplementedError(
+                "Loading JSON object templates inside a TMX map is currently not supported, "
+                "but will be in a future release."
+            )
+
+    if raw_object.attrib.get("gid"):
+        return _parse_tile(raw_object, new_tileset, new_tileset_path)
+
+    return _get_parser(raw_object)(raw_object)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tileset.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/parsers/tmx/tileset.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,222 +1,222 @@
-import xml.etree.ElementTree as etree
-from pathlib import Path
-from typing import Optional
-from ...common_types import OrderedPair
-from ...parsers.tmx.layer import parse as parse_layer
-from ...parsers.tmx.properties import parse as parse_properties
-from ...parsers.tmx.wang_set import parse as parse_wangset
-from ...tileset import Frame, Grid, Tile, Tileset, Transformations
-from ...util import parse_color
-
-
-def _parse_frame(raw_frame: etree.Element) -> Frame:
-    """Parse the raw_frame to a Frame object.
-
-    Args:
-        raw_frame: XML Element to be parsed to a Frame
-
-    Returns:
-        Frame: The Frame created from the raw_frame
-    """
-
-    return Frame(
-        duration=int(raw_frame.attrib["duration"]),
-        tile_id=int(raw_frame.attrib["tileid"]),
-    )
-
-
-def _parse_grid(raw_grid: etree.Element) -> Grid:
-    """Parse the raw_grid to a Grid object.
-
-    Args:
-        raw_grid: XML Element to be parsed to a Grid
-
-    Returns:
-        Grid: The Grid created from the raw_grid
-    """
-
-    return Grid(
-        orientation=raw_grid.attrib["orientation"],
-        width=int(raw_grid.attrib["width"]),
-        height=int(raw_grid.attrib["height"]),
-    )
-
-
-def _parse_transformations(raw_transformations: etree.Element) -> Transformations:
-    """Parse the raw_transformations to a Transformations object.
-
-    Args:
-        raw_transformations: XML Element to be parsed to a Transformations
-
-    Returns:
-        Transformations: The Transformations created from the raw_transformations
-    """
-
-    return Transformations(
-        hflip=bool(int(raw_transformations.attrib["hflip"])),
-        vflip=bool(int(raw_transformations.attrib["vflip"])),
-        rotate=bool(int(raw_transformations.attrib["rotate"])),
-        prefer_untransformed=bool(
-            int(raw_transformations.attrib["preferuntransformed"])
-        ),
-    )
-
-
-def _parse_tile(raw_tile: etree.Element, external_path: Optional[Path] = None) -> Tile:
-    """Parse the raw_tile to a Tile object.
-
-    Args:
-        raw_tile: XML Element to be parsed to a Tile
-
-    Returns:
-        Tile: The Tile created from the raw_tile
-    """
-
-    tile = Tile(id=int(raw_tile.attrib["id"]))
-
-    if raw_tile.attrib.get("type") is not None:
-        tile.class_ = raw_tile.attrib["type"]
-
-    if raw_tile.attrib.get("class") is not None:
-        tile.class_ = raw_tile.attrib["class"]
-
-    animation_element = raw_tile.find("./animation")
-    if animation_element is not None:
-        tile.animation = []
-        for raw_frame in animation_element.findall("./frame"):
-            tile.animation.append(_parse_frame(raw_frame))
-
-    object_element = raw_tile.find("./objectgroup")
-    if object_element is not None:
-        tile.objects = parse_layer(object_element)
-
-    properties_element = raw_tile.find("./properties")
-    if properties_element is not None:
-        tile.properties = parse_properties(properties_element)
-
-    image_element = raw_tile.find("./image")
-    if image_element is not None:
-        if external_path:
-            tile.image = (
-                Path(external_path / image_element.attrib["source"])
-                .absolute()
-                .resolve()
-            )
-        else:
-            tile.image = Path(image_element.attrib["source"])
-
-        tile.image_width = int(image_element.attrib["width"])
-        tile.width = tile.image_width
-        tile.image_height = int(image_element.attrib["height"])
-        tile.height = tile.image_height
-
-    if raw_tile.attrib.get("x") is not None:
-        tile.x = int(raw_tile.attrib["x"])
-
-    if raw_tile.attrib.get("y") is not None:
-        tile.y = int(raw_tile.attrib["y"])
-
-    if raw_tile.attrib.get("width") is not None:
-        tile.width = int(raw_tile.attrib["width"])
-
-    if raw_tile.attrib.get("height") is not None:
-        tile.height = int(raw_tile.attrib["height"])
-
-    return tile
-
-
-def parse(
-    raw_tileset: etree.Element,
-    firstgid: int,
-    external_path: Optional[Path] = None,
-) -> Tileset:
-    tileset = Tileset(
-        name=raw_tileset.attrib["name"],
-        tile_count=int(raw_tileset.attrib["tilecount"]),
-        tile_width=int(raw_tileset.attrib["tilewidth"]),
-        tile_height=int(raw_tileset.attrib["tileheight"]),
-        columns=int(raw_tileset.attrib["columns"]),
-        firstgid=firstgid,
-    )
-
-    if raw_tileset.attrib.get("version") is not None:
-        tileset.version = raw_tileset.attrib["version"]
-
-    if raw_tileset.attrib.get("tiledversion") is not None:
-        tileset.tiled_version = raw_tileset.attrib["tiledversion"]
-
-    if raw_tileset.attrib.get("backgroundcolor") is not None:
-        tileset.background_color = parse_color(raw_tileset.attrib["backgroundcolor"])
-
-    if raw_tileset.attrib.get("spacing") is not None:
-        tileset.spacing = int(raw_tileset.attrib["spacing"])
-
-    if raw_tileset.attrib.get("margin") is not None:
-        tileset.margin = int(raw_tileset.attrib["margin"])
-
-    if raw_tileset.attrib.get("objectalignment") is not None:
-        tileset.alignment = raw_tileset.attrib["objectalignment"]
-
-    if raw_tileset.attrib.get("class") is not None:
-        tileset.class_ = raw_tileset.attrib["class"]
-
-    if raw_tileset.attrib.get("fillmode") is not None:
-        tileset.fill_mode = raw_tileset.attrib["fillmode"]
-
-    if raw_tileset.attrib.get("tilerendersize") is not None:
-        tileset.tile_render_size = raw_tileset.attrib["tilerendersize"]
-
-    image_element = raw_tileset.find("image")
-    if image_element is not None:
-        if external_path:
-            tileset.image = (
-                Path(external_path / image_element.attrib["source"])
-                .absolute()
-                .resolve()
-            )
-        else:
-            tileset.image = Path(image_element.attrib["source"])
-
-        tileset.image_width = int(image_element.attrib["width"])
-        tileset.image_height = int(image_element.attrib["height"])
-
-        if image_element.attrib.get("trans") is not None:
-            my_string = image_element.attrib["trans"]
-            if my_string[0] != "#":
-                my_string = f"#{my_string}"
-            tileset.transparent_color = parse_color(my_string)
-
-    tileoffset_element = raw_tileset.find("./tileoffset")
-    if tileoffset_element is not None:
-        tileset.tile_offset = OrderedPair(
-            int(tileoffset_element.attrib["x"]), int(tileoffset_element.attrib["y"])
-        )
-
-    grid_element = raw_tileset.find("./grid")
-    if grid_element is not None:
-        tileset.grid = _parse_grid(grid_element)
-
-    properties_element = raw_tileset.find("./properties")
-    if properties_element is not None:
-        tileset.properties = parse_properties(properties_element)
-
-    tiles = {}
-    for tile_element in raw_tileset.findall("./tile"):
-        tiles[int(tile_element.attrib["id"])] = _parse_tile(
-            tile_element, external_path=external_path
-        )
-    if tiles:
-        tileset.tiles = tiles
-
-    wangsets_element = raw_tileset.find("./wangsets")
-    if wangsets_element is not None:
-        wangsets = []
-        for raw_wangset in wangsets_element.findall("./wangset"):
-            wangsets.append(parse_wangset(raw_wangset))
-        tileset.wang_sets = wangsets
-
-    transformations_element = raw_tileset.find("./transformations")
-    if transformations_element is not None:
-        tileset.transformations = _parse_transformations(transformations_element)
-
-    return tileset
+import xml.etree.ElementTree as etree
+from pathlib import Path
+from typing import Optional
+from ...common_types import OrderedPair
+from ...parsers.tmx.layer import parse as parse_layer
+from ...parsers.tmx.properties import parse as parse_properties
+from ...parsers.tmx.wang_set import parse as parse_wangset
+from ...tileset import Frame, Grid, Tile, Tileset, Transformations
+from ...util import parse_color
+
+
+def _parse_frame(raw_frame: etree.Element) -> Frame:
+    """Parse the raw_frame to a Frame object.
+
+    Args:
+        raw_frame: XML Element to be parsed to a Frame
+
+    Returns:
+        Frame: The Frame created from the raw_frame
+    """
+
+    return Frame(
+        duration=int(raw_frame.attrib["duration"]),
+        tile_id=int(raw_frame.attrib["tileid"]),
+    )
+
+
+def _parse_grid(raw_grid: etree.Element) -> Grid:
+    """Parse the raw_grid to a Grid object.
+
+    Args:
+        raw_grid: XML Element to be parsed to a Grid
+
+    Returns:
+        Grid: The Grid created from the raw_grid
+    """
+
+    return Grid(
+        orientation=raw_grid.attrib["orientation"],
+        width=int(raw_grid.attrib["width"]),
+        height=int(raw_grid.attrib["height"]),
+    )
+
+
+def _parse_transformations(raw_transformations: etree.Element) -> Transformations:
+    """Parse the raw_transformations to a Transformations object.
+
+    Args:
+        raw_transformations: XML Element to be parsed to a Transformations
+
+    Returns:
+        Transformations: The Transformations created from the raw_transformations
+    """
+
+    return Transformations(
+        hflip=bool(int(raw_transformations.attrib["hflip"])),
+        vflip=bool(int(raw_transformations.attrib["vflip"])),
+        rotate=bool(int(raw_transformations.attrib["rotate"])),
+        prefer_untransformed=bool(
+            int(raw_transformations.attrib["preferuntransformed"])
+        ),
+    )
+
+
+def _parse_tile(raw_tile: etree.Element, external_path: Optional[Path] = None) -> Tile:
+    """Parse the raw_tile to a Tile object.
+
+    Args:
+        raw_tile: XML Element to be parsed to a Tile
+
+    Returns:
+        Tile: The Tile created from the raw_tile
+    """
+
+    tile = Tile(id=int(raw_tile.attrib["id"]))
+
+    if raw_tile.attrib.get("type") is not None:
+        tile.class_ = raw_tile.attrib["type"]
+
+    if raw_tile.attrib.get("class") is not None:
+        tile.class_ = raw_tile.attrib["class"]
+
+    animation_element = raw_tile.find("./animation")
+    if animation_element is not None:
+        tile.animation = []
+        for raw_frame in animation_element.findall("./frame"):
+            tile.animation.append(_parse_frame(raw_frame))
+
+    object_element = raw_tile.find("./objectgroup")
+    if object_element is not None:
+        tile.objects = parse_layer(object_element)
+
+    properties_element = raw_tile.find("./properties")
+    if properties_element is not None:
+        tile.properties = parse_properties(properties_element)
+
+    image_element = raw_tile.find("./image")
+    if image_element is not None:
+        if external_path:
+            tile.image = (
+                Path(external_path / image_element.attrib["source"])
+                .absolute()
+                .resolve()
+            )
+        else:
+            tile.image = Path(image_element.attrib["source"])
+
+        tile.image_width = int(image_element.attrib["width"])
+        tile.width = tile.image_width
+        tile.image_height = int(image_element.attrib["height"])
+        tile.height = tile.image_height
+
+    if raw_tile.attrib.get("x") is not None:
+        tile.x = int(raw_tile.attrib["x"])
+
+    if raw_tile.attrib.get("y") is not None:
+        tile.y = int(raw_tile.attrib["y"])
+
+    if raw_tile.attrib.get("width") is not None:
+        tile.width = int(raw_tile.attrib["width"])
+
+    if raw_tile.attrib.get("height") is not None:
+        tile.height = int(raw_tile.attrib["height"])
+
+    return tile
+
+
+def parse(
+    raw_tileset: etree.Element,
+    firstgid: int,
+    external_path: Optional[Path] = None,
+) -> Tileset:
+    tileset = Tileset(
+        name=raw_tileset.attrib["name"],
+        tile_count=int(raw_tileset.attrib["tilecount"]),
+        tile_width=int(raw_tileset.attrib["tilewidth"]),
+        tile_height=int(raw_tileset.attrib["tileheight"]),
+        columns=int(raw_tileset.attrib["columns"]),
+        firstgid=firstgid,
+    )
+
+    if raw_tileset.attrib.get("version") is not None:
+        tileset.version = raw_tileset.attrib["version"]
+
+    if raw_tileset.attrib.get("tiledversion") is not None:
+        tileset.tiled_version = raw_tileset.attrib["tiledversion"]
+
+    if raw_tileset.attrib.get("backgroundcolor") is not None:
+        tileset.background_color = parse_color(raw_tileset.attrib["backgroundcolor"])
+
+    if raw_tileset.attrib.get("spacing") is not None:
+        tileset.spacing = int(raw_tileset.attrib["spacing"])
+
+    if raw_tileset.attrib.get("margin") is not None:
+        tileset.margin = int(raw_tileset.attrib["margin"])
+
+    if raw_tileset.attrib.get("objectalignment") is not None:
+        tileset.alignment = raw_tileset.attrib["objectalignment"]
+
+    if raw_tileset.attrib.get("class") is not None:
+        tileset.class_ = raw_tileset.attrib["class"]
+
+    if raw_tileset.attrib.get("fillmode") is not None:
+        tileset.fill_mode = raw_tileset.attrib["fillmode"]
+
+    if raw_tileset.attrib.get("tilerendersize") is not None:
+        tileset.tile_render_size = raw_tileset.attrib["tilerendersize"]
+
+    image_element = raw_tileset.find("image")
+    if image_element is not None:
+        if external_path:
+            tileset.image = (
+                Path(external_path / image_element.attrib["source"])
+                .absolute()
+                .resolve()
+            )
+        else:
+            tileset.image = Path(image_element.attrib["source"])
+
+        tileset.image_width = int(image_element.attrib["width"])
+        tileset.image_height = int(image_element.attrib["height"])
+
+        if image_element.attrib.get("trans") is not None:
+            my_string = image_element.attrib["trans"]
+            if my_string[0] != "#":
+                my_string = f"#{my_string}"
+            tileset.transparent_color = parse_color(my_string)
+
+    tileoffset_element = raw_tileset.find("./tileoffset")
+    if tileoffset_element is not None:
+        tileset.tile_offset = OrderedPair(
+            int(tileoffset_element.attrib["x"]), int(tileoffset_element.attrib["y"])
+        )
+
+    grid_element = raw_tileset.find("./grid")
+    if grid_element is not None:
+        tileset.grid = _parse_grid(grid_element)
+
+    properties_element = raw_tileset.find("./properties")
+    if properties_element is not None:
+        tileset.properties = parse_properties(properties_element)
+
+    tiles = {}
+    for tile_element in raw_tileset.findall("./tile"):
+        tiles[int(tile_element.attrib["id"])] = _parse_tile(
+            tile_element, external_path=external_path
+        )
+    if tiles:
+        tileset.tiles = tiles
+
+    wangsets_element = raw_tileset.find("./wangsets")
+    if wangsets_element is not None:
+        wangsets = []
+        for raw_wangset in wangsets_element.findall("./wangset"):
+            wangsets.append(parse_wangset(raw_wangset))
+        tileset.wang_sets = wangsets
+
+    transformations_element = raw_tileset.find("./transformations")
+    if transformations_element is not None:
+        tileset.transformations = _parse_transformations(transformations_element)
+
+    return tileset
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_map.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_map.py`

 * *Ordering differences only*

 * *Files 19% similar despite different names*

```diff
@@ -1,77 +1,77 @@
-"""The tiled_map module contains the primary TiledMap class which represents a single
-map from Tiled.
-"""
-
-from pathlib import Path
-from typing import Dict, List, Optional
-from .common_types import Color, OrderedPair, Size
-from .layer import Layer
-from .properties import Properties
-from .tileset import Tileset
-
-
-TilesetDict = Dict[int, Tileset]
-
-
-class TiledMap:
-    """Object for storing a Tiled map with all associated objects.
-
-    This object is the top level object for a map. It contains all layers within a map,
-    as well as all Tiesets used by the map. When creating an implementation, this will
-    be the primary class to work with to pull all data relating to a map.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#map>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#map>`_
-
-    Attributes:
-        infinite: If the map is infinite or not.
-        layers: List of layer objects by draw order.
-        map_size: The map width in tiles.
-        next_layer_id: Stores the next available ID for new layers.
-        next_object_id: Stores the next available ID for new objects.
-        orientation: Map orientation. Tiled supports "orthogonal", "isometric",
-            "staggered" and "hexagonal"
-        render_order: The order in which tiles on tile layers are rendered. Valid values
-            are right-down, right-up, left-down and left-up. In all cases, the map is
-            drawn row-by-row. (only supported for orthogonal maps at the moment)
-        tiled_version: The Tiled version used to save the file. May be a date (for
-            snapshot builds).
-        tile_size: The size of a tile.
-        tilesets: Dict of Tileset where Key is the firstgid and the value is the Tileset
-        version: The JSON format version.
-        background_color: The background color of the map.
-        properties: The properties of the Map.
-        hex_side_length: Only for hexagonal maps. Determines the width or height
-            (depending on the staggered axis) of the tile's edge, in pixels.
-        stagger_axis: For staggered and hexagonal maps, determines which axis ("x" or
-            "y") is staggered.
-        stagger_index: For staggered and hexagonal maps, determines whether the "even"
-            or "odd" indexes along the staggered axis are shifted.
-        class_: The Tiled class of this Map.
-        parallax_origin: The point on the map to center the parallax scrolling of layers on.
-    """
-    def __init__(self, **kwars):
-        for k,v in kwars.items():
-            setattr(self, k, v)
-        # infinite: bool
-        # layers: List[Layer]
-        # map_size: Size
-        # next_layer_id: Optional[int]
-        # next_object_id: int
-        # orientation: str
-        # render_order: str
-        # tiled_version: str
-        # tile_size: Size
-        # tilesets: TilesetDict
-        # version: str
-        #
-        # parallax_origin: OrderedPair = OrderedPair(0, 0)
-        #
-        # map_file: Optional[Path] = None
-        # class_: Optional[str] = None
-        # background_color: Optional[Color] = None
-        # properties: Optional[Properties] = None
-        # hex_side_length: Optional[int] = None
-        # stagger_axis: Optional[str] = None
-        # stagger_index: Optional[str] = None
+"""The tiled_map module contains the primary TiledMap class which represents a single
+map from Tiled.
+"""
+
+from pathlib import Path
+from typing import Dict, List, Optional
+from .common_types import Color, OrderedPair, Size
+from .layer import Layer
+from .properties import Properties
+from .tileset import Tileset
+
+
+TilesetDict = Dict[int, Tileset]
+
+
+class TiledMap:
+    """Object for storing a Tiled map with all associated objects.
+
+    This object is the top level object for a map. It contains all layers within a map,
+    as well as all Tiesets used by the map. When creating an implementation, this will
+    be the primary class to work with to pull all data relating to a map.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#map>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#map>`_
+
+    Attributes:
+        infinite: If the map is infinite or not.
+        layers: List of layer objects by draw order.
+        map_size: The map width in tiles.
+        next_layer_id: Stores the next available ID for new layers.
+        next_object_id: Stores the next available ID for new objects.
+        orientation: Map orientation. Tiled supports "orthogonal", "isometric",
+            "staggered" and "hexagonal"
+        render_order: The order in which tiles on tile layers are rendered. Valid values
+            are right-down, right-up, left-down and left-up. In all cases, the map is
+            drawn row-by-row. (only supported for orthogonal maps at the moment)
+        tiled_version: The Tiled version used to save the file. May be a date (for
+            snapshot builds).
+        tile_size: The size of a tile.
+        tilesets: Dict of Tileset where Key is the firstgid and the value is the Tileset
+        version: The JSON format version.
+        background_color: The background color of the map.
+        properties: The properties of the Map.
+        hex_side_length: Only for hexagonal maps. Determines the width or height
+            (depending on the staggered axis) of the tile's edge, in pixels.
+        stagger_axis: For staggered and hexagonal maps, determines which axis ("x" or
+            "y") is staggered.
+        stagger_index: For staggered and hexagonal maps, determines whether the "even"
+            or "odd" indexes along the staggered axis are shifted.
+        class_: The Tiled class of this Map.
+        parallax_origin: The point on the map to center the parallax scrolling of layers on.
+    """
+    def __init__(self, **kwars):
+        for k,v in kwars.items():
+            setattr(self, k, v)
+        # infinite: bool
+        # layers: List[Layer]
+        # map_size: Size
+        # next_layer_id: Optional[int]
+        # next_object_id: int
+        # orientation: str
+        # render_order: str
+        # tiled_version: str
+        # tile_size: Size
+        # tilesets: TilesetDict
+        # version: str
+        #
+        # parallax_origin: OrderedPair = OrderedPair(0, 0)
+        #
+        # map_file: Optional[Path] = None
+        # class_: Optional[str] = None
+        # background_color: Optional[Color] = None
+        # properties: Optional[Properties] = None
+        # hex_side_length: Optional[int] = None
+        # stagger_axis: Optional[str] = None
+        # stagger_index: Optional[str] = None
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_object.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tiled_object.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,154 +1,154 @@
-# pylint: disable=too-few-public-methods
-import xml.etree.ElementTree as etree
-from pathlib import Path
-from typing import Any, Dict, List, Optional, Union
-
-from . import properties as properties_
-from .common_types import Color, OrderedPair, Size
-
-
-class TiledObject:
-    """TiledObject object.
-
-    See:
-        https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#object
-
-    Attributes:
-        id_: Unique ID of the tiled object. Each tiled object that is placed on a map
-            gets a unique id. Even if an tiled object was deleted, no tiled object gets
-            the same ID.
-        gid: Global tiled object ID.
-        coordinates: The location of the tiled object in pixels.
-        size: The width of the tiled object in pixels (default: (0, 0)).
-        rotation: The rotation of the tiled object in degrees clockwise (default: 0).
-        opacity: The opacity of the tiled object. (default: 1)
-        name: The name of the tiled object.
-        class_: The Tiled class of the tiled object.
-        properties: The properties of the TiledObject.
-    """
-    def __init__(self, id=None, gid=None, coordinates=None, size=None, rotation=0, opacity=0, name='', class_='', visible=True, properties=None):
-        self.id = id
-        self.gid = gid
-        self.coordinates = [0, 0]
-        if coordinates:
-            self.coordinates=coordinates
-        self.size = [0, 0]
-        if size:
-            self.size=size
-        self.rotation = rotation
-        self.opacity = opacity
-        self.name = name
-        self.class_ = class_
-        self.visible=visible
-        if not properties:
-            self.properties = dict()
-        else:
-            self.properties = properties
-
-
-class Ellipse(TiledObject):
-    """Elipse shape defined by a point, width, height, and rotation.
-
-    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#ellipse
-    """
-
-
-class Point(TiledObject):
-    """Point defined by a coordinate (x,y).
-
-    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#point
-    """
-
-
-class Polygon(TiledObject):
-    """Polygon shape defined by a set of connections between points.
-
-    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#polygon
-
-    Attributes:
-        points: List of coordinates relative to the location of the object.
-    """
-    def __init__(self, **kwargs):
-        self.points = list()
-        if 'points' in kwargs:
-            self.points = kwargs['points']
-        super().__init__(**kwargs)
-
-
-class Polyline(TiledObject):
-    """Polyline defined by a set of connections between points.
-
-    See:
-        https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#polyline
-
-    Attributes:
-        points: List of coordinates relative to the location of the object.
-    """
-    # points: List[OrderedPair]
-    pass
-
-
-class Rectangle(TiledObject):
-    """Rectangle shape defined by a point, width, and height.
-
-    See: https://doc.mapeditor.org/en/stable/manual/objects/#insert-rectangle
-        (objects in tiled are rectangles by default, so there is no specific
-        documentation on the tmx-map-format page for it.)
-    """
-
-
-class Text(TiledObject):
-    """Text object with associated settings.
-
-    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#text
-        and https://doc.mapeditor.org/en/stable/manual/objects/#insert-text
-
-    Attributes:
-        text: The text to display
-        color: Color of the text. (default: (255, 255, 255, 255))
-        font_family: The font family used (default: "sans-serif")
-        font_size: The size of the font in pixels. (default: 16)
-        bold: Whether the font is bold. (default: False)
-        italic: Whether the font is italic. (default: False)
-        kerning: Whether kerning should be used while rendering the text. (default:
-            False)
-        strike_out: Whether the text is striked-out. (default: False)
-        underline: Whether the text is underlined. (default: False)
-        horizontal_align: Horizontal alignment of the text (default: "left")
-        vertical_align: Vertical alignment of the text (defalt: "top")
-        wrap: Whether word wrapping is enabled. (default: False)
-    """
-    def __init__(self, text='', **kwargs):
-        self.text =text
-        super().__init__(**kwargs)
-
-        # TODO finish
-        # text: str
-        # color: Color = Color(255, 255, 255, 255)
-        #
-        # font_family: str = "sans-serif"
-        # font_size: float = 16
-        #
-        # bold: bool = False
-        # italic: bool = False
-        # kerning: bool = True
-        # strike_out: bool = False
-        # underline: bool = False
-        #
-        # horizontal_align: str = "left"
-        # vertical_align: str = "top"
-        # wrap: bool = False
-
-
-class Tile(TiledObject):
-    """Tile object
-
-    See: https://doc.mapeditor.org/en/stable/manual/objects/#insert-tile
-
-    Attributes:
-        gid: Reference to a global tile id.
-    """
-
-    gid: int
-    new_tileset: Optional[Union[etree.Element, Dict[str, Any]]] = None
-    new_tileset_path: Optional[Path] = None
+# pylint: disable=too-few-public-methods
+import xml.etree.ElementTree as etree
+from pathlib import Path
+from typing import Any, Dict, List, Optional, Union
+
+from . import properties as properties_
+from .common_types import Color, OrderedPair, Size
+
+
+class TiledObject:
+    """TiledObject object.
+
+    See:
+        https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#object
+
+    Attributes:
+        id_: Unique ID of the tiled object. Each tiled object that is placed on a map
+            gets a unique id. Even if an tiled object was deleted, no tiled object gets
+            the same ID.
+        gid: Global tiled object ID.
+        coordinates: The location of the tiled object in pixels.
+        size: The width of the tiled object in pixels (default: (0, 0)).
+        rotation: The rotation of the tiled object in degrees clockwise (default: 0).
+        opacity: The opacity of the tiled object. (default: 1)
+        name: The name of the tiled object.
+        class_: The Tiled class of the tiled object.
+        properties: The properties of the TiledObject.
+    """
+    def __init__(self, id=None, gid=None, coordinates=None, size=None, rotation=0, opacity=0, name='', class_='', visible=True, properties=None):
+        self.id = id
+        self.gid = gid
+        self.coordinates = [0, 0]
+        if coordinates:
+            self.coordinates=coordinates
+        self.size = [0, 0]
+        if size:
+            self.size=size
+        self.rotation = rotation
+        self.opacity = opacity
+        self.name = name
+        self.class_ = class_
+        self.visible=visible
+        if not properties:
+            self.properties = dict()
+        else:
+            self.properties = properties
+
+
+class Ellipse(TiledObject):
+    """Elipse shape defined by a point, width, height, and rotation.
+
+    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#ellipse
+    """
+
+
+class Point(TiledObject):
+    """Point defined by a coordinate (x,y).
+
+    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#point
+    """
+
+
+class Polygon(TiledObject):
+    """Polygon shape defined by a set of connections between points.
+
+    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#polygon
+
+    Attributes:
+        points: List of coordinates relative to the location of the object.
+    """
+    def __init__(self, **kwargs):
+        self.points = list()
+        if 'points' in kwargs:
+            self.points = kwargs['points']
+        super().__init__(**kwargs)
+
+
+class Polyline(TiledObject):
+    """Polyline defined by a set of connections between points.
+
+    See:
+        https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#polyline
+
+    Attributes:
+        points: List of coordinates relative to the location of the object.
+    """
+    # points: List[OrderedPair]
+    pass
+
+
+class Rectangle(TiledObject):
+    """Rectangle shape defined by a point, width, and height.
+
+    See: https://doc.mapeditor.org/en/stable/manual/objects/#insert-rectangle
+        (objects in tiled are rectangles by default, so there is no specific
+        documentation on the tmx-map-format page for it.)
+    """
+
+
+class Text(TiledObject):
+    """Text object with associated settings.
+
+    See: https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#text
+        and https://doc.mapeditor.org/en/stable/manual/objects/#insert-text
+
+    Attributes:
+        text: The text to display
+        color: Color of the text. (default: (255, 255, 255, 255))
+        font_family: The font family used (default: "sans-serif")
+        font_size: The size of the font in pixels. (default: 16)
+        bold: Whether the font is bold. (default: False)
+        italic: Whether the font is italic. (default: False)
+        kerning: Whether kerning should be used while rendering the text. (default:
+            False)
+        strike_out: Whether the text is striked-out. (default: False)
+        underline: Whether the text is underlined. (default: False)
+        horizontal_align: Horizontal alignment of the text (default: "left")
+        vertical_align: Vertical alignment of the text (defalt: "top")
+        wrap: Whether word wrapping is enabled. (default: False)
+    """
+    def __init__(self, text='', **kwargs):
+        self.text =text
+        super().__init__(**kwargs)
+
+        # TODO finish
+        # text: str
+        # color: Color = Color(255, 255, 255, 255)
+        #
+        # font_family: str = "sans-serif"
+        # font_size: float = 16
+        #
+        # bold: bool = False
+        # italic: bool = False
+        # kerning: bool = True
+        # strike_out: bool = False
+        # underline: bool = False
+        #
+        # horizontal_align: str = "left"
+        # vertical_align: str = "top"
+        # wrap: bool = False
+
+
+class Tile(TiledObject):
+    """Tile object
+
+    See: https://doc.mapeditor.org/en/stable/manual/objects/#insert-tile
+
+    Attributes:
+        gid: Reference to a global tile id.
+    """
+
+    gid: int
+    new_tileset: Optional[Union[etree.Element, Dict[str, Any]]] = None
+    new_tileset_path: Optional[Path] = None
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/tileset.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/tileset.py`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,245 +1,245 @@
-"""Provides an interface for Tilesets and the various objects within them.
-
-Also see [Tiled's Docs for Editing Tilesets](https://doc.mapeditor.org/en/stable/manual/editing-tilesets/)
-and [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tileset)
-and [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#tileset)
-"""
-# pylint: disable=too-few-public-methods
-from pathlib import Path
-from typing import Dict, List, NamedTuple, Optional
-
-from . import layer
-from . import properties as properties_
-from .common_types import Color, OrderedPair
-
-
-# from .wang_set import WangSet
-
-
-class Grid(NamedTuple):
-    """Contains info used in isometric maps.
-
-    This element is only used in case of isometric orientation, and determines how tile
-    overlays for terrain and collision information are rendered.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-grid>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#grid>`_
-
-    Attributes:
-        orientation: Orientation of the grid for the tiles in this tileset (orthogonal
-            or isometric).
-        width: Width of a grid cell.
-        height: Height of a grid cell.
-    """
-
-    orientation: str
-    width: int
-    height: int
-
-
-class Frame(NamedTuple):
-    """Animation Frame object.
-
-    This is only used as a part of an animation for Tile objects. A frame simply points
-    to a tile within the tileset, and gives a duration. Meaning that tile would be
-    displayed for the given duration.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-frame>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-frame>`_
-
-    Attributes:
-        tile_id: The local ID of a tile within the parent tile set object.
-        duration: How long in milliseconds this frame should be displayed before
-            advancing to the next frame.
-    """
-
-    tile_id: int
-    duration: int
-
-
-class Transformations:
-    """Transformations Object.
-
-    This is used to store what transformations may be performed on Tiles
-    within a tileset. Within Tiled this primarily used with wang sets and
-    the terrain system, however, could be used for any means a game/engine
-    wants to really.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#transformations>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#transformations>`_
-
-    Attributes:
-        hflip: Allow horizontal flip?
-        vflip: Allow vertical flip?
-        rotate: Allow rotation?
-        prefer_untransformed: Should untransformed tiles be preferred?
-    """
-
-    hflip: bool = False
-    vflip: bool = False
-    rotate: bool = False
-    prefer_untransformed: bool = False
-
-
-class Tile:
-    """Individual tile object.
-
-    This class more closely resembles the JSON format than TMX. A number of values
-    within this class in the TMX format are pulled into other sub-tags such as <image>.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tile>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tile-definition>`_
-
-    Attributes:
-        id: The local tile ID within it's tileset.
-        opacity: The opacity this Tiled should be rendered with.
-        type: An optional, arbitrary string that can be used to denote different
-            types of tiles. For example "wall" or "floor".
-        animation: A list of [Frame][pytiled_parser.tileset.Frame] objects which
-            makeup the animation for an animated tile.
-        objects: An [ObjectLayer][pytiled_parser.layer.ObjectLayer] which contains
-            objects that can be used for custom collision on the Tile. This field
-            is set by the Tile Collision editor in Tiled.
-        image: A path to the image for this tile.
-        image_width: The width of this tile's image.
-        image_height: The height of this tile's image.
-        properties: A list of properties on this Tile.
-        tileset: The [Tileset][pytiled_parser.tileset.Tileset] this tile came from.
-        flipped_horizontally: Should this Tile be flipped horizontally?
-        flipped_diagonally: Should this Tile be flipped diagonally?
-        flipped_vertically: Should this Tile be flipped vertically?
-        class_: The Tiled class of this Tile.
-    """
-
-    id: int
-    opacity: int = 1
-    x: int = 0
-    y: int = 0
-    width: Optional[int] = None
-    height: Optional[int] = None
-    class_: Optional[str] = None
-    animation: Optional[List[Frame]] = None
-    objects: Optional[layer.Layer] = None
-    image: Optional[Path] = None
-    image_width: Optional[int] = None
-    image_height: Optional[int] = None
-    properties: Optional[properties_.Properties] = None
-    tileset: Optional["Tileset"] = None
-    flipped_horizontally: bool = False
-    flipped_diagonally: bool = False
-    flipped_vertically: bool = False
-
-
-class Tileset:
-    """A Tileset is a collection of tiles.
-
-    This class much more closely resembles the JSON format than TMX.
-
-    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tileset>`_
-
-    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tileset>`_
-
-    Attributes:
-        name: The name of this tileset.
-        tile_width: The width of a tile in this tileset in pixels.
-        tile_height: The height of a tile in this tileset in pixels.
-        tile_count: The number of tiles in this tileset.
-        columns: The number of tile columns in the tileset. For image collection
-            tilesets it is editable and is used when displaying the tileset.
-        firstgid: The global ID to give to the first Tile in this tileset. Global IDs
-            for the rest of the tiles will increment from this number.
-        spacing: The spacing in pixels between the tiles in this tileset (applies to
-            the tileset image).
-        type: Will always be `tileset`. Is statically included as a way to determine the
-            type of a JSON file since Tiled does not have different extesnsions for map
-            and tileset JSON files(as opposed to TMX/TSX files). This value will typically not be used.
-        spacing: Spacing between adjacent tiles in the image in pixels. Defaults to 0.
-        margin: Buffer between the image edge and the first tile in the image in pixels. Defaults to 0.
-        tiled_version: The version of Tiled this tileset was saved with
-        version: The version of the JSON or TSX format this tileset was saved with.
-            This will typically be the same as the tiled_version parameter, but they are tracked separately
-            mostly for futureproofing.
-        image: The image file to be used for spritesheet tile sets.
-        image_width: The width of the `image` in pixels. Only set if the image parameter is.
-            This value is taken from whatever Tiled outputs, the image size is not calculated by pytiled-parser.
-        image_height: The height of the `image` in pixels. Only set if the image parameter is.
-            This value is taken from whatever Tiled outputs, the image size is not calculated by pytiled-parser.
-        transformations: What types of transformations are allowed on tiles within
-            this Tileset
-        background_color: The background color of the tileset. This will typically only be
-            used by the editor, but could be useful for displaying a TileSet if you had the need to do that.
-        tileoffset: Used to specify an offset in pixels when drawing a tile from the
-            tileset. When not present, no offset is applied.
-        transparent_color: A color that should act as transparent on any tiles within the
-            tileset. This would need to be taken into account by an implementation when loading the tile images.
-        grid: Only used in case of isometric orientation, and determines how tile
-            overlays for terrain and collision information are rendered.
-        properties: The properties for this Tileset.
-        tiles: Dict of Tile objects with the Tile.id value as the key.
-        wang_sets: List of WangSets, this is used by the terrain system in Tiled. It is unlikely an
-            implementation in a game engine would need to use these values.
-        alignment: Which alignment to use for tile objects from this tileset.
-        class_: The Tiled class of this TileSet.
-        tile_render_size: The size to use when rendering tiles from this tileset. Can be either "tile" or "grid".
-        fill_mode: The fill mode to use when rendering tiles from this tileset.
-            Can be either "stretch" or "preserve-aspect-fit".
-    """
-
-    def __init__(self,
-                 name='',
-                 tile_width=0,
-                 tile_height=0,
-                 tile_count=0,
-                 columns=0,
-                 firstgid=0,
-                 type="tileset",
-                 tile_render_size="tile",
-                 fill_mode="stretch",
-                 spacing=0,
-                 margin=0,
-                 tiled_version=None,
-                 version=None,
-                 image=None,
-                 image_width=None,
-                 image_height=None,
-                 transformations=None,
-                 class_=None,
-                 background_color=None,
-                 tileoffset=None,
-                 transparent_color=None,
-                 grid=None,
-                 properties=None,
-                 tiles=None,
-                 wang_sets=None,  # Optional[List[WangSet]] = None
-                 alignment=None,
-                 ):
-        self.name = name
-        self.tile_width = tile_width
-        self.tile_height = tile_height
-        self.tile_count = tile_count
-        self.columns = columns
-        self.firstgid = firstgid
-        self.type = type
-        self.tile_render_size = tile_render_size
-        self.fill_mode = fill_mode
-        self.spacing = spacing,
-        self.margin = margin
-        self.tiled_version = tiled_version
-        self.version = version
-        self.image = image
-        self.image_width = image_width
-        self.image_height = image_height
-        self.transformations = transformations
-        self.class_ = class_
-        self.background_color = background_color
-        self.tileoffset = tileoffset
-        self.transparent_color = transparent_color
-        self.grid = grid
-        self.properties = properties
-        self.tiles = tiles
-        self.wang_sets = wang_sets
-        self.alignment = alignment
+"""Provides an interface for Tilesets and the various objects within them.
+
+Also see [Tiled's Docs for Editing Tilesets](https://doc.mapeditor.org/en/stable/manual/editing-tilesets/)
+and [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tileset)
+and [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#tileset)
+"""
+# pylint: disable=too-few-public-methods
+from pathlib import Path
+from typing import Dict, List, NamedTuple, Optional
+
+from . import layer
+from . import properties as properties_
+from .common_types import Color, OrderedPair
+
+
+# from .wang_set import WangSet
+
+
+class Grid(NamedTuple):
+    """Contains info used in isometric maps.
+
+    This element is only used in case of isometric orientation, and determines how tile
+    overlays for terrain and collision information are rendered.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-grid>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#grid>`_
+
+    Attributes:
+        orientation: Orientation of the grid for the tiles in this tileset (orthogonal
+            or isometric).
+        width: Width of a grid cell.
+        height: Height of a grid cell.
+    """
+
+    orientation: str
+    width: int
+    height: int
+
+
+class Frame(NamedTuple):
+    """Animation Frame object.
+
+    This is only used as a part of an animation for Tile objects. A frame simply points
+    to a tile within the tileset, and gives a duration. Meaning that tile would be
+    displayed for the given duration.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tmx-frame>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#json-frame>`_
+
+    Attributes:
+        tile_id: The local ID of a tile within the parent tile set object.
+        duration: How long in milliseconds this frame should be displayed before
+            advancing to the next frame.
+    """
+
+    tile_id: int
+    duration: int
+
+
+class Transformations:
+    """Transformations Object.
+
+    This is used to store what transformations may be performed on Tiles
+    within a tileset. Within Tiled this primarily used with wang sets and
+    the terrain system, however, could be used for any means a game/engine
+    wants to really.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#transformations>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#transformations>`_
+
+    Attributes:
+        hflip: Allow horizontal flip?
+        vflip: Allow vertical flip?
+        rotate: Allow rotation?
+        prefer_untransformed: Should untransformed tiles be preferred?
+    """
+
+    hflip: bool = False
+    vflip: bool = False
+    rotate: bool = False
+    prefer_untransformed: bool = False
+
+
+class Tile:
+    """Individual tile object.
+
+    This class more closely resembles the JSON format than TMX. A number of values
+    within this class in the TMX format are pulled into other sub-tags such as <image>.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tile>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tile-definition>`_
+
+    Attributes:
+        id: The local tile ID within it's tileset.
+        opacity: The opacity this Tiled should be rendered with.
+        type: An optional, arbitrary string that can be used to denote different
+            types of tiles. For example "wall" or "floor".
+        animation: A list of [Frame][pytiled_parser.tileset.Frame] objects which
+            makeup the animation for an animated tile.
+        objects: An [ObjectLayer][pytiled_parser.layer.ObjectLayer] which contains
+            objects that can be used for custom collision on the Tile. This field
+            is set by the Tile Collision editor in Tiled.
+        image: A path to the image for this tile.
+        image_width: The width of this tile's image.
+        image_height: The height of this tile's image.
+        properties: A list of properties on this Tile.
+        tileset: The [Tileset][pytiled_parser.tileset.Tileset] this tile came from.
+        flipped_horizontally: Should this Tile be flipped horizontally?
+        flipped_diagonally: Should this Tile be flipped diagonally?
+        flipped_vertically: Should this Tile be flipped vertically?
+        class_: The Tiled class of this Tile.
+    """
+
+    id: int
+    opacity: int = 1
+    x: int = 0
+    y: int = 0
+    width: Optional[int] = None
+    height: Optional[int] = None
+    class_: Optional[str] = None
+    animation: Optional[List[Frame]] = None
+    objects: Optional[layer.Layer] = None
+    image: Optional[Path] = None
+    image_width: Optional[int] = None
+    image_height: Optional[int] = None
+    properties: Optional[properties_.Properties] = None
+    tileset: Optional["Tileset"] = None
+    flipped_horizontally: bool = False
+    flipped_diagonally: bool = False
+    flipped_vertically: bool = False
+
+
+class Tileset:
+    """A Tileset is a collection of tiles.
+
+    This class much more closely resembles the JSON format than TMX.
+
+    `TMX Reference <https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#tileset>`_
+
+    `JSON Reference <https://doc.mapeditor.org/en/stable/reference/json-map-format/#tileset>`_
+
+    Attributes:
+        name: The name of this tileset.
+        tile_width: The width of a tile in this tileset in pixels.
+        tile_height: The height of a tile in this tileset in pixels.
+        tile_count: The number of tiles in this tileset.
+        columns: The number of tile columns in the tileset. For image collection
+            tilesets it is editable and is used when displaying the tileset.
+        firstgid: The global ID to give to the first Tile in this tileset. Global IDs
+            for the rest of the tiles will increment from this number.
+        spacing: The spacing in pixels between the tiles in this tileset (applies to
+            the tileset image).
+        type: Will always be `tileset`. Is statically included as a way to determine the
+            type of a JSON file since Tiled does not have different extesnsions for map
+            and tileset JSON files(as opposed to TMX/TSX files). This value will typically not be used.
+        spacing: Spacing between adjacent tiles in the image in pixels. Defaults to 0.
+        margin: Buffer between the image edge and the first tile in the image in pixels. Defaults to 0.
+        tiled_version: The version of Tiled this tileset was saved with
+        version: The version of the JSON or TSX format this tileset was saved with.
+            This will typically be the same as the tiled_version parameter, but they are tracked separately
+            mostly for futureproofing.
+        image: The image file to be used for spritesheet tile sets.
+        image_width: The width of the `image` in pixels. Only set if the image parameter is.
+            This value is taken from whatever Tiled outputs, the image size is not calculated by pytiled-parser.
+        image_height: The height of the `image` in pixels. Only set if the image parameter is.
+            This value is taken from whatever Tiled outputs, the image size is not calculated by pytiled-parser.
+        transformations: What types of transformations are allowed on tiles within
+            this Tileset
+        background_color: The background color of the tileset. This will typically only be
+            used by the editor, but could be useful for displaying a TileSet if you had the need to do that.
+        tileoffset: Used to specify an offset in pixels when drawing a tile from the
+            tileset. When not present, no offset is applied.
+        transparent_color: A color that should act as transparent on any tiles within the
+            tileset. This would need to be taken into account by an implementation when loading the tile images.
+        grid: Only used in case of isometric orientation, and determines how tile
+            overlays for terrain and collision information are rendered.
+        properties: The properties for this Tileset.
+        tiles: Dict of Tile objects with the Tile.id value as the key.
+        wang_sets: List of WangSets, this is used by the terrain system in Tiled. It is unlikely an
+            implementation in a game engine would need to use these values.
+        alignment: Which alignment to use for tile objects from this tileset.
+        class_: The Tiled class of this TileSet.
+        tile_render_size: The size to use when rendering tiles from this tileset. Can be either "tile" or "grid".
+        fill_mode: The fill mode to use when rendering tiles from this tileset.
+            Can be either "stretch" or "preserve-aspect-fit".
+    """
+
+    def __init__(self,
+                 name='',
+                 tile_width=0,
+                 tile_height=0,
+                 tile_count=0,
+                 columns=0,
+                 firstgid=0,
+                 type="tileset",
+                 tile_render_size="tile",
+                 fill_mode="stretch",
+                 spacing=0,
+                 margin=0,
+                 tiled_version=None,
+                 version=None,
+                 image=None,
+                 image_width=None,
+                 image_height=None,
+                 transformations=None,
+                 class_=None,
+                 background_color=None,
+                 tileoffset=None,
+                 transparent_color=None,
+                 grid=None,
+                 properties=None,
+                 tiles=None,
+                 wang_sets=None,  # Optional[List[WangSet]] = None
+                 alignment=None,
+                 ):
+        self.name = name
+        self.tile_width = tile_width
+        self.tile_height = tile_height
+        self.tile_count = tile_count
+        self.columns = columns
+        self.firstgid = firstgid
+        self.type = type
+        self.tile_render_size = tile_render_size
+        self.fill_mode = fill_mode
+        self.spacing = spacing,
+        self.margin = margin
+        self.tiled_version = tiled_version
+        self.version = version
+        self.image = image
+        self.image_width = image_width
+        self.image_height = image_height
+        self.transformations = transformations
+        self.class_ = class_
+        self.background_color = background_color
+        self.tileoffset = tileoffset
+        self.transparent_color = transparent_color
+        self.grid = grid
+        self.properties = properties
+        self.tiles = tiles
+        self.wang_sets = wang_sets
+        self.alignment = alignment
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/util.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/util.py`

 * *Ordering differences only*

 * *Files 23% similar despite different names*

```diff
@@ -1,84 +1,84 @@
-"""Utility Functions for PyTiled"""
-import json
-import xml.etree.ElementTree as etree
-from pathlib import Path
-from typing import Any
-from .common_types import Color
-
-
-def parse_color(color: str) -> Color:
-    """Convert Tiled color format into PyTiled's.
-
-    Tiled's color format is #AARRGGBB and PyTiled's is an RGBA tuple.
-
-    Args:
-        color (str): Tiled formatted color string.
-    Returns:
-        :Color: Color object in the format that PyTiled understands.
-    """
-    # the actual part we care about is always an even number
-    if len(color) % 2:
-        # strip initial '#' character
-        color = color[1:]
-
-    if len(color) == 6:
-        # full opacity if no alpha specified
-        return Color(int(color[0:2], 16), int(color[2:4], 16), int(color[4:6], 16), 255)
-    elif len(color) == 8:
-        return Color(
-            int(color[2:4], 16),
-            int(color[4:6], 16),
-            int(color[6:8], 16),
-            int(color[0:2], 16),
-        )
-
-    raise ValueError("Improperly formatted color passed to parse_color")
-
-
-def check_format(file_path) -> str:  # file_path: Path
-    with open(file_path) as file:
-        line = file.readline().rstrip().strip()
-        if line[0] == "<":
-            return "tmx"
-        else:
-            return "json"
-
-
-def load_object_template(file_path: Path) -> Any:
-    template_format = check_format(file_path)
-
-    new_tileset = None
-    new_tileset_path = None
-
-    if template_format == "tmx":
-        with open(file_path) as template_file:
-            template = etree.parse(template_file).getroot()
-
-            tileset_element = template.find("./tileset")
-            if tileset_element is not None:
-                tileset_path = Path(file_path.parent / tileset_element.attrib["source"])
-                new_tileset = load_object_tileset(tileset_path)
-                new_tileset_path = tileset_path.parent
-    else:
-        with open(file_path) as template_file:
-            template = json.load(template_file)
-            if "tileset" in template:
-                tileset_path = Path(file_path.parent / template["tileset"]["source"])  # type: ignore
-                new_tileset = load_object_tileset(tileset_path)
-                new_tileset_path = tileset_path.parent
-
-    return (template, new_tileset, new_tileset_path)
-
-
-def load_object_tileset(file_path: Path) -> Any:
-    tileset_format = check_format(file_path)
-
-    new_tileset = None
-
-    with open(file_path) as tileset_file:
-        if tileset_format == "tmx":
-            new_tileset = etree.parse(tileset_file).getroot()
-        else:
-            new_tileset = json.load(tileset_file)
-
-    return new_tileset
+"""Utility Functions for PyTiled"""
+import json
+import xml.etree.ElementTree as etree
+from pathlib import Path
+from typing import Any
+from .common_types import Color
+
+
+def parse_color(color: str) -> Color:
+    """Convert Tiled color format into PyTiled's.
+
+    Tiled's color format is #AARRGGBB and PyTiled's is an RGBA tuple.
+
+    Args:
+        color (str): Tiled formatted color string.
+    Returns:
+        :Color: Color object in the format that PyTiled understands.
+    """
+    # the actual part we care about is always an even number
+    if len(color) % 2:
+        # strip initial '#' character
+        color = color[1:]
+
+    if len(color) == 6:
+        # full opacity if no alpha specified
+        return Color(int(color[0:2], 16), int(color[2:4], 16), int(color[4:6], 16), 255)
+    elif len(color) == 8:
+        return Color(
+            int(color[2:4], 16),
+            int(color[4:6], 16),
+            int(color[6:8], 16),
+            int(color[0:2], 16),
+        )
+
+    raise ValueError("Improperly formatted color passed to parse_color")
+
+
+def check_format(file_path) -> str:  # file_path: Path
+    with open(file_path) as file:
+        line = file.readline().rstrip().strip()
+        if line[0] == "<":
+            return "tmx"
+        else:
+            return "json"
+
+
+def load_object_template(file_path: Path) -> Any:
+    template_format = check_format(file_path)
+
+    new_tileset = None
+    new_tileset_path = None
+
+    if template_format == "tmx":
+        with open(file_path) as template_file:
+            template = etree.parse(template_file).getroot()
+
+            tileset_element = template.find("./tileset")
+            if tileset_element is not None:
+                tileset_path = Path(file_path.parent / tileset_element.attrib["source"])
+                new_tileset = load_object_tileset(tileset_path)
+                new_tileset_path = tileset_path.parent
+    else:
+        with open(file_path) as template_file:
+            template = json.load(template_file)
+            if "tileset" in template:
+                tileset_path = Path(file_path.parent / template["tileset"]["source"])  # type: ignore
+                new_tileset = load_object_tileset(tileset_path)
+                new_tileset_path = tileset_path.parent
+
+    return (template, new_tileset, new_tileset_path)
+
+
+def load_object_tileset(file_path: Path) -> Any:
+    tileset_format = check_format(file_path)
+
+    new_tileset = None
+
+    with open(file_path) as tileset_file:
+        if tileset_format == "tmx":
+            new_tileset = etree.parse(tileset_file).getroot()
+        else:
+            new_tileset = json.load(tileset_file)
+
+    return new_tileset
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/wang_set.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/wang_set.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,86 +1,86 @@
-"""This module contains a number of classes related to Wang Sets.
-
-Wang Sets are the underlying data used by Tiled's terrain system.
-See [Tiled's docs about terrain](https://doc.mapeditor.org/en/stable/manual/terrain/)
-and also the [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangsets)
-and the [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-set)
-"""
-from typing import Dict, List, Optional
-
-import attr
-
-from ..common_types import Color
-from pytiled_parser.properties import Properties
-
-
-@attr.s(auto_attribs=True)
-class WangTile:
-    """Defines a Wang tile by linking a tile in the tileset to a Wang ID.
-
-    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangtile)
-
-    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-tile)
-
-    Attributes:
-        tile_id: The ID of the tile this WangTile maps to
-        wang_id: The wang color indexes for this tile. This is a list of IDs referring
-            to colors within the wang set. In the order of top, top right, right,
-            bottom right, bottom, bottom left, left, top left.
-    """
-
-    tile_id: int
-    wang_id: List[int]
-
-
-@attr.s(auto_attribs=True)
-class WangColor:
-    """A color that can be used to define the corner and/or edge of a Wang tile
-
-    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangcolor)
-
-    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-color)
-
-    Attributes:
-        color: An RGBA color used to identify this Wang color
-        name: The name for this color
-        probability: The probability used when randomizing tiles
-        properties: The properties for this wang color
-        class_: The Tiled class of this Wang Color
-        tile: Tile ID of the tile representing this color
-    """
-
-    color: Color
-    name: str
-    probability: float
-    tile: int
-    class_: Optional[str] = None
-    properties: Optional[Properties] = None
-
-
-@attr.s(auto_attribs=True)
-class WangSet:
-    """A complete Wang Set defining a list of corner and edge
-    [WangColors][pytiled_parser.wang_set.WangColor], and any number of
-    [WangTiles][pytiled_parser.wang_set.WangTile]
-
-    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangset)
-
-    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-set)
-
-    Attributes:
-        name: Name of the WangSet
-        properties: The properties for this wang set
-        class_: The Tiled class of this Wang Set
-        tile: Tile ID of the tile representing this Wang Set
-        wang_colors: A list of [WangColors][pytiled_parser.wang_set.WangColor]
-        wang_tiles: A list of [WangTiles][pytiled_parser.wang_set.WangTile]
-        wang_type: A string noting the type of this wang set
-    """
-
-    name: str
-    tile: int
-    wang_type: str
-    wang_tiles: Dict[int, WangTile]
-    wang_colors: List[WangColor]
-    class_: Optional[str] = None
-    properties: Optional[Properties] = None
+"""This module contains a number of classes related to Wang Sets.
+
+Wang Sets are the underlying data used by Tiled's terrain system.
+See [Tiled's docs about terrain](https://doc.mapeditor.org/en/stable/manual/terrain/)
+and also the [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangsets)
+and the [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-set)
+"""
+from typing import Dict, List, Optional
+
+import attr
+
+from ..common_types import Color
+from pytiled_parser.properties import Properties
+
+
+@attr.s(auto_attribs=True)
+class WangTile:
+    """Defines a Wang tile by linking a tile in the tileset to a Wang ID.
+
+    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangtile)
+
+    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-tile)
+
+    Attributes:
+        tile_id: The ID of the tile this WangTile maps to
+        wang_id: The wang color indexes for this tile. This is a list of IDs referring
+            to colors within the wang set. In the order of top, top right, right,
+            bottom right, bottom, bottom left, left, top left.
+    """
+
+    tile_id: int
+    wang_id: List[int]
+
+
+@attr.s(auto_attribs=True)
+class WangColor:
+    """A color that can be used to define the corner and/or edge of a Wang tile
+
+    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangcolor)
+
+    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-color)
+
+    Attributes:
+        color: An RGBA color used to identify this Wang color
+        name: The name for this color
+        probability: The probability used when randomizing tiles
+        properties: The properties for this wang color
+        class_: The Tiled class of this Wang Color
+        tile: Tile ID of the tile representing this color
+    """
+
+    color: Color
+    name: str
+    probability: float
+    tile: int
+    class_: Optional[str] = None
+    properties: Optional[Properties] = None
+
+
+@attr.s(auto_attribs=True)
+class WangSet:
+    """A complete Wang Set defining a list of corner and edge
+    [WangColors][pytiled_parser.wang_set.WangColor], and any number of
+    [WangTiles][pytiled_parser.wang_set.WangTile]
+
+    [TMX Reference](https://doc.mapeditor.org/en/stable/reference/tmx-map-format/#wangset)
+
+    [JSON Reference](https://doc.mapeditor.org/en/stable/reference/json-map-format/#wang-set)
+
+    Attributes:
+        name: Name of the WangSet
+        properties: The properties for this wang set
+        class_: The Tiled class of this Wang Set
+        tile: Tile ID of the tile representing this Wang Set
+        wang_colors: A list of [WangColors][pytiled_parser.wang_set.WangColor]
+        wang_tiles: A list of [WangTiles][pytiled_parser.wang_set.WangTile]
+        wang_type: A string noting the type of this wang set
+    """
+
+    name: str
+    tile: int
+    wang_type: str
+    wang_tiles: Dict[int, WangTile]
+    wang_colors: List[WangColor]
+    class_: Optional[str] = None
+    properties: Optional[Properties] = None
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/pytiled_parser/world.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/pytiled_parser/world.py`

 * *Ordering differences only*

 * *Files 12% similar despite different names*

```diff
@@ -1,163 +1,163 @@
-"""This module provides an implementation for World files from Tiled.
-
-See [Tiled's docs for Worlds](https://doc.mapeditor.org/en/stable/manual/worlds/)
-for more info about worlds and how to use them.
-
-The functionality within PyTiled Parser is to load the world and outline the size
-and position of each map, and provide the path to the map file. Loading a world
-does not automatically load each map within the world, this is so that the game
-or engine implementation can decide how to handle map loading.
-"""
-
-import json
-import re
-from os import listdir
-from os.path import isfile, join
-from pathlib import Path
-from typing import List
-
-# from typing_extensions import TypedDict
-from .common_types import OrderedPair, Size
-
-
-class WorldMap:
-    """Represents a map within a world.
-
-    This object can be accessed to load in a map after loading the world.
-
-    This class translates to each object within the `maps` list of a
-    World file
-
-    Attributes:
-        map_file: A Path object to the map file, can be passed to
-            the pytiled_parser.parse_map function later.
-        size: The size of the map in pixels
-        coordinates: The position of the map within the world in pixels
-    """
-
-    map_file: Path
-    size: Size
-    coordinates: OrderedPair
-
-
-class World:
-    """Represents a world file.
-
-    Attributes:
-        maps: The list of maps within the world. These are not fully parsed
-            TiledMap objects, but rather WorldMap objects which can be used
-            to later parse each individual map.
-        only_show_adjacent: Largely only used by the Tiled editor to determine
-            if only maps adjacent to the active one should be displayed. This
-            could be used to determine implementation behavior as well though
-            to toggle auto-loading of adjacent maps or something of the sort.
-    """
-
-    maps: List[WorldMap]
-    only_show_adjacent: bool = False
-
-
-# class RawPattern(TypedDict):
-#     regexp: str
-#     multiplierX: float
-#     multiplierY: float
-#     offsetX: float
-#     offsetY: float
-#
-#
-# class RawWorldMap(TypedDict):
-#     fileName: str
-#     height: float
-#     width: float
-#     x: float
-#     y: float
-#
-#
-# class RawWorld(TypedDict):
-#     maps: List[RawWorldMap]
-#     patterns: List[RawPattern]
-#     onlyShowAdjacentMaps: bool
-
-
-def _parse_world_map(raw_world_map, map_file: Path) -> WorldMap:  # raw_world_map: RawWorldMap
-    """Parse the RawWorldMap into a WorldMap.
-
-    Args:
-        raw_world_map: The RawWorldMap to parse
-        map_file: The file of tiled_map to parse
-
-    Returns:
-        WorldMap: The parsed WorldMap object
-    """
-    return WorldMap(
-        map_file=map_file,
-        size=Size(raw_world_map["width"], raw_world_map["height"]),
-        coordinates=OrderedPair(raw_world_map["x"], raw_world_map["y"]),
-    )
-
-
-def parse_world(file: Path) -> World:
-    """Parse the raw world into a pytiled_parser type
-
-    Args:
-        file: Path to the world's file
-
-    Returns:
-        World: A properly parsed [World][pytiled_parser.world.World]
-    """
-
-    with open(file) as world_file:
-        raw_world = json.load(world_file)
-
-    parent_dir = file.parent
-
-    maps: List[WorldMap] = []
-
-    if raw_world.get("maps"):
-        for raw_map in raw_world["maps"]:
-            map_path = Path(parent_dir / raw_map["fileName"])
-            maps.append(_parse_world_map(raw_map, map_path))
-
-    if raw_world.get("patterns"):
-        for raw_pattern in raw_world["patterns"]:
-            regex = re.compile(raw_pattern["regexp"])
-            map_files = [
-                f
-                for f in listdir(parent_dir)
-                if isfile(join(parent_dir, f)) and regex.match(f)
-            ]
-            for map_file in map_files:
-                search = regex.search(map_file)
-                if search:
-                    width = raw_pattern["multiplierX"]
-                    height = raw_pattern["multiplierY"]
-
-                    offset_x = 0
-                    offset_y = 0
-
-                    if raw_pattern.get("offsetX"):
-                        offset_x = raw_pattern["offsetX"]
-
-                    if raw_pattern.get("offsetY"):
-                        offset_y = raw_pattern["offsetY"]
-
-                    x = (float(search.group(1)) * width) + offset_x
-                    y = (float(search.group(2)) * height) + offset_y
-
-                    raw_world_map = {  # raw_world_map : RawWorldMap
-                        "fileName": map_file,
-                        "width": width,
-                        "height": height,
-                        "x": x,
-                        "y": y,
-                    }
-
-                    map_path = Path(parent_dir / map_file)
-                    maps.append(_parse_world_map(raw_world_map, map_path))
-
-    world = World(maps=maps)
-
-    if raw_world.get("onlyShowAdjacentMaps"):
-        world.only_show_adjacent = raw_world["onlyShowAdjacentMaps"]
-
-    return world
+"""This module provides an implementation for World files from Tiled.
+
+See [Tiled's docs for Worlds](https://doc.mapeditor.org/en/stable/manual/worlds/)
+for more info about worlds and how to use them.
+
+The functionality within PyTiled Parser is to load the world and outline the size
+and position of each map, and provide the path to the map file. Loading a world
+does not automatically load each map within the world, this is so that the game
+or engine implementation can decide how to handle map loading.
+"""
+
+import json
+import re
+from os import listdir
+from os.path import isfile, join
+from pathlib import Path
+from typing import List
+
+# from typing_extensions import TypedDict
+from .common_types import OrderedPair, Size
+
+
+class WorldMap:
+    """Represents a map within a world.
+
+    This object can be accessed to load in a map after loading the world.
+
+    This class translates to each object within the `maps` list of a
+    World file
+
+    Attributes:
+        map_file: A Path object to the map file, can be passed to
+            the pytiled_parser.parse_map function later.
+        size: The size of the map in pixels
+        coordinates: The position of the map within the world in pixels
+    """
+
+    map_file: Path
+    size: Size
+    coordinates: OrderedPair
+
+
+class World:
+    """Represents a world file.
+
+    Attributes:
+        maps: The list of maps within the world. These are not fully parsed
+            TiledMap objects, but rather WorldMap objects which can be used
+            to later parse each individual map.
+        only_show_adjacent: Largely only used by the Tiled editor to determine
+            if only maps adjacent to the active one should be displayed. This
+            could be used to determine implementation behavior as well though
+            to toggle auto-loading of adjacent maps or something of the sort.
+    """
+
+    maps: List[WorldMap]
+    only_show_adjacent: bool = False
+
+
+# class RawPattern(TypedDict):
+#     regexp: str
+#     multiplierX: float
+#     multiplierY: float
+#     offsetX: float
+#     offsetY: float
+#
+#
+# class RawWorldMap(TypedDict):
+#     fileName: str
+#     height: float
+#     width: float
+#     x: float
+#     y: float
+#
+#
+# class RawWorld(TypedDict):
+#     maps: List[RawWorldMap]
+#     patterns: List[RawPattern]
+#     onlyShowAdjacentMaps: bool
+
+
+def _parse_world_map(raw_world_map, map_file: Path) -> WorldMap:  # raw_world_map: RawWorldMap
+    """Parse the RawWorldMap into a WorldMap.
+
+    Args:
+        raw_world_map: The RawWorldMap to parse
+        map_file: The file of tiled_map to parse
+
+    Returns:
+        WorldMap: The parsed WorldMap object
+    """
+    return WorldMap(
+        map_file=map_file,
+        size=Size(raw_world_map["width"], raw_world_map["height"]),
+        coordinates=OrderedPair(raw_world_map["x"], raw_world_map["y"]),
+    )
+
+
+def parse_world(file: Path) -> World:
+    """Parse the raw world into a pytiled_parser type
+
+    Args:
+        file: Path to the world's file
+
+    Returns:
+        World: A properly parsed [World][pytiled_parser.world.World]
+    """
+
+    with open(file) as world_file:
+        raw_world = json.load(world_file)
+
+    parent_dir = file.parent
+
+    maps: List[WorldMap] = []
+
+    if raw_world.get("maps"):
+        for raw_map in raw_world["maps"]:
+            map_path = Path(parent_dir / raw_map["fileName"])
+            maps.append(_parse_world_map(raw_map, map_path))
+
+    if raw_world.get("patterns"):
+        for raw_pattern in raw_world["patterns"]:
+            regex = re.compile(raw_pattern["regexp"])
+            map_files = [
+                f
+                for f in listdir(parent_dir)
+                if isfile(join(parent_dir, f)) and regex.match(f)
+            ]
+            for map_file in map_files:
+                search = regex.search(map_file)
+                if search:
+                    width = raw_pattern["multiplierX"]
+                    height = raw_pattern["multiplierY"]
+
+                    offset_x = 0
+                    offset_y = 0
+
+                    if raw_pattern.get("offsetX"):
+                        offset_x = raw_pattern["offsetX"]
+
+                    if raw_pattern.get("offsetY"):
+                        offset_y = raw_pattern["offsetY"]
+
+                    x = (float(search.group(1)) * width) + offset_x
+                    y = (float(search.group(2)) * height) + offset_y
+
+                    raw_world_map = {  # raw_world_map : RawWorldMap
+                        "fileName": map_file,
+                        "width": width,
+                        "height": height,
+                        "x": x,
+                        "y": y,
+                    }
+
+                    map_path = Path(parent_dir / map_file)
+                    maps.append(_parse_world_map(raw_world_map, map_path))
+
+    world = World(maps=maps)
+
+    if raw_world.get("onlyShowAdjacentMaps"):
+        world.only_show_adjacent = raw_world["onlyShowAdjacentMaps"]
+
+    return world
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/looparts/tmx/ztilemap.py` & `pyved-engine-23.6a1/src/pyved_engine/looparts/tmx/ztilemap.py`

 * *Ordering differences only*

 * *Files 25% similar despite different names*

```diff
@@ -1,157 +1,157 @@
-
-from pathlib import Path
-
-from . import pytiled_parser
-import katagames_sdk as katasdk
-
-# game settings
-# Ensure no partial squares with these values
-WINDOW_WIDTH = 1024  # 16 * 64 or 32 * 32 or 64 * 16
-WINDOW_HEIGHT = 768  # 16 * 48 or 32 * 24 or 64 * 12
-TILESIZE = 64
-BLACK = (0, 0, 0)
-
-kengi = katasdk.kengi
-pygame = kengi.pygame
-TileLayerCls = pytiled_parser.layer.TileLayer
-ObjLayerCls = pytiled_parser.layer.ObjectLayer
-
-
-# By default, the collide method uses the default rect of the player.
-# We create this custom method to compare the player's 'hit_rect' instead.
-def collide_hit_rect(one, two):
-    return one.hit_rect.colliderect(two.rect)
-
-
-class Map:
-    def __init__(self, filename):
-        self.data = []
-        with open(filename, 'rt') as f:
-            for line in f:
-                self.data.append(line.strip())  # ignore \n chars to avoid extra tiles on map
-
-        self.tilewidth = len(self.data[0])
-        self.tileheight = len(self.data)
-        self.width = self.tilewidth * TILESIZE
-        self.height = self.tileheight * TILESIZE
-
-
-class MapObj:
-    def __init__(self):
-        self.x = self.y = 0
-        self.width = self.height = 0
-        self.name = ''
-        self.type = ''
-
-
-class CustomTiledMap:
-    def __init__(self, filename, ts_path): #, filename):
-        # tm = pytmx.load_pygame(filename, pixelAlpha=True)  # for transparency
-        # LOCAL CtX
-        #mapfile = Path(gpath+'/'+filename)
-        #tm = pytiled_parser.parse_map(mapfile)
-        # WEB
-        tm = pytiled_parser.parse_map(filename)  #'assets/maps/level1.tmj')
-
-        tilew, tileh = tm.tile_size
-        self.tile_size = (tilew, tileh)
-
-        mapw, maph = tm.map_size
-        self.width = mapw * tilew
-        self.height = maph * tileh
-        self.tmxdata = tm
-
-        self.objects = list()  # loaded objects. Need to have attr: x, y, width, height, name, type
-        self._populate_obj()
-
-        # init my_tileset/ self.ts.
-        # /!\ here we support only ONE tileset
-        my_tileset = None
-        for firstgid, obj in tm.tilesets.items():
-            self.firstgid = firstgid
-            new_sprsheet = kengi.gfx.Spritesheet(ts_path+obj.image.as_posix())  #gpath+ '/' + obj.image.as_posix() )
-
-            # hot fix suite au massacre de pytiled_parser (retrait brutal attr)
-            if not isinstance(obj.spacing, int):
-                spp = obj.spacing[0]
-            else:
-                spp = obj.spacing
-            # -- done
-
-            new_sprsheet.set_infos(
-                (obj.tile_width, obj.tile_height),
-                obj.tile_count,
-                obj.columns,
-                spp
-            )
-            my_tileset = new_sprsheet
-            break
-
-        self.ts = my_tileset
-
-        # ! super important! #  GAMECHANGER!!!!!
-        for pimg in self.ts.cache.values():
-            pimg.set_colorkey(BLACK)
-
-    def _populate_obj(self):
-        ref_objlayer = None
-        for elt in self.tmxdata.layers:
-            if isinstance(elt, ObjLayerCls):
-                ref_objlayer = elt
-                for obj_elt in ref_objlayer.tiled_objects:
-                    mo = MapObj()
-                    mo.name = obj_elt.name
-                    mo.x, mo.y = obj_elt.coordinates
-                    mo.type = obj_elt.class_
-                    mo.width, mo.height = obj_elt.size
-                    self.objects.append(mo)
-                    print(mo.name, mo.type, mo.x, mo.y, mo.width, mo.height)
-                break
-        if not ref_objlayer:
-            raise ValueError('no object layer found in the provided tmx/tmj map!')
-
-    def render(self, surface):
-        # get tile image by id used in the tmx file
-
-        for layer in self.tmxdata.layers:
-            if not isinstance(layer, ObjLayerCls):
-                layerw, layerh = layer.size
-                for j in range(layerh):
-                    for i in range(layerw):  # iterate over all tiles...
-                        tilerank = layer.data[j][i] - self.firstgid  # <-> (gid - firsgid)
-                        tile_img = None
-                        if tilerank >= self.ts.card:
-                            print('**warning** ignored tilerank:', tilerank)
-                        elif tilerank >= 0:
-                            tile_img = self.ts[tilerank]
-                        if tile_img:
-                            surface.blit(tile_img, (i * self.tile_size[0], j * self.tile_size[1]))
-
-    def make_map(self):
-        temp_surface = pygame.Surface((self.width, self.height))
-        self.render(temp_surface)
-        return temp_surface
-
-
-class Camera:
-    def __init__(self, width, height):
-        self.camera = pygame.Rect(0, 0, width, height)
-        self.width = width
-        self.height = height
-
-    def apply_sprite(self, entity):
-        return entity.rect.move(self.camera.topleft)
-
-    def apply_rect(self, rect):
-        return rect.move(self.camera.topleft)
-
-    def update(self, target):
-        x = -target.rect.centerx + int(WINDOW_WIDTH / 2)
-        y = -target.rect.centery + int(WINDOW_HEIGHT / 2)
-
-        # limit scrolling to map size
-        x = min(0, x)  # left hand side
-        y = min(0, y)  # top
-        x = max(-(self.width - WINDOW_WIDTH), x)  # right side
-        y = max(-(self.height - WINDOW_HEIGHT), y)  # bottom
-        self.camera = pygame.Rect(x, y, self.width, self.height)
+
+from pathlib import Path
+
+from . import pytiled_parser
+import katagames_sdk as katasdk
+
+# game settings
+# Ensure no partial squares with these values
+WINDOW_WIDTH = 1024  # 16 * 64 or 32 * 32 or 64 * 16
+WINDOW_HEIGHT = 768  # 16 * 48 or 32 * 24 or 64 * 12
+TILESIZE = 64
+BLACK = (0, 0, 0)
+
+kengi = katasdk.kengi
+pygame = kengi.pygame
+TileLayerCls = pytiled_parser.layer.TileLayer
+ObjLayerCls = pytiled_parser.layer.ObjectLayer
+
+
+# By default, the collide method uses the default rect of the player.
+# We create this custom method to compare the player's 'hit_rect' instead.
+def collide_hit_rect(one, two):
+    return one.hit_rect.colliderect(two.rect)
+
+
+class Map:
+    def __init__(self, filename):
+        self.data = []
+        with open(filename, 'rt') as f:
+            for line in f:
+                self.data.append(line.strip())  # ignore \n chars to avoid extra tiles on map
+
+        self.tilewidth = len(self.data[0])
+        self.tileheight = len(self.data)
+        self.width = self.tilewidth * TILESIZE
+        self.height = self.tileheight * TILESIZE
+
+
+class MapObj:
+    def __init__(self):
+        self.x = self.y = 0
+        self.width = self.height = 0
+        self.name = ''
+        self.type = ''
+
+
+class CustomTiledMap:
+    def __init__(self, filename, ts_path): #, filename):
+        # tm = pytmx.load_pygame(filename, pixelAlpha=True)  # for transparency
+        # LOCAL CtX
+        #mapfile = Path(gpath+'/'+filename)
+        #tm = pytiled_parser.parse_map(mapfile)
+        # WEB
+        tm = pytiled_parser.parse_map(filename)  #'assets/maps/level1.tmj')
+
+        tilew, tileh = tm.tile_size
+        self.tile_size = (tilew, tileh)
+
+        mapw, maph = tm.map_size
+        self.width = mapw * tilew
+        self.height = maph * tileh
+        self.tmxdata = tm
+
+        self.objects = list()  # loaded objects. Need to have attr: x, y, width, height, name, type
+        self._populate_obj()
+
+        # init my_tileset/ self.ts.
+        # /!\ here we support only ONE tileset
+        my_tileset = None
+        for firstgid, obj in tm.tilesets.items():
+            self.firstgid = firstgid
+            new_sprsheet = kengi.gfx.Spritesheet(ts_path+obj.image.as_posix())  #gpath+ '/' + obj.image.as_posix() )
+
+            # hot fix suite au massacre de pytiled_parser (retrait brutal attr)
+            if not isinstance(obj.spacing, int):
+                spp = obj.spacing[0]
+            else:
+                spp = obj.spacing
+            # -- done
+
+            new_sprsheet.set_infos(
+                (obj.tile_width, obj.tile_height),
+                obj.tile_count,
+                obj.columns,
+                spp
+            )
+            my_tileset = new_sprsheet
+            break
+
+        self.ts = my_tileset
+
+        # ! super important! #  GAMECHANGER!!!!!
+        for pimg in self.ts.cache.values():
+            pimg.set_colorkey(BLACK)
+
+    def _populate_obj(self):
+        ref_objlayer = None
+        for elt in self.tmxdata.layers:
+            if isinstance(elt, ObjLayerCls):
+                ref_objlayer = elt
+                for obj_elt in ref_objlayer.tiled_objects:
+                    mo = MapObj()
+                    mo.name = obj_elt.name
+                    mo.x, mo.y = obj_elt.coordinates
+                    mo.type = obj_elt.class_
+                    mo.width, mo.height = obj_elt.size
+                    self.objects.append(mo)
+                    print(mo.name, mo.type, mo.x, mo.y, mo.width, mo.height)
+                break
+        if not ref_objlayer:
+            raise ValueError('no object layer found in the provided tmx/tmj map!')
+
+    def render(self, surface):
+        # get tile image by id used in the tmx file
+
+        for layer in self.tmxdata.layers:
+            if not isinstance(layer, ObjLayerCls):
+                layerw, layerh = layer.size
+                for j in range(layerh):
+                    for i in range(layerw):  # iterate over all tiles...
+                        tilerank = layer.data[j][i] - self.firstgid  # <-> (gid - firsgid)
+                        tile_img = None
+                        if tilerank >= self.ts.card:
+                            print('**warning** ignored tilerank:', tilerank)
+                        elif tilerank >= 0:
+                            tile_img = self.ts[tilerank]
+                        if tile_img:
+                            surface.blit(tile_img, (i * self.tile_size[0], j * self.tile_size[1]))
+
+    def make_map(self):
+        temp_surface = pygame.Surface((self.width, self.height))
+        self.render(temp_surface)
+        return temp_surface
+
+
+class Camera:
+    def __init__(self, width, height):
+        self.camera = pygame.Rect(0, 0, width, height)
+        self.width = width
+        self.height = height
+
+    def apply_sprite(self, entity):
+        return entity.rect.move(self.camera.topleft)
+
+    def apply_rect(self, rect):
+        return rect.move(self.camera.topleft)
+
+    def update(self, target):
+        x = -target.rect.centerx + int(WINDOW_WIDTH / 2)
+        y = -target.rect.centery + int(WINDOW_HEIGHT / 2)
+
+        # limit scrolling to map size
+        x = min(0, x)  # left hand side
+        y = min(0, y)  # top
+        x = max(-(self.width - WINDOW_WIDTH), x)  # right side
+        y = max(-(self.height - WINDOW_HEIGHT), y)  # bottom
+        self.camera = pygame.Rect(x, y, self.width, self.height)
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/state_management.py` & `pyved-engine-23.6a1/src/pyved_engine/state_management.py`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,88 +1,88 @@
-from ._hub import events
-from .struct import Stack, StContainer
-from .core.events import EngineEvTypes
-
-
-multistate_flag = False
-stack_based_ctrl = None
-state_stack = None
-
-
-class StateStackCtrl(events.EvListener):
-    def __init__(self, all_gs, stmapping, refgame):
-        super().__init__()
-        self._gs_omega = all_gs
-        self._stack = Stack()
-        # CONVENTION: the first of the enum <=> the init gamestate id !
-        self.first_state_id = all_gs.all_codes[0]
-        self._st_container = StContainer()
-        self._st_container.setup(all_gs, stmapping, None)
-        self.__state_stack = Stack()
-        self.refgame = refgame
-
-    def turn_on(self):
-        super().turn_on()
-        print('>>>>>>>>>* Note: State stack is OPERATIONAL *')
-
-    @property
-    def current(self):
-        return self.__state_stack.peek()
-
-    # (it's a private method)
-    # WARNING: never, ever call that method without a kind of follow-up
-    def __only_the_pop_part(self):
-        tmp = self.__state_stack.pop()
-        state_obj = self._st_container.retrieve(tmp)
-        state_obj.release()
-
-    def _change_state(self, state_obj):
-        self.__only_the_pop_part()
-        self.__state_stack.push(state_obj.get_id())
-        state_obj.enter()
-
-    def _push_state(self, state_obj):
-        tmp = self.__state_stack.peek()
-        curr_state = self._st_container.retrieve(tmp)
-        curr_state.pause()
-        self.__state_stack.push(state_obj.get_id())
-        state_obj.enter()
-
-    def _pop_state(self):
-        self.__only_the_pop_part()
-        print('remains:', self.__state_stack.count())
-        if self.__state_stack.count() > 0:
-            tmp = self.__state_stack.peek()
-            state_obj = self._st_container.retrieve(tmp)
-            state_obj.resume()
-        else:
-            self.refgame.gameover = True  # no need to push event
-
-    # --------------------
-    #  CALLBACKS
-    # --------------------
-    def on_gamestart(self, ev):
-        self.__state_stack.push(self.first_state_id)
-        self._st_container.retrieve(self.first_state_id).enter()
-
-    def on_state_change(self, ev):
-        state_obj = self._st_container.retrieve(ev.state_ident)
-        self._change_state(state_obj)
-
-    def on_state_push(self, ev):
-        state_obj = self._st_container.retrieve(ev.state_ident)
-        self._push_state(state_obj)
-
-    def on_state_pop(self, ev):
-        self._pop_state()
-
-
-def declare_game_states(gs_enum, assoc_gscode_gscls, refgame):
-    """
-    :param gs_enum: enum of every single gamestate code
-    :param assoc_gscode_gscls: a dict that binds a gamestate code to a gamestate class
-    """
-    global stack_based_ctrl, multistate_flag
-    multistate_flag = True
-    stack_based_ctrl = StateStackCtrl(gs_enum, assoc_gscode_gscls, refgame)
-    # activation Autho!
-    stack_based_ctrl.turn_on()
+from ._hub import events
+from .struct import Stack, StContainer
+from .core.events import EngineEvTypes
+
+
+multistate_flag = False
+stack_based_ctrl = None
+state_stack = None
+
+
+class StateStackCtrl(events.EvListener):
+    def __init__(self, all_gs, stmapping, refgame):
+        super().__init__()
+        self._gs_omega = all_gs
+        self._stack = Stack()
+        # CONVENTION: the first of the enum <=> the init gamestate id !
+        self.first_state_id = all_gs.all_codes[0]
+        self._st_container = StContainer()
+        self._st_container.setup(all_gs, stmapping, None)
+        self.__state_stack = Stack()
+        self.refgame = refgame
+
+    def turn_on(self):
+        super().turn_on()
+        print('>>>>>>>>>* Note: State stack is OPERATIONAL *')
+
+    @property
+    def current(self):
+        return self.__state_stack.peek()
+
+    # (it's a private method)
+    # WARNING: never, ever call that method without a kind of follow-up
+    def __only_the_pop_part(self):
+        tmp = self.__state_stack.pop()
+        state_obj = self._st_container.retrieve(tmp)
+        state_obj.release()
+
+    def _change_state(self, state_obj):
+        self.__only_the_pop_part()
+        self.__state_stack.push(state_obj.get_id())
+        state_obj.enter()
+
+    def _push_state(self, state_obj):
+        tmp = self.__state_stack.peek()
+        curr_state = self._st_container.retrieve(tmp)
+        curr_state.pause()
+        self.__state_stack.push(state_obj.get_id())
+        state_obj.enter()
+
+    def _pop_state(self):
+        self.__only_the_pop_part()
+        print('remains:', self.__state_stack.count())
+        if self.__state_stack.count() > 0:
+            tmp = self.__state_stack.peek()
+            state_obj = self._st_container.retrieve(tmp)
+            state_obj.resume()
+        else:
+            self.refgame.gameover = True  # no need to push event
+
+    # --------------------
+    #  CALLBACKS
+    # --------------------
+    def on_gamestart(self, ev):
+        self.__state_stack.push(self.first_state_id)
+        self._st_container.retrieve(self.first_state_id).enter()
+
+    def on_state_change(self, ev):
+        state_obj = self._st_container.retrieve(ev.state_ident)
+        self._change_state(state_obj)
+
+    def on_state_push(self, ev):
+        state_obj = self._st_container.retrieve(ev.state_ident)
+        self._push_state(state_obj)
+
+    def on_state_pop(self, ev):
+        self._pop_state()
+
+
+def declare_game_states(gs_enum, assoc_gscode_gscls, refgame):
+    """
+    :param gs_enum: enum of every single gamestate code
+    :param assoc_gscode_gscls: a dict that binds a gamestate code to a gamestate class
+    """
+    global stack_based_ctrl, multistate_flag
+    multistate_flag = True
+    stack_based_ctrl = StateStackCtrl(gs_enum, assoc_gscode_gscls, refgame)
+    # activation Autho!
+    stack_based_ctrl.turn_on()
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/struct.py` & `pyved-engine-23.6a1/src/pyved_engine/struct.py`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,375 +1,375 @@
-import abc
-
-from .util import underscore_format
-
-
-def enum_builder_generic(to_upper, starting_index, *sequential, **named):
-    domaine = range(starting_index, len(sequential) + starting_index)
-    enums = dict(zip(sequential, domaine), **named)
-    tmp_inv_map = {v: k for k, v in enums.items()}
-    tmp_all_codes = domaine
-
-    if to_upper:
-        tmp = dict()
-        for k, v in enums.items():
-            if k == 'inv_map' or k == 'all_codes':
-                continue
-            tmp[k.upper()] = v
-        enums = tmp
-
-    enums['inv_map'] = tmp_inv_map
-    enums['all_codes'] = tmp_all_codes
-    enums['last_code'] = len(sequential) + starting_index - 1
-    return type('Enum', (), enums)
-
-
-def enum_from_n(n, *sequential, **named):
-    return enum_builder_generic(False, n, *sequential, **named)
-
-
-def enum(*sequential, **named):
-    """
-    the most used enum builder
-    """
-    return enum_from_n(0, *sequential, **named)
-
-
-# --- trick from stackoverflow...
-class abstractclassmethod(classmethod):
-    __isabstractmethod__ = True
-
-    def __init__(self, callable):
-        callable.__isabstractmethod__ = True
-        super(abstractclassmethod, self).__init__(callable)
-
-
-# ------------------------------- matrices -------------------------------
-class BaseMatrix(object):
-    """
-    classe ABSTRAITE
-    représentation 1d dune matrice bidimensionnelle de taille connue
-    """
-    __metaclass__ = abc.ABCMeta
-
-    def __init__(self, matr_size, li1d_val_init=None):
-        self.width, self.height = matr_size
-        nb_elem = self.width * self.height
-        if li1d_val_init is not None:
-            if len(li1d_val_init) != nb_elem:
-                raise ValueError('val pour init matrice incoherentes')
-            for elt in li1d_val_init:
-                if not self.__class__.isValidValue(elt):
-                    raise ValueError('val type doesnt match matrix type, elt={}'.format(elt))
-            self.repr_1d = li1d_val_init
-        else:
-            self.repr_1d = [self.__class__.defaultValue()] * nb_elem
-
-    @abstractclassmethod
-    def defaultValue(cls):
-        pass
-
-    @abstractclassmethod
-    def isValidValue(cls, val):
-        pass
-
-    def get_val(self, i, j):
-        if self.is_out(i, j):
-            raise ValueError('coords {} {} out of bounds for the current matrix'.format(i, j))
-        adhoc_ind = j * self.width + i
-        return self.repr_1d[adhoc_ind]
-
-    def set_val(self, i, j, val):
-        if not self.__class__.isValidValue(val):
-            raise ValueError(
-                'val {} incompatible avec le type de matrice utilisé ({})'.format(val, self.__class__.__name__)
-            )
-        ind = j * self.width + i
-        self.repr_1d[ind] = val
-
-    def set_all(self, val):
-        for i in range(self.width):
-            for j in range(self.height):
-                self.set_val(i, j, val)
-
-    def is_out(self, i, j):
-        return not (0 <= i < self.width and 0 <= j < self.height)
-
-    def get_size(self):
-        return self.width, self.height
-
-    def __str__(self):
-        res = '{} x {} matrix'.format(self.width, self.height)
-        res += "\n"
-        for j in range(self.height):
-            for i in range(self.width):
-                ind = j * self.width + i
-                res += '  {}'.format(self.repr_1d[ind])
-            res += "\n"
-        return res
-
-
-class BoolMatrix(BaseMatrix):
-    # --- redefinition de 2 methodes venant den haut
-    @classmethod
-    def defaultValue(cls):
-        return True
-
-    @classmethod
-    def isValidValue(cls, val):
-        return isinstance(val, bool)
-
-
-class IntegerMatrix(BaseMatrix):
-    """
-    modélise une matrice d'entiers. Par défaut, toutes les cellules sont à 0. On redef 2 methodes venant den haut
-    """
-    @classmethod
-    def defaultValue(cls):
-        return 0
-
-    @classmethod
-    def isValidValue(cls, val):
-        return (val is None) or isinstance(val, int)
-# --------------- end of matrices -------------------------
-
-
-class Stack:
-    def __init__(self, given_seq=None):
-        if given_seq is None:
-            self.fifo_list = []
-        else:
-            self.fifo_list = list(given_seq)
-
-    def push(self, element):
-        self.fifo_list.append(element)
-        # - debug
-        # print()
-        # print('PUSH')
-        # print('etat de pile {}'.format(self.fifo_list))
-
-    def top_down_trav(self):
-        return reversed(self.fifo_list)
-
-    def bottom_up_trav(self):
-        return self.fifo_list
-
-    def pop(self):
-        try:
-            tmp = self.fifo_list.pop()
-            res = tmp
-        except IndexError:
-            res = None  # the stack's already empty
-
-        return res
-
-    def peek(self):
-        try:
-            return self.fifo_list[-1]
-        except IndexError:
-            return None  # the stack's empty
-
-    def count(self):
-        return len(self.fifo_list)
-
-
-# --------------------------------------------
-#  generic tree structure
-# --------------------------------------------
-class Tree:
-    def __init__(self, rootnode_ref):
-        self._root = rootnode_ref
-        self.allnodesinfo = set()  # do not modify this member directly
-
-    @property
-    def root(self):
-        return self._root
-
-    # TODO
-    # @root.setter
-    # def root(self, noderef):
-    #     self._root = noderef
-
-    def append_value(self, value, parent_node):
-        if parent_node is None:
-            raise ValueError('[Tree]Error - Cannot use append_value to create a root node!')
-        if parent_node not in self.allnodesinfo:
-            raise ValueError('[Tree]Error - Trying to append value to a node that doesnt exist!')
-        return TreeNode(value, parent_node)
-
-    @property
-    def count(self):
-        return len(self.allnodesinfo)
-
-    def has_node(self, node_ref):
-        return node_ref in self.allnodesinfo
-
-    def node_by_content(self, needle_value):
-        """
-        returns None if needle_value isnt found
-        """
-        for node_ref in self.allnodesinfo:
-            if needle_value == node_ref.value:
-                return node_ref
-
-    def sub_tree(self, node_ref):
-        raise NotImplementedError  # TODO, use node cloning
-
-    def __str__(self):
-        r = ''
-        for node in self._root.traverse():
-            d = node.depth
-            v = node.value
-            spstr = ''.join([' ' for _ in range(d)])
-            r += f'{spstr}node[depth:{d}] val={v}' + '\n'
-        return r
-
-    # def cut_from_node(self, ref_node):
-    #     if ref_node == self.root:
-    #         raise ValueError('empty tree not allowed')
-    #
-    #     if not ref_node.is_leaf():
-    #         # if node has childs, we shall cut the whole branch
-    #         for c in ref_node.childs:
-    #             self.cut_from_node(c)
-    #
-    #     ref_node.parent.childs.remove(ref_node)
-    #     self.__allnodes.remove(ref_node)
-
-
-class TreeNode:
-    def __init__(self, value, parent_ref):
-        """
-        set parent_ref to None,
-        in order to create a root node + the associated tree.
-
-        Important remark: this class doesnt allow for the creation of 'headless' nodes,
-        that is nodes that are not bound to a given Tree! It simplifies the implementation
-        as it prevents the dev from doing things that make no sense. For instance: trying to
-        add an existing node (say, the 1st child of root) to the 2nd child of root
-            r
-          /  \
-         a    b
-        doing b.add_child(a) should be always be forbidden,
-        so we dont implement an add_child method.
-        """
-        self.value = value  # data
-
-        if parent_ref:
-            self.parent = parent_ref
-            self.parent.children.append(self)
-            self.tree_ref = parent_ref.tree_ref
-        else:
-            self.parent = None
-            self.tree_ref = Tree(self)
-        self.tree_ref.allnodesinfo.add(self)
-
-        self.children = list()  # references to other nodes
-
-    @property
-    def depth(self):
-        cpt = 0
-        r = self
-        while not r.is_root():
-            r = r.parent
-            cpt += 1
-        return cpt
-
-    @property
-    def child_count(self):
-        return len(self.children)
-
-    def is_root(self):
-        return self.parent is None
-
-    def is_leaf(self):
-        return len(self.children) == 0
-
-    def remove_child(self, child_node):
-        # removes parent-child relationship
-        if self.tree_ref.has_node(child_node):
-            self.children = [child for child in self.children if child is not child_node]
-            self.tree_ref.allnodesinfo.remove(child_node)
-        else:
-            print('***[TreeNode] warning trying to remove a child that does not exist***')
-
-    def traverse(self):
-        visited_nodes = list()
-        nodes_to_visit = [self]
-        while len(nodes_to_visit) > 0:
-            curr_node = nodes_to_visit.pop(0)
-            visited_nodes.append(curr_node)
-            nodes_to_visit += curr_node.children
-        return visited_nodes
-
-
-class StContainer:
-    """
-    contient toutes les instances de classes qui dérivent de BaseGameState
-    """
-
-    def __init__(self):
-        self.__setup_done = False
-        self.assoc_id_state_obj = dict()
-
-    def setup(self, enum_game_states, stmapping, pymodule=None):
-        self.__setup_done = True
-
-        # - initialisation d'après paramètre type: core.enum
-        if stmapping:  # but = charger la classe deja identifiee en memoire
-            for state_ident, adhoc_cls in stmapping.items():
-                print('creating state:', adhoc_cls.__name__)
-                obj = adhoc_cls(state_ident)
-
-                # if needed: enable Kata bios state
-                if -1 == state_ident:
-                    obj.glvars_module = pymodule  # TODO fix architecture,
-                    # StContainer shouldnt know details bout SDK feat
-
-                # the regular op
-                self.assoc_id_state_obj[state_ident] = obj
-        else:
-
-            # old code
-            for id_choisi, nom_etat in enum_game_states.inv_map.items():
-                class_name = nom_etat + 'State'
-                self._auto_find_statecls(id_choisi, nom_etat, class_name)
-
-    def _auto_find_statecls(self, id_choisi, nom_etat, nom_cls):
-        pymodule_name = underscore_format(nom_etat)
-        pythonpath = 'app.{}.state'.format(pymodule_name)
-        print('StContainer is loading a new game state...')
-        try:
-            pymodule = __import__(pythonpath, fromlist=[nom_cls])
-            adhoc_cls = getattr(pymodule, nom_cls)  # class has been retrieved -> ok
-
-            obj = adhoc_cls(id_choisi, nom_etat)
-            self.assoc_id_state_obj[id_choisi] = obj
-
-        except ImportError as exc:
-            print('ERR: Cannot import State Cls!')
-            print()
-            print('adhoc module name(conv. to underscore format)={}'.format(pymodule_name))
-            print('full path for finding class={}'.format(pythonpath))
-            print('target class={}'.format(nom_cls))
-
-    def retrieve(self, identifiant):
-        """
-        :param identifiant: peut-être aussi bien le code (int) que le nom de classe dédiée (e.g. PlayState)
-        :return: instance de BaseGameState
-        """
-
-        # construction par nom ou identifiant entier
-        # TODO rétablir recherche par nom et non par code...
-
-        # if isinstance(identifiant, str):
-        #     gamestate_id = None
-        #     for num_id, nom in state_listing.items():
-        #         if nom == identifiant:
-        #             gamestate_id = num_id
-        #             break
-        #     if gamestate_id is None:
-        #         assert 0, "state name not found: " + identifiant
-        # else:
-        #     gamestate_id = identifiant
-        gamestate_id = identifiant
-        return self.assoc_id_state_obj[gamestate_id]
+import abc
+
+from .util import underscore_format
+
+
+def enum_builder_generic(to_upper, starting_index, *sequential, **named):
+    domaine = range(starting_index, len(sequential) + starting_index)
+    enums = dict(zip(sequential, domaine), **named)
+    tmp_inv_map = {v: k for k, v in enums.items()}
+    tmp_all_codes = domaine
+
+    if to_upper:
+        tmp = dict()
+        for k, v in enums.items():
+            if k == 'inv_map' or k == 'all_codes':
+                continue
+            tmp[k.upper()] = v
+        enums = tmp
+
+    enums['inv_map'] = tmp_inv_map
+    enums['all_codes'] = tmp_all_codes
+    enums['last_code'] = len(sequential) + starting_index - 1
+    return type('Enum', (), enums)
+
+
+def enum_from_n(n, *sequential, **named):
+    return enum_builder_generic(False, n, *sequential, **named)
+
+
+def enum(*sequential, **named):
+    """
+    the most used enum builder
+    """
+    return enum_from_n(0, *sequential, **named)
+
+
+# --- trick from stackoverflow...
+class abstractclassmethod(classmethod):
+    __isabstractmethod__ = True
+
+    def __init__(self, callable):
+        callable.__isabstractmethod__ = True
+        super(abstractclassmethod, self).__init__(callable)
+
+
+# ------------------------------- matrices -------------------------------
+class BaseMatrix(object):
+    """
+    classe ABSTRAITE
+    représentation 1d dune matrice bidimensionnelle de taille connue
+    """
+    __metaclass__ = abc.ABCMeta
+
+    def __init__(self, matr_size, li1d_val_init=None):
+        self.width, self.height = matr_size
+        nb_elem = self.width * self.height
+        if li1d_val_init is not None:
+            if len(li1d_val_init) != nb_elem:
+                raise ValueError('val pour init matrice incoherentes')
+            for elt in li1d_val_init:
+                if not self.__class__.isValidValue(elt):
+                    raise ValueError('val type doesnt match matrix type, elt={}'.format(elt))
+            self.repr_1d = li1d_val_init
+        else:
+            self.repr_1d = [self.__class__.defaultValue()] * nb_elem
+
+    @abstractclassmethod
+    def defaultValue(cls):
+        pass
+
+    @abstractclassmethod
+    def isValidValue(cls, val):
+        pass
+
+    def get_val(self, i, j):
+        if self.is_out(i, j):
+            raise ValueError('coords {} {} out of bounds for the current matrix'.format(i, j))
+        adhoc_ind = j * self.width + i
+        return self.repr_1d[adhoc_ind]
+
+    def set_val(self, i, j, val):
+        if not self.__class__.isValidValue(val):
+            raise ValueError(
+                'val {} incompatible avec le type de matrice utilisé ({})'.format(val, self.__class__.__name__)
+            )
+        ind = j * self.width + i
+        self.repr_1d[ind] = val
+
+    def set_all(self, val):
+        for i in range(self.width):
+            for j in range(self.height):
+                self.set_val(i, j, val)
+
+    def is_out(self, i, j):
+        return not (0 <= i < self.width and 0 <= j < self.height)
+
+    def get_size(self):
+        return self.width, self.height
+
+    def __str__(self):
+        res = '{} x {} matrix'.format(self.width, self.height)
+        res += "\n"
+        for j in range(self.height):
+            for i in range(self.width):
+                ind = j * self.width + i
+                res += '  {}'.format(self.repr_1d[ind])
+            res += "\n"
+        return res
+
+
+class BoolMatrix(BaseMatrix):
+    # --- redefinition de 2 methodes venant den haut
+    @classmethod
+    def defaultValue(cls):
+        return True
+
+    @classmethod
+    def isValidValue(cls, val):
+        return isinstance(val, bool)
+
+
+class IntegerMatrix(BaseMatrix):
+    """
+    modélise une matrice d'entiers. Par défaut, toutes les cellules sont à 0. On redef 2 methodes venant den haut
+    """
+    @classmethod
+    def defaultValue(cls):
+        return 0
+
+    @classmethod
+    def isValidValue(cls, val):
+        return (val is None) or isinstance(val, int)
+# --------------- end of matrices -------------------------
+
+
+class Stack:
+    def __init__(self, given_seq=None):
+        if given_seq is None:
+            self.fifo_list = []
+        else:
+            self.fifo_list = list(given_seq)
+
+    def push(self, element):
+        self.fifo_list.append(element)
+        # - debug
+        # print()
+        # print('PUSH')
+        # print('etat de pile {}'.format(self.fifo_list))
+
+    def top_down_trav(self):
+        return reversed(self.fifo_list)
+
+    def bottom_up_trav(self):
+        return self.fifo_list
+
+    def pop(self):
+        try:
+            tmp = self.fifo_list.pop()
+            res = tmp
+        except IndexError:
+            res = None  # the stack's already empty
+
+        return res
+
+    def peek(self):
+        try:
+            return self.fifo_list[-1]
+        except IndexError:
+            return None  # the stack's empty
+
+    def count(self):
+        return len(self.fifo_list)
+
+
+# --------------------------------------------
+#  generic tree structure
+# --------------------------------------------
+class Tree:
+    def __init__(self, rootnode_ref):
+        self._root = rootnode_ref
+        self.allnodesinfo = set()  # do not modify this member directly
+
+    @property
+    def root(self):
+        return self._root
+
+    # TODO
+    # @root.setter
+    # def root(self, noderef):
+    #     self._root = noderef
+
+    def append_value(self, value, parent_node):
+        if parent_node is None:
+            raise ValueError('[Tree]Error - Cannot use append_value to create a root node!')
+        if parent_node not in self.allnodesinfo:
+            raise ValueError('[Tree]Error - Trying to append value to a node that doesnt exist!')
+        return TreeNode(value, parent_node)
+
+    @property
+    def count(self):
+        return len(self.allnodesinfo)
+
+    def has_node(self, node_ref):
+        return node_ref in self.allnodesinfo
+
+    def node_by_content(self, needle_value):
+        """
+        returns None if needle_value isnt found
+        """
+        for node_ref in self.allnodesinfo:
+            if needle_value == node_ref.value:
+                return node_ref
+
+    def sub_tree(self, node_ref):
+        raise NotImplementedError  # TODO, use node cloning
+
+    def __str__(self):
+        r = ''
+        for node in self._root.traverse():
+            d = node.depth
+            v = node.value
+            spstr = ''.join([' ' for _ in range(d)])
+            r += f'{spstr}node[depth:{d}] val={v}' + '\n'
+        return r
+
+    # def cut_from_node(self, ref_node):
+    #     if ref_node == self.root:
+    #         raise ValueError('empty tree not allowed')
+    #
+    #     if not ref_node.is_leaf():
+    #         # if node has childs, we shall cut the whole branch
+    #         for c in ref_node.childs:
+    #             self.cut_from_node(c)
+    #
+    #     ref_node.parent.childs.remove(ref_node)
+    #     self.__allnodes.remove(ref_node)
+
+
+class TreeNode:
+    def __init__(self, value, parent_ref):
+        """
+        set parent_ref to None,
+        in order to create a root node + the associated tree.
+
+        Important remark: this class doesnt allow for the creation of 'headless' nodes,
+        that is nodes that are not bound to a given Tree! It simplifies the implementation
+        as it prevents the dev from doing things that make no sense. For instance: trying to
+        add an existing node (say, the 1st child of root) to the 2nd child of root
+            r
+          /  \
+         a    b
+        doing b.add_child(a) should be always be forbidden,
+        so we dont implement an add_child method.
+        """
+        self.value = value  # data
+
+        if parent_ref:
+            self.parent = parent_ref
+            self.parent.children.append(self)
+            self.tree_ref = parent_ref.tree_ref
+        else:
+            self.parent = None
+            self.tree_ref = Tree(self)
+        self.tree_ref.allnodesinfo.add(self)
+
+        self.children = list()  # references to other nodes
+
+    @property
+    def depth(self):
+        cpt = 0
+        r = self
+        while not r.is_root():
+            r = r.parent
+            cpt += 1
+        return cpt
+
+    @property
+    def child_count(self):
+        return len(self.children)
+
+    def is_root(self):
+        return self.parent is None
+
+    def is_leaf(self):
+        return len(self.children) == 0
+
+    def remove_child(self, child_node):
+        # removes parent-child relationship
+        if self.tree_ref.has_node(child_node):
+            self.children = [child for child in self.children if child is not child_node]
+            self.tree_ref.allnodesinfo.remove(child_node)
+        else:
+            print('***[TreeNode] warning trying to remove a child that does not exist***')
+
+    def traverse(self):
+        visited_nodes = list()
+        nodes_to_visit = [self]
+        while len(nodes_to_visit) > 0:
+            curr_node = nodes_to_visit.pop(0)
+            visited_nodes.append(curr_node)
+            nodes_to_visit += curr_node.children
+        return visited_nodes
+
+
+class StContainer:
+    """
+    contient toutes les instances de classes qui dérivent de BaseGameState
+    """
+
+    def __init__(self):
+        self.__setup_done = False
+        self.assoc_id_state_obj = dict()
+
+    def setup(self, enum_game_states, stmapping, pymodule=None):
+        self.__setup_done = True
+
+        # - initialisation d'après paramètre type: core.enum
+        if stmapping:  # but = charger la classe deja identifiee en memoire
+            for state_ident, adhoc_cls in stmapping.items():
+                print('creating state:', adhoc_cls.__name__)
+                obj = adhoc_cls(state_ident)
+
+                # if needed: enable Kata bios state
+                if -1 == state_ident:
+                    obj.glvars_module = pymodule  # TODO fix architecture,
+                    # StContainer shouldnt know details bout SDK feat
+
+                # the regular op
+                self.assoc_id_state_obj[state_ident] = obj
+        else:
+
+            # old code
+            for id_choisi, nom_etat in enum_game_states.inv_map.items():
+                class_name = nom_etat + 'State'
+                self._auto_find_statecls(id_choisi, nom_etat, class_name)
+
+    def _auto_find_statecls(self, id_choisi, nom_etat, nom_cls):
+        pymodule_name = underscore_format(nom_etat)
+        pythonpath = 'app.{}.state'.format(pymodule_name)
+        print('StContainer is loading a new game state...')
+        try:
+            pymodule = __import__(pythonpath, fromlist=[nom_cls])
+            adhoc_cls = getattr(pymodule, nom_cls)  # class has been retrieved -> ok
+
+            obj = adhoc_cls(id_choisi, nom_etat)
+            self.assoc_id_state_obj[id_choisi] = obj
+
+        except ImportError as exc:
+            print('ERR: Cannot import State Cls!')
+            print()
+            print('adhoc module name(conv. to underscore format)={}'.format(pymodule_name))
+            print('full path for finding class={}'.format(pythonpath))
+            print('target class={}'.format(nom_cls))
+
+    def retrieve(self, identifiant):
+        """
+        :param identifiant: peut-être aussi bien le code (int) que le nom de classe dédiée (e.g. PlayState)
+        :return: instance de BaseGameState
+        """
+
+        # construction par nom ou identifiant entier
+        # TODO rétablir recherche par nom et non par code...
+
+        # if isinstance(identifiant, str):
+        #     gamestate_id = None
+        #     for num_id, nom in state_listing.items():
+        #         if nom == identifiant:
+        #             gamestate_id = num_id
+        #             break
+        #     if gamestate_id is None:
+        #         assert 0, "state name not found: " + identifiant
+        # else:
+        #     gamestate_id = identifiant
+        gamestate_id = identifiant
+        return self.assoc_id_state_obj[gamestate_id]
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine/tankui.py` & `pyved-engine-23.6a1/src/pyved_engine/tankui.py`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,130 +1,130 @@
-import time
-
-from . import _hub
-from . import util
-from .compo import vscreen
-
-
-text = util.drawtext
-
-
-class Button:
-    def __init__(self, x=0, y=0, w=100, h=50, label='Button', action=None):
-        self.x = x
-        self.y = y
-        self.w = w
-        self.h = h
-        self.action = action
-        self.label = label
-        self.text = text(self.label, 40, aliased=True)
-        self.active_color = (204, 122, 68)
-        self.inactive_color = (182, 122, 87)
-        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
-        self.is_active = False
-
-    def update(self, events):
-        mx, my = vscreen.proj_to_vscreen(_hub.pygame.mouse.get_pos())
-
-        if self.rect.collidepoint(mx, my):
-            self.is_active = True
-        else:
-            self.is_active = False
-        for e in events:
-            if e.type == _hub.pygame.MOUSEBUTTONDOWN:
-                if e.button == 1:
-                    if self.is_active:
-                        if self.action is not None:
-                            self.action()
-
-    def draw(self, surf):
-        color = self.active_color if self.is_active else self.inactive_color
-        _hub.pygame.draw.rect(surf, color, (self.x, self.y, self.w, self.h), border_radius=5)
-        surf.blit(self.text, self.text.get_rect(center=self.rect.center))
-
-
-class Label:
-    def __init__(self, x=0, y=0, w=100, h=50, label='Label'):
-        self.x = x
-        self.y = y
-        self.w = w
-        self.h = h
-        self.label = label
-        self.text = text(self.label, size=25, aliased=True)
-        self.color = (182, 122, 87)
-        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
-        self.is_active = False
-
-    def update(self, events):
-        pass
-
-    def draw(self, surf):
-        _hub.pygame.draw.rect(surf, self.color, (self.x, self.y, self.w, self.h))
-        surf.blit(self.text, self.text.get_rect(center=self.rect.center))
-
-
-class InputBox:
-    def __init__(self, x=0, y=0, w=100, h=50, default='Type Here', initial_string='', label='none', extendable=True, numeric_only=False):
-        self.x = x
-        self.y = y
-        self.w = w
-        self.h = h
-        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
-        self.numeric_only = numeric_only
-        self.active_color = (204, 122, 68)
-        self.inactive_color = (182, 122, 87)
-        self.label = label
-        self.default = default
-        self.extendable = extendable
-        self.is_active = False
-        self.is_hovered = False
-        self.text = initial_string
-        self.allowed_input = 'abcdefghijklmnopqrstuvwxyz1234567890' if not self.numeric_only else '1234567890'
-        self.cursor_visible = True
-        self.cursor_blink_timer = time.time()
-
-    def update(self, events):
-        pygame = _hub.pygame
-        mx, my = vscreen.proj_to_vscreen(pygame.mouse.get_pos())
-        if self.rect.collidepoint(mx, my):
-            self.is_hovered = True
-        else:
-            self.is_hovered = False
-        for e in events:
-            if e.type == pygame.MOUSEBUTTONDOWN:
-                if e.button == 1:
-                    if self.is_hovered:
-                        self.is_active = True
-                    else:
-                        self.is_active = False
-            if e.type == pygame.KEYDOWN:
-                if self.is_active:
-                    if e.key == pygame.K_BACKSPACE:
-                        self.text = self.text[:-1]
-                    if not len(self.text) > self.w // 15 - 3:
-                        if e.key == pygame.K_SPACE:
-                            self.text += ' '
-                        # elif e.key != pygame.KMOD_SHIFT and chr(e.key) in self.allowed_input:
-                        #     self.text += chr(e.key).upper()
-            if e.type == pygame.TEXTINPUT:
-                if self.is_active:
-                    if e.text.lower() in self.allowed_input:
-                        if not len(self.text) > self.w // 15 - 3:
-                            self.text += e.text
-
-    def draw(self, surf):
-        color = self.active_color if self.is_hovered or self.is_active else self.inactive_color
-        if self.is_active:
-            display_text = self.text
-        else:
-            display_text = self.text if self.text != '' else self.default
-        if self.is_active:
-            if time.time() - self.cursor_blink_timer > 0.5:
-                self.cursor_blink_timer = time.time()
-                self.cursor_visible = not self.cursor_visible
-            if self.cursor_visible:
-                display_text += '_'
-            else:
-                display_text += ' '
-        t = text(display_text, 25, aliased=True)
-        _hub.pygame.draw.rect(surf, color, self.rect)
-        surf.blit(t, t.get_rect(center=self.rect.center))
+import time
+
+from . import _hub
+from . import util
+from .compo import vscreen
+
+
+text = util.drawtext
+
+
+class Button:
+    def __init__(self, x=0, y=0, w=100, h=50, label='Button', action=None):
+        self.x = x
+        self.y = y
+        self.w = w
+        self.h = h
+        self.action = action
+        self.label = label
+        self.text = text(self.label, 40, aliased=True)
+        self.active_color = (204, 122, 68)
+        self.inactive_color = (182, 122, 87)
+        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
+        self.is_active = False
+
+    def update(self, events):
+        mx, my = vscreen.proj_to_vscreen(_hub.pygame.mouse.get_pos())
+
+        if self.rect.collidepoint(mx, my):
+            self.is_active = True
+        else:
+            self.is_active = False
+        for e in events:
+            if e.type == _hub.pygame.MOUSEBUTTONDOWN:
+                if e.button == 1:
+                    if self.is_active:
+                        if self.action is not None:
+                            self.action()
+
+    def draw(self, surf):
+        color = self.active_color if self.is_active else self.inactive_color
+        _hub.pygame.draw.rect(surf, color, (self.x, self.y, self.w, self.h), border_radius=5)
+        surf.blit(self.text, self.text.get_rect(center=self.rect.center))
+
+
+class Label:
+    def __init__(self, x=0, y=0, w=100, h=50, label='Label'):
+        self.x = x
+        self.y = y
+        self.w = w
+        self.h = h
+        self.label = label
+        self.text = text(self.label, size=25, aliased=True)
+        self.color = (182, 122, 87)
+        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
+        self.is_active = False
+
+    def update(self, events):
+        pass
+
+    def draw(self, surf):
+        _hub.pygame.draw.rect(surf, self.color, (self.x, self.y, self.w, self.h))
+        surf.blit(self.text, self.text.get_rect(center=self.rect.center))
+
+
+class InputBox:
+    def __init__(self, x=0, y=0, w=100, h=50, default='Type Here', initial_string='', label='none', extendable=True, numeric_only=False):
+        self.x = x
+        self.y = y
+        self.w = w
+        self.h = h
+        self.rect = _hub.pygame.Rect(self.x, self.y, self.w, self.h)
+        self.numeric_only = numeric_only
+        self.active_color = (204, 122, 68)
+        self.inactive_color = (182, 122, 87)
+        self.label = label
+        self.default = default
+        self.extendable = extendable
+        self.is_active = False
+        self.is_hovered = False
+        self.text = initial_string
+        self.allowed_input = 'abcdefghijklmnopqrstuvwxyz1234567890' if not self.numeric_only else '1234567890'
+        self.cursor_visible = True
+        self.cursor_blink_timer = time.time()
+
+    def update(self, events):
+        pygame = _hub.pygame
+        mx, my = vscreen.proj_to_vscreen(pygame.mouse.get_pos())
+        if self.rect.collidepoint(mx, my):
+            self.is_hovered = True
+        else:
+            self.is_hovered = False
+        for e in events:
+            if e.type == pygame.MOUSEBUTTONDOWN:
+                if e.button == 1:
+                    if self.is_hovered:
+                        self.is_active = True
+                    else:
+                        self.is_active = False
+            if e.type == pygame.KEYDOWN:
+                if self.is_active:
+                    if e.key == pygame.K_BACKSPACE:
+                        self.text = self.text[:-1]
+                    if not len(self.text) > self.w // 15 - 3:
+                        if e.key == pygame.K_SPACE:
+                            self.text += ' '
+                        # elif e.key != pygame.KMOD_SHIFT and chr(e.key) in self.allowed_input:
+                        #     self.text += chr(e.key).upper()
+            if e.type == pygame.TEXTINPUT:
+                if self.is_active:
+                    if e.text.lower() in self.allowed_input:
+                        if not len(self.text) > self.w // 15 - 3:
+                            self.text += e.text
+
+    def draw(self, surf):
+        color = self.active_color if self.is_hovered or self.is_active else self.inactive_color
+        if self.is_active:
+            display_text = self.text
+        else:
+            display_text = self.text if self.text != '' else self.default
+        if self.is_active:
+            if time.time() - self.cursor_blink_timer > 0.5:
+                self.cursor_blink_timer = time.time()
+                self.cursor_visible = not self.cursor_visible
+            if self.cursor_visible:
+                display_text += '_'
+            else:
+                display_text += ' '
+        t = text(display_text, 25, aliased=True)
+        _hub.pygame.draw.rect(surf, color, self.rect)
+        surf.blit(t, t.get_rect(center=self.rect.center))
```

### Comparing `pyved-engine-23.5a1/src/pyved_engine.egg-info/SOURCES.txt` & `pyved-engine-23.6a1/src/pyved_engine.egg-info/SOURCES.txt`

 * *Files 1% similar despite different names*

```diff
@@ -13,14 +13,15 @@
 src/pyved_engine/state_management.py
 src/pyved_engine/struct.py
 src/pyved_engine/tankui.py
 src/pyved_engine/util.py
 src/pyved_engine.egg-info/PKG-INFO
 src/pyved_engine.egg-info/SOURCES.txt
 src/pyved_engine.egg-info/dependency_links.txt
+src/pyved_engine.egg-info/entry_points.txt
 src/pyved_engine.egg-info/requires.txt
 src/pyved_engine.egg-info/top_level.txt
 src/pyved_engine/compo/__init__.py
 src/pyved_engine/compo/gfx.py
 src/pyved_engine/compo/modes.py
 src/pyved_engine/compo/packed_capello_ft.py
 src/pyved_engine/compo/vscreen.py
```

