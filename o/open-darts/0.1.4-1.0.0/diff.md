# Comparing `tmp/open_darts-0.1.4-cp39-cp39-win_amd64.whl.zip` & `tmp/open_darts-1.0.0-cp39-cp39-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,80 +1,102 @@
-Zip file size: 2713233 bytes, number of entries: 78
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/__init__.py
--rw-rw-rw-  2.0 fat       46 b- defN 23-Apr-15 09:09 darts/build_info.txt
--rw-rw-rw-  2.0 fat  6398464 b- defN 23-Apr-15 09:09 darts/engines.pyd
+Zip file size: 2747666 bytes, number of entries: 100
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/__init__.py
+-rw-rw-rw-  2.0 fat       51 b- defN 23-Jun-16 16:31 darts/build_info.txt
+-rw-rw-rw-  2.0 fat   880128 b- defN 23-Jun-16 16:31 darts/discretizer.pyd
+-rw-rw-rw-  2.0 fat  6606848 b- defN 23-Jun-16 16:30 darts/engines.pyd
 -rw-rw-rw-  2.0 fat   579920 b- defN 23-Feb-01 17:18 darts/msvcp140.dll
--rw-rw-rw-  2.0 fat      923 b- defN 23-Feb-14 18:00 darts/print_build_info.py
--rw-rw-rw-  2.0 fat      652 b- defN 23-Feb-14 18:00 darts/utils.py
+-rw-rw-rw-  2.0 fat     1774 b- defN 23-Jun-15 11:42 darts/print_build_info.py
+-rw-rw-rw-  2.0 fat      652 b- defN 23-Jun-15 11:42 darts/utils.py
 -rw-rw-rw-  2.0 fat   191824 b- defN 23-Feb-01 17:18 darts/vcomp140.dll
 -rw-rw-rw-  2.0 fat   109392 b- defN 23-Feb-01 17:18 darts/vcruntime140.dll
--rw-rw-rw-  2.0 fat   477295 b- defN 23-Feb-16 15:03 darts/docs/reference.pdf
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/mesh/__init__.py
--rw-rw-rw-  2.0 fat    41162 b- defN 23-Feb-14 18:00 darts/mesh/geometrymodule.py
--rw-rw-rw-  2.0 fat    20566 b- defN 23-Feb-14 18:00 darts/mesh/nb_geometrymodule.py
--rw-rw-rw-  2.0 fat    38906 b- defN 23-Mar-30 08:55 darts/mesh/struct_discretizer.py
--rw-rw-rw-  2.0 fat    16223 b- defN 23-Feb-14 18:00 darts/mesh/transcalc.py
--rw-rw-rw-  2.0 fat   196837 b- defN 23-Feb-27 08:40 darts/mesh/unstruct_discretizer.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/mesh/geometry/__init__.py
--rw-rw-rw-  2.0 fat    17409 b- defN 23-Feb-14 18:00 darts/mesh/geometry/fluidflower.py
--rw-rw-rw-  2.0 fat    19120 b- defN 23-Feb-14 18:00 darts/mesh/geometry/geometry.py
--rw-rw-rw-  2.0 fat     4383 b- defN 23-Feb-14 18:00 darts/mesh/geometry/main.py
--rw-rw-rw-  2.0 fat     5846 b- defN 23-Feb-14 18:00 darts/mesh/geometry/map_mesh.py
--rw-rw-rw-  2.0 fat    28000 b- defN 23-Feb-14 18:00 darts/mesh/geometry/shapes.py
--rw-rw-rw-  2.0 fat     4921 b- defN 23-Feb-14 18:00 darts/mesh/geometry/structured.py
--rw-rw-rw-  2.0 fat    11806 b- defN 23-Feb-14 18:00 darts/mesh/geometry/unstructured.py
--rw-rw-rw-  2.0 fat    17317 b- defN 23-Feb-14 18:00 darts/mesh/geometry/wells.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/__init__.py
--rw-rw-rw-  2.0 fat    14553 b- defN 23-Mar-06 12:34 darts/models/darts_model.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/opt/__init__.py
--rw-rw-rw-  2.0 fat   185953 b- defN 23-Mar-02 01:45 darts/models/opt/opt_module_settings.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/physics/__init__.py
--rw-rw-rw-  2.0 fat     8905 b- defN 23-Mar-06 12:34 darts/models/physics/geothermal.py
--rw-rw-rw-  2.0 fat    22992 b- defN 23-Feb-14 18:00 darts/models/physics/geothermal_operators.py
--rw-rw-rw-  2.0 fat     8674 b- defN 23-Feb-14 18:00 darts/models/physics/physics_base.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/physics/iapws/__init__.py
--rw-rw-rw-  2.0 fat    45070 b- defN 23-Feb-14 18:00 darts/models/physics/iapws/_iapws.py
--rw-rw-rw-  2.0 fat     5359 b- defN 23-Feb-14 18:00 darts/models/physics/iapws/_utils.py
--rw-rw-rw-  2.0 fat     1357 b- defN 23-Mar-03 15:31 darts/models/physics/iapws/custom_rock_property.py
--rw-rw-rw-  2.0 fat   169761 b- defN 23-Feb-14 18:00 darts/models/physics/iapws/iapws97.py
--rw-rw-rw-  2.0 fat     9854 b- defN 23-Mar-02 17:36 darts/models/physics/iapws/iapws_property.py
--rw-rw-rw-  2.0 fat     1381 b- defN 23-Feb-14 18:00 darts/models/physics/iapws/iapws_property_vec.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/physics/mech/__init__.py
--rw-rw-rw-  2.0 fat    11055 b- defN 23-Feb-14 18:00 darts/models/physics/mech/dead_oil_poromechanics.py
--rw-rw-rw-  2.0 fat     3614 b- defN 23-Feb-14 18:00 darts/models/physics/mech/elasticity.py
--rw-rw-rw-  2.0 fat     8449 b- defN 23-Feb-14 18:00 darts/models/physics/mech/poromechanics.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/physics_sup/__init__.py
--rw-rw-rw-  2.0 fat     1777 b- defN 23-Feb-14 18:00 darts/models/physics_sup/interpolation.py
--rw-rw-rw-  2.0 fat    11749 b- defN 23-Feb-14 18:00 darts/models/physics_sup/operator_evaluator_sup.py
--rw-rw-rw-  2.0 fat     8076 b- defN 23-Feb-14 18:00 darts/models/physics_sup/physics_comp_sup.py
--rw-rw-rw-  2.0 fat     4855 b- defN 23-Feb-14 18:00 darts/models/physics_sup/properties_basic.py
--rw-rw-rw-  2.0 fat    13950 b- defN 23-Feb-14 18:00 darts/models/physics_sup/properties_black_oil.py
--rw-rw-rw-  2.0 fat    23095 b- defN 23-Feb-14 18:00 darts/models/physics_sup/properties_ccs_thermal.py
--rw-rw-rw-  2.0 fat     7488 b- defN 23-Feb-14 18:00 darts/models/physics_sup/property_container.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/models/reservoirs/__init__.py
--rw-rw-rw-  2.0 fat    24468 b- defN 23-Mar-31 15:03 darts/models/reservoirs/struct_reservoir.py
--rw-rw-rw-  2.0 fat     5832 b- defN 23-Feb-27 08:40 darts/models/reservoirs/unstruct_reservoir.py
--rw-rw-rw-  2.0 fat     8636 b- defN 23-Feb-14 18:00 darts/tools/GRDECL2VTK.py
--rw-rw-rw-  2.0 fat    31570 b- defN 23-Feb-14 18:00 darts/tools/GRDECL_FaultProcess.py
--rw-rw-rw-  2.0 fat    19427 b- defN 23-Feb-14 18:00 darts/tools/GRDECL_Parser.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/tools/__init__.py
--rw-rw-rw-  2.0 fat      748 b- defN 23-Feb-14 18:00 darts/tools/adgprs_io.py
--rw-rw-rw-  2.0 fat     1860 b- defN 23-Feb-14 18:00 darts/tools/calculate_WI.py
--rw-rw-rw-  2.0 fat    47669 b- defN 23-Feb-14 18:00 darts/tools/eclipse_io.py
--rw-rw-rw-  2.0 fat      591 b- defN 23-Feb-14 18:00 darts/tools/eclipse_rates_io.py
--rw-rw-rw-  2.0 fat     1478 b- defN 23-Feb-14 18:00 darts/tools/interpolation.py
--rw-rw-rw-  2.0 fat     4984 b- defN 23-Feb-14 18:00 darts/tools/keyword_file_tools.py
--rw-rw-rw-  2.0 fat     6002 b- defN 23-Feb-14 18:00 darts/tools/plot_adgprs.py
--rw-rw-rw-  2.0 fat    16142 b- defN 23-Feb-14 18:00 darts/tools/plot_darts.py
--rw-rw-rw-  2.0 fat     2917 b- defN 23-Feb-14 18:00 darts/tools/plot_eclipse.py
--rw-rw-rw-  2.0 fat        0 b- defN 23-Apr-15 09:03 darts/tools/pyevtk/__init__.py
--rw-rw-rw-  2.0 fat     4701 b- defN 23-Feb-14 18:00 darts/tools/pyevtk/evtk.py
--rw-rw-rw-  2.0 fat    10329 b- defN 23-Feb-14 18:00 darts/tools/pyevtk/hl.py
--rw-rw-rw-  2.0 fat    19522 b- defN 23-Feb-14 18:00 darts/tools/pyevtk/vtk.py
--rw-rw-rw-  2.0 fat     3764 b- defN 23-Feb-14 18:00 darts/tools/pyevtk/xml.py
--rw-rw-rw-  2.0 fat    13539 b- defN 23-Feb-15 13:35 open_darts-0.1.4.data/data/LICENSE
--rw-rw-rw-  2.0 fat    13539 b- defN 23-Apr-15 09:09 open_darts-0.1.4.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     2536 b- defN 23-Apr-15 09:09 open_darts-0.1.4.dist-info/METADATA
--rw-rw-rw-  2.0 fat      100 b- defN 23-Apr-15 09:09 open_darts-0.1.4.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        6 b- defN 23-Apr-15 09:09 open_darts-0.1.4.dist-info/top_level.txt
-?rw-rw-r--  2.0 fat     6910 b- defN 23-Apr-15 09:09 open_darts-0.1.4.dist-info/RECORD
-78 files, 8996249 bytes uncompressed, 2702239 bytes compressed:  70.0%
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/mesh/__init__.py
+-rw-rw-rw-  2.0 fat    41162 b- defN 23-Jun-15 11:42 darts/mesh/geometrymodule.py
+-rw-rw-rw-  2.0 fat    20566 b- defN 23-Jun-15 11:42 darts/mesh/nb_geometrymodule.py
+-rw-rw-rw-  2.0 fat    38906 b- defN 23-Jun-15 11:42 darts/mesh/struct_discretizer.py
+-rw-rw-rw-  2.0 fat    16223 b- defN 23-Jun-15 11:42 darts/mesh/transcalc.py
+-rw-rw-rw-  2.0 fat   196837 b- defN 23-Jun-15 11:42 darts/mesh/unstruct_discretizer.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/mesh/geometry/__init__.py
+-rw-rw-rw-  2.0 fat    17401 b- defN 23-Jun-15 11:42 darts/mesh/geometry/fluidflower.py
+-rw-rw-rw-  2.0 fat    19104 b- defN 23-Jun-15 11:42 darts/mesh/geometry/geometry.py
+-rw-rw-rw-  2.0 fat     4383 b- defN 23-Jun-15 11:42 darts/mesh/geometry/main.py
+-rw-rw-rw-  2.0 fat     5846 b- defN 23-Jun-15 11:42 darts/mesh/geometry/map_mesh.py
+-rw-rw-rw-  2.0 fat    28000 b- defN 23-Jun-15 11:42 darts/mesh/geometry/shapes.py
+-rw-rw-rw-  2.0 fat     4913 b- defN 23-Jun-15 11:42 darts/mesh/geometry/structured.py
+-rw-rw-rw-  2.0 fat    11807 b- defN 23-Jun-15 11:42 darts/mesh/geometry/unstructured.py
+-rw-rw-rw-  2.0 fat    17309 b- defN 23-Jun-15 11:42 darts/mesh/geometry/wells.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/__init__.py
+-rw-rw-rw-  2.0 fat    14647 b- defN 23-Jun-15 11:42 darts/models/darts_model.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/opt/__init__.py
+-rw-rw-rw-  2.0 fat   151128 b- defN 23-Jun-15 11:42 darts/models/opt/opt_module_settings.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/physics/__init__.py
+-rw-rw-rw-  2.0 fat     8905 b- defN 23-Jun-15 11:42 darts/models/physics/geothermal.py
+-rw-rw-rw-  2.0 fat    23163 b- defN 23-Jun-16 06:33 darts/models/physics/geothermal_operators.py
+-rw-rw-rw-  2.0 fat     8674 b- defN 23-Jun-15 11:42 darts/models/physics/physics_base.py
+-rw-rw-rw-  2.0 fat    34819 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/LICENSE_GPLv3.txt
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/physics/iapws/__init__.py
+-rw-rw-rw-  2.0 fat     1336 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/custom_rock_property.py
+-rw-rw-rw-  2.0 fat     9812 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/iapws_property.py
+-rw-rw-rw-  2.0 fat     1381 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/iapws_property_vec.py
+-rw-rw-rw-  2.0 fat      193 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/__init__.cpython-39.pyc
+-rw-rw-rw-  2.0 fat    42177 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/_iapws.cpython-39.pyc
+-rw-rw-rw-  2.0 fat     4509 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/_utils.cpython-39.pyc
+-rw-rw-rw-  2.0 fat     1696 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/custom_rock_property.cpython-39.pyc
+-rw-rw-rw-  2.0 fat   131257 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/iapws97.cpython-39.pyc
+-rw-rw-rw-  2.0 fat    11035 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/iapws_property.cpython-39.pyc
+-rw-rw-rw-  2.0 fat     1441 b- defN 23-Jun-15 11:42 darts/models/physics/iapws/__pycache__/iapws_property_vec.cpython-39.pyc
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/physics/mech/__init__.py
+-rw-rw-rw-  2.0 fat    11055 b- defN 23-Jun-15 11:42 darts/models/physics/mech/dead_oil_poromechanics.py
+-rw-rw-rw-  2.0 fat     3614 b- defN 23-Jun-15 11:42 darts/models/physics/mech/elasticity.py
+-rw-rw-rw-  2.0 fat     8449 b- defN 23-Jun-15 11:42 darts/models/physics/mech/poromechanics.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/physics_sup/__init__.py
+-rw-rw-rw-  2.0 fat     1777 b- defN 23-Jun-15 11:42 darts/models/physics_sup/interpolation.py
+-rw-rw-rw-  2.0 fat    11383 b- defN 23-Jun-15 11:42 darts/models/physics_sup/operator_evaluator_sup.py
+-rw-rw-rw-  2.0 fat     8397 b- defN 23-Jun-15 11:42 darts/models/physics_sup/physics_comp_sup.py
+-rw-rw-rw-  2.0 fat     6771 b- defN 23-Jun-15 11:42 darts/models/physics_sup/properties_basic.py
+-rw-rw-rw-  2.0 fat    13950 b- defN 23-Jun-15 11:42 darts/models/physics_sup/properties_black_oil.py
+-rw-rw-rw-  2.0 fat    23095 b- defN 23-Jun-15 11:42 darts/models/physics_sup/properties_ccs_thermal.py
+-rw-rw-rw-  2.0 fat     8479 b- defN 23-Jun-15 11:42 darts/models/physics_sup/property_container.py
+-rw-rw-rw-  2.0 fat     7115 b- defN 23-Jun-15 11:42 darts/models/physics_sup/flash/components.py
+-rw-rw-rw-  2.0 fat      818 b- defN 23-Jun-15 11:42 darts/models/physics_sup/flash/eos_properties.py
+-rw-rw-rw-  2.0 fat     1503 b- defN 23-Jun-15 11:42 darts/models/physics_sup/flash/flash.py
+-rw-rw-rw-  2.0 fat    16073 b- defN 23-Jun-15 11:42 darts/models/physics_sup/flash/properties.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/models/reservoirs/__init__.py
+-rw-rw-rw-  2.0 fat    24456 b- defN 23-Jun-16 06:33 darts/models/reservoirs/struct_reservoir.py
+-rw-rw-rw-  2.0 fat     5858 b- defN 23-Jun-15 11:42 darts/models/reservoirs/unstruct_reservoir.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/physics/__init__.py
+-rw-rw-rw-  2.0 fat     9763 b- defN 23-Jun-15 11:42 darts/physics/physics_base.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/physics/geothermal/__init__.py
+-rw-rw-rw-  2.0 fat    22992 b- defN 23-Jun-15 11:42 darts/physics/geothermal/operator_evaluator.py
+-rw-rw-rw-  2.0 fat     8864 b- defN 23-Jun-15 11:42 darts/physics/geothermal/physics.py
+-rw-rw-rw-  2.0 fat       22 b- defN 23-Jun-15 11:42 darts/physics/geothermal/property_container.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/physics/properties/__init__.py
+-rw-rw-rw-  2.0 fat     2337 b- defN 23-Jun-15 11:42 darts/physics/properties/basic.py
+-rw-rw-rw-  2.0 fat    13974 b- defN 23-Jun-15 11:42 darts/physics/properties/black_oil.py
+-rw-rw-rw-  2.0 fat     2062 b- defN 23-Jun-15 11:42 darts/physics/properties/conductivity.py
+-rw-rw-rw-  2.0 fat     5863 b- defN 23-Jun-15 11:42 darts/physics/properties/density.py
+-rw-rw-rw-  2.0 fat     3580 b- defN 23-Jun-15 11:42 darts/physics/properties/enthalpy.py
+-rw-rw-rw-  2.0 fat     2431 b- defN 23-Jun-15 11:42 darts/physics/properties/flash.py
+-rw-rw-rw-  2.0 fat     5447 b- defN 23-Jun-15 11:42 darts/physics/properties/kinetics.py
+-rw-rw-rw-  2.0 fat     3740 b- defN 23-Jun-15 11:42 darts/physics/properties/viscosity.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/physics/super/__init__.py
+-rw-rw-rw-  2.0 fat    12498 b- defN 23-Jun-15 11:42 darts/physics/super/operator_evaluator.py
+-rw-rw-rw-  2.0 fat     7885 b- defN 23-Jun-15 11:42 darts/physics/super/physics.py
+-rw-rw-rw-  2.0 fat     8558 b- defN 23-Jun-15 11:42 darts/physics/super/property_container.py
+-rw-rw-rw-  2.0 fat     8636 b- defN 23-Jun-15 11:42 darts/tools/GRDECL2VTK.py
+-rw-rw-rw-  2.0 fat    31570 b- defN 23-Jun-15 11:42 darts/tools/GRDECL_FaultProcess.py
+-rw-rw-rw-  2.0 fat    19427 b- defN 23-Jun-15 11:42 darts/tools/GRDECL_Parser.py
+-rw-rw-rw-  2.0 fat        0 b- defN 23-Jun-16 16:25 darts/tools/__init__.py
+-rw-rw-rw-  2.0 fat      748 b- defN 23-Jun-15 11:42 darts/tools/adgprs_io.py
+-rw-rw-rw-  2.0 fat     1860 b- defN 23-Jun-15 11:42 darts/tools/calculate_WI.py
+-rw-rw-rw-  2.0 fat      591 b- defN 23-Jun-15 11:42 darts/tools/eclipse_rates_io.py
+-rw-rw-rw-  2.0 fat     1478 b- defN 23-Jun-15 11:42 darts/tools/interpolation.py
+-rw-rw-rw-  2.0 fat     4984 b- defN 23-Jun-15 11:42 darts/tools/keyword_file_tools.py
+-rw-rw-rw-  2.0 fat     6002 b- defN 23-Jun-15 11:42 darts/tools/plot_adgprs.py
+-rw-rw-rw-  2.0 fat    16142 b- defN 23-Jun-15 11:42 darts/tools/plot_darts.py
+-rw-rw-rw-  2.0 fat     2917 b- defN 23-Jun-15 11:42 darts/tools/plot_eclipse.py
+-rw-rw-rw-  2.0 fat    11560 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1873 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/LICENSE.md
+-rw-rw-rw-  2.0 fat     2764 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      100 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        6 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/top_level.txt
+?rw-rw-r--  2.0 fat     9249 b- defN 23-Jun-16 16:31 open_darts-1.0.0.dist-info/RECORD
+100 files, 9621935 bytes uncompressed, 2732810 bytes compressed:  71.6%
```

## zipnote {}

```diff
@@ -1,13 +1,16 @@
 Filename: darts/__init__.py
 Comment: 
 
 Filename: darts/build_info.txt
 Comment: 
 
+Filename: darts/discretizer.pyd
+Comment: 
+
 Filename: darts/engines.pyd
 Comment: 
 
 Filename: darts/msvcp140.dll
 Comment: 
 
 Filename: darts/print_build_info.py
@@ -18,17 +21,14 @@
 
 Filename: darts/vcomp140.dll
 Comment: 
 
 Filename: darts/vcruntime140.dll
 Comment: 
 
-Filename: darts/docs/reference.pdf
-Comment: 
-
 Filename: darts/mesh/__init__.py
 Comment: 
 
 Filename: darts/mesh/geometrymodule.py
 Comment: 
 
 Filename: darts/mesh/nb_geometrymodule.py
@@ -90,33 +90,48 @@
 
 Filename: darts/models/physics/geothermal_operators.py
 Comment: 
 
 Filename: darts/models/physics/physics_base.py
 Comment: 
 
+Filename: darts/models/physics/iapws/LICENSE_GPLv3.txt
+Comment: 
+
 Filename: darts/models/physics/iapws/__init__.py
 Comment: 
 
-Filename: darts/models/physics/iapws/_iapws.py
+Filename: darts/models/physics/iapws/custom_rock_property.py
 Comment: 
 
-Filename: darts/models/physics/iapws/_utils.py
+Filename: darts/models/physics/iapws/iapws_property.py
 Comment: 
 
-Filename: darts/models/physics/iapws/custom_rock_property.py
+Filename: darts/models/physics/iapws/iapws_property_vec.py
 Comment: 
 
-Filename: darts/models/physics/iapws/iapws97.py
+Filename: darts/models/physics/iapws/__pycache__/__init__.cpython-39.pyc
 Comment: 
 
-Filename: darts/models/physics/iapws/iapws_property.py
+Filename: darts/models/physics/iapws/__pycache__/_iapws.cpython-39.pyc
 Comment: 
 
-Filename: darts/models/physics/iapws/iapws_property_vec.py
+Filename: darts/models/physics/iapws/__pycache__/_utils.cpython-39.pyc
+Comment: 
+
+Filename: darts/models/physics/iapws/__pycache__/custom_rock_property.cpython-39.pyc
+Comment: 
+
+Filename: darts/models/physics/iapws/__pycache__/iapws97.cpython-39.pyc
+Comment: 
+
+Filename: darts/models/physics/iapws/__pycache__/iapws_property.cpython-39.pyc
+Comment: 
+
+Filename: darts/models/physics/iapws/__pycache__/iapws_property_vec.cpython-39.pyc
 Comment: 
 
 Filename: darts/models/physics/mech/__init__.py
 Comment: 
 
 Filename: darts/models/physics/mech/dead_oil_poromechanics.py
 Comment: 
@@ -147,89 +162,140 @@
 
 Filename: darts/models/physics_sup/properties_ccs_thermal.py
 Comment: 
 
 Filename: darts/models/physics_sup/property_container.py
 Comment: 
 
+Filename: darts/models/physics_sup/flash/components.py
+Comment: 
+
+Filename: darts/models/physics_sup/flash/eos_properties.py
+Comment: 
+
+Filename: darts/models/physics_sup/flash/flash.py
+Comment: 
+
+Filename: darts/models/physics_sup/flash/properties.py
+Comment: 
+
 Filename: darts/models/reservoirs/__init__.py
 Comment: 
 
 Filename: darts/models/reservoirs/struct_reservoir.py
 Comment: 
 
 Filename: darts/models/reservoirs/unstruct_reservoir.py
 Comment: 
 
-Filename: darts/tools/GRDECL2VTK.py
+Filename: darts/physics/__init__.py
 Comment: 
 
-Filename: darts/tools/GRDECL_FaultProcess.py
+Filename: darts/physics/physics_base.py
 Comment: 
 
-Filename: darts/tools/GRDECL_Parser.py
+Filename: darts/physics/geothermal/__init__.py
 Comment: 
 
-Filename: darts/tools/__init__.py
+Filename: darts/physics/geothermal/operator_evaluator.py
 Comment: 
 
-Filename: darts/tools/adgprs_io.py
+Filename: darts/physics/geothermal/physics.py
 Comment: 
 
-Filename: darts/tools/calculate_WI.py
+Filename: darts/physics/geothermal/property_container.py
 Comment: 
 
-Filename: darts/tools/eclipse_io.py
+Filename: darts/physics/properties/__init__.py
 Comment: 
 
-Filename: darts/tools/eclipse_rates_io.py
+Filename: darts/physics/properties/basic.py
 Comment: 
 
-Filename: darts/tools/interpolation.py
+Filename: darts/physics/properties/black_oil.py
 Comment: 
 
-Filename: darts/tools/keyword_file_tools.py
+Filename: darts/physics/properties/conductivity.py
 Comment: 
 
-Filename: darts/tools/plot_adgprs.py
+Filename: darts/physics/properties/density.py
 Comment: 
 
-Filename: darts/tools/plot_darts.py
+Filename: darts/physics/properties/enthalpy.py
 Comment: 
 
-Filename: darts/tools/plot_eclipse.py
+Filename: darts/physics/properties/flash.py
+Comment: 
+
+Filename: darts/physics/properties/kinetics.py
+Comment: 
+
+Filename: darts/physics/properties/viscosity.py
+Comment: 
+
+Filename: darts/physics/super/__init__.py
+Comment: 
+
+Filename: darts/physics/super/operator_evaluator.py
+Comment: 
+
+Filename: darts/physics/super/physics.py
+Comment: 
+
+Filename: darts/physics/super/property_container.py
+Comment: 
+
+Filename: darts/tools/GRDECL2VTK.py
 Comment: 
 
-Filename: darts/tools/pyevtk/__init__.py
+Filename: darts/tools/GRDECL_FaultProcess.py
 Comment: 
 
-Filename: darts/tools/pyevtk/evtk.py
+Filename: darts/tools/GRDECL_Parser.py
 Comment: 
 
-Filename: darts/tools/pyevtk/hl.py
+Filename: darts/tools/__init__.py
 Comment: 
 
-Filename: darts/tools/pyevtk/vtk.py
+Filename: darts/tools/adgprs_io.py
 Comment: 
 
-Filename: darts/tools/pyevtk/xml.py
+Filename: darts/tools/calculate_WI.py
+Comment: 
+
+Filename: darts/tools/eclipse_rates_io.py
+Comment: 
+
+Filename: darts/tools/interpolation.py
+Comment: 
+
+Filename: darts/tools/keyword_file_tools.py
+Comment: 
+
+Filename: darts/tools/plot_adgprs.py
+Comment: 
+
+Filename: darts/tools/plot_darts.py
+Comment: 
+
+Filename: darts/tools/plot_eclipse.py
 Comment: 
 
-Filename: open_darts-0.1.4.data/data/LICENSE
+Filename: open_darts-1.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: open_darts-0.1.4.dist-info/LICENSE
+Filename: open_darts-1.0.0.dist-info/LICENSE.md
 Comment: 
 
-Filename: open_darts-0.1.4.dist-info/METADATA
+Filename: open_darts-1.0.0.dist-info/METADATA
 Comment: 
 
-Filename: open_darts-0.1.4.dist-info/WHEEL
+Filename: open_darts-1.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: open_darts-0.1.4.dist-info/top_level.txt
+Filename: open_darts-1.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: open_darts-0.1.4.dist-info/RECORD
+Filename: open_darts-1.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## darts/build_info.txt

```diff
@@ -1,3 +1,3 @@
-15/04/2023 11:09:24
+16/06/2023 18:31:26
 SRV554$@SRV554
-ce01336
+v1.0.0-dirty
```

## darts/print_build_info.py

```diff
@@ -1,7 +1,11 @@
+import datetime
+import getpass
+import socket
+import subprocess
 import os
 
 def print_build_info():
     here = os.path.abspath(os.path.dirname(__file__))
     version_info_file = os.path.join(here, 'build_info.txt')
     if os.path.exists(version_info_file):
         with open(version_info_file, 'r') as fp:
@@ -13,7 +17,31 @@
         import subprocess
         try:
             git_hash = subprocess.run(['git', 'describe', '--always', '--dirty'], stdout=subprocess.PIPE, cwd=here)
         except FileNotFoundError:
             print('darts-package is run locally from %s [no git hash info available]', here)
             return
         print('darts-package is imported locally from %s [%s]' % (here, git_hash.stdout.decode('utf-8').rstrip()))
+
+
+if __name__ == '__main__':
+  """
+  When this script is excecuted, it will generate 'build_info.txt'
+  """
+
+  print("Creating version info file...")
+  here = os.path.abspath(os.path.dirname(__file__))
+  version_info_file = os.path.join(here, 'build_info.txt')
+  with open(version_info_file, 'w') as fp:
+    build_date = datetime.datetime.now()
+    fp.write(build_date.strftime("%d/%m/%Y %H:%M:%S\n"))
+
+    username = getpass.getuser()
+    hostname = socket.gethostname()
+    fp.write("%s@%s\n" % (username, hostname))
+
+    git_hash = subprocess.run(['git', 'describe', '--always', '--dirty'], stdout=subprocess.PIPE)
+    fp.write(git_hash.stdout.decode('utf-8'))
+
+  print ("Embedded build info:")
+  with open(version_info_file, 'r') as f:
+    print(f.read())
```

## darts/mesh/geometry/fluidflower.py

```diff
@@ -1,8 +1,8 @@
-from geometry.shapes import *
+from .shapes import *
 
 
 class FluidFlower(Shape):
     def __init__(self):
         super().__init__()
 
         self.connect_points()
```

## darts/mesh/geometry/geometry.py

```diff
@@ -1,13 +1,13 @@
 import numpy as np
 import math
 import warnings
 # from dataclasses import dataclass, is_dataclass, field
-from geometry.shapes import *
-from geometry.wells import *
+from .shapes import *
+from .wells import *
 
 import gmsh
 
 
 class Geometry:
     def __init__(self, dim, axs=[0, 1, 2]):
         self.dim = dim
```

## darts/mesh/geometry/structured.py

```diff
@@ -1,12 +1,12 @@
 import numpy as np
 import math
 import warnings
 import matplotlib.pyplot as plt
-from geometry.geometry import Geometry
+from .geometry import Geometry
 
 import numba
 from numba import jit, njit
 
 
 @jit(nopython=True)
 def _find_surface(xyz, ax1, ax2, points, curves, surfaces):
```

## darts/mesh/geometry/unstructured.py

```diff
@@ -1,11 +1,11 @@
 import numpy as np
 import math
 import warnings
-from geometry import Geometry
+from .geometry import Geometry
 
 import gmsh
 
 
 class Unstructured(Geometry):
     def __init__(self, dim, axs=[0, 1, 2]):
         super().__init__(dim, axs)
```

## darts/mesh/geometry/wells.py

```diff
@@ -1,10 +1,10 @@
 import numpy as np
 import math
-from geometry.shapes import *
+from .shapes import *
 
 
 class Well(Shape):
     def __init__(self):
         self.curves_map = {}
 
         super().__init__()
```

## darts/models/darts_model.py

```diff
@@ -1,14 +1,15 @@
 from math import fabs
 import pickle
 import os
 import numpy as np
 
 from darts.engines import *
 from darts.engines import print_build_info as engines_pbi
+from darts.discretizer import print_build_info as discretizer_pbi
 from darts.print_build_info import print_build_info as package_pbi
 
 
 class DartsModel:
     """
     Base class with multiple functions
 
@@ -16,14 +17,15 @@
 
     def __init__(self):
         """"
            Initialize DartsModel class.
         """
         # print out build information
         engines_pbi()
+        discretizer_pbi()
         package_pbi()
         self.timer = timer_node()  # Create time_node object for time record
         self.timer.start()  # Start time record
         self.timer.node["simulation"] = timer_node()  # Create timer.node called "simulation" to record simulation time
         self.timer.node["newton update"] = timer_node()
         self.timer.node[
             "initialization"] = timer_node()  # Create timer.node called "initialization" to record initialization time
```

## darts/models/opt/opt_module_settings.py

```diff
@@ -133,727 +133,14 @@
 
         # hinge loss for binary classification or threshold problem
         self.threshold = []
         self.binary_array = []
         self.save_error = False
         self.label = ''
 
-# ----------------------------------------------------------------------------------------------------------------------
-# ---------------------------------------------  Legacy code - Mark Khait-----------------------------------------------
-# ----------------------------------------------------------------------------------------------------------------------
-    def set_modifier(self, modifier):
-        self.modifier = modifier
-
-    def report(self):
-        cum_data = pd.DataFrame.from_dict(self.physics.engine.time_data_report)
-        return cum_data
-
-    def gen_response_data (self):
-        # generate response from time_data based on observed data
-        assert (type(self.observation_data) == pd.core.frame.DataFrame)
-        assert (type(self.response_data) == pd.core.frame.DataFrame)
-
-        # convert time_data to df
-        time_data = pd.DataFrame.from_dict(model.time_data)
-        # generate time differences
-        time_diff = time_data['time'].diff()
-        time_diff[0] = time_data['time'][0]
-        for c in self.observation_data:
-            if c == 'time':
-                continue
-            volume = time_data[c] * time_diff
-
-
-    def objfun_all_rates_l2(self):
-        observation = self.observation_data
-        # response = self.response_data
-        time_data = pd.DataFrame.from_dict(self.physics.engine.time_data)
-        response = time_data.set_index('time', drop=False)
-        misfit = {}
-        if len(response) == 0 or np.array(response['time'])[-1] != np.array(observation['time'])[-1]:
-            objfun = 1000
-        else:
-            for w in self.reservoir.inj_wells:
-                c = w.name + ' : water rate (m3/day)'
-                misfit[c] = observation[c] - response[c]
-
-            for w in self.reservoir.prod_wells:
-                c = w.name + ' : water rate (m3/day)'
-                misfit[c] = observation[c] - response[c]
-                c = w.name + ' : oil rate (m3/day)'
-                misfit[c] = observation[c] - response[c]
-        objfun = 0
-        for m in misfit:
-            if m != 'time':
-                objfun += np.linalg.norm(misfit[m])
-            else:
-                continue
-        return objfun / self.objfun_norm
-
-
-    def objfun_observed_cumulative_rates_l2(self):
-        # Get Data
-        observation = self.observation_data
-        time_data = self.physics.engine.time_data
-        # seaching string
-        search_str = 'rate (m3/day)'
-
-        # Check for simullation to finish
-        if len(time_data) == 0 or time_data['time'][len(time_data['time']) - 1] != self.observation_last_date:
-            # simulation has not finished or even started
-            return 1000
-        else:
-
-            # 1. Make simulated data cumulative
-            time_data = pd.DataFrame.from_dict(time_data)
-            time_data = self.make_cumulative(time_data)
-
-            # 2. Get only relative data
-            if time_data.size > observation.size:
-                relevant_time_data = {key: time_data[key] for key in observation.columns}
-            else:
-                relevant_time_data = {key: time_data[key] for key in observation.columns if search_str in key or 'time' in key}
-            response = pd.DataFrame.from_dict(relevant_time_data)
-
-            # 2. Adjust response data accroding to uniform time
-            response = response.set_index('time', drop=False)
-
-            # 3. calculate misfit
-            misfit = observation - response.loc[observation.index, :]
-
-            # 4. Calculate objective function
-            objfun = 0
-            for m in misfit:
-                if m != 'time' and search_str in m:
-                    objfun += np.linalg.norm(misfit[m])
-
-            return objfun / self.objfun_norm
-
-    def objfun_observed_cumulative_rates_ver2(self):
-        # Get Data
-        observation = self.observation_data # already in cumulative format
-        time_data = self.report()
-        # seaching strings
-        search_str_acc = 'acc volume'
-
-        # Check for simullation to finish
-        if len(time_data) == 0 or time_data['time'][len(time_data['time']) - 1] != self.observation_last_date:
-            # simulation has not finished or even started
-            print(time_data['time'][len(time_data['time']) - 1])
-            print(self.observation_last_date)
-            return 1000
-        else:
-
-            # 2. Get only relative data
-            if time_data.size > observation.size:
-                relevant_time_data = {key: time_data[key] for key in observation.columns}
-            else:
-                relevant_time_data = {key: time_data[key] for key in observation.columns if search_str_acc in key or 'time' in key}
-            response = pd.DataFrame.from_dict(relevant_time_data)
-
-            # 2. Adjust response data accroding to uniform time
-            response = response.set_index('time', drop=False)
-
-            # 3. calculate misfit
-            if self.data_error_switch:
-                data_error = self.calculate_trust_region(abs(observation),region=1) # region 2 is to check last period
-                misfit = abs(abs(observation) - abs(response.loc[observation.index, :])) - data_error
-                misfit[misfit < 0] = 0
-            else:
-                misfit = abs(abs(observation) - abs(response.loc[observation.index, :]))
-
-            # 4. Calculate objective function
-            objfun = 0
-            for m in misfit:
-                if m != 'time' and search_str_acc in m:
-                        objfun += np.linalg.norm(misfit[m])
-
-            return objfun / self.objfun_norm
-
-    def objfun_observed_reactive_rates(self, start_opt=[],stop_opt=[]):
-        # Get Data (if interval optimization choosen only spicific part of truth data will be extracted)
-        if start_opt or stop_opt:
-            observation = self.observation_data[start_opt:stop_opt]  # already in cumulative format # For Intervals
-        else:
-            observation = self.observation_data
-        time_data = self.report()
-
-        # seaching strings
-        search_str = 'rate (m3/day)'
-
-        # Check for simulation to finish
-        if start_opt or stop_opt:
-            if len(time_data) == 0: # For intervals last date is different TODO:can be optimized
-                return 1000
-            else:
-                # 2. Get only relative data
-                if time_data.size > observation.size:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns}
-                else:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns if
-                                          search_str in key or 'time' in key}
-                response = pd.DataFrame.from_dict(relevant_time_data)
-
-                # 2. Adjust response data accroding to uniform time
-                # print(observation['time'])
-                if len(response) !=len(observation['time']):
-                    return 1000
-                else:
-                    response = response.set_index(observation['time'], drop=False)
-        else:
-            if len(time_data) == 0 or time_data['time'][len(time_data['time']) - 1] != self.observation_last_date:
-                # simulation has not finished or even started
-                print(time_data['time'][len(time_data['time']) - 1])
-                print(self.observation_last_date)
-                return 1000
-            else:
-
-                # 2. Get only relative data
-                if time_data.size > observation.size:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns}
-                else:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns if search_str in key or 'time' in key}
-                response = pd.DataFrame.from_dict(relevant_time_data)
-
-                # 2. Adjust response data accroding to uniform time
-                response = response.set_index('time', drop=False) #
-
-        # 3. calculate misfit
-        misfit = abs(observation) - abs(response.loc[observation.index, :])
-        misfit_std = sum(misfit.std())
-
-        # 4. Calculate objective function - simple L2 norm of misfit
-        objfun = 0
-        for m in misfit:
-            if m != 'time' and search_str in m and 'I' not in m:
-                objfun += np.linalg.norm(misfit[m])
-
-        # print(objfun)
-
-        return objfun / self.objfun_norm
-
-
-    def objfun_ensamble_based(self, start_opt=[],stop_opt=[]):
-        # Get Data (if interval optimization choosen only spicific part of truth data will be extracted)
-        if start_opt or stop_opt:
-            observation = self.observation_data[start_opt:stop_opt]  # already in cumulative format # For Intervals
-        else:
-            observation = self.observation_data
-        time_data = self.report()
-
-        # Check for simulation to finish
-        if start_opt or stop_opt:
-            if len(time_data) == 0: # For intervals last date is different TODO:can be optimized
-                return 1000
-            else:
-                # 2. Get only relative data
-                if time_data.size > observation.size:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns}
-                else:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns if
-                                          search_str in key or 'time' in key}
-                response = pd.DataFrame.from_dict(relevant_time_data)
-
-                # 2. Adjust response data accroding to uniform time
-                # print(observation['time'])
-                if len(response) !=len(observation['time']):
-                    return 1000
-                else:
-                    response = response.set_index(observation['time'], drop=False)
-        else:
-            if len(time_data) == 0 or time_data['time'][len(time_data['time']) - 1] != self.observation_last_date:
-                # simulation has not finished or even started
-                print(time_data['time'][len(time_data['time']) - 1])
-                print(self.observation_last_date)
-                return 1000
-            else:
-
-                # 2. Get only relative data
-                if time_data.size > observation.size:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns}
-                else:
-                    relevant_time_data = {key: time_data[key] for key in observation.columns if search_str in key or 'time' in key}
-                response = pd.DataFrame.from_dict(relevant_time_data)
-
-                # 2. Adjust response data accroding to uniform time
-                response = response.set_index('time', drop=False) #
-
-        # 3. calculate misfit
-        misfit = abs(observation) - abs(response.loc[observation.index, :])
-        misfit_std = sum(misfit.std())
-
-        # 4. Calculate objective function - based on covariance matrix
-        # 4. Separate misfit into three components and combine either vertically or add up (make a single column vector)
-        misfit_df = pd.DataFrame()
-        misfit_df['time'] = misfit['time']
-        misfit_df['Water Rate'] = 0
-        misfit_df['Oil Rate'] = 0
-        misfit_df['Injection Rate'] = 0
-        search_str = ' : water rate'
-        search_str_2 = ' : oil rate'
-
-        for col in misfit.columns:
-            if search_str in col:
-                if 'I' not in col:
-                    misfit_df['Water Rate'] += misfit[col]
-                else:
-                    misfit_df['Injection Rate'] += misfit[col]
-            elif search_str_2 in col:
-                if 'I' not in col:
-                    misfit_df['Oil Rate'] += misfit[col]
-
-        # misfit_df_single = pd.concat([misfit_df['Water Rate'], misfit_df['Oil Rate']], axis=0, ignore_index=True).values
-        misfit_df_single = (misfit_df['Water Rate'] + misfit_df['Oil Rate']).values
-
-        objfun = 0.5 * misfit_df_single.dot(self.cov_mat_inv).dot(np.transpose(misfit_df_single))
-
-
-        return objfun / self.objfun_norm
-
-    def objfun_watercut_l2(self):
-        observed_response = self.get_response(self.observation_data)
-        response = self.get_response(self.get_response_data())
-
-        if len(response) == 0 or len(response[0]) == 0 or len(response[0][0]) != len(observed_response[0][0]):
-            objfun = 1000
-        else:
-            objfun = 0
-            all_water_rates = response[1]
-            all_oil_rates = response[2]
-            all_observed_water_rates = observed_response[1]
-            all_observed_oil_rates = observed_response[2]
-            for wrate, orate, wrate_obs, orate_obs in zip(all_water_rates, all_oil_rates, all_observed_water_rates,
-                                                          all_observed_oil_rates):
-                if True in np.isnan(wrate) or True in np.isnan(orate):
-                    print('nan detected')
-                    return 500
-                else:
-                    watercut = wrate / (wrate + orate)
-                    watercut_obs = wrate_obs / (wrate_obs + orate_obs)
-                    objfun += np.linalg.norm(watercut - watercut_obs) / np.linalg.norm(watercut_obs)
-
-        return 10 * objfun
-
-    # the function to be called by optimizer
-    # 1. Update model according to model_modifier
-    # 2. Perform run
-    # 3. Return objective function
-    def make_opt_step_stages(self, x, *args):
-        self.opt_step_time -= time.time()
-
-        # 1. Update model
-        self.modifier.set_x(self, x)
-
-        # 2. Reset
-        self.reset(self.interval_init[args[2]])
-
-        self.sim_time -= time.time()
-        # 3. Run
-        self.run(start_opt=args[0],stop_opt=args[1])
-        # self.run()
-        self.sim_time += time.time()
-
-        self.obj_time -= time.time()
-        # 4. Return objective
-        obj = self.objfun(start_opt=args[0],stop_opt=args[1])
-        self.obj_time += time.time()
-
-        # 5. If simulation has not finished, rerun it to save the logs
-        if self.save_unfinished_runs:
-            if (obj == 1000):
-                log_fname = 'terminated_run_%d' % self.terminated_runs
-
-                with open(log_fname + '.x', 'w') as log:
-                    log.write('Problem occurred with: \n')
-                    log.write(np.array_str(x))
-
-                np.save(log_fname, x)
-
-                redirect_darts_output(log_fname + '.log')
-                self.terminated_runs += 1
-                self.modifier.set_x(self, x)
-                self.reset()
-                self.run()
-                redirect_darts_output('')
-
-        self.opt_step_time += time.time()
-        self.n_opt_steps += 1
-
-        print('\r Run %d: %f s/step, %f s/sim, %f s/obj' % (self.n_opt_steps, self.opt_step_time / self.n_opt_steps,
-                                                              self.sim_time / self.n_opt_steps,
-                                                              self.obj_time / self.n_opt_steps), end='',
-              flush=True)
-        return obj
-
-    def make_opt_step(self, x, *args):
-        # print(args[0])
-
-        self.opt_step_time -= time.time()
-
-        # 1. Update model
-        self.modifier.set_x(self, x)
-        # self.modifier.set_x_by_du_dT(self, x)
-
-        self.set_boundary_conditions()
-        # 2. Reset
-        self.reset()
-
-
-        self.sim_time -= time.time()
-        # # 3. Run
-        # self.run()
-        # # self.run()
-        # self.sim_time += time.time()
-        #
-        # self.obj_time -= time.time()
-        # # 4. Return objective
-        # obj = self.objfun()
-        # self.obj_time += time.time()
-        # 3. Run
-        if args:
-            args = args[0]
-            self.run(start_opt=args[0],stop_opt=args[1])
-        else:
-            self.run()
-        # self.run()
-        self.sim_time += time.time()
-
-        self.obj_time -= time.time()
-        # 4. Return objective
-        if args:
-            obj = self.objfun(start_opt=args[0],stop_opt=args[1])
-        else:
-            obj = self.objfun()
-            # print(obj)
-        self.obj_time += time.time()
-
-        # 5. If simulation has not finished, rerun it to save the logs
-        if self.save_unfinished_runs:
-            if (obj == 1000):
-                log_fname = 'terminated_run_%d' % self.terminated_runs
-
-                with open(log_fname + '.x', 'w') as log:
-                    log.write('Problem occurred with: \n')
-                    log.write(np.array_str(x))
-
-                np.save(log_fname, x)
-
-                redirect_darts_output(log_fname + '.log')
-                self.terminated_runs += 1
-                self.modifier.set_x(self, x)
-                self.reset()
-                self.run()
-                redirect_darts_output('')
-
-        self.opt_step_time += time.time()
-        self.n_opt_steps += 1
-
-        print('\r Run %d: %f s/step, %f s/sim, %f s/obj' % (self.n_opt_steps, self.opt_step_time / self.n_opt_steps,
-                                                              self.sim_time / self.n_opt_steps,
-                                                              self.obj_time / self.n_opt_steps), end='', flush=True)
-        return obj
-
-    def make_opt_step_2(self, x, grad, opt_control):
-        args = opt_control
-        eps = 1e-6 + 1e-10
-        # eps = 1e-10
-        if grad.size > 0:
-
-            grad[:] = np.array(approx_fprime(x, self.make_opt_step, eps, opt_control))
-            #scipy.optimize.check_grad
-            # print(grad)
-
-            self.opt_step_time -= time.time()
-
-            # 1. Update model
-            self.modifier.set_x(self, x)
-
-            # 2. Reset
-            self.reset()
-
-            self.sim_time -= time.time()
-            # # 3. Run
-            # self.run()
-            # self.sim_time += time.time()
-            #
-            # self.obj_time -= time.time()
-            # # 4. Return objective
-            # obj = self.objfun()
-            # self.obj_time += time.time()
-            # 3. Run
-            self.run(start_opt=args[0], stop_opt=args[1])
-            # self.run()
-            self.sim_time += time.time()
-
-            self.obj_time -= time.time()
-            # 4. Return objective
-            obj = self.objfun(start_opt=args[0], stop_opt=args[1])
-            self.obj_time += time.time()
-
-            # 5. If simulation has not finished, rerun it to save the logs
-            if self.save_unfinished_runs:
-                if (obj == 1000):
-                    log_fname = 'terminated_run_%d' % self.terminated_runs
-
-                    with open(log_fname + '.x', 'w') as log:
-                        log.write('Problem occurred with: \n')
-                        log.write(np.array_str(x))
-
-                    np.save(log_fname, x)
-
-                    redirect_darts_output(log_fname + '.log')
-                    self.terminated_runs += 1
-                    self.modifier.set_x(self, x)
-                    self.reset()
-                    self.run()
-                    redirect_darts_output('')
-
-            self.opt_step_time += time.time()
-            self.n_opt_steps += 1
-
-            print('\r Run %d: %f s/step, %f s/sim, %f s/obj' % (self.n_opt_steps, self.opt_step_time / self.n_opt_steps,
-                                                                self.sim_time / self.n_opt_steps,
-                                                                self.obj_time / self.n_opt_steps), end='',
-                  flush=True)
-        else:
-            self.opt_step_time -= time.time()
-
-            # 1. Update model
-            self.modifier.set_x(self, x)
-
-            # 2. Reset
-            self.reset()
-
-            self.sim_time -= time.time()
-            # # 3. Run
-            # self.run()
-            # self.sim_time += time.time()
-            #
-            # self.obj_time -= time.time()
-            # # 4. Return objective
-            # obj = self.objfun()
-            # self.obj_time += time.time()
-            # 3. Run
-            self.run(start_opt=args[0], stop_opt=args[1])
-            # self.run()
-            self.sim_time += time.time()
-
-            self.obj_time -= time.time()
-            # 4. Return objective
-            obj = self.objfun(start_opt=args[0], stop_opt=args[1])
-            self.obj_time += time.time()
-
-            # 5. If simulation has not finished, rerun it to save the logs
-            if self.save_unfinished_runs:
-                if (obj == 1000):
-                    log_fname = 'terminated_run_%d' % self.terminated_runs
-
-                    with open(log_fname + '.x', 'w') as log:
-                        log.write('Problem occurred with: \n')
-                        log.write(np.array_str(x))
-
-                    np.save(log_fname, x)
-
-                    redirect_darts_output(log_fname + '.log')
-                    self.terminated_runs += 1
-                    self.modifier.set_x(self, x)
-                    self.reset()
-                    self.run()
-                    redirect_darts_output('')
-
-            self.opt_step_time += time.time()
-            self.n_opt_steps += 1
-
-            print('\r Run %d: %f s/step, %f s/sim, %f s/obj' % (self.n_opt_steps, self.opt_step_time / self.n_opt_steps,
-                                                                self.sim_time / self.n_opt_steps,
-                                                                self.obj_time / self.n_opt_steps), end='',
-                  flush=True)
-        print(f' Objective function: {obj}')
-        return np.float(obj)
-
-    def make_cumulative(self, darts_df):
-        time_diff = darts_df['time'].diff()
-        time_diff[0] = darts_df['time'][0]
-        search_str = ' : water rate'
-        search_str_2 = ' : oil rate'
-        for col in darts_df.columns:
-            if 'time' != col:
-                darts_df[col] *= time_diff
-                inj = darts_df[col] > 0
-                prod = darts_df[col] < 0
-                if sum(inj) > 0 and search_str in col:
-                    darts_df[col + 'I'] = darts_df[col][inj]
-                    darts_df[col + 'I'] = darts_df[col + 'I'].fillna(0)
-                    darts_df[col + 'I'] = darts_df[col + 'I'].cumsum()
-                if search_str in col or search_str_2 in col:
-                    darts_df[col] = darts_df[col][prod]
-                    darts_df[col] = darts_df[col].fillna(0)
-                    darts_df[col] = darts_df[col].cumsum()
-
-        return darts_df
-
-    def make_cumulative_acc_format(self, darts_df):
-        time_diff = darts_df['time'].diff()
-        time_diff[0] = darts_df['time'][0]
-        search_str = ' : water rate'
-        search_str_2 = ' : oil rate'
-        for col in darts_df.columns:
-            if 'time' != col:
-                for i, w in enumerate(self.reservoir.wells):
-                    if search_str in col and w.name in col:
-                        water_volume_col = w.name + " : water  volume (m3)"
-                        water_acc_col = w.name + " : water  acc volume (m3)"
-                        darts_df[water_volume_col] = darts_df[col] * time_diff
-                        darts_df[water_acc_col] = darts_df[water_volume_col].cumsum()
-                    elif search_str_2 in col and w.name in col:
-                        oil_volume_col = w.name + " : oil  volume (m3)"
-                        oil_acc_col = w.name + " : oil  acc volume (m3)"
-                        darts_df[oil_volume_col] = darts_df[col] * time_diff
-                        darts_df[oil_acc_col] = darts_df[oil_volume_col].cumsum()
-        return darts_df
-
-
-    def calculate_interval_error(self, start, stop, run_switch = False):
-        # Get Data (if interval optimization choosen only spicific part of truth data will be extracted)
-        if start or stop:
-            observation = self.observation_data[start:stop]  # already in cumulative format # For Intervals
-        else:
-            observation = self.observation_data
-
-        # seaching strings
-        search_str = 'rate (m3/day)'
-
-        if run_switch:
-            self.run(export_to_vtk=False,start_opt=start,stop_opt=stop)
-            print(1)
-
-        time_data = self.report()[start:stop]
-
-        # 2. Get only relative data
-        if time_data.size > observation.size:
-            relevant_time_data = {key: time_data[key] for key in observation.columns}
-        else:
-            relevant_time_data = {key: time_data[key] for key in observation.columns if
-                                  search_str in key or 'time' in key}
-        response = pd.DataFrame.from_dict(relevant_time_data)
-
-        # 2. Adjust response data accroding to uniform time
-        # print(observation['time'])
-        if len(response) != len(observation['time']):
-            return 1000
-        else:
-            response = response.set_index(observation['time'], drop=False)
-
-        # 3. calculate misfit
-        if self.data_error_switch:
-            data_error = self.calculate_trust_region(abs(observation))  # region 2 is to check last period
-            misfit = abs(abs(observation) - abs(response.loc[observation.index, :])) - data_error
-            misfit[misfit < 0] = 0
-        else:
-            misfit = abs(abs(observation) - abs(response.loc[observation.index, :]))
-        misfit['time']
-
-
-            # 4. Calculate objective function
-        objfun = 0
-        objfun2 = 0
-        for m in misfit:
-            if m != 'time' and search_str in m:
-                if self.data_error_switch:
-                    objfun += np.linalg.norm(misfit[m])
-                    objfun2 += np.linalg.norm(misfit[m], ord= np.inf)
-                else:
-                    # objfun += np.linalg.norm(misfit[m] / math.sqrt(np.std(misfit[m])))
-                    # objfun += sum(misfit[m]**2)
-                    # objfun += sum(misfit[m])
-                    # objfun += np.linalg.norm(misfit[m])
-                    # objfun += np.linalg.norm(misfit[m] / math.sqrt(np.var(misfit[m])))
-                    # objfun += 1/len(misfit[m]) * sum((misfit[m]**2)/ np.std(misfit[m]))
-                    objfun += 1/len(misfit[m]) * sum((misfit[m]**2))
-
-
-        return objfun / self.objfun_norm, objfun2 / self.objfun_norm
-
-    def calculate_misfit_error(self, truth_df, opt_df, train_lenght, rate_string='Oil Rate'):
-
-        # search_str = rate_type
-        search_str = ' : water rate'
-        search_str_2 = ' : oil rate'
-
-        if opt_df.size > truth_df.size:
-            relevant_time_data = {key: opt_df[key] for key in truth_df.columns}
-        else:
-            relevant_time_data = {key: opt_df[key] for key in truth_df.columns if
-                                  search_str in key or 'time' in key}
-        response = pd.DataFrame.from_dict(relevant_time_data)
-
-        # search_str = ' : water rate'
-        # search_str_2 = ' : oil rate'
-
-        acc_df = pd.DataFrame()
-        acc_df['time'] = truth_df['time']
-        acc_df['Water Rate'] = 0
-        acc_df['Oil Rate'] = 0
-        acc_df['Injection Rate'] = 0
-        acc_df_2 = pd.DataFrame()
-        acc_df_2['time'] = truth_df['time']
-        acc_df_2['Water Rate'] = 0
-        acc_df_2['Oil Rate'] = 0
-        acc_df_2['Injection Rate'] = 0
-        for col in truth_df.columns:
-            if search_str in col:
-                if 'I' not in col:
-                    acc_df['Water Rate'] += truth_df[col]
-                else:
-                    acc_df['Injection Rate'] +=truth_df[col]
-            elif search_str_2 in col:
-                if 'I' not in col:
-                    acc_df['Oil Rate'] += truth_df[col]
-        for col in opt_df.columns:
-            if search_str in col:
-                if 'I' not in col:
-                    acc_df_2['Water Rate'] += opt_df[col]
-                else:
-                    acc_df_2['Injection Rate'] +=opt_df[col]
-            elif search_str_2 in col:
-                if 'I' not in col:
-                    acc_df_2['Oil Rate'] += opt_df[col]
-
-        # acc_df['Water Rate'][acc_df['Water Rate'] == 0] = 1e-6
-        # acc_df['Water Rate'][acc_df['Water Rate'] <= 1e-5] = 1e-5
-        # acc_df_2['Water Rate'][acc_df_2['Water Rate'] <= 1e-5] = 1e-5
-        # SAE = abs(abs(acc_df['Water Rate'])-abs(acc_df_2['Water Rate']))
-        SAE = abs(abs(acc_df[rate_string])-abs(acc_df_2[rate_string]))
-
-        MAE_1 = (SAE[0:train_lenght].sum())/len(SAE[0:train_lenght])
-        MAE_2 = (SAE[train_lenght:].sum())/len(SAE[train_lenght:])
-
-
-        # AE = abs((abs(acc_df_2['Water Rate'])-abs(acc_df['Water Rate']))/abs(acc_df['Water Rate']))*100
-        # AE = AE.replace(np.inf, 0)
-        AE = abs((abs(acc_df_2[rate_string])-abs(acc_df[rate_string]))/abs(acc_df[rate_string]))*100
-
-
-        # misfit = abs(abs(truth_df) - abs(response.loc[truth_df.index, :]))
-        #
-        # error_training = 0
-        # error_prediction = 0
-        # for m in misfit:
-        #     if m != 'time' and search_str in m and 'I' not in m:
-        #         # error_training += misfit[m][0:train_lenght+1].sum()
-        #         # error_prediction += misfit[m][train_lenght+1:].sum()
-        #         error_training += np.linalg.norm(misfit[m][0:train_lenght+1])
-        #         error_prediction += np.linalg.norm(misfit[m][train_lenght+1:])
-
-        return MAE_1,MAE_2, np.mean(AE[0:train_lenght]), np.mean(AE[train_lenght:]), np.mean(AE[:])
-        # return SAE, abs(acc_df[rate_string]), np.mean(AE[0:train_lenght]), np.mean(AE[train_lenght:]), np.mean(AE[:])
-
-
-
-
 #-----------------------------------------------------------------------------------------------------------------------
 #---------------------------------------  Adjoint method - Xiaoming Tian------------------------------------------------
 #-----------------------------------------------------------------------------------------------------------------------
     def set_modifier_and_du_dT_and_x_idx(self, modifier, x_idx: List[int]):
         '''
         The settings of modifier, x_idx, and col_idx
         :param modifier: model modifier
@@ -2278,15 +1565,15 @@
             R = self.alpha * np.sum((self.x_diff ** 2) * self.Cm_inv_diagonal)
 
             print('misfit: %s' % self.fval_temp)
             print('R: %s' % R)
             self.fval_temp = self.fval_temp + R
 
 
-        print(' fval: %s' % self.fval_temp)
+        print('fval: %s' % self.fval_temp)
         return self.fval_temp
 
 
 
 
     def fval_nonlinear_FDM(self, x_eps: np.array) -> float:
         '''
@@ -3942,119 +3229,7 @@
 # Legacy code for multiprocessing, will be depricated
 #-----------------------------------------------------------------------------------------------------------------------
 def grad_linear_adjoint_method(model, x):
     return model.grad_linear_adjoint_method(x)
 
 def fval_nonlinear_FDM(model, x):
     return model.fval_nonlinear_FDM(x)
-
-
-# def kriging_interpolation_2D():
-#     from darts.tools.keyword_file_tools import load_single_keyword
-#     from pykrige.ok import OrdinaryKriging
-#     from pykrige.uk import UniversalKriging
-#     from matplotlib import pyplot as plt
-#
-#     # Switches
-#     Kriging_switch = 1
-#     Include_boundary = 0
-#
-#     dz = load_single_keyword('dz.txt', 'DZ')
-#     well_coordinates = np.array(
-#         ([69, 7], [63, 3], [46, 16], [94, 14], [103, 13], [26, 12], [20, 15], [81, 6], [39, 9], [39,
-#                                                                                                  22], [52, 19],
-#          [63, 23], [64, 15], [74, 12], [88, 6], [72, 21], [82, 18], [87, 17], [57, 9], [44, 12], [32, 11],
-#          [35, 15], [110, 15], [26, 14], [30, 22]))
-#     bnd_coordinates = np.array(
-#         ([112, 13], [112, 19], [85, 19], [84, 22], [69, 22], [54, 28], [37, 28], [15, 20], [15, 11],
-#          [40, 5], [55, 5], [62, 1], [96, 1], [97, 9], [101, 9]))
-#     Nx = 187
-#     Ny = 57
-#     cell_in_layer = Nx * Ny
-#     well_dz = np.zeros((len(well_coordinates), 1))
-#     bnd_dz = np.zeros((len(bnd_coordinates), 1))
-#     for k in range(0, 11):
-#         for i in range(0, len(well_coordinates)):
-#             I_well = (well_coordinates[i][1] - 1) * Nx + well_coordinates[i][0] - 1
-#             well_dz[i] += dz[int(I_well + k * cell_in_layer)]
-#         for i in range(0, len(bnd_coordinates)):
-#             I_bnd = (bnd_coordinates[i][1] - 1) * Nx + bnd_coordinates[i][0] - 1
-#             bnd_dz[i] += dz[int(I_bnd + k * cell_in_layer)]
-#
-#     boundary_data = np.hstack((bnd_coordinates, bnd_dz))
-#     boundary_data = boundary_data[[boundary_data[:, 2] != 0]]
-#     well_data = np.hstack((well_coordinates, well_dz))
-#
-#     if Include_boundary:
-#         data = np.vstack((well_data, boundary_data))
-#     else:
-#         data = well_data
-#
-#     gridx = np.arange(0, 121, 1)
-#     gridy = np.arange(0, 31, 1)
-#     data = data.astype(float)
-#     gridx = gridx.astype(float)
-#     gridy = gridy.astype(float)
-#
-#     # Example
-#     # data = np.array([[0.3, 1.2, 0.47],
-#     # [1.9, 0.6, 0.56],
-#     # [1.1, 3.2, 0.74],
-#     # [3.3, 4.4, 1.47],
-#     # [4.7, 3.8, 1.74]])
-#     # gridx = np.arange(0.0, 5.5, 0.5)
-#     # gridy = np.arange(0.0, 5.5, 0.5)
-#
-#     if Kriging_switch == 0:
-#         # params = {'sill': 25, 'range': 20, 'nugget': 2}
-#         OK = OrdinaryKriging(data[:, 0], data[:, 1], data[:, 2], variogram_model='gaussian',
-#                              verbose=True, weight=False, enable_plotting=True, nlags=12)
-#
-#         z, ss = OK.execute('grid', gridx, gridy)
-#     elif Kriging_switch == 1:
-#         UK = UniversalKriging(data[:, 0], data[:, 1], data[:, 2], variogram_model='gaussian',
-#                               verbose=True, enable_plotting=True, nlags=12)
-#         z, ss = UK.execute('grid', gridx, gridy)
-#
-#     plt.imshow(z)
-#     plt.show()
-#
-#     # Convert data into a data frame for easier visualization
-#     z = pd.DataFrame.from_dict(z)
-#
-#     # Plot Kriging result
-#     data = [go.Surface(z=z.as_matrix())]
-#     # data = [go.Heatmapgl(z=z.as_matrix(),
-#     #         colorscale=[[0.0, 'rgb(165,0,38)'], [0.1111111111111111, 'rgb(165,0,40)'], [0.2222222222222222, 'rgb(165,0,42)'],
-#     #         [0.3333333333333333, 'rgb(253,174,97)'], [0.4444444444444444, 'rgb(254,224,144)'], [0.5555555555555556, 'rgb(224,243,248)'],
-#     #         [0.6666666666666666, 'rgb(171,217,233)'],[0.7777777777777778, 'rgb(116,173,209)'], [0.8888888888888888, 'rgb(69,117,180)'],
-#     #         [1.0, 'rgb(49,54,149)']],
-#     #         )]
-#     layout = go.Layout(
-#         title='Depth map by ODK',
-#         autosize=True,
-#         scene=dict(
-#             xaxis=dict(
-#                 title='I',
-#                 gridcolor='rgb(255, 255, 255)',
-#                 zerolinecolor='rgb(255, 255, 255)',
-#                 showbackground=True,
-#                 backgroundcolor='rgb(230, 230,230)'
-#             ),
-#             yaxis=dict(
-#                 title='J',
-#                 gridcolor='rgb(255, 255, 255)',
-#                 zerolinecolor='rgb(255, 255, 255)',
-#                 showbackground=True,
-#                 backgroundcolor='rgb(230, 230,230)'
-#             ),
-#             zaxis=dict(
-#                 title='Depth[m]',
-#                 gridcolor='rgb(255, 255, 255)',
-#                 zerolinecolor='rgb(255, 255, 255)',
-#                 showbackground=True,
-#                 backgroundcolor='rgb(230, 230,230)'
-#             )
-#         )
-#     )
-#     fig = go.Figure(data=data, layout=layout)
-#     plotly.offline.plot(fig, filename='depth_map.html')
```

## darts/models/physics/geothermal.py

 * *Ordering differences only*

```diff
@@ -1,10 +1,10 @@
+from darts.models.physics.physics_base import PhysicsBase
 from darts.models.physics.geothermal_operators import *
 from darts.models.physics.iapws.iapws_property import *
-from darts.models.physics.physics_base import PhysicsBase
 from darts.tools.keyword_file_tools import *
 
 
 class Geothermal(PhysicsBase):
     """"
        Class to generate geothermal physics, including
         Important definitions:
```

## darts/models/physics/geothermal_operators.py

```diff
@@ -66,28 +66,31 @@
         self.steam_density      = property_data.steam_density
         self.water_viscosity    = property_data.water_viscosity
         self.steam_viscosity    = property_data.steam_viscosity
         self.rock_compaction    = property_data.rock_compaction
         self.rock_energy        = property_data.rock_energy
 
     def evaluate(self, state, values):
-
-        water_enth = self.water_enthalpy.evaluate(state)
-        steam_enth = self.steam_enthalpy.evaluate(state)
-        water_den  = self.water_density.evaluate(state)
-        steam_den  = self.steam_density.evaluate(state)
-        water_sat  = self.water_saturation.evaluate(state)
-        steam_sat  = self.steam_saturation.evaluate(state)
-        temp       = self.temperature.evaluate(state)
-        water_rp   = self.water_relperm.evaluate(state)
-        steam_rp   = self.steam_relperm.evaluate(state)
-        water_vis  = self.water_viscosity.evaluate(state)
-        steam_vis  = self.steam_viscosity.evaluate(state)
-        pore_volume_factor = self.rock_compaction.evaluate(state)
-        rock_int_energy    = self.rock_energy.evaluate(state)
+        try:
+            water_enth = self.water_enthalpy.evaluate(state)
+            steam_enth = self.steam_enthalpy.evaluate(state)
+            water_den  = self.water_density.evaluate(state)
+            steam_den  = self.steam_density.evaluate(state)
+            water_sat  = self.water_saturation.evaluate(state)
+            steam_sat  = self.steam_saturation.evaluate(state)
+            temp       = self.temperature.evaluate(state)
+            water_rp   = self.water_relperm.evaluate(state)
+            steam_rp   = self.steam_relperm.evaluate(state)
+            water_vis  = self.water_viscosity.evaluate(state)
+            steam_vis  = self.steam_viscosity.evaluate(state)
+            pore_volume_factor = self.rock_compaction.evaluate(state)
+            rock_int_energy    = self.rock_energy.evaluate(state)
+        except:
+            print('state:', state)
+            raise Exception('Incoming out of bound')
         pressure = state[0]
 
         # mass accumulation
         values[0] = pore_volume_factor * (water_den * water_sat + steam_den * steam_sat)
         # mass flux
         values[1] = water_den * water_rp / water_vis + steam_den * steam_rp / steam_vis
         # fluid internal energy = water_enthalpy + steam_enthalpy - work
```

## darts/models/physics/iapws/custom_rock_property.py

```diff
@@ -1,9 +1,9 @@
 from darts.engines import property_evaluator_iface
-from darts.models.physics.iapws.iapws97 import _Backward1_T_Ph
+from iapws.iapws97 import _Backward1_T_Ph
 from darts.models.physics.iapws.iapws_property import iapws_temperature_evaluator, temperature_region1_evaluator
 
 class custom_rock_energy_evaluator(property_evaluator_iface):
      def __init__(self, rock):
         super().__init__()
         self.rock_table = rock
      def evaluate(self, state):
```

## darts/models/physics/iapws/iapws_property.py

```diff
@@ -1,10 +1,10 @@
 from darts.engines import property_evaluator_iface
-from darts.models.physics.iapws.iapws97 import _Region1, _Region2, _Region4, _Backward1_T_Ph, _Backward2_T_Ph, _Bound_Ph, _Bound_TP, _TSat_P, Pmin
-from darts.models.physics.iapws._iapws import _D2O_Viscosity, _Viscosity
+from iapws.iapws97 import _Region1, _Region2, _Region4, _Backward1_T_Ph, _Backward2_T_Ph, _Bound_Ph, _Bound_TP, _TSat_P, Pmin
+from iapws._iapws import _D2O_Viscosity, _Viscosity
 from scipy.optimize import newton
 
 
 class water_density_property_evaluator(property_evaluator_iface):
     def __init__(self):
         super().__init__()
     def evaluate(self, state):
```

## darts/models/physics_sup/operator_evaluator_sup.py

```diff
@@ -34,15 +34,15 @@
         #       al + bt        + gm + dlt + chi     + rock_temp por    + gr/cap  + por
         total = ne + ne * nph + nph + ne + ne * nph + 3 + 2 * nph + 1
 
         for i in range(total):
             values[i] = 0
 
         #  some arrays will be reused in thermal
-        (self.sat, self.x, rho, self.rho_m, self.mu, self.kr, self.pc, self.ph) = self.property.evaluate(state)
+        (self.sat, self.x, rho, self.rho_m, self.mu, kin_rates, self.kr, self.pc, self.ph) = self.property.evaluate(state)
 
         self.compr = (1 + self.property.rock_comp * (pressure - self.property.p_ref))  # compressible rock
 
         density_tot = np.sum(self.sat * self.rho_m)
         zc = np.append(vec_state_as_np[1:nc], 1 - np.sum(vec_state_as_np[1:nc]))
         phi = 1 - np.sum(zc[nc_fl:nc])
 
@@ -71,18 +71,16 @@
         shift += nph
         for i in range(nc):
             for j in self.ph:
                 values[shift + i * nph + j] = self.property.diff_coef * self.x[j][i] * self.rho_m[j]
 
         """ Delta operator for reaction """
         shift += nph * ne
-        if self.property.kinetic_rate_ev:
-            kinetic_rate = self.property.kinetic_rate_ev.evaluate(self.x, zc[nc_fl:])
-            for i in range(nc):
-                values[shift + i] = kinetic_rate[i]
+        for i in range(nc):
+            values[shift + i] = kin_rates[i]
 
         """ Gravity and Capillarity operators """
         shift += ne
         # E3-> gravity
         for i in self.ph:
             values[shift + 3 + i] = rho[i]
 
@@ -125,15 +123,15 @@
 
         #       al + bt        + gm + dlt + chi     + rock_temp por    + gr/cap  + por
         total = ne + ne * nph + nph + ne + ne * nph + 3 + 2 * nph + 1
 
         for i in range(total):
             values[i] = 0
 
-        (sat, x, rho, rho_m, mu, kr, pc, ph) = self.property.evaluate(state)
+        (sat, x, rho, rho_m, mu, kin_rates, kr, pc, ph) = self.property.evaluate(state)
 
         self.compr = (1 + self.property.rock_comp * (pressure - self.property.p_ref))  # compressible rock
 
         density_tot = np.sum(sat * rho_m)
         zc = np.append(vec_state_as_np[1:nc], 1 - np.sum(vec_state_as_np[1:nc]))
         phi = 1
 
@@ -157,18 +155,16 @@
         shift = ne + ne * nph
 
         """ Chi operator for diffusion """
         shift += nph
 
         """ Delta operator for reaction """
         shift += nph * ne
-        if self.property.kinetic_rate_ev:
-            kinetic_rate = self.property.kinetic_rate_ev.evaluate(x, zc[nc_fl:])
-            for i in range(ne):
-                values[shift + i] = kinetic_rate[i]
+        for i in range(ne):
+            values[shift + i] = kin_rates[i]
 
         """ Gravity and Capillarity operators """
         shift += ne
         # E3-> gravity
         for i in range(nph):
             values[shift + 3 + i] = rho[i]
 
@@ -194,15 +190,15 @@
         :param state: state variables [pres, comp_0, ..., comp_N-1]
         :param values: values of the operators (used for storing the operator values)
         :return: updated value for operators, stored in values
         """
         for i in range(self.nph):
             values[i] = 0
 
-        (sat, x, rho, rho_m, mu, kr, pc, ph) = self.property.evaluate(state)
+        (sat, x, rho, rho_m, mu, kin_rates, kr, pc, ph) = self.property.evaluate(state)
 
 
         self.flux[:] = 0
         # step-1
         for j in ph:
             for i in range(self.nc):
                 self.flux[i] += rho_m[j] * kr[j] * x[j][i] / mu[j]
@@ -239,15 +235,15 @@
         super().evaluate(state, values)
 
         vec_state_as_np = np.asarray(state)
         pressure = state[0]
         temperature = vec_state_as_np[-1]
 
         # (enthalpy, rock_energy) = self.property.evaluate_thermal(state)
-        (enthalpy, cond, rock_energy) = self.property.evaluate_thermal(state)
+        (enthalpy, cond, rock_energy, heat_source) = self.property.evaluate_thermal(state)
 
         nc = self.property.nc
         nph = self.property.nph
         ne = nc + self.thermal
 
         i = nc  # use this numeration for energy operators
         """ Alpha operator represents accumulation term: """
@@ -264,15 +260,15 @@
         shift = ne + ne * nph + nph
         for j in range(nph):
             # values[shift + nc * nph + j] = temperature
             values[shift + ne * j + nc] = temperature * cond[j]
 
         """ Delta operator for reaction """
         shift += nph * ne
-        values[shift + i] = 0
+        values[shift + i] = heat_source
 
         """ Additional energy operators """
         shift += ne
         # E1-> rock internal energy
         values[shift] = rock_energy / self.compr  # kJ/m3
         # E2-> rock temperature
         values[shift + 1] = temperature
@@ -281,33 +277,30 @@
 
         #print(state, values)
 
         return 0
 
 
 class DefaultPropertyEvaluator(operator_set_evaluator_iface):
-    def __init__(self, property_container, thermal=0):
+    def __init__(self, variables, property_container):
         super().__init__()  # Initialize base-class
-        # Store your input parameters in self here, and initialize other parameters here in self
-        self.min_z = property_container.min_z
+
         self.property = property_container
-        self.thermal = thermal
-        self.n_ops = self.property.nph
+
+        self.vars = variables
+        self.n_vars = len(self.vars)
+        self.props = ['sat_' + str(j) for j in range(self.property.nph)]
+        self.n_props = len(self.props)
 
     def evaluate(self, state, values):
         """
         Class methods which evaluates the state operators for the element based physics
         :param state: state variables [pres, comp_0, ..., comp_N-1]
         :param values: values of the operators (used for storing the operator values)
         :return: updated value for operators, stored in values
         """
-        # Composition vector and pressure from state:
-
-        nph = self.property.nph
+        (self.sat, self.x, rho, self.rho_m, self.mu, kin_rates, self.kr, self.pc, self.ph) = self.property.evaluate(state)
 
-        #  some arrays will be reused in thermal
-        (self.sat, self.x, rho, self.rho_m, self.mu, self.kr, self.pc, self.ph) = self.property.evaluate(state)
-
-        for i in range(nph):
+        for i in range(self.property.nph):
             values[i] = self.sat[i]
 
-        return
+        return 0
```

## darts/models/physics_sup/physics_comp_sup.py

```diff
@@ -1,44 +1,42 @@
 import numpy as np
 from darts.engines import *
 from darts.models.physics.physics_base import PhysicsBase
 
 from .operator_evaluator_sup import *
 
-# Define our own operator evaluator class
-class Compositional(PhysicsBase):
-    class operators_storage:
-        def __init__(self):
-            self.reservoir_operators = {}
-            self.wellbore_operators = {}
-            self.rate_operators = {}
-            self.property_operators = {}
 
-    def __init__(self, property_container, timer, n_points, min_p, max_p, min_z, max_z, min_t=-1, max_t=-1, thermal=0,
-                 platform='cpu', itor_type='multilinear', itor_mode='adaptive', itor_precision='d', cache=False):
+class Compositional(PhysicsBase):
+    reservoir_operators = {}
+    wellbore_operators = {}
+    rate_operators = {}
+    property_operators = {}
+
+    def __init__(self, property_container, components, phases,
+                 timer, n_points, min_p, max_p, min_z, max_z, min_t=-1, max_t=-1, thermal=0,
+                 platform='cpu', itor_type='multilinear', itor_mode='adaptive', itor_precision='d', cache=False,
+                 output_props: DefaultPropertyEvaluator = None):
         super().__init__(cache)
         # Obtain properties from user input during initialization:
         self.timer = timer.node["simulation"]
-        self.components = property_container.components_name
-        # self.nc = property_container.nc
-        self.nc = property_container.nelem
-        self.phases = property_container.phases_name
-        self.nph = property_container.nph
+
+        if not isinstance(property_container, dict):
+            property_container = {0: property_container}
+
+        self.components = components
+        self.nc = len(components)
+        self.phases = phases
+        self.nph = len(phases)
+
         self.n_vars = self.nc + thermal
         NE = self.n_vars
-        self.vars = ['pressure', 'Temp']
         self.n_points = n_points
 
         self.n_axes_points = index_vector([n_points] * self.n_vars)
 
-        self.phases = property_container.phases_name
-
-        operators = self.set_operators(property_container, thermal)
-
-
         """ Name of interpolation method and engine used for this physics: """
         # engine including gravity term
 
         self.n_ops = NE + self.nph * NE + self.nph + self.nph * NE + NE + 3 + 2 * self.nph + 1
 
         if thermal:
             self.vars = ['pressure'] + self.components[:-1] + ['temperature']
@@ -47,35 +45,39 @@
             self.engine = eval("engine_super_%s%d_%d_t" % (platform, self.nc, self.nph))()
         else:
             self.vars = ['pressure'] + self.components[:-1]
             self.n_axes_min = value_vector([min_p] + [min_z] * (self.nc - 1))
             self.n_axes_max = value_vector([max_p] + [max_z] * (self.nc - 1))
             self.engine = eval("engine_super_%s%d_%d" % (platform, self.nc, self.nph))()
 
+        # operators = self.set_operators(property_container, thermal)
+        self.set_operators(property_container, thermal, output_props)
+
         self.acc_flux_itor = {}
-        for i in operators.reservoir_operators.keys():
-            self.acc_flux_itor[i] = self.create_interpolator(operators.reservoir_operators[i], self.n_vars,
-                                                             self.n_ops, self.n_axes_points,
-                                                             self.n_axes_min, self.n_axes_max, platform=platform)
+        for i in self.reservoir_operators.keys():
+            self.acc_flux_itor[i] = self.create_interpolator(self.reservoir_operators[i], self.n_vars, self.n_ops,
+                                                             self.n_axes_points, self.n_axes_min, self.n_axes_max,
+                                                             platform=platform)
             self.create_itor_timers(self.acc_flux_itor[i], 'reservoir %d interpolation' % i)
 
-        self.acc_flux_w_itor = self.create_interpolator(operators.wellbore_operators, self.n_vars, self.n_ops,
-                                                        self.n_axes_points,
-                                                        self.n_axes_min, self.n_axes_max, platform=platform)
+        self.acc_flux_w_itor = self.create_interpolator(self.wellbore_operators, self.n_vars, self.n_ops,
+                                                        self.n_axes_points, self.n_axes_min, self.n_axes_max,
+                                                        platform=platform)
 
-        self.property_itor = self.create_interpolator(operators.property_operators, self.n_vars, self.n_ops,
+        self.property_itor = self.create_interpolator(self.property_operators, self.n_vars, self.property_operators.n_props,
                                                       self.n_axes_points, self.n_axes_min, self.n_axes_max,
                                                       platform=platform)
 
-
-        self.rate_itor = self.create_interpolator(operators.rate_operators, self.n_vars, self.nph, self.n_axes_points,
-                                              self.n_axes_min, self.n_axes_max, platform=platform)
+        self.rate_itor = self.create_interpolator(self.rate_operators, self.n_vars, self.nph,
+                                                  self.n_axes_points, self.n_axes_min, self.n_axes_max,
+                                                  platform=platform)
 
         self.create_itor_timers(self.acc_flux_w_itor, 'wellbore interpolation')
         self.create_itor_timers(self.rate_itor, 'well controls interpolation')
+        self.create_itor_timers(self.property_itor, 'property interpolation')
 
         # define well control factories
         # Injection wells (upwind method requires both bhp and inj_stream for bhp controlled injection wells):
         self.new_bhp_inj = lambda bhp, inj_stream: bhp_inj_well_control(bhp, value_vector(inj_stream))
         self.new_rate_inj = lambda rate, inj_stream, iph: rate_inj_well_control(self.phases, iph, self.n_vars,
                                                                                self.n_vars, rate,
                                                                                value_vector(inj_stream), self.rate_itor)
@@ -107,16 +109,15 @@
         if self.nc == 2:
             for c in range(self.nc - 1):
                 composition[c::(self.nc - 1)] = uniform_composition[:]
         else:
             for c in range(self.nc - 1):  # Denis
                 composition[c::(self.nc - 1)] = uniform_composition[c]
 
-
-    def set_uniform_T_initial_conditions(self, mesh, uniform_pressure, uniform_composition, uniform_temp: list):
+    def set_uniform_T_initial_conditions(self, mesh, uniform_pressure, uniform_composition: list, uniform_temp):
         """""
         Function to set uniform initial reservoir condition
         Arguments:
             -mesh: mesh object
             -uniform_pressure: uniform pressure setting
             -uniform_composition: uniform uniform_composition setting
         """
@@ -144,23 +145,27 @@
         pressure.fill(uniform_pressure)
 
         mesh.composition.resize(mesh.n_blocks * (self.nc - 1))
         composition = np.array(mesh.composition, copy=False)
         for c in range(self.nc - 1):
             composition[c::(self.nc - 1)] = uniform_composition[c]
 
-    def set_operators(self, property_container, thermal):  # default definition of operators
-
-        operators = self.operators_storage()
+    def set_operators(self, property_container, thermal, output_properties=None):  # default definition of operators
+        # operators = self.operators_storage()
 
         if thermal:
-            operators.reservoir_operators[0] = ReservoirThermalOperators(property_container)
-            operators.wellbore_operators = ReservoirThermalOperators(property_container)
+            for tag, prop_container in property_container.items():
+                self.reservoir_operators[tag] = ReservoirThermalOperators(prop_container)
+            self.wellbore_operators = ReservoirThermalOperators(property_container[0])
         else:
-            operators.reservoir_operators[0] = ReservoirOperators(property_container)
-            operators.wellbore_operators = WellOperators(property_container)
+            for tag, prop_container in property_container.items():
+                self.reservoir_operators[tag] = ReservoirOperators(prop_container)
+            self.wellbore_operators = WellOperators(property_container[0])
 
-        operators.rate_operators = RateOperators(property_container)
+        self.rate_operators = RateOperators(property_container[0])
 
-        operators.property_operators = DefaultPropertyEvaluator(property_container)
+        if output_properties is None:
+            self.property_operators = DefaultPropertyEvaluator(self.vars, property_container[0])
+        else:
+            self.property_operators = output_properties
 
-        return operators
+        return
```

## darts/models/physics_sup/properties_basic.py

```diff
@@ -1,35 +1,39 @@
 import numpy as np
 
-# from src.cubic_main import *
-# from src.Binary_Interactions import *
-# from src.flash_funcs import *
 
-
-#  dummy function
-class const_fun():
-    def __init__(self, value=0):
+class ConstFunc:
+    def __init__(self, value):
         super().__init__()
-        self.ret = value
+        self.value = value
+
+    def evaluate(self, dummy1=0, dummy2=0, dummy3=0, dummy4=0):
+        return self.value
+
+
+class Flash:
+    def __init__(self, nph, nc):
+        self.nph = nph
+        self.nc = nc
+
+    def evaluate(self, pressure, temperature, zc):
+        pass
 
-    def evaluate(self, dummy1=0, dummy2=0, dummy3=0):
-        return self.ret
 
 class flash_3phase():
-    def __init__(self, components, T):
+    def __init__(self, components):
         self.components = components
-        self.T = T
         mixture = Mix(components)
         binary = Kij(components)
         mixture.kij_cubic(binary)
 
         self.eos = preos(mixture, mixrule='qmr', volume_translation=True)
 
-    def evaluate(self, p, zc):
-        nu, x, status = multiphase_flash(self.components, zc, self.T, p, self.eos)
+    def evaluate(self, p, T, zc):
+        nu, x, status = multiphase_flash(self.components, zc, T, p, self.eos)
 
         return x, nu
 
 
 # Uncomment these two lines if numba package is installed and make things happen much faster:
 from numba import jit
 @jit(nopython=True)
@@ -54,68 +58,92 @@
         print("Flash warning!!!")
 
     x = zc / (V * (k - 1) + 1)
     y = k * x
 
     return (x, y, V)
 
-class Flash:
-    def __init__(self, components, ki, min_z=1e-11):
-        self.components = components
+
+# from dartsflash import RRN2Convex
+# def RR_convex(zc, k, eps):
+#     nc = len(zc)
+#     rr = RRN2Convex(nc)
+#     v = rr.solve_rr(zc, k, 1e-10, 50)
+#     x = rr.getx()
+#     return x[0, :], x[1, :], v[1]
+
+
+class ConstantK(Flash):
+    def __init__(self, nc, ki, min_z=1e-11):
+        super().__init__(nph=2, nc=nc)
+
         self.min_z = min_z
         self.K_values = np.array(ki)
 
-    def evaluate(self, pressure, zc):
+    def evaluate(self, pressure, temperature, zc):
 
         (x, y, V) = RR_func(zc, self.K_values, self.min_z)
-        return [y, x], [V, 1-V]
-
+        return np.array([V, 1-V]), np.array([y, x])
 
 
 #  Density dependent on compressibility only
+class Density:
+    def __init__(self, dens0, compr=0., p0=1.):
+        self.dens0 = dens0
+        self.compr = compr
+        self.p0 = p0
+
+    def evaluate(self, pressure, temperature: float = None, x: list = None):
+        return self.dens0 * (1 + self.compr * (pressure - self.p0))
+
+
+class DensityBrineCo2(Density):
+    def __init__(self, components, dens0=1000., compr=0., p0=1., x_mult=0.):
+        super().__init__(dens0, compr, p0)
+        self.x_max = x_mult
+
+        if "CO2" in components:
+            self.CO2_idx = components.index("CO2")
+        else:
+            self.CO2_idx = None
+
+    def evaluate(self, pressure, temperature, x):
+        if self.CO2_idx is not None:
+            x_co2 = x[self.CO2_idx]
+        else:
+            x_co2 = 0.
+
+        density = (self.dens0 + x_co2 * self.x_max) * (1 + self.compr * (pressure - self.p0))
+        return density
+
+
 class Density4Ions:
     def __init__(self, density, compressibility=0, p_ref=1, ions_fac=0):
         super().__init__()
         # Density evaluator class based on simple first order compressibility approximation (Taylor expansion)
         self.density_rc = density
         self.cr = compressibility
         self.p_ref = p_ref
         self.ions_fac = ions_fac
 
     def evaluate(self, pres, ion_liq_molefrac):
         return self.density_rc * (1 + self.cr * (pres - self.p_ref) + self.ions_fac * ion_liq_molefrac)
 
-class Density:
-    def __init__(self, dens0=1000, compr=0, p0=1, x_mult=0):
-        self.compr = compr
-        self.p0 = p0
-        self.dens0 = dens0
-        self.x_max = x_mult
-
-    def evaluate(self, pressure, x_co2):
-        density = (self.dens0 + x_co2 * self.x_max) * (1 + self.compr * (pressure - self.p0))
-        return density
-
-class ViscosityConst:
-    def __init__(self, visc):
-        self.visc = visc
-
-    def evaluate(self):
-        return self.visc
 
 class Enthalpy:
     def __init__(self, tref=273.15, hcap=0.0357):
         self.tref = tref
         self.hcap = hcap
 
-    def evaluate(self, temp):
-        # methane heat capacity
-        enthalpy = self.hcap * (temp - self.tref)
+    def evaluate(self, pressure: float = None, temperature: float = None, x: list = None):
+        # Enthalpy based on constant heat capacity
+        enthalpy = self.hcap * (temperature - self.tref)
         return enthalpy
 
+
 class PhaseRelPerm:
     def __init__(self, phase, swc=0, sgr=0):
         self.phase = phase
 
         self.Swc = swc
         self.Sgr = sgr
         if phase == "oil":
@@ -130,42 +158,79 @@
             self.n = 2
         else:  # water
             self.kre = 1
             self.sr = 0
             self.sr1 = 0
             self.n = 2
 
-
     def evaluate(self, sat):
-
         if sat >= 1 - self.sr1:
             kr = self.kre
-
         elif sat <= self.sr:
             kr = 0
-
         else:
             # general Brook-Corey
             kr = self.kre * ((sat - self.sr) / (1 - self.Sgr - self.Swc)) ** self.n
 
         return kr
 
 
-class kinetic_basic():
+class CapillaryPressure:
+    def __init__(self, p_entry=0, swc=0, labda=2):
+        self.swc = swc
+        self.p_entry = p_entry
+        self.labda = labda
+        self.eps = 1e-3
+
+    def evaluate(self, sat):
+        '''
+        default evaluator of capillary pressure Pc based on pow
+        :param sat: saturation
+        :return: Pc
+        '''
+        Se = (sat - self.swc)/(1 - self.swc)
+        if Se < self.eps:
+            Se = self.eps
+        pc = self.p_entry * Se ** (-1/self.labda)
+
+        Pc = np.array([0, pc], dtype=object)
+
+        return Pc
+
+
+class KineticBasic:
     def __init__(self, equi_prod, kin_rate_cte, ne, combined_ions=True):
         self.equi_prod = equi_prod
         self.kin_rate_cte = kin_rate_cte
         self.kinetic_rate = np.zeros(ne)
         self.combined_ions = combined_ions
 
-    def evaluate(self, x, nu_sol):
+    def evaluate(self, pressure, temperature, x, nu_sol):
         if self.combined_ions:
             ion_prod = (x[1][1] / 2) ** 2
             self.kinetic_rate[1] = - self.kin_rate_cte * (1 - ion_prod / self.equi_prod) * nu_sol
             self.kinetic_rate[-1] = - 0.5 * self.kinetic_rate[1]
         else:
             ion_prod = x[1][1] * x[1][2]
             self.kinetic_rate[1] = - self.kin_rate_cte * (1 - ion_prod / self.equi_prod) * nu_sol
             self.kinetic_rate[2] = - self.kin_rate_cte * (1 - ion_prod / self.equi_prod) * nu_sol
             self.kinetic_rate[-1] = - self.kinetic_rate[1]
 
-        return self.kinetic_rate
+        return self.kinetic_rate
+
+
+class RockCompactionEvaluator:
+    def __init__(self, pref=1, compres=1.45e-5):
+        self.Pref = pref
+        self.compres = compres
+
+    def evaluate(self, pressure):
+        return 1.0 + self.compres * (pressure - self.Pref)
+
+
+class RockEnergyEvaluator:
+    def __init__(self, c_vr=3710., T_ref=273.15):
+        self.c_vr = c_vr  # 1400 J/kg.K * 2650 kg/m3 -> kJ/m3
+        self.T_ref = T_ref
+
+    def evaluate(self, temperature):
+        return self.c_vr * (temperature - self.T_ref)  # kJ/m3
```

## darts/models/physics_sup/property_container.py

```diff
@@ -1,65 +1,93 @@
 import numpy as np
 
-class property_container:
-    def __init__(self, phases_name, components_name, Mw, Cm=0, min_z=1e-11,
-                 diff_coef=0, rock_comp=1e-6, solid_dens=None, rate_ann_mat=None):
-        super().__init__()
+
+class PropertyContainer:
+    def __init__(self, phases_name, components_name, Mw, min_z=1e-11,
+                 diff_coef=0., rock_comp=1e-6, solid_dens=None, rate_ann_mat=None, temperature=None):
         # This class contains all the property evaluators required for simulation
         if solid_dens is None:
             solid_dens = []
 
         if rate_ann_mat is None:
             rate_ann_mat = np.eye(len(components_name))
         # assert rate_ann_mat.shape[1] == len(components_name)  # necessary check?
 
+        if temperature:  # constant T specified
+            self.thermal = False
+            self.temperature = temperature
+        else:
+            self.thermal = True
+            self.temperature = None
+
         self.nph = len(phases_name)
         self.nm = len(solid_dens)
         # self.nc = len(components_name)
         self.nc = rate_ann_mat.shape[1]
         self.nelem = rate_ann_mat.shape[0]
         self.ncfl = self.nc - self.nm
         self.rate_ann_mat = rate_ann_mat
         self.components_name = components_name
         self.phases_name = phases_name
         self.min_z = min_z
         self.Mw = Mw
-        self.Cm = Cm
         self.solid_dens = solid_dens
         for i in range(self.nm):
             solid_dens[i] /= Mw[i + self.ncfl]
 
         self.rock_comp = rock_comp
         self.p_ref = 1.0
         self.diff_coef = diff_coef
 
         # Allocate (empty) evaluators for functions
         self.density_ev = []
         self.viscosity_ev = []
         self.rel_perm_ev = []
         self.rel_well_perm_ev = []
         self.enthalpy_ev = []
+        self.conductivity_ev = []
         self.rock_energy_ev = []
         self.capillary_pressure_ev = []
         self.kinetic_rate_ev = []
+        self.heat_source_ev = []
         self.flash_ev = 0
 
         # passing arguments
         self.x = np.zeros((self.nph, self.nc))
         self.dens = np.zeros(self.nph)
         self.dens_m = np.zeros(self.nph)
         self.sat = np.zeros(self.nph)
         self.nu = np.zeros(self.nph)
         self.mu = np.zeros(self.nph)
         self.kr = np.zeros(self.nph)
         self.pc = np.zeros(self.nph)
         self.enthalpy = np.zeros(self.nph)
+        self.kappa = np.zeros(self.nph)
 
-        self.phase_props = [self.dens, self.dens_m, self.sat, self.nu, self.mu, self.kr, self.pc, self.enthalpy]
+        self.phase_props = [self.dens, self.dens_m, self.sat, self.nu, self.mu, self.kr, self.pc, self.enthalpy, self.kappa]
+
+    def get_state(self, state):
+        """
+        Get tuple of (pressure, temperature, [z0, ... zn-1]) at current OBL point (state)
+        If isothermal, temperature returns initial temperature
+        """
+        # Composition vector and pressure from state:
+        vec_state_as_np = np.asarray(state)
+        pressure = vec_state_as_np[0]
 
+        zc = np.append(vec_state_as_np[1:self.nc], 1 - np.sum(vec_state_as_np[1:self.nc]))
+        if zc[-1] < 0:
+            zc = self.comp_out_of_bounds(zc)
+
+        if self.thermal:
+            temperature = vec_state_as_np[-1]
+        else:
+            temperature = self.temperature
+
+        return pressure, temperature, zc
 
     def comp_out_of_bounds(self, vec_composition):
         # Check if composition sum is above 1 or element comp below 0, i.e. if point is unphysical:
         temp_sum = 0
         count_corr = 0
         check_vec = np.zeros((len(vec_composition),))
 
@@ -84,116 +112,109 @@
     def clean_arrays(self):
         for a in self.phase_props:
             a[:] = 0
         for j in range(self.nph):
             self.x[j][:] = 0
 
     def compute_saturation(self, ph):
-        if len(ph) == 1:
-            self.sat[ph[0]] = 1
-        elif len(ph) == 2:
-            denom = self.dens_m[ph[0]] - self.dens_m[ph[0]] * self.nu[ph[0]] + self.dens_m[ph[1]] * self.nu[ph[0]]
-            self.sat[ph[0]] = self.dens_m[ph[1]] * self.nu[ph[0]] / denom
-            self.sat[ph[1]] = self.dens_m[ph[0]] * self.nu[ph[1]] / denom
-        else:
-            denom = self.dens_m[0] * self.dens_m[1] * self.nu[2] + self.dens_m[0] * self.dens_m[2] * self.nu[1]\
-                  + self.dens_m[1] * self.dens_m[2] * self.nu[0]
-            self.sat[0] = self.dens_m[1] * self.dens_m[2] * self.nu[0] / denom
-            self.sat[1] = self.dens_m[0] * self.dens_m[2] * self.nu[1] / denom
-            self.sat[2] = self.dens_m[0] * self.dens_m[1] * self.nu[2] / denom
-        return
+        # Get saturations [volume fraction]
+        Vtot = 0
+        for j in ph:
+            Vtot += self.nu[j] / self.dens_m[j]
 
-    def run_flash(self, pressure, zc):
+        for j in ph:
+            self.sat[j] = (self.nu[j] / self.dens_m[j]) / Vtot
 
-        (self.x, self.nu) = self.flash_ev.evaluate(pressure, zc)
+        return
+
+    def run_flash(self, pressure, temperature, zc):
+        self.nu, self.x = self.flash_ev.evaluate(pressure, temperature, zc)
 
         ph = []
         for j in range(self.nph):
             if self.nu[j] > 0:
                 ph.append(j)
 
         if len(ph) == 1:
             self.x[ph[0]] = zc
 
         return ph
 
-
-
     def evaluate(self, state):
         """
         Class methods which evaluates the state operators for the element based physics
-        :param state: state variables [pres, comp_0, ..., comp_N-1]
+        :param state: state variables [pres, comp_0, ..., comp_N-1, temperature (optional)]
         :param values: values of the operators (used for storing the operator values)
         :return: updated value for operators, stored in values
         """
         # Composition vector and pressure from state:
-        vec_state_as_np = np.asarray(state)
-        pressure = vec_state_as_np[0]
-
-        zc = np.append(vec_state_as_np[1:self.nc], 1 - np.sum(vec_state_as_np[1:self.nc]))
-
-        if zc[-1] < 0:
-            # print(zc)
-            zc = self.comp_out_of_bounds(zc)
+        pressure, temperature, zc = self.get_state(state)
 
         self.clean_arrays()
-        # two-phase flash - assume water phase is always present and water component last
 
-        ph = self.run_flash(pressure, zc)
+        self.ph = self.run_flash(pressure, temperature, zc)
 
-        for j in ph:
-            M = 0
-            # molar weight of mixture (note: self.nc is fluid components here!)
-            for i in range(self.nc):
-                M += self.Mw[i] * self.x[j][i]
-            self.dens[j] = self.density_ev[self.phases_name[j]].evaluate(pressure, self.x[j][0])  # output in [kg/m3]
-            self.dens_m[j] = self.dens[j] / M
-            self.mu[j] = self.viscosity_ev[self.phases_name[j]].evaluate()  # output in [cp]
+        for j in self.ph:
+            M = np.sum(self.Mw * self.x[j][:])
 
-        self.compute_saturation(ph)
+            self.dens[j] = self.density_ev[self.phases_name[j]].evaluate(pressure, temperature, self.x[j][:])  # output in [kg/m3]
+            self.dens_m[j] = self.dens[j] / M  # molar density [kg/m3]/[kg/kmol]=[kmol/m3]
+            self.mu[j] = self.viscosity_ev[self.phases_name[j]].evaluate(pressure, temperature, self.x[j][:], self.dens[j])  # output in [cp]
+        self.compute_saturation(self.ph)
 
-        for j in ph:
+        if self.capillary_pressure_ev:
+            self.pc = self.capillary_pressure_ev.evaluate(self.sat[1])
+
+        for j in self.ph:
             self.kr[j] = self.rel_perm_ev[self.phases_name[j]].evaluate(self.sat[j])
-            self.pc[j] = 0
 
-        return self.sat, self.x, self.dens, self.dens_m, self.mu, self.kr, self.pc, ph
+        kin_rates = np.zeros(self.nc)
+        for j, reaction in enumerate(self.kinetic_rate_ev):
+            rate = reaction.evaluate(pressure, temperature, self.x, zc[-1])
+            # rate = reaction.evaluate(pressure, temperature, self.x, self.sat[-1])
+            kin_rates += rate
+
+        return self.sat, self.x, self.dens, self.dens_m, self.mu, kin_rates, self.kr, self.pc, self.ph
 
     def evaluate_thermal(self, state):
         """
         Class methods which evaluates the state operators for the element based physics
         :param state: state variables [pres, comp_0, ..., comp_N-1]
         :param values: values of the operators (used for storing the operator values)
         :return: updated value for operators, stored in values
         """
         # Composition vector and pressure from state:
-        vec_state_as_np = np.asarray(state)
-        temperature = vec_state_as_np[-1]
-        fluid_cond = np.ones(self.nph)
-        for m in range(self.nph):
-            self.enthalpy[m] = self.enthalpy_ev[self.phases_name[m]].evaluate(temperature)
-            fluid_cond[m] = 1
+        pressure, temperature, zc = self.get_state(state)
 
-        rock_energy = self.rock_energy_ev.evaluate(temperature)
+        for j in self.ph:
+            self.enthalpy[j] = self.enthalpy_ev[self.phases_name[j]].evaluate(pressure, temperature, self.x[j][:])  # kJ/kmol
+            self.kappa[j] = self.conductivity_ev[self.phases_name[j]].evaluate(pressure, temperature, self.x[j][:], self.dens[j])
 
-        return self.enthalpy, fluid_cond, rock_energy
+        rock_energy = self.rock_energy_ev.evaluate(temperature=temperature)
 
-    def evaluate_at_cond(self, pressure, zc):
+        # Heat source and Reaction enthalpy
+        heat_source = 0
+        if self.heat_source_ev:
+            heat_source += self.heat_source_ev.evaluate(state)
 
-        self.sat[:] = 0
+        for j, reaction in enumerate(self.kinetic_rate_ev):
+            heat_source += reaction.evaluate_enthalpy(pressure, temperature, self.x, self.sat[-1])
 
-        if zc[-1] < 0:
-            # print(zc)
-            zc = self.comp_out_of_bounds(zc)
+        return self.enthalpy, self.kappa, rock_energy, heat_source
+
+    def evaluate_at_cond(self, state):
+        # Composition vector and pressure from state:
+        pressure, temperature, zc = self.get_state(state)
 
-        ph = self.run_flash(pressure, zc)
+        ph = self.run_flash(pressure, temperature, zc)
 
         for j in ph:
             M = 0
             # molar weight of mixture
             for i in range(self.nc):
                 M += self.Mw[i] * self.x[j][i]
-            self.dens_m[j] = self.density_ev[self.phases_name[j]].evaluate(pressure, self.x[j][0]) / M
+            self.dens_m[j] = self.density_ev[self.phases_name[j]].evaluate(pressure, temperature, self.x[j][:]) / M
 
         self.compute_saturation(ph)
 
         return self.sat, self.dens_m
```

## darts/models/reservoirs/struct_reservoir.py

```diff
@@ -1,14 +1,14 @@
 import os
 from math import pi
 
 import numpy as np
 from darts.engines import conn_mesh, ms_well, ms_well_vector, timer_node, value_vector, index_vector
 from darts.mesh.struct_discretizer import StructDiscretizer
-from darts.tools.pyevtk import hl
+from pyevtk import hl
 from scipy.interpolate import griddata
 
 
 class StructReservoir:
     def __init__(self, timer, nx: int, ny: int, nz: int,
                  dx, dy, dz,
                  permx, permy, permz,
```

## darts/models/reservoirs/unstruct_reservoir.py

```diff
@@ -95,19 +95,19 @@
         well.well_head_depth = depth
         well.well_body_depth = depth
         well.segment_transmissibility = 1e5
         well.segment_depth_increment = 1
         self.wells.append(well)
         return 0
 
-    def add_perforation(self, well, res_block, well_index):
+    def add_perforation(self, well, res_block, well_index, well_indexD):
         """
         Class method which ads perforation to each (existing!) well
 
         :param well: data object which contains data of the particular well
         :param res_block: reservoir block in which the well has a perforation
         :param well_index: well index (productivity index)
         :return:
         """
         well_block = 0
-        well.perforations = well.perforations + [(well_block, res_block, well_index)]
+        well.perforations = well.perforations + [(well_block, res_block, well_index, well_indexD)]
         return 0
```

## Comparing `open_darts-0.1.4.data/data/LICENSE` & `open_darts-1.0.0.dist-info/LICENSE`

 * *Files 10% similar despite different names*

```diff
@@ -196,45 +196,7 @@
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
-
-=============================================================================
-THIRD-PARTY
-=============================================================================
-
-SuperLU
-
-Copyright (c) 2003, The Regents of the University of California, through
-Lawrence Berkeley National Laboratory (subject to receipt of any required 
-approvals from U.S. Dept. of Energy) 
-
-All rights reserved. 
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met: 
-
-(1) Redistributions of source code must retain the above copyright notice,
-this list of conditions and the following disclaimer. 
-(2) Redistributions in binary form must reproduce the above copyright notice,
-this list of conditions and the following disclaimer in the documentation
-and/or other materials provided with the distribution. 
-(3) Neither the name of Lawrence Berkeley National Laboratory, U.S. Dept. of
-Energy nor the names of its contributors may be used to endorse or promote
-products derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
-CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
-EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
-PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
-LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
-NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
-  
-=============================================================================
```

